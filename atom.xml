<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Giskard's CFD Learning Tricks]]></title>
  <subtitle><![CDATA[CFD and Scientific Computing]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://xiaopingqiu.github.io/"/>
  <updated>2016-08-27T08:25:35.420Z</updated>
  <id>http://xiaopingqiu.github.io/</id>
  
  <author>
    <name><![CDATA[Giskard Q.]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Paraview 中创建 Custom Filter]]></title>
    <link href="http://xiaopingqiu.github.io/2016/08/27/ParaviewCustomFilter/"/>
    <id>http://xiaopingqiu.github.io/2016/08/27/ParaviewCustomFilter/</id>
    <published>2016-08-27T08:04:07.000Z</published>
    <updated>2016-08-27T08:25:35.420Z</updated>
    <content type="html"><![CDATA[<p>在 <a href="http://xiaopingqiu.github.io/2016/08/27/ParaviewStreamLineOnSlice/" target="_blank" rel="external">上一篇</a>，介绍了如果作截面上的流线，其中涉及到多个 filter 的组合操作。如果每次都要来这么一串操作，挺繁琐的。Paraview 提供的 Custom Filter 的功能，能大大简化这种繁琐的重复操作。Custom Filter，本质上就是将一系列 filter 的组合操作打包成一个新的 filter。下面以作截面流线的操作为例，介绍如何创建一个 Custom Filter。</p>
<a id="more"></a>
<p>步骤如下：</p>
<ol>
<li>选定下图中所示的三个pipeline，</li>
</ol>
<p><img src="/image/Paraview/select1.png" alt=""></p>
<p>然后点右键选择 Create Custom Filter</p>
<p><img src="/image/Paraview/CF1.png" alt=""></p>
<ol>
<li>Next，进入 Custom Fliter 的配置环节</li>
</ol>
<p><img src="/image/Paraview/CFsetting1.png" alt=""></p>
<p>选择 SurfaceVector1，设置为 Input，并取名为 SurfaceVector，设置好以后，点 “+”添加这个 Input。<br>然后，Next</p>
<p><img src="/image/Paraview/CFsetting2.png" alt=""></p>
<p>将 StreamTracerWithCustomSource1 和 MaskPoints1 设置为 output。</p>
<p>继续 Next，这一步可以指定一些将来可以再调整的参数，如果不设置，那么新建立的 filter 将使用当前的 StreamTracerWithCustomSource1 和 MaskPoints1 使用的参数，不可调整，这样显然会严重限制新 fliter 的实用性，至少，我们应该添加控制 MaskPoint 的点数的参数。添加的方法是，选定左边的 MaskPoints，然后在右边的 Property 下拉菜单中，选择一个参数，比如，Maximum Number of Points，然后点 “+”，将来可能需要重新调整什么参数，就在这一步选上它，</p>
<p><img src="/image/Paraview/CFsetting3.png" alt=""></p>
<p>然后，点 Finish，就完成了 Custom Filter 的添加。</p>
<p>之后，你可以在 Filter 菜单中找到新添加的 SurfaceStreamLines ，将其用在某个 slice 上，就自动生成了这个 slice 的流线。</p>
<p><img src="/image/Paraview/CFusing1.png" alt=""></p>
<p>注意 pipe line 这边，能调的参数，正是在建立 Custom filter 的最后一步添加的那四个。</p>
<p>建立好的 Custom Filter，应该保存下来，用下图中的 export。要不然，下次打开Paraview，自定义的 filter 就没了。选择菜单的 Tools-&gt; Manage Custom Filters</p>
<p><img src="/image/Paraview/export.png" alt=""></p>
<p>导出的文件可以共享给其他人。</p>
<p>如果对建立的 filter 不满意，需要删除重建，在上图中选择需要删除的，点 Remove 即可。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在 <a href="http://xiaopingqiu.github.io/2016/08/27/ParaviewStreamLineOnSlice/">上一篇</a>，介绍了如果作截面上的流线，其中涉及到多个 filter 的组合操作。如果每次都要来这么一串操作，挺繁琐的。Paraview 提供的 Custom Filter 的功能，能大大简化这种繁琐的重复操作。Custom Filter，本质上就是将一系列 filter 的组合操作打包成一个新的 filter。下面以作截面流线的操作为例，介绍如何创建一个 Custom Filter。</p>]]>
    
    </summary>
    
      <category term="PostProcessing" scheme="http://xiaopingqiu.github.io/tags/PostProcessing/"/>
    
      <category term="Paraview" scheme="http://xiaopingqiu.github.io/categories/Paraview/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在 Paraview 中画截面上的流线]]></title>
    <link href="http://xiaopingqiu.github.io/2016/08/27/ParaviewStreamLineOnSlice/"/>
    <id>http://xiaopingqiu.github.io/2016/08/27/ParaviewStreamLineOnSlice/</id>
    <published>2016-08-27T07:39:10.000Z</published>
    <updated>2016-08-27T08:03:04.437Z</updated>
    <content type="html"><![CDATA[<p>paraview 的 Stream Tracer 无法直接作一个截面上的流线。比如，对于OpenFOAM的算例，即使是二维算例，截取一个面后，用 Stream tracer 无法得到流线。解决办法是存在的，本篇介绍如果通过一系列 filter 的组合来得到截面上的流线。</p>
<a id="more"></a>
<p>以 pitzdaily 算例为例，步骤如下：</p>
<ol>
<li><p>作一个截面（slice），这一步不需详述</p>
</li>
<li><p>对截面使用 Surface Vector filter，这个的作用是让速度矢量投影到平面上。</p>
</li>
<li><p>对得到的 SurfaceVector 使用 Mask Points filter，这个的作用是生成一系列参考点，将来画流线的时候，以这些参考点的位置来确定流线的位置和疏密。<br><img src="/image/Paraview/maskPoint.png" alt=""><br>On Ratio 参数控制取点的疏密，这里的设置，表示每2560个点中取一个；Maximum number of points 控制总点数的数目；Random Sampling，开启随机取点模式，如果是非随机模式，将按坐标从小到大取点。假设 On Ratio = 2560 情况下，一共有1000个点，但是 Maximum number of points 设置为 100，那么将只取坐标最小的前100个点，而如果开启了随机模式，则点的分布基本上是均匀充满这个流动区域的。Generate Vertices，选择是否要显示参考点，如果开启，则会显示一个点阵。</p>
</li>
<li><p>Filter 里选择 Stream Tracer with Custom Source，Input 和 Seed Source 分别按下图设置<br><img src="/image/Paraview/Input1.png" alt=""><br><img src="/image/Paraview/seedSource1.png" alt=""></p>
</li>
</ol>
<p>就得到了如下的流线图，流线的疏密，可以通过Mask Points 的点数来控制，只是，遗憾的是点数的空间分布不好控制，比如，我想让中间部分稀疏一点，角落上密一点，不容易做到。另外，还需要注意左边 Pipeline，出现了三个 StreamTracerWithCustomSource，似乎这三个其实是一个，改变任意一个都会改变流线的属性。</p>
<p><img src="/image/Paraview/streamline1.png" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>paraview 的 Stream Tracer 无法直接作一个截面上的流线。比如，对于OpenFOAM的算例，即使是二维算例，截取一个面后，用 Stream tracer 无法得到流线。解决办法是存在的，本篇介绍如果通过一系列 filter 的组合来得到截面上的流线。</p>]]>
    
    </summary>
    
      <category term="Postprocessing" scheme="http://xiaopingqiu.github.io/tags/Postprocessing/"/>
    
      <category term="Paraview" scheme="http://xiaopingqiu.github.io/categories/Paraview/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenFOAM 中求解 ODE 一例]]></title>
    <link href="http://xiaopingqiu.github.io/2016/08/21/ODE/"/>
    <id>http://xiaopingqiu.github.io/2016/08/21/ODE/</id>
    <published>2016-08-21T07:26:43.000Z</published>
    <updated>2016-08-21T07:57:24.790Z</updated>
    <content type="html"><![CDATA[<p>本篇介绍如何编写一个小程序来调用 OpenFOAM 的 ODE 求解器来求解任意常微分方程的初值问题。 </p>
<a id="more"></a>
<h5 id="1-_数学背景">1. 数学背景</h5><p>首先简要看一下涉及的数学背景。对于一阶的常微分方程，<br>$$<br>y’=f(x,y), \quad x\in[a,b] \\<br>y(a)=y_0<br>$$<br>常微分方程，如果存在解析解的话，其解应该是一个函数 $y=f(x)$。然而，大多数常微分方程是没有解析解的，只能数值求解。数值方法得到的，是一系列的 $x_0, x_1, \cdots x_n$ 对应的函数值 $y_0, y_1, \cdots y_n$。</p>
<p>常用的数值解法有：</p>
<ul>
<li>显式欧拉法<br>这种方法最简单，将区间 $[a,b]$ 分成 n 份，则得到步长 $h=(b-a)/n$。以 $y(a)=y_0$ 为起点，通过下述迭代，<br>$$<br>y_{m+1} = y_m+hf(x_m,y_m)<br>$$<br>可以得到 $x_m=a+m*h$ 处的函数值 $y_m$，此即为常微分方程的数值解。显式欧拉法形式简单，但是只有一阶精度，而且稳定性是有条件的，一般在实际中较少用到。</li>
<li>改进的欧拉法<br>这种方法是在显式欧拉法的基础上改进得到，将显式欧拉法中使用的向前积分改为梯形积分。其迭代形式为<br>$$<br>y_{m+1} = y_m +\frac{h}{2}[f(x_m,y_m)+f(x_{m+1},y_{m+1})]<br>$$<br>这种方法不是显式地，所以，需要在每一步内进行迭代求解。可以用如下的迭代公式<br>$$<br>y_{m+1}^{(n+1)} = y_m +\frac{h}{2}[f(x_m,y_m)+f(x_{m+1},y_{m+1}^{(n)})]<br>$$<br>注意，这里的 n 指的是计算 $y_{m+1}$ 的值时的内迭代次数，迭代的初始值 $y_{m+1}^{(0)}$ 可以用显式欧拉公式来给出<br>$$<br>y_{m+1}^{(0)} = y_m + hf(x_m, y_m)<br>$$</li>
<li>显式 4 阶 Runge-Kutta 方法<br>这是现实中常用的一种方法，其迭代形式如下<br>$$<br>\begin{align*}<br>y_{m+1} &amp; = y_m + \frac{h}{6}[k_1+2k_2+2k_3+k_4] \\<br>k_1 &amp; = f(x_m, y_m) \\<br>k_2 &amp; = f(x_m+\frac{1}{2}h, y_m+\frac{1}{2}hk_1) \\<br>k_3 &amp; = f(x_m+\frac{1}{2}h, y_m+\frac{1}{2}hk_2) \\<br>k_4&amp;  = f(x_m+h, y_m+hk_3)<br>\end{align*}<br>$$</li>
</ul>
<p>除了以上，当然还有很多方法，比如预测校正等等，这里就不再逐一介绍了。</p>
<p>问题是，实际中遇到的还可能是高阶的常微分方程，比如，弹簧-谐振子系统可以用以下e二阶常微分方程描述<br>$$<br>\frac{d^2y}{dt^2} = -\frac{k}{m}y<br>$$</p>
<p>高阶常微分方程的初值问题，可以用以下通式来描述<br>$$<br>y^{n} = f(x,y,y’,\cdots y^{n-1})<br>$$</p>
<p>其初始条件为<br>$$<br>y(0) = a_0, \quad y’(0) = a_1, \quad \cdots, \quad y^{n-1}(0) = a_n<br>$$<br>对于这种高阶常微分方程，可以将其表述为一系列一阶常微分方程的组成的方程组来求解。下面以二阶常微分方程为例，介绍如何将高阶常微分方程的初值问题转化为一阶常微分方程组。<br>考察如下二阶常微分方程<br>$$<br>y’’ = f(x,y,y’), \quad x\in[a,b] \\<br>y(a) = a_0, \quad y’(a) = a_1<br>$$</p>
<p>若令 $z=y’$，则上述二阶常微分方程可以表示成如下方程组<br>$$<br>\left \{<br>\begin{align*}<br>y’ &amp;= z \\<br>z’ &amp;= f(x,y,z)<br>\end{align*}<br>\right. \\<br>y(a)=a_0,\quad z(a)=a_1<br>$$</p>
<p>这个方程组，就可以用前面介绍的一阶常微分方程的解法来求解了，比如，若用最简单的显式欧拉法，则<br>$$<br>\begin{align*}<br>y_{m+1} &amp;= y_m + h z_m \\<br>z_{m+1} &amp;= z_m +hf(x_m, y_m, z_m)<br>\end{align*}<br>$$<br>或者用显式 4 阶 Runge-Kutta 方法<br>$$<br>\begin{align*}<br>y_{m+1} &amp; = y_m + \frac{h}{6}[K_1+2K_2+2K_3+K_4] \\<br>z_{m+1} &amp; = z_m + \frac{h}{6}[M_1+2M_2+2M_3+K_4] \\<br>K_1 &amp; = z_m,\quad M_1=f(x_m, y_m, z_m) \\<br>K_2 &amp; = z_m + \frac{M_1}{2}, \quad M_2 = f(x_m+\frac{h}{2}, y_m+\frac{K_1}{2}, z_m+\frac{M_1}{2})\\<br>K_3 &amp; = z_m + \frac{M_2}{2},\quad M_3 = f(x_m+\frac{h}{2}, y_m+\frac{K_2}{2}, z_m+\frac{M_2}{2})\\<br>K_4&amp;  = z_m + M_3,\quad M_4=f(x_m+h, y_m+K_3, z_m+M_3)<br>\end{align*}<br>$$</p>
<p>二阶以上的常微分方程，除了可以给出初值条件，还可以给出边值条件，比如<br>$$<br>y’’ = f(x,y,y’), \quad x\in[a,b] \\<br>y(a) = \alpha, \quad y(b) = \beta<br>$$</p>
<p>这种情况下，就无法直接将此方程转化为一阶常微分方程组了。但是，边值问题可以通过一定的方法转换成初值问题，以下给出一种：<strong>试射法</strong>。<br>在不知道 $y’(a)$ 的情况下，不妨假设 $y’(a)=\gamma_1$，这样，就得到了一个初值问题<br>$$<br>y’’ = f(x,y,y’), \quad x\in[a,b] \\<br>y(a) = \alpha, \quad y’(a) = \gamma_1<br>$$<br>解此初值问题，得到 $y(b)$ 的值 $\beta_1$，并与 $\beta$ 比较，如果误差足够小，则认为假设的 $y’(a)=\gamma_1$ 是合理的。否则，就对 $\gamma_1$ 进行修正，比如令 $\gamma_2 = \tfrac{\beta}{\beta_1}\gamma_1$，然后再以 $y’(a)=\gamma_2$ 为初值，继续求解初值问题。直到得到的初值问题的解$y(b)=\beta_k$ 与 $\beta$ 足够接近为止。</p>
<p>上述方程可以归纳为，将初值问题转化为如下边值问题<br>$$<br>y’’ = f(x,y,y’), \quad x\in[a,b] \\<br>y(a) = \alpha, \quad y’(a) = \gamma_k, k=1,2,\cdots<br>$$<br>若记问题 $y_k(x)$ 的解为 $y(x;\gamma_k)$，则 $\gamma_k$ 的理想值应该满足<br>$$<br>F(\gamma) = y(b;\gamma)-\beta = 0<br>$$<br>这个方程，可以用牛顿迭代法来求解：<br>$$<br>\gamma_{k+1} = \gamma_k-\frac{F(\gamma_k)}{F’(\gamma_k)}<br>$$<br>其中，$F(\gamma_k)=y(b;\gamma_k)-\beta=\beta_k-\beta$。那么 $F’(\gamma_k)$ 该如何得到呢？根据 $F(\gamma_k)$ 的定义，可以知道 $F’(\gamma_k) = \frac{\partial y(b;\gamma)}{\partial \gamma}\big|_{\gamma=\gamma_k}$，若定义 $W=\frac{\partial y(b;\gamma)}{\partial \gamma}$，则 $F’(\gamma_k)=W(b;\gamma_k)$。</p>
<p>将上述归纳形式的初值问题，对$\gamma$ 求偏导，得<br>$$<br>\frac{\partial y’’}{\partial \gamma} = \frac{\partial f(x,y(x;\gamma),y’(x,y’))}{\partial y} \frac{\partial y(x;\gamma)}{\partial \gamma} + \frac{\partial f(x,y(x;\gamma),y’(x,y’))}{\partial y’} \frac{\partial y’(x,y’)}{\partial \gamma}<br>$$</p>
<p>根据 $W$ 的定义，有<br>$$<br>W=\frac{\partial y(x;\gamma)}{\partial \gamma}, W’=\frac{\partial y’(x,y’)}{\partial \gamma}, W’’=\frac{\partial y’’}{\partial \gamma}<br>$$</p>
<p>于是，可以得到一个关于 $W$ 的二阶常微分方程<br>$$<br>W’’=\frac{\partial f(x,y,y’)}{\partial y} W + \frac{\partial f(x,y,y’)}{\partial y’}W’<br>$$<br>其定解条件为<br>$$<br>W(a)=\frac{\partial y(a;\gamma)}{\partial \gamma}=0, W’(a)=\frac{\partial y’(a;\gamma)}{\partial \gamma}=\frac{\partial \gamma}{\partial \gamma} = 1<br>$$</p>
<p>这样就构成了一个关于 $W$ 的二阶初值常微分方程。<br>总结一下，二阶常微分方程的边值问题<br>$$<br>y’’ = f(x,y,y’), \quad x\in[a,b] \\<br>y(a) = \alpha, \quad y(b) = \beta<br>$$<br>的求解步骤如下：</p>
<ol>
<li>假定一个 $\gamma_1$ 值，求解初值问题<br>$$<br>y’’ = f(x,y,y’), \quad x\in[a,b] \\<br>y(a) = \alpha, \quad y’(a) = \gamma_1<br>$$<br>然后计算 $F(\gamma_1)=y(b;\gamma_1)$</li>
<li>求解关于 $W$ 的初值问题<br>$$<br>W’’=\frac{\partial f(x,y,y’)}{\partial y} W + \frac{\partial f(x,y,y’)}{\partial y’}W’ \\<br>W(a) = 0, W’(a) = 1<br>$$<br>然后计算 $F’(\gamma_1) = W(b;\gamma_1)$。</li>
<li>更新$\gamma$ 的值，<br>$$<br>\gamma_2 = \gamma_1-\frac{F(\gamma_1)}{F’(\gamma_1)}<br>$$<br>继续迭代，直到最后得到的 $y(b;\gamma_k)$ 与 $\beta$ 足够接近为止。</li>
</ol>
<h5 id="2-_OpenFOAM_中的实现">2. OpenFOAM 中的实现</h5><p>为了在OpenFOAM中求解一个任意阶常微分方程的初值问题，需要做如下准备。<br>考虑一个通用形式的常微分方程<br>$$<br>y^{n}=f(x,y,y’,\cdots,y^{n-1})<br>$$<br>定义<br>$$<br>\begin{align*}<br>y_1 &amp;=y\\<br>y_2 &amp;=y’\\<br>y_j &amp;=y^{\,j-1}, \quad j=1,2,\cdots,n<br>\end{align*}<br>$$<br>如果是求解刚性问题的 ODE 求解器，还需要定义 jacobian 矩阵。<br>令<br>$$<br>\begin{align*}<br>f_1 &amp;=y’=y_2\\<br>f_j &amp;=y’_{j}=y^{\,j+1}, \quad j=1,2,\cdots,n<br>\end{align*}<br>$$<br>则 jacobian 矩阵<br>$$<br>\begin{equation*}<br>J =<br>\begin{bmatrix}<br>\frac{\partial f_1}{\partial y_1} &amp; \frac{\partial f_1}{\partial y_2} &amp;<br>\cdots &amp;\frac{\partial f_1}{\partial y_n}\\<br>\frac{\partial f_2}{\partial y_1} &amp; \frac{\partial f_2}{\partial y_2} &amp;<br>\cdots &amp;\frac{\partial f_2}{\partial y_n}\\<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>\frac{\partial f_n}{\partial y_1} &amp; \cdots &amp; \cdots<br>&amp;\frac{\partial f_n}{\partial y_n}<br>\end{bmatrix}<br>\end{equation*}<br>$$<br>此外，还需要给出 $f_1, f_2,\cdots,f_n$ 对自变量 $x$ 的偏导数，$\frac{\partial f_1}{\partial x}, \frac{\partial f_2}{\partial x},\cdots,\frac{\partial f_n}{\partial x}$。</p>
<p>下面举一个例子来具体说明。以常微分方程<br>$$<br>y’’=2x+2, x\in[0,1] \\<br>y(0) = 0, y’(0)= 0<br>$$<br>为例，需要定义的量为<br>$$<br>\begin{align*}<br>f_1 &amp;=y’=y_2 \\<br>f_2 &amp;= y’_{2} = 2x+2<br>\end{align*}<br>$$</p>
<p>$$<br>\begin{equation*}<br>J=<br>\begin{bmatrix}<br>0 &amp; 1 \\<br>0 &amp; 0<br>\end{bmatrix}<br>\end{equation*}<br>$$</p>
<p>$$<br>\frac{\partial f_1}{\partial x} = 0, \frac{\partial f_2}{\partial x} = 2<br>$$</p>
<p>求解这个常微分方程的代码如下：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">Description</span><br><span class="line"></span><br><span class="line">d2y/dx2 = ax + b, with a=2, b=2.</span><br><span class="line">initial value: y(0) = 0; y'(0) = 0</span><br><span class="line"></span><br><span class="line">analytical solution: y = 1/3<span class="keyword">*</span>x^3 + x^2;</span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>/</span><br><span class="line"></span><br><span class="line"><span class="comment">#include "argList.H"</span></span><br><span class="line"><span class="comment">#include "IOmanip.H"</span></span><br><span class="line"><span class="comment">#include "ODESystem.H"</span></span><br><span class="line"><span class="comment">#include "ODESolver.H"</span></span><br><span class="line"></span><br><span class="line">using namespace Foam;</span><br><span class="line"></span><br><span class="line">·// <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> //</span><br><span class="line"></span><br><span class="line">class myODE2</span><br><span class="line">:</span><br><span class="line">    public ODESystem</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    const scalar a_; //parameter</span><br><span class="line">    const scalar b_; //parameter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    myODE2(const scalar&amp; a, const scalar&amp; b)</span><br><span class="line">	:ODESystem(),</span><br><span class="line">	a_(a),</span><br><span class="line">	b_(b)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    label nEqns() const // number of equations, equals to the order of ODE</span><br><span class="line">    &#123;</span><br><span class="line">        return 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void derivatives</span><br><span class="line">    (</span><br><span class="line">        const scalar x,</span><br><span class="line">        const scalarField&amp; y,</span><br><span class="line">        scalarField&amp; dydx</span><br><span class="line">    ) const</span><br><span class="line">    &#123;</span><br><span class="line">        dydx[0] = y[1];         //f1</span><br><span class="line">        dydx[1] = a_<span class="keyword">*</span>x + b_;    //f2</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void jacobian // optional</span><br><span class="line">    (</span><br><span class="line">        const scalar x,</span><br><span class="line">        const scalarField&amp; y,</span><br><span class="line">        scalarField&amp; dfdx,</span><br><span class="line">        scalarSquareMatrix&amp; dfdy</span><br><span class="line">    ) const</span><br><span class="line">    &#123;</span><br><span class="line">        dfdx[0] = 0.0;        //df1/dx</span><br><span class="line">        dfdx[1] = a_;         //df2/dx</span><br><span class="line"></span><br><span class="line">        dfdy[0][0] = 0.0;     //df1/dy1</span><br><span class="line">        dfdy[0][1] = 1.0;     //df1/dy2</span><br><span class="line"></span><br><span class="line">        dfdy[1][0] = 0.0;     //df2/dy1</span><br><span class="line">        dfdy[1][1] = 0.0;     //df2/dy2</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> //</span><br><span class="line">// Main program:</span><br><span class="line"></span><br><span class="line">int main(int argc, char <span class="keyword">*</span>argv[])</span><br><span class="line">&#123;</span><br><span class="line">    argList::validArgs.append(<span class="string">"ODESolver"</span>);</span><br><span class="line">    argList args(argc, argv);</span><br><span class="line"></span><br><span class="line">    const scalar a = 2.0; </span><br><span class="line">    const scalar b = 2.0; </span><br><span class="line"></span><br><span class="line">    const label n = 100;         //number of steps</span><br><span class="line">    const scalar endTime = 1.0;  //upper bound of the interval</span><br><span class="line"></span><br><span class="line">    // Create the ODE system</span><br><span class="line">    myODE2 ode(a, b);</span><br><span class="line"></span><br><span class="line">    dictionary dict;</span><br><span class="line">    dict.add(<span class="string">"solver"</span>, args[1]);</span><br><span class="line"></span><br><span class="line">    // Create the selected ODE system solver</span><br><span class="line">    autoPtr<span class="variable">&lt;ODESolver&gt;</span> odeSolver = ODESolver::New(ode, dict);</span><br><span class="line"></span><br><span class="line">    // Initialise the ODE system fields</span><br><span class="line">    scalar xStart = 0.0;        // lower bound of the interval</span><br><span class="line">    scalar dx = endTime/n;      //step value</span><br><span class="line"></span><br><span class="line">    scalarField yStart(ode.nEqns());</span><br><span class="line">    yStart[0] = 0.0; // initial value of y</span><br><span class="line">    yStart[1] = 0.0; // initial value of y'</span><br><span class="line"></span><br><span class="line">    scalar dxEst = 0.1;</span><br><span class="line">    scalar xEnd  = 0.0;</span><br><span class="line"></span><br><span class="line">    scalarField dyStart(ode.nEqns()); // dyStart[0]=f1, dyStart[1]=f2 ...</span><br><span class="line"></span><br><span class="line">    for(label i =0; i<span class="variable">&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">	    xEnd = xStart + dx;</span><br><span class="line">	    ode.derivatives(xStart, yStart, dyStart);</span><br><span class="line">	    odeSolver-&gt;</span>solve(xStart, xEnd, yStart, dxEst);</span><br><span class="line">	    xStart = xEnd;</span><br><span class="line">	    Info <span class="variable">&lt;&lt; xStart &lt;&lt; "    " &lt;&lt; yStart[0] &lt;&lt; endl; // output (x,y) for each dx.</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>编译之后，假设你的可执行程序名为 <code>TestODE</code>，则运行<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TestODE RKCK45 &gt; <span class="command">log</span></span><br></pre></td></tr></table></figure></p>
<p>就得到了数值解。<br>将数值解与解析解画图如下<br><img src="/image/RKCK45.png" alt=""><br>可见在这里简单例子中，数值解与解析解吻合非常好。<br>同时注意，这个例子，用显式欧拉方法无法得到收敛的解。</p>
<p><strong>参考资料</strong>：</p>
<ol>
<li><a href="http://hassankassem.me/posts/ode/" target="_blank" rel="external">http://hassankassem.me/posts/ode/</a></li>
<li>余德浩 , 汤华中， 微分方程数值解法，科学出版社，2003</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>本篇介绍如何编写一个小程序来调用 OpenFOAM 的 ODE 求解器来求解任意常微分方程的初值问题。 </p>]]>
    
    </summary>
    
      <category term="ODE" scheme="http://xiaopingqiu.github.io/tags/ODE/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[fixedFluxPressure 边界条件]]></title>
    <link href="http://xiaopingqiu.github.io/2016/08/21/fixedFluxPressure/"/>
    <id>http://xiaopingqiu.github.io/2016/08/21/fixedFluxPressure/</id>
    <published>2016-08-21T06:47:12.000Z</published>
    <updated>2016-08-21T07:24:00.688Z</updated>
    <content type="html"><![CDATA[<p>本篇说说我对 fixedFluxPressure 边界条件的理解。</p>
<a id="more"></a>
<p>先来看 OpenFOAM-2.2.x 里的<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class fixedFluxPressureFvPatchScalarField</span><br><span class="line">:</span><br><span class="line">    <span class="keyword">public</span> fixedGradientFvPatchScalarField</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Private data</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Name of the predicted flux transporting the field</span></span><br><span class="line">        word phiHbyAName_;</span><br><span class="line">        <span class="comment">//- Name of the flux transporting the field</span></span><br><span class="line">        word phiName_;</span><br><span class="line">        <span class="comment">//- Name of the density field used to normalise the mass flux</span></span><br><span class="line">        <span class="comment">//  if neccessary</span></span><br><span class="line">        word rhoName_;</span><br><span class="line">        <span class="comment">//- Name of the pressure diffusivity field</span></span><br><span class="line">        word DpName_;</span><br><span class="line">        <span class="comment">//- Is the pressure adjoint, i.e. has the opposite sign</span></span><br><span class="line">        Switch adjoint_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">//- Runtime type information</span></span><br><span class="line">    TypeName(<span class="string">"fixedFluxPressure"</span>);</span><br><span class="line">    <span class="attribute">...</span><span class="attribute">...</span></span><br><span class="line">    <span class="attribute">...</span><span class="attribute">...</span></span><br><span class="line">    <span class="comment">//- Update the coefficients associated with the patch field</span></span><br><span class="line">    virtual <span class="literal">void</span> updateCoeffs();</span><br><span class="line">   </span><br><span class="line">    <span class="attribute">...</span><span class="attribute">...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其中 <code>updateCoeffs</code> 函数定义如下：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">void Foam::fixedFluxPressureFvPatchScalarField::updateCoeffs()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (updated())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> surfaceScalarField&amp; phiHbyA =</span><br><span class="line">        <span class="keyword">db</span>().lookupObject&lt;surfaceScalarField&gt;(phiHbyAName_);</span><br><span class="line">    <span class="keyword">const</span> surfaceScalarField&amp; phi =</span><br><span class="line">        <span class="keyword">db</span>().lookupObject&lt;surfaceScalarField&gt;(phiName_);</span><br><span class="line">    fvsPatchField&lt;<span class="keyword">scalar</span>&gt; phiHbyAp =</span><br><span class="line">        patch().patchField&lt;surfaceScalarField, <span class="keyword">scalar</span>&gt;(phiHbyA);</span><br><span class="line">    fvsPatchField&lt;<span class="keyword">scalar</span>&gt; phip =</span><br><span class="line">        patch().patchField&lt;surfaceScalarField, <span class="keyword">scalar</span>&gt;(phi);</span><br><span class="line">    <span class="keyword">const</span> scalarField *DppPtr = NULL;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">db</span>().foundObject&lt;volScalarField&gt;(DpName_))</span><br><span class="line">    &#123;</span><br><span class="line">        DppPtr =</span><br><span class="line">            &amp;patch().lookupPatchField&lt;volScalarField, <span class="keyword">scalar</span>&gt;(DpName_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">db</span>().foundObject&lt;surfaceScalarField&gt;(DpName_))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> surfaceScalarField&amp; Dp =</span><br><span class="line">            <span class="keyword">db</span>().lookupObject&lt;surfaceScalarField&gt;(DpName_);</span><br><span class="line">        DppPtr =</span><br><span class="line">            &amp;patch().patchField&lt;surfaceScalarField, <span class="keyword">scalar</span>&gt;(Dp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (adjoint_)</span><br><span class="line">    &#123;</span><br><span class="line">        gradient() = (phip - phiHbyAp)/patch().magSf()/(*DppPtr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        gradient() = (phiHbyAp - phip)/patch().magSf()/(*DppPtr);</span><br><span class="line">    &#125;</span><br><span class="line">    fixedGradientFvPatchScalarField::updateCoeffs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码的说明如下：</p>
<p>这个边界条件，继承自 <code>fixedGradientFvPatchScalarField</code>，可见它是一个用于压力场的第二类边界条件。其用如下公式来计算边界上的压力梯度：<br>$$<br>\nabla(p) = \frac{\phi_{H/A} - \phi}{|S_f| D_p}<br>$$</p>
<p>在设置边界条件的时候，可以指定 <code>phiHbyA</code>， <code>phi</code> 和 <code>Dp</code> 对应的场，如果不指定，则三个量对应的默认场名分别是 <code>phiHbyA</code>， <code>phi</code> 和 <code>Dp</code>，这时如果你的程序中找不到这三个场，那就将出错了。</p>
<p>这个边界条件可以这样理解：<br>首先来看单相流的情形，比如 <code>icoFoam</code>，半离散化的动量方程为<br>$$<br>AU=H-\nabla p<br>$$<br>即<br>$$<br>\nabla p = H - AU<br>$$<br>在入口处，理论上当计算收敛后，压力梯度应当是0。但是在构建压力方程<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fvScalarMatrix pEqn</span><br><span class="line"><span class="list">(</span><br><span class="line">   <span class="keyword">fvm</span>:<span class="keyword">:laplacian</span><span class="list">(<span class="keyword">rAU</span>, p)</span> == fvc:<span class="keyword">:div</span><span class="list">(<span class="keyword">phiHbyA</span>)</span></span><br><span class="line">)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>的时候，速度 $U$ 还没有经过修正，即这里的 $U$ 是预测值，所以，迭代过程中入口压力梯度不一定为零。将入口压力设置为等于 $H/A-U$，有助于提高计算稳定性。<br>从代码角度看，对压力方程而言，需要设置的是 inlet 边界上的 $(\nabla p)_{\bot} \cdot rAU$，<br>$$<br>(\nabla p)_{\bot} \cdot rAU = (\nabla p)_{\bot}/A_f = \frac{1}{A_f}(\nabla p \cdot \vec{n} \cdot |S_f|) = (H/A) \cdot S_f-U\cdot S_f<br>$$<br>设置的边界条件应为<br>$$<br>\nabla p \cdot \vec{n} = \frac{(H/A) \cdot S_f-U\cdot S_f}{\big |S_f \big| \cdot rAU}<br>$$</p>
<p>但实际上，<code>fixedFluxPressureFvPatchScalarField</code> 主要是用于两相流中，以 <code>twoPhaseEulerFoam</code> 为例，<br>半离散的动量方程为：<br>$$<br>U_{a}=\frac{1}{a_{p,a}}H(U_a)-\frac{\nabla p}{a_{p,a}\rho_a}+\frac{\alpha_b}{ a_{p,a} \rho_a} K U_b +\frac{1}{a_{p,a}} g<br>$$</p>
<p>$$<br>U_{b}=\frac{1}{a_{p,b}}H(U_b)-\frac{\nabla p}{a_{p,b}\rho_b}+\frac{\alpha_a}{ a_{p,b} \rho_b} K U_a +\frac{1}{a_{p,b}} g<br>$$</p>
<p>对 $U_a$ 项两边同时乘以 $\alpha_a$ ，$U_b$ 项两边同时乘以 $\alpha_b$ ，然后合并起来，得到<br>$$<br>\begin{align*}<br>\Big(\frac{\alpha_a}{a_{p,a}\rho_a}+ \frac{\alpha_b}{a_{p,b}\rho_b}\Big)\nabla p &amp; = \alpha_a \Big[\frac{1}{a_{p,a}}H(U_a)+\frac{\alpha_b}{ a_{p,a} \rho_a} K U_b +\frac{1}{a_{p,a}} g\Big] + \alpha_b \Big[ \frac{1}{a_{p,b}}H(U_b)+\frac{\alpha_a}{ a_{p,b} \rho_b} K U_a +\frac{1}{a_{p,b}} g\Big] \\<br>&amp; - (\alpha_a U_a + \alpha_b U_b)<br>\end{align*}<br>$$</p>
<p>转换成界面通量形式，则<br>$$<br>D_p \nabla p \cdot S_f = \alpha_a \cdot phiHbyA1 + \alpha_b \cdot phiHbyA2 - (\alpha_a \cdot phi1 + \alpha_b \cdot phi2) = phiHbyA - phi<br>$$</p>
<p>于是得到压力的边界条件为<br>$$<br>\nabla p \cdot \vec{n} = \frac{phiHbyA - phi}{Dp \cdot \big|S_f\big|}<br>$$<br>这大概就是 <code>fixedFluxPressureFvPatchScalarField</code> 的物理含义吧。</p>
<p>在 OpenFOAM-2.3.x 以后，<code>fixedFluxPressureFvPatchScalarField</code> 做了修改，不需要指定 <code>Dp</code> 等这些量的值，而是在求解器中直接指定压力梯度。<br>比如 <code>twoPhaseEulerFoam</code> 中<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">setSnGrad&lt;fixedFluxPressureFvPatchScalarField&gt;</span><br><span class="line">   (</span><br><span class="line">       p.boundaryField(),</span><br><span class="line">       (</span><br><span class="line">           phiHbyA.boundaryField()</span><br><span class="line">         - mrfZones.relative</span><br><span class="line">           (</span><br><span class="line">               alpha1f.boundaryField()</span><br><span class="line">              *(mesh.Sf().boundaryField() &amp; U1.boundaryField())</span><br><span class="line">             + alpha2f.boundaryField()</span><br><span class="line">              *(mesh.Sf().boundaryField() &amp; U2.boundaryField())</span><br><span class="line">           )</span><br><span class="line">       )/(mesh.magSf().boundaryField()*rAUf.boundaryField())</span><br><span class="line">   );</span><br></pre></td></tr></table></figure></p>
<p><code>setSnGrad</code> 这个函数的定义在 <code>fixedFluxPressureFvPatchScalarField</code> 中定义：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> GradBC&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">setSnGrad</span></span><br><span class="line">    <span class="params">(</span><br><span class="line">        volScalarField::GeometricBoundaryField&amp; bf,</span><br><span class="line">        <span class="keyword">const</span> FieldField&lt;fvsPatchField, scalar&gt;&amp; snGrad</span><br><span class="line">    )</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        forAll(bf, patchi)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (isA&lt;GradBC&gt;(bf[patchi]))</span><br><span class="line">            &#123;</span><br><span class="line">                refCast&lt;GradBC&gt;(bf[patchi]).updateCoeffs(snGrad[patchi]);<span class="comment">// 调用带一个参数的 updateCoeffs 函数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际调用的是这个函数，这个函数调用完以后，curTimeIndex_ 将等于当前时间步的标签。</span></span><br><span class="line"><span class="keyword">void</span> Foam::fixedFluxPressureFvPatchScalarField::updateCoeffs</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; snGradp</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (updated())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    curTimeIndex_ = <span class="keyword">this</span>-&gt;db().time().timeIndex();</span><br><span class="line"></span><br><span class="line">    gradient() = snGradp;</span><br><span class="line">    fixedGradientFvPatchScalarField::updateCoeffs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是，很多其他地方仍然需要不带参数的 updateCoeffs 函数接口。</span></span><br><span class="line"><span class="comment">// 这个函数将不起实质作用，但是，如果在调用这个无参的 updateCoeffs 函数之前，没有先调用带一个参数的 updateCoeffs 函数，</span></span><br><span class="line"><span class="comment">// curTimeIndex_ 也没有更新到当前的时间步标签，那就报错，表明不适合使用这个边界条件。</span></span><br><span class="line"><span class="keyword">void</span> Foam::fixedFluxPressureFvPatchScalarField::updateCoeffs()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (updated())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (curTimeIndex_ != <span class="keyword">this</span>-&gt;db().time().timeIndex())</span><br><span class="line">    &#123;</span><br><span class="line">        FatalErrorIn(<span class="string">"fixedFluxPressureFvPatchScalarField::updateCoeffs()"</span>)</span><br><span class="line">            &lt;&lt; <span class="string">"updateCoeffs(const scalarField&amp; snGradp) MUST be called before"</span></span><br><span class="line">               <span class="string">" updateCoeffs() or evaluate() to set the boundary gradient."</span></span><br><span class="line">            &lt;&lt; <span class="built_in">exit</span>(FatalError);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因此，显然，从 2.3 开始，只有在求解器中显式地调用带一个参数的 updateCoeffs 函数来指定 p 的边界条件时，该求解器的算例才能使用 <code>fixedFluxPressure</code> 这个边界条件。 </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本篇说说我对 fixedFluxPressure 边界条件的理解。</p>]]>
    
    </summary>
    
      <category term="Boundary conditions" scheme="http://xiaopingqiu.github.io/tags/Boundary-conditions/"/>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenFOAM 中用手动并行分块的方法]]></title>
    <link href="http://xiaopingqiu.github.io/2016/08/21/ManualDecomposition/"/>
    <id>http://xiaopingqiu.github.io/2016/08/21/ManualDecomposition/</id>
    <published>2016-08-21T06:34:46.000Z</published>
    <updated>2016-08-21T06:45:29.922Z</updated>
    <content type="html"><![CDATA[<p>OpenFOAM 提供了许多并行区域划分的方法，常用的有 simple，scotch 等。但是，有时候希望能手动地将指定区域指派给一个进程，幸运的是 OpenFOAM 提供了这样的功能。本篇就来介绍一下如何进行手动并行分块。</p>
<a id="more"></a>
<p>以自带的 dambreak 算例为例，首先，将分块方法设置为 simple，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">numberOfSubdomains <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">method          simple;</span><br><span class="line"></span><br><span class="line">simpleCoeffs</span><br><span class="line">&#123;</span><br><span class="line">    n               ( <span class="number">2</span> <span class="number">2</span> <span class="number">1</span> );</span><br><span class="line">    delta           <span class="number">0.001</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后，运行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">decomposePar -cellDist</span><br></pre></td></tr></table></figure></p>
<p>于是便在 0 下面得到一个 <code>volScalarField</code>：<code>cellDist</code>。<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">FoamFile</span><br><span class="line">&#123;</span><br><span class="line">    version     2.0;</span><br><span class="line">    format      ascii;</span><br><span class="line">    class       volScalarField;</span><br><span class="line">    location    <span class="string">"0"</span>;</span><br><span class="line">    object      cellDist;</span><br><span class="line">&#125;</span><br><span class="line">// <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> //</span><br><span class="line"></span><br><span class="line">dimensions      [0 0 0 0 0 0 0];</span><br><span class="line"></span><br><span class="line">internalField   nonuniform List<span class="variable">&lt;scalar&gt;</span> </span><br><span class="line">2268</span><br><span class="line">(</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">...</span><br><span class="line">);</span><br><span class="line">boundaryField</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，上面可以看到， <code>cellDist</code> 的值是 1 和 0 等，这个值，对应着将来该网格将被分配到的 processor 的id。</p>
<p>所以，如果将 <code>cellDist</code> 当成是一个标量场，然后用设置初始场的工具对其值进行初始化，将来就能将对应网格手动分配到 <code>cellDist</code> 的值对应的进程。</p>
<p>OpenFOAM 自带的设置初始场的工具是 <code>setFields</code> ， <code>swak4Foam</code> 中的 <code>funkySetField</code> 也是可以的。这里介绍 <code>setFields</code> 的用法。</p>
<p>使用 <code>setFields</code> ，需要编写 <code>setFieldsDict</code>，示例如下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">defaultFieldValues</span><br><span class="line">(</span><br><span class="line">    volScalarFieldValue cellDist <span class="number">0</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">regions</span><br><span class="line">(</span><br><span class="line">    boxToCell</span><br><span class="line">    &#123;</span><br><span class="line">        box (<span class="number">0</span> <span class="number">0</span> -<span class="number">1</span>) (<span class="number">0.2</span> <span class="number">0.2</span> <span class="number">1</span>);</span><br><span class="line">        fieldValues</span><br><span class="line">        (</span><br><span class="line">            volScalarFieldValue cellDist <span class="number">1</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    boxToCell</span><br><span class="line">    &#123;</span><br><span class="line">        box (<span class="number">0</span> <span class="number">0.2</span> -<span class="number">1</span>) (<span class="number">0.2</span> <span class="number">0.6</span> <span class="number">1</span>);</span><br><span class="line">        fieldValues</span><br><span class="line">        (</span><br><span class="line">            volScalarFieldValue cellDist <span class="number">2</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    boxToCell</span><br><span class="line">    &#123;</span><br><span class="line">        box (<span class="number">0.2</span> <span class="number">0.2</span> -<span class="number">1</span>) (<span class="number">0.6</span> <span class="number">0.6</span> <span class="number">1</span>);</span><br><span class="line">        fieldValues</span><br><span class="line">        (</span><br><span class="line">            volScalarFieldValue cellDist <span class="number">3</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>这里，用的是最简单的 <code>boxToCell</code>，即指定一个 box 中的网格的 <code>cellDist</code> 值。 <code>setFields</code> 还有很多种方式来设置初始值。这里再举一个例子，可以先用 <code>topoSet</code> 来将指定区域的网格先提取到 <code>cellSet</code> ，然后，对整个 <code>cellSet</code> 的网格的 <code>cellDist</code> 值进行指定，示例如下：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">defaultFieldValues <span class="list">( <span class="keyword">volScalarFieldValue</span> cellDist <span class="number">0</span> )</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">regions         </span><br><span class="line"><span class="list">(</span><br><span class="line">    <span class="keyword">cellToCell</span></span><br><span class="line">    &#123;</span><br><span class="line">        set cellSet1 <span class="comment">; </span></span><br><span class="line">        fieldValues</span><br><span class="line">        <span class="list">( </span><br><span class="line">            <span class="keyword">volScalarFieldValue</span> cellDist <span class="number">1</span></span><br><span class="line">        )</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cellToCell1</span><br><span class="line">    &#123;</span><br><span class="line">        set cellSet2 <span class="comment">; </span></span><br><span class="line">        fieldValues</span><br><span class="line">        <span class="list">( </span><br><span class="line">            <span class="keyword">volScalarFieldValue</span> cellDist <span class="number">2</span></span><br><span class="line">        )</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p><code>topoSet</code> 的用法这里不举例了，有很多花样，详细的信息可以参考 <code>applications/utilities/mesh/manipulation/topoSet/topoSetDict</code> 中的说明。</p>
<p>设置好 <code>setFieldDict</code>以后，运行 <code>setFields</code>，便对 <code>cellDist</code> 的值进行了修改，可视化如下</p>
<p><img src="/image/cellDistValue.png" alt=""></p>
<p>下一步，需要根据 <code>cellDist</code> 的值来创建一个 <code>labelList</code>，因为手动分块的时候，需要的是一个 <code>labelList</code> 。<br>在constant下创建一个文件， <code>cellDecomposition</code> ，内容如下<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">FoamFile</span><br><span class="line">&#123;</span><br><span class="line">    version     2.0;</span><br><span class="line">    format      ascii;</span><br><span class="line">    class       labelList;</span><br><span class="line">    location    <span class="string">"constant"</span>;</span><br><span class="line">    object      cellDecomposition;</span><br><span class="line">&#125;</span><br><span class="line">// <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> //</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2268</span><br><span class="line">(</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">......</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>注意文件头的写法。 <code>()</code> 内的内容与 <code>cellDist</code> 文件中 <code>()</code> 内的内容一样。</p>
<p>再下一步，就是修改 <code>decomposeParDict</code><br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">numberOfSubdomains <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">method</span>           manual;</span><br><span class="line"></span><br><span class="line">manualCoeffs</span><br><span class="line">&#123;</span><br><span class="line">    dataFile        <span class="string">"cellDecomposition"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后再运行 <code>decomposePar -force</code>，这样就得到了根据 <code>cellDist</code> 值来指定的分块方式，如下</p>
<p><img src="/image/decomposition.png" alt=""></p>
<p>注意看这里的进程边界，跟上图中 <code>cellDist</code> 的值的边界是一样的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>OpenFOAM 提供了许多并行区域划分的方法，常用的有 simple，scotch 等。但是，有时候希望能手动地将指定区域指派给一个进程，幸运的是 OpenFOAM 提供了这样的功能。本篇就来介绍一下如何进行手动并行分块。</p>]]>
    
    </summary>
    
      <category term="Preprocessing" scheme="http://xiaopingqiu.github.io/tags/Preprocessing/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LES 中的 commutation error]]></title>
    <link href="http://xiaopingqiu.github.io/2016/08/21/commutationError/"/>
    <id>http://xiaopingqiu.github.io/2016/08/21/commutationError/</id>
    <published>2016-08-21T03:27:48.000Z</published>
    <updated>2016-08-21T06:27:37.355Z</updated>
    <content type="html"><![CDATA[<p>大涡模拟不仅对网格的解析度有要求，而且对网格质量也有更高的要求。本文介绍一种由网格带来的误差，commutation error，并简单分析其对结果的影响。</p>
<a id="more"></a>
<p>在 LES 模拟的程序中，常用的一种过滤方法是隐式过滤，即，用当地网格的尺度作为该处的过滤尺度。这种方法在各种类型的网格上实现起来都相对简单。只是，稍微复杂一点的几何构体，生成的网格的尺度总是不可能一样，这也就意味着过滤尺度是变化的。如果相邻网格的尺度变化很大，这也将引起相邻网格的过滤尺度相差很大，这时就会带来严重的 commutation error。</p>
<p>Commutation error 产生的根本原因是，当相邻网格过滤尺度不一样时，，$\overline{\tfrac{\partial \phi}{\partial x}} \neq \tfrac{\partial \overline{\phi}}{\partial x}$。下面举一个例子来说明：<br>假设有一个场量，解析值为<br>$$<br>\phi = 1-x^2<br>$$<br>其导数为<br>$$<br>\frac{\partial \phi}{\partial x} = -2x<br>$$<br>在一个如下图的网格中来进行过滤</p>
<p><img src="/image/LES/filterGrid.png" alt=""></p>
<p>第一次，我们对点 $P$ 和 $N_1$ 处进行过滤，过滤直径都是 $\Delta_1 = 1$，使用 top hat 过滤函数，即</p>
<p>$$<br>G(x,\Delta)=<br>\begin{cases}<br>\frac{1}{\Delta} &amp; if(|x’\le\frac{\Delta}{2}|) \\<br>0 &amp; otherwise<br>\end{cases}<br>$$</p>
<p>则<br>$$<br>\overline{\phi}_P = \oint G(x,x\prime;\Delta)\,f(x\prime) dx\prime = \int _{-\infty} ^{-1} 0\cdot \phi(x\prime) dx\prime + \int_{-1}^{0} \frac{1}{\Delta_1} \cdot \phi(x\prime)dx\prime + \int _{0} ^{\infty} 0\cdot \phi(x\prime) dx\prime = \frac{2}{3}<br>$$<br>类似地，<br>$$<br>\overline{\phi}_{N_1} = \int_0^1 \frac{1}{\Delta_1} \cdot \phi(x\prime) dx\prime = \frac{2}{3}<br>$$</p>
<p>另一方面，对梯度使用过滤，得<br>$$<br>\Bigg(\overline{\frac{\partial \phi}{\partial x}} \Bigg)_0= \int_{-0.5}^{0.5} \frac{1}{\Delta_1}\cdot(-2x)dx = 0<br>$$<br>而<br>$$<br>\frac{\partial \overline{\phi}}{\partial x} = \frac{\overline{\phi}_{N1}-\overline{\phi}_P}{x_{N1}-x_{P}} = 0<br>$$</p>
<p>这说明，当相邻网格的过滤尺度一致时，commutation error 为零。但是，当过滤尺度不一致时，考虑右边的网格中心为 $N_2$ 的情形，此时<br>$$<br>\overline{\phi}_{N2} = \int_{0}^{0.5} \frac{1}{\Delta_2} \cdot \phi dx = \frac{11}{12}<br>$$</p>
<p>$$<br>\frac{\partial \overline{\phi}}{\partial x} = \frac{\overline{\phi}_{N2}-\overline{\phi}_P}{x_{N2}-x_{P}} = \frac{1}{6} \neq  0<br>$$<br>这时就产生了 commutation error。</p>
<p>所以，网格尺度不均匀现象严重的区域就会出现显著的 commutation error。边界层是容易出现网格尺度不一致的区域，在壁面上，严格来说，过滤尺度必须是零，否则将破坏无滑移条件。这种情况还可以通过 DES 这样的方法来处理。但是，核心区也可能出现相邻网格不一致的情形。局部网格加密是一种实用的节省计算量的方法，这种方法只需要在重要区域进行加密，不必全局加密。但是局部加密就导致了相邻网格尺度不一致，由此就带来了显著的 commutation error。所以，使用局部加密时，要注意<strong>不要让相邻两种等级的网格的边界落在重要区域</strong>。</p>
<p>局部加密效应可以从下图看出</p>
<p><img src="/image/LES/localRefinement.png" alt=""></p>
<p>当从细网格向粗网格过渡时，会出现亚格子粘度的突降；当从粗网格过渡到细网格时，亚格子粘度会突然上升。有一种办法是对过滤尺度进行光滑处理：</p>
<p>$$<br>\Delta P=max(\Delta P, \Delta N/C_{\Delta s})<br>$$</p>
<p><img src="/image/LES/smoothedDelta.png" alt=""></p>
<p>$C_{\Delta s}$ 的取值约为 1.5。</p>
<p>用这种方法可让局部加密带来的问题得到部分缓解。亚格子粘度在粗细网格交接附近的过渡也更光滑。</p>
<p><img src="/image/LES/smoothedViscosity.png" alt=""></p>
<p>误差总是无可避免的，降低误差的技术也有很多。从“计算性价比”（即为了得到一定准确度的结果所耗费的计算量） 的角度看，没有哪个结果就一定是严格地错误或者正确，只是“计算性价比”不同。有时候为了降低计算量，在一些区域即便产生了严重的误差，也是可以接受的。关键是要对误差差生的原因有清楚的认识，尽量不要让很大的误差出现在重要的区域。</p>
<p>本篇的图，文，公式，完全取材整理自 Eugene de Villiers 的博士论文 “The Potential of Large Eddy Simulation for the Modeling of Wall Bounded Flows”，特此声明。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>大涡模拟不仅对网格的解析度有要求，而且对网格质量也有更高的要求。本文介绍一种由网格带来的误差，commutation error，并简单分析其对结果的影响。</p>]]>
    
    </summary>
    
      <category term="LES" scheme="http://xiaopingqiu.github.io/tags/LES/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenFOAM 中的热物理类之添加新模型]]></title>
    <link href="http://xiaopingqiu.github.io/2016/06/25/thermophysics5/"/>
    <id>http://xiaopingqiu.github.io/2016/06/25/thermophysics5/</id>
    <published>2016-06-25T13:27:55.000Z</published>
    <updated>2016-06-25T13:30:51.827Z</updated>
    <content type="html"><![CDATA[<p>本篇探讨如何增加一个新的热物理模型。</p>
<a id="more"></a>
<p>有了前面的基础，增加一个模型应该不在话下了，这里给出一个例子。<br>关键在调用 <code>makeThermo</code> 宏函数，来将各个子模型组合起来，形成一个新的热物理模型，并添加到合适的 hashTable 里。</p>
<p>这里只看看怎么来增加状态方程模型，transport 模型（描述黏度 随温度的变化），thermo 模型（描述 cp 随温度的变化），energy 模型。将 <code>perfectGas</code>， <code>constTransport</code>， <code>hConstThermo</code>，以及 <code>sensibleInternalEnergy</code> 拷贝出来到一个目录下，并分别重命名为 <code>my+原始模型名</code> 的形式。同时，修改各个模型的typeName，比如， <code>perfectGas</code> 修改为 <code>myperfectGas</code>， <code>myperfectGas.H</code> 的 <code>typeName</code> 修改为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> word <span class="title">typeName</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"myperfectGas&lt;"</span> + word(Specie::typeName_()) + <span class="string">'&gt;'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，这里 <code>typeName</code> 一定要改，否则，将在运行算例的时候，出现 <code>duplicate entry</code> 的错误，根本原因在于，将模型添加到 hashTable 的时候，hashTable 的 key 是由 <code>typeName</code> 组合而成的，如果新模型使用了跟旧模型一样的 <code>typeName</code> 就可能会在 hashTable 出现两个一个一样的 key，即 <code>duplicate entry</code>。</p>
<p>然后，将 <code>src/thermophysicalModels/basic/rhoThermo</code> 目录下的 <code>rhoThermos.C</code> 拷贝到新模型所在目录下，并修改为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "rhoThermo.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "makeThermo.H"</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "specie.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "perfectGas.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "myperfectGas.H" <span class="comment">// 新加的</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "incompressiblePerfectGas.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "rhoConst.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "perfectFluid.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "PengRobinsonGas.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "adiabaticPerfectFluid.H"</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "hConstThermo.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "myhConstThermo.H" <span class="comment">// 新加的</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "janafThermo.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "sensibleEnthalpy.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "sensibleInternalEnergy.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "mysensibleInternalEnergy.H" <span class="comment">// 新加的</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "thermo.H"</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "constTransport.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "myconstTransport.H" <span class="comment">// 新加的</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "sutherlandTransport.H"</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "icoPolynomial.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "hPolynomialThermo.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "polynomialTransport.H"</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "heRhoThermo.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "pureMixture.H"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Foam</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">makeThermo</span><br><span class="line">(</span><br><span class="line">    rhoThermo,</span><br><span class="line">    heRhoThermo,</span><br><span class="line">    pureMixture,</span><br><span class="line">    myconstTransport,</span><br><span class="line">    mysensibleInternalEnergy,</span><br><span class="line">    myhConstThermo,</span><br><span class="line">    myperfectGas,</span><br><span class="line">    specie</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// End namespace Foam</span></span><br></pre></td></tr></table></figure></p>
<p>注意，头文件里有四个是新加的。 <code>makeThermo</code> 宏只调用了一次，即这里只增加了一个模型。其他的组合当然也是可以的，比如像这样<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">makeThermo</span><br><span class="line"><span class="list">(</span><br><span class="line">    <span class="keyword">rhoThermo</span>,</span><br><span class="line">    heRhoThermo,</span><br><span class="line">    pureMixture,</span><br><span class="line">    constTransport,</span><br><span class="line">    sensibleInternalEnergy,</span><br><span class="line">    hConstThermo,</span><br><span class="line">    myperfectGas,</span><br><span class="line">    specie</span><br><span class="line">)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>灵活组合就好了。</p>
<p>最后，将 <code>src/thermophysicalModels/basic</code> 目录下的 <code>Make</code> 拷贝到新模型所在目录下。并将 <code>files</code> 和 <code>options</code> 如下：</p>
<ul>
<li><p>files</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rhoThermos.C</span><br><span class="line"></span><br><span class="line"><span class="constant">LIB</span> = <span class="variable">$(FOAM_USER_LIBBIN)</span>/libMyTestfluidThermophysicalModels</span><br></pre></td></tr></table></figure>
</li>
<li><p>options</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">EXE_INC = \</span><br><span class="line">    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/finiteVolume/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/thermophysicalModels/specie/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/thermophysicalModels/basic/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/meshTools/lnInclude </span><br><span class="line"></span></span><br><span class="line"></span><br><span class="line">LIB_LIBS = \</span><br><span class="line">    -<span class="ruby">lfiniteVolume \</span><br><span class="line"></span>    -<span class="ruby">lspecie \</span><br><span class="line"></span>    -<span class="ruby">lfluidThermophysicalModels</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>注意，这里也作了修改， <code>EXE_INC</code> 里增加了 <code>-I$(LIB_SRC)/thermophysicalModels/basic/lnInclude \</code> ； <code>LIB_LIBS</code> 里增加了两条： <code>-lspecie</code> 和 <code>-lfluidThermophysicalModels</code> 。</p>
<p>有了这些，就万事具备了，下面给出一个目录树：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">├── const</span><br><span class="line">│   ├── myconstTransport<span class="class">.C</span></span><br><span class="line">│   ├── myconstTransport<span class="class">.H</span></span><br><span class="line">│   └── myconstTransportI<span class="class">.H</span></span><br><span class="line">├── hConst</span><br><span class="line">│   ├── myhConstThermo<span class="class">.C</span></span><br><span class="line">│   ├── myhConstThermo<span class="class">.H</span></span><br><span class="line">│   └── myhConstThermoI<span class="class">.H</span></span><br><span class="line">├── Make</span><br><span class="line">│   ├── files</span><br><span class="line">│   └── options</span><br><span class="line">├── perfectGas</span><br><span class="line">│   ├── myperfectGas<span class="class">.C</span></span><br><span class="line">│   ├── myperfectGas<span class="class">.H</span></span><br><span class="line">│   └── myperfectGasI<span class="class">.H</span></span><br><span class="line">├── rhoThermos<span class="class">.C</span></span><br><span class="line">└── sensibleInternalEnergy</span><br><span class="line">    └── mysensibleInternalEnergy.H</span><br></pre></td></tr></table></figure></p>
<p>运行 <code>wmake libso</code>，就能编译得到一个新的库了。</p>
<p>那么怎么调用新增的模型呢？分两步：</p>
<ol>
<li>修改 controlDict，增加一条 <code>libs ( &quot;libMyTestfluidThermophysicalModels.so&quot; );</code> </li>
<li>修改 <code>constant/thermophysicalProperties</code>，改为如下<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">thermoType</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title">type</span>            heRhoThermo;</span><br><span class="line">    <span class="title">mixture</span>         pureMixture;</span><br><span class="line">    <span class="title">transport</span>       myconst;</span><br><span class="line">    <span class="title">thermo</span>          myhConst;</span><br><span class="line">    <span class="title">equationOfState</span> myperfectGas;</span><br><span class="line">    <span class="title">specie</span>          specie;</span><br><span class="line">    <span class="title">energy</span>          mysensibleInternalEnergy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title">pRef</span>            <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line"><span class="title">mixture</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title">specie</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title">nMoles</span>          <span class="number">1</span>;</span><br><span class="line">        <span class="title">molWeight</span>       <span class="number">28</span>.<span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title">thermodynamics</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title">Cp</span>              <span class="number">1000</span>;</span><br><span class="line">        <span class="title">Hf</span>              <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title">transport</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title">mu</span>              <span class="number">1</span>.8e-<span class="number">05</span>;</span><br><span class="line">        <span class="title">Pr</span>              <span class="number">0</span>.<span class="number">7</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这样改好以后，新模型就会被调用了。当运行求解器的时候出现如下内容，<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">......</span><br><span class="line">......</span><br><span class="line">Reading thermophysical properties</span><br><span class="line"></span><br><span class="line">Selecting thermodynamics package </span><br><span class="line">&#123;</span><br><span class="line">    type            heRhoThermo;</span><br><span class="line">    mixture         pureMixture;</span><br><span class="line">    transport       myconst;</span><br><span class="line">    thermo          myhConst;</span><br><span class="line">    equationOfState myperfectGas;</span><br><span class="line">    specie          specie;</span><br><span class="line">    energy          mysensibleInternalEnergy;</span><br><span class="line">&#125;</span><br><span class="line">.......</span></span><br><span class="line">.......</span><br></pre></td></tr></table></figure></p>
<p>就表示新模型调用成功了。</p>
<p>最后提醒一下，这里的测试，只是将原有模型原封不动地拷贝出来了，只是改了 <code>tpeName</code>。实际应用场景肯定会比这个复杂，这里只是给出一个最基本的流程来供大家参考。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本篇探讨如何增加一个新的热物理模型。</p>]]>
    
    </summary>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="thermophysicalModels" scheme="http://xiaopingqiu.github.io/tags/thermophysicalModels/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一个具体能量方程的解析]]></title>
    <link href="http://xiaopingqiu.github.io/2016/06/25/thermophysics4/"/>
    <id>http://xiaopingqiu.github.io/2016/06/25/thermophysics4/</id>
    <published>2016-06-25T07:48:02.000Z</published>
    <updated>2016-06-25T08:03:40.062Z</updated>
    <content type="html"><![CDATA[<p>本篇来看一个具体的能量方程，以 <code>twoPhaseEulerFoam</code> 的 <code>EEqn.H</code> 为例。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    volScalarField&amp; he1 = thermo1.he();</span><br><span class="line">    volScalarField&amp; he2 = thermo2.he();</span><br><span class="line"></span><br><span class="line">    <span class="function">volScalarField <span class="title">Cpv1</span><span class="params">("Cpv1", thermo1.Cpv()</span>)</span>;</span><br><span class="line">    <span class="function">volScalarField <span class="title">Cpv2</span><span class="params">("Cpv2", thermo2.Cpv()</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">volScalarField <span class="title">heatTransferCoeff</span><span class="params">(fluid.heatTransferCoeff()</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">fvScalarMatrix <span class="title">he1Eqn</span></span><br><span class="line">    <span class="params">(</span><br><span class="line">        fvm::ddt(alpha1, rho1, he1)</span> + fvm::<span class="title">div</span><span class="params">(alphaRhoPhi1, he1)</span></span><br><span class="line">      - fvm::<span class="title">Sp</span><span class="params">(contErr1, he1)</span></span><br><span class="line"></span><br><span class="line">      + fvc::<span class="title">ddt</span><span class="params">(alpha1, rho1, K1)</span> + fvc::<span class="title">div</span><span class="params">(alphaRhoPhi1, K1)</span></span><br><span class="line">      - contErr1*K1</span><br><span class="line">      + <span class="params">(</span><br><span class="line">            he1.name()</span> </span>== thermo1.phasePropertyName(<span class="string">"e"</span>)</span><br><span class="line">          ? fvc::ddt(alpha1)*p + fvc::div(alphaPhi1, p)</span><br><span class="line">          : -alpha1*dpdt</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">      - fvm::laplacian</span><br><span class="line">        (</span><br><span class="line">            fvc::interpolate(alpha1)</span><br><span class="line">           *fvc::interpolate(thermo1.alphaEff(phase1.turbulence().mut())),</span><br><span class="line">            he1</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    he1Eqn.relax();</span><br><span class="line"></span><br><span class="line">    he1Eqn -=</span><br><span class="line">    (</span><br><span class="line">        heatTransferCoeff*(thermo2.T() - thermo1.T())</span><br><span class="line">      + heatTransferCoeff*he1/Cpv1</span><br><span class="line">      - fvm::Sp(heatTransferCoeff/Cpv1, he1)</span><br><span class="line">      + fvOptions(alpha1, rho1, he1)</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<p>对应的能量方程为（忽略fvOptions）<br>$$<br>\alpha \rho \frac{\partial (\mathrm{he})}{\partial t} + \alpha \rho U\cdot \nabla(\mathrm{he}) + \alpha \rho \frac{\partial (\mathrm{K})}{\partial t} + \alpha \rho U\cdot \nabla\mathrm{K} + \\<br>\begin{cases}<br>p\cdot\dfrac{\partial \alpha}{\partial t} + \nabla \cdot (\alpha U p) , &amp; \mbox{ if } he.name == \mbox{“e”} \\<br>-\alpha \dfrac{\partial p}{\partial t}, &amp; \mbox{  if } he.name == \mbox{“h”}<br>\end{cases} \\<br>-\nabla \cdot \big(\alpha \cdot \alpha_{eff} \nabla (\mathrm{he}) \big) - \gamma(T_2 - T_1) = 0<br>$$</p>
<p>代码里剩下的两项，<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ heatTransferCoeff*he1/Cpv1</span><br><span class="line">- fvm::<span class="function"><span class="title">Sp</span><span class="params">(heatTransferCoeff/Cpv1, he1)</span></span></span><br></pre></td></tr></table></figure></p>
<p>含义暂不明。这两项，其实是同一个公式，只是前者是显示处理，后者用了隐式源项，估计是为了数值稳定性的目的而构建的。</p>
<p>前面提过，对于如下设置，<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">thermoType</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title">type</span>             heRhoThermo;</span><br><span class="line">    <span class="title">mixture</span>          pureMixture;</span><br><span class="line">    <span class="title">transport</span>        const;</span><br><span class="line">    <span class="title">thermo</span>           hConst;</span><br><span class="line">    <span class="title">equationOfState</span>  perfectGas;</span><br><span class="line">    <span class="title">specie</span>           specie;</span><br><span class="line">    <span class="title">energy</span>           sensibleInternalEnergy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最终，<code>thermo</code> 指针指向的是 <code>heRhoThermo</code> 类的对象，所以，从 <code>heRhoThermo</code> 类的构造函数看起：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">BasicPsiThermo</span>, class <span class="type">MixtureType</span>&gt;</span><br><span class="line"><span class="type">Foam</span>::heRhoThermo&lt;<span class="type">BasicPsiThermo</span>, <span class="type">MixtureType</span>&gt;::heRhoThermo</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> fvMesh&amp; mesh,</span><br><span class="line">    <span class="keyword">const</span> word&amp; phaseName</span><br><span class="line">)</span><br><span class="line">:</span><br><span class="line">    heThermo&lt;<span class="type">BasicPsiThermo</span>, <span class="type">MixtureType</span>&gt;(mesh, phaseName)</span><br><span class="line">&#123;</span><br><span class="line">    calculate(); // 构造函数调用 calculate 函数来初始化所有的热物理相关量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可见，构造函数里调用了 <code>calculate</code> 函数，前面提过，这个函数的作用是更新各个热物理相关量。</p>
<p>接下来一个一个来看里面涉及到的函数。</p>
<h5 id="he"><code>he</code></h5><p><code>he</code> 其实是 “h or e”，具体是焓，还是内能，取决于 <code>energy</code> 这一项的设置。 <code>he</code> 函数在 <code>heThermo</code> 类中定义，返回的是数据成员 <code>he_</code>，所以这里需要看一下数据成员 <code>he_</code> 的初始化：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> BasicThermo, <span class="keyword">class</span> MixtureType&gt;</span><br><span class="line">Foam::heThermo&lt;BasicThermo, MixtureType&gt;::heThermo</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> fvMesh&amp; mesh,</span><br><span class="line">    <span class="keyword">const</span> dictionary&amp; dict,</span><br><span class="line">    <span class="keyword">const</span> word&amp; phaseName</span><br><span class="line">)</span><br><span class="line">:</span><br><span class="line">    BasicThermo(mesh, dict, phaseName),</span><br><span class="line">    MixtureType(*<span class="keyword">this</span>, mesh),</span><br><span class="line"></span><br><span class="line">    he_</span><br><span class="line">    (</span><br><span class="line">        IOobject</span><br><span class="line">        (</span><br><span class="line">            BasicThermo::phasePropertyName</span><br><span class="line">            (</span><br><span class="line">                MixtureType::thermoType::heName()</span><br><span class="line">            ),</span><br><span class="line">            mesh.time().timeName(),</span><br><span class="line">            mesh,</span><br><span class="line">            IOobject::NO_READ,</span><br><span class="line">            IOobject::NO_WRITE</span><br><span class="line">        ),</span><br><span class="line">        mesh,</span><br><span class="line">        dimEnergy/dimMass,</span><br><span class="line">        <span class="keyword">this</span>-&gt;heBoundaryTypes(),</span><br><span class="line">        <span class="keyword">this</span>-&gt;heBoundaryBaseTypes()</span><br><span class="line">    )</span><br><span class="line">&#123;</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里调用的 <code>init</code> 函数的内容为<br><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">template&lt;<span class="keyword">class</span> <span class="type">BasicThermo</span>, <span class="keyword">class</span> <span class="type">MixtureType</span>&gt;</span><br><span class="line">void <span class="type">Foam</span>::heThermo&lt;<span class="type">BasicThermo</span>, <span class="type">MixtureType</span>&gt;::init<span class="literal">()</span></span><br><span class="line">&#123;</span><br><span class="line">    scalarField&amp; heCells = he_.internalField<span class="literal">()</span>;</span><br><span class="line">    const scalarField&amp; pCells = this-&gt;p_.internalField<span class="literal">()</span>;</span><br><span class="line">    const scalarField&amp; <span class="type">TCells</span> = this-&gt;<span class="type">T_</span>.internalField<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">    forAll(heCells, celli)</span><br><span class="line">    &#123;</span><br><span class="line">        heCells[celli] =</span><br><span class="line">            this-&gt;cellMixture(celli).<span class="type">HE</span>(pCells[celli], <span class="type">TCells</span>[celli]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    forAll(he_.boundaryField<span class="literal">()</span>, patchi)</span><br><span class="line">    &#123;</span><br><span class="line">        he_.boundaryField<span class="literal">()</span>[patchi] == he</span><br><span class="line">        (</span><br><span class="line">            this-&gt;p_.boundaryField<span class="literal">()</span>[patchi],</span><br><span class="line">            this-&gt;<span class="type">T_</span>.boundaryField<span class="literal">()</span>[patchi],</span><br><span class="line">            patchi</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this-&gt;heBoundaryCorrection(he_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里调用了 <code>HE</code> 函数来初始化 <code>he_</code> 的内部场，并对调用另一个三个数的 <code>he</code> 函数其边界条件进行了修正：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> BasicThermo, <span class="keyword">class</span> MixtureType&gt;</span><br><span class="line">Foam::tmp&lt;Foam::scalarField&gt; Foam::heThermo&lt;BasicThermo, MixtureType&gt;::he</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; p,</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; T,</span><br><span class="line">    <span class="keyword">const</span> label patchi</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    tmp&lt;scalarField&gt; the(<span class="keyword">new</span> scalarField(T.size()));</span><br><span class="line">    scalarField&amp; he = the();</span><br><span class="line"></span><br><span class="line">    forAll(T, facei)</span><br><span class="line">    &#123;</span><br><span class="line">        he[facei] =</span><br><span class="line">            <span class="keyword">this</span>-&gt;patchFaceMixture(patchi, facei).HE(p[facei], T[facei]);</span><br><span class="line">            <span class="comment">// 本质上还是调用了 HE 函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> the;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再来看 <code>HE</code> 函数，这个函数看名字和参数，应该是根据压力和温度来计算能量的，其定义在 <code>species::thermo</code> 类：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Thermo, <span class="keyword">template</span>&lt;<span class="keyword">class</span>&gt; <span class="keyword">class</span> Type&gt;</span><br><span class="line"><span class="keyword">inline</span> Foam::scalar</span><br><span class="line">Foam::species::thermo&lt;Thermo, Type&gt;::HE(<span class="keyword">const</span> scalar p, <span class="keyword">const</span> scalar T) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Type&lt;thermo&lt;Thermo, Type&gt; &gt;::HE(*<span class="keyword">this</span>, p, T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里，由于能量最终是什么形式，取决于 <code>energy</code> 关键字对应的类，所以，这里也是调用了定义在前面提到的 <code>energy variable</code> 类中的 <code>HE</code> 函数，以 <code>sensibleInternalEnergy</code> 为例：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">scalar</span> <span class="keyword">HE</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> Thermo&amp; thermo,</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">scalar</span> p,</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">scalar</span> T</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> thermo.Es(p, T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可见，其返回的是 <code>species::thermo</code> 类的 <code>Es</code> 函数，<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Thermo</span>, <span class="keyword">template</span>&lt;class&gt; class <span class="type">Type</span>&gt;</span><br><span class="line">inline <span class="type">Foam</span>::scalar</span><br><span class="line"><span class="type">Foam</span>::species::thermo&lt;<span class="type">Thermo</span>, <span class="type">Type</span>&gt;::<span class="type">Es</span>(<span class="keyword">const</span> scalar p, <span class="keyword">const</span> scalar T) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> this-&gt;es(p, T)/this-&gt;W();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Thermo</span>, <span class="keyword">template</span>&lt;class&gt; class <span class="type">Type</span>&gt;</span><br><span class="line">inline <span class="type">Foam</span>::scalar</span><br><span class="line"><span class="type">Foam</span>::species::thermo&lt;<span class="type">Thermo</span>, <span class="type">Type</span>&gt;::es(<span class="keyword">const</span> scalar p, <span class="keyword">const</span> scalar T) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> this-&gt;hs(p, T) - p*this-&gt;W()/this-&gt;rho(p, T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> <code>hs</code> 函数定义在 <code>thermo</code> 类型的类中，以 <code>hConstThermo</code> 类为例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> equationOfState&gt;</span><br><span class="line"><span class="keyword">inline</span> Foam::scalar Foam::hConstThermo&lt;equationOfState&gt;::hs</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> scalar p, <span class="keyword">const</span> scalar T</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Cp_*T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>hs</code> 表示的是显焓，等于 <code>Cp_*T</code> 。 <code>es</code> 是内能，根据焓的定义，$H=U+pV$。代码中的 <code>hs</code> 和 <code>es</code> 都是 <code>J/kMol</code> 的量纲，所以，$es=hs-pV/n$ 。以理想气体状态方程为例，$pV=nRT$，或者写成 $pM=\rho RT$，得 $pV/n = RT = pM/\rho$ 。</p>
<p>注意，这里的 <code>Cp_</code>，在字典文件里给的是 <code>J/(kg.K)</code> 量纲的，但是在构造函数中，将其转成了 <code>J/(kmol.K)</code> 的量纲：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class equationOfState&gt;</span><br><span class="line"><span class="type">Foam</span>::hConstThermo&lt;equationOfState&gt;::hConstThermo(<span class="keyword">const</span> dictionary&amp; dict)</span><br><span class="line">:</span><br><span class="line">    equationOfState(dict),</span><br><span class="line">    <span class="type">Cp_</span>(readScalar(dict.subDict(<span class="string">"thermodynamics"</span>).lookup(<span class="string">"Cp"</span>))),</span><br><span class="line">    <span class="type">Hf_</span>(readScalar(dict.subDict(<span class="string">"thermodynamics"</span>).lookup(<span class="string">"Hf"</span>)))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">Cp_</span> *= this-&gt;W();</span><br><span class="line">    <span class="type">Hf_</span> *= this-&gt;W();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以，<code>hs</code>， <code>es</code> 是 <code>J/kmol</code> ； <code>Es</code>， <code>HE</code> 是 <code>J/kg</code>。</p>
<h5 id="Cpv">Cpv</h5><p>这个函数定义在 <code>heThermo</code> 类中。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> BasicThermo, <span class="keyword">class</span> MixtureType&gt;</span><br><span class="line">Foam::tmp&lt;Foam::volScalarField&gt;</span><br><span class="line">Foam::heThermo&lt;BasicThermo, MixtureType&gt;::Cpv() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> fvMesh&amp; mesh = <span class="keyword">this</span>-&gt;T_.mesh();</span><br><span class="line"></span><br><span class="line">    tmp&lt;volScalarField&gt; tCpv</span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">new</span> volScalarField</span><br><span class="line">        (</span><br><span class="line">            IOobject</span><br><span class="line">            (</span><br><span class="line">                <span class="string">"Cpv"</span>,</span><br><span class="line">                mesh.time().timeName(),</span><br><span class="line">                mesh,</span><br><span class="line">                IOobject::NO_READ,</span><br><span class="line">                IOobject::NO_WRITE</span><br><span class="line">            ),</span><br><span class="line">            mesh,</span><br><span class="line">            dimEnergy/dimMass/dimTemperature</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">    volScalarField&amp; cpv = tCpv();</span><br><span class="line"></span><br><span class="line">    forAll(<span class="keyword">this</span>-&gt;T_, celli)</span><br><span class="line">    &#123;</span><br><span class="line">        cpv[celli] =</span><br><span class="line">            <span class="keyword">this</span>-&gt;cellMixture(celli).Cpv(<span class="keyword">this</span>-&gt;p_[celli], <span class="keyword">this</span>-&gt;T_[celli]);</span><br><span class="line">    &#125;</span><br><span class="line">    forAll(<span class="keyword">this</span>-&gt;T_.boundaryField(), patchi)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> fvPatchScalarField&amp; pp = <span class="keyword">this</span>-&gt;p_.boundaryField()[patchi];</span><br><span class="line">        <span class="keyword">const</span> fvPatchScalarField&amp; pT = <span class="keyword">this</span>-&gt;T_.boundaryField()[patchi];</span><br><span class="line">        fvPatchScalarField&amp; pCpv = cpv.boundaryField()[patchi];</span><br><span class="line"></span><br><span class="line">        forAll(pT, facei)</span><br><span class="line">        &#123;</span><br><span class="line">            pCpv[facei] =</span><br><span class="line">                <span class="keyword">this</span>-&gt;patchFaceMixture(patchi, facei).Cpv(pp[facei], pT[facei]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tCpv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数，创建了一个 <code>tmp&lt;volScalarField&gt;</code>，然后调用定义在 <code>species::thermo</code> 类中的两参数 <code>Cpv</code> 函数来对场量进行初始化，这个函数的形式如下<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Thermo</span>, <span class="keyword">template</span>&lt;class&gt; class <span class="type">Type</span>&gt;</span><br><span class="line">inline <span class="type">Foam</span>::scalar</span><br><span class="line"><span class="type">Foam</span>::species::thermo&lt;<span class="type">Thermo</span>, <span class="type">Type</span>&gt;::<span class="type">Cpv</span>(<span class="keyword">const</span> scalar p, <span class="keyword">const</span> scalar T) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> this-&gt;cpv(p, T)/this-&gt;W();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Thermo</span>, <span class="keyword">template</span>&lt;class&gt; class <span class="type">Type</span>&gt;</span><br><span class="line">inline <span class="type">Foam</span>::scalar</span><br><span class="line"><span class="type">Foam</span>::species::thermo&lt;<span class="type">Thermo</span>, <span class="type">Type</span>&gt;::cpv(<span class="keyword">const</span> scalar p, <span class="keyword">const</span> scalar T) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Type</span>&lt;thermo&lt;<span class="type">Thermo</span>, <span class="type">Type</span>&gt; &gt;::cpv(*this, p, T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>cpv</code> 函数返回的是定义在 <code>energy variable</code> 类中的三参数 <code>cpv</code> 函数，对于 <code>sensibleInternalEnergy</code>，<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">scalar</span> cpv</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> Thermo&amp; thermo,</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">scalar</span> p,</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">scalar</span> T</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> thermo.cv(p, T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里返回的是 <code>species::thermo</code> 类的 <code>cv</code> 函数，<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Thermo</span>, <span class="keyword">template</span>&lt;class&gt; class <span class="type">Type</span>&gt;</span><br><span class="line">inline <span class="type">Foam</span>::scalar</span><br><span class="line"><span class="type">Foam</span>::species::thermo&lt;<span class="type">Thermo</span>, <span class="type">Type</span>&gt;::cv(<span class="keyword">const</span> scalar p, <span class="keyword">const</span> scalar T) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> this-&gt;cp(p, T) - this-&gt;cpMcv(p, T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的 <code>cp</code> 函数定义在 <code>thermo</code> 类型的类中，以 <code>hConst</code> 为例<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class equationOfState&gt;</span><br><span class="line">inline <span class="type">Foam</span>::scalar <span class="type">Foam</span>::hConstThermo&lt;equationOfState&gt;::cp</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> scalar p,</span><br><span class="line">    <span class="keyword">const</span> scalar T</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Cp_</span>; // 量纲是 J/(kmol.K)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>cpMcv</code> 的定义在状态方程类中，以 <code>perfectGas</code> 为例<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Specie</span>&gt;</span><br><span class="line">inline <span class="type">Foam</span>::scalar <span class="type">Foam</span>::perfectGas&lt;<span class="type">Specie</span>&gt;::cpMcv(scalar, scalar) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> this-&gt;<span class="type">RR</span>; // 量纲是 J/(kmol.K)，所以值应该是 <span class="number">8314</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="alphaEff">alphaEff</h5><p>这个函数需要一个参数，其定义在 <code>heThermo</code> 类中<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class <span class="constant">BasicThermo,</span> class <span class="constant">MixtureType&gt;</span></span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:tmp&lt;Foam</span><span class="symbol">:</span><span class="symbol">:volScalarField&gt;</span></span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:heThermo&lt;BasicThermo</span>, <span class="constant">MixtureType&gt;</span><span class="symbol">:</span><span class="symbol">:alphaEff</span></span><br><span class="line">(</span><br><span class="line">    const volScalarField&amp; alphat</span><br><span class="line">) const</span><br><span class="line">&#123;</span><br><span class="line">    tmp&lt;<span class="constant">Foam:</span><span class="symbol">:volScalarField&gt;</span> alphaEff(this-&gt;<span class="constant">CpByCpv(</span>)*(this-&gt;alpha<span class="constant">_</span> + alphat));</span><br><span class="line">    alphaEff().rename(<span class="string">"alphaEff"</span>);</span><br><span class="line">    <span class="keyword">return</span> alphaEff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里， 无参数的 <code>CpByCpv</code> 函数定义在 <code>species::thermo</code> 类中，最终调用的是 <code>energy varialble</code> 类中的 <code>CpByCpv</code> 函数，如果是内能形式的，则返回 <code>thermo.gamma(p, T)</code> ，焓形式则返回 <code>1</code>。 <code>gamma</code> 的定义在 <code>species::thermo</code><br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Thermo</span>, <span class="keyword">template</span>&lt;class&gt; class <span class="type">Type</span>&gt;</span><br><span class="line">inline <span class="type">Foam</span>::scalar</span><br><span class="line"><span class="type">Foam</span>::species::thermo&lt;<span class="type">Thermo</span>, <span class="type">Type</span>&gt;::gamma(<span class="keyword">const</span> scalar p, <span class="keyword">const</span> scalar T) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    scalar cp = this-&gt;cp(p, T);</span><br><span class="line">    <span class="keyword">return</span> cp/(cp - this-&gt;cpMcv(p, T));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>alpha_</code> 是层流能量扩散系数，定义在 <code>basicThermo</code> 类，并在该类的构造函数中初始化为零。在 <code>heRhoThermo</code> 类的 <code>calculate</code> 函数中，对其进行了更新<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="atom">scalarField</span>&amp; <span class="atom">alphaCells</span> = <span class="atom">this</span>-&gt;<span class="atom">alpha_</span>.<span class="atom">internalField</span>();</span><br><span class="line"><span class="atom">alphaCells</span>[<span class="atom">celli</span>] = <span class="atom">mixture_</span>.<span class="atom">alphah</span>(<span class="atom">pCells</span>[<span class="atom">celli</span>], <span class="name">TCells</span>[<span class="atom">celli</span>]);</span><br><span class="line"></span><br><span class="line"><span class="atom">fvPatchScalarField</span>&amp; <span class="atom">palpha</span> = <span class="atom">this</span>-&gt;<span class="atom">alpha_</span>.<span class="atom">boundaryField</span>()[<span class="atom">patchi</span>];</span><br><span class="line"><span class="atom">palpha</span>[<span class="atom">facei</span>] = <span class="atom">mixture_</span>.<span class="atom">alphah</span>(<span class="atom">pp</span>[<span class="atom">facei</span>], <span class="atom">pT</span>[<span class="atom">facei</span>]);</span><br></pre></td></tr></table></figure></p>
<p>可见， <code>alpha_</code> 的值是通过 <code>alphah</code> 函数来计算更新的，这个函数的定义在 <code>trasnport</code> 模型里，以 <code>constTransport</code> 为例<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Thermo</span>&gt;</span><br><span class="line">inline <span class="type">Foam</span>::scalar <span class="type">Foam</span>::constTransport&lt;<span class="type">Thermo</span>&gt;::alphah</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> scalar p,</span><br><span class="line">    <span class="keyword">const</span> scalar T</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> mu(p, T)*rPr_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>返回粘度与普朗特数的比值。<br>至于 <code>alphat</code> ，则是函数 <code>alphaEff</code> 的参数，根据开头的代码可知， <code>alphat</code> 其实是 <code>mut</code> 。<br>只是，暂时不知道为什么有效热扩散系数 <code>alphaEff = CpByCpv * (alpha + alphat)</code>。</p>
<p>构建起能量方程后，就该对其进行求解了。<br><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fvOptions.constrain(he1Eqn);</span><br><span class="line">   he1Eqn.solve<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">   fvOptions.constrain(he2Eqn);</span><br><span class="line">   he2Eqn.solve<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">   thermo1.correct<span class="literal">()</span>;</span><br><span class="line">   <span class="type">Info</span>&lt;&lt; <span class="string">"min "</span> &lt;&lt; thermo1.<span class="type">T</span><span class="literal">()</span>.name<span class="literal">()</span></span><br><span class="line">       &lt;&lt; <span class="string">" "</span> &lt;&lt; min(thermo1.<span class="type">T</span><span class="literal">()</span>).<span class="keyword">value</span><span class="literal">()</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">   thermo2.correct<span class="literal">()</span>;</span><br><span class="line">   <span class="type">Info</span>&lt;&lt; <span class="string">"min "</span> &lt;&lt; thermo2.<span class="type">T</span><span class="literal">()</span>.name<span class="literal">()</span></span><br><span class="line">       &lt;&lt; <span class="string">" "</span> &lt;&lt; min(thermo2.<span class="type">T</span><span class="literal">()</span>).<span class="keyword">value</span><span class="literal">()</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p>
<p>这里， <code>solve</code> 函数值得细说，重点是看 <code>correct()</code> 函数，以及 <code>T()</code> 函数。</p>
<p><code>corretc()</code> 函数指的是定义在 <code>heRhoThermo</code> 类中的 <code>correct()</code> 函数：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">BasicPsiThermo</span>, class <span class="type">MixtureType</span>&gt;</span><br><span class="line"><span class="type">void</span> <span class="type">Foam</span>::heRhoThermo&lt;<span class="type">BasicPsiThermo</span>, <span class="type">MixtureType</span>&gt;::correct()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (debug)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Info</span>&lt;&lt; <span class="string">"entering heRhoThermo&lt;MixtureType&gt;::correct()"</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    calculate();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (debug)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Info</span>&lt;&lt; <span class="string">"exiting heRhoThermo&lt;MixtureType&gt;::correct()"</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可见， <code>correct()</code> 函数，其实就是对 <code>calculate</code> 函数进行了一次调用而已。<br>看来最核心最关键的就在 <code>calculate</code> 函数中了。在仔细看这个函数之前，先把 <code>T()</code> 的定义看完。 <code>T()</code> 定义在 <code>basicThermo</code> 类中，其作用仅是返回同样定义在 <code>basicThermo</code> 类中定义的数据成员 <code>T_</code> 而已。</p>
<p>下面深入分析一下 <code>heRhoThermo</code> 类中的 <code>calculate</code> 函数，这里再将它列出来一次：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="atom">template</span>&lt;<span class="atom">class</span> <span class="name">BasicPsiThermo</span>, <span class="atom">class</span> <span class="name">MixtureType</span>&gt;</span><br><span class="line"><span class="atom">void</span> <span class="name">Foam</span>::<span class="atom">heRhoThermo</span>&lt;<span class="name">BasicPsiThermo</span>, <span class="name">MixtureType</span>&gt;::<span class="atom">calculate</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="atom">const</span> <span class="atom">scalarField</span>&amp; <span class="atom">hCells</span> = <span class="atom">this</span>-&gt;<span class="atom">he</span>().<span class="atom">internalField</span>();</span><br><span class="line">    <span class="atom">const</span> <span class="atom">scalarField</span>&amp; <span class="atom">pCells</span> = <span class="atom">this</span>-&gt;<span class="atom">p_</span>.<span class="atom">internalField</span>();</span><br><span class="line"></span><br><span class="line">    <span class="atom">scalarField</span>&amp; <span class="name">TCells</span> = <span class="atom">this</span>-&gt;<span class="name">T_</span>.<span class="atom">internalField</span>();</span><br><span class="line">    <span class="atom">scalarField</span>&amp; <span class="atom">psiCells</span> = <span class="atom">this</span>-&gt;<span class="atom">psi_</span>.<span class="atom">internalField</span>();</span><br><span class="line">    <span class="atom">scalarField</span>&amp; <span class="atom">rhoCells</span> = <span class="atom">this</span>-&gt;<span class="atom">rho_</span>.<span class="atom">internalField</span>();</span><br><span class="line">    <span class="atom">scalarField</span>&amp; <span class="atom">muCells</span> = <span class="atom">this</span>-&gt;<span class="atom">mu_</span>.<span class="atom">internalField</span>();</span><br><span class="line">    <span class="atom">scalarField</span>&amp; <span class="atom">alphaCells</span> = <span class="atom">this</span>-&gt;<span class="atom">alpha_</span>.<span class="atom">internalField</span>();</span><br><span class="line"></span><br><span class="line">    <span class="atom">forAll</span>(<span class="name">TCells</span>, <span class="atom">celli</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="atom">const</span> <span class="atom">typename</span> <span class="name">MixtureType</span>::<span class="atom">thermoType</span>&amp; <span class="atom">mixture_</span> =</span><br><span class="line">            <span class="atom">this</span>-&gt;<span class="atom">cellMixture</span>(<span class="atom">celli</span>);</span><br><span class="line"></span><br><span class="line">        <span class="name">TCells</span>[<span class="atom">celli</span>] = <span class="atom">mixture_</span>.<span class="name">THE</span></span><br><span class="line">        (</span><br><span class="line">            <span class="atom">hCells</span>[<span class="atom">celli</span>],</span><br><span class="line">            <span class="atom">pCells</span>[<span class="atom">celli</span>],</span><br><span class="line">            <span class="name">TCells</span>[<span class="atom">celli</span>]</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="atom">psiCells</span>[<span class="atom">celli</span>] = <span class="atom">mixture_</span>.<span class="atom">psi</span>(<span class="atom">pCells</span>[<span class="atom">celli</span>], <span class="name">TCells</span>[<span class="atom">celli</span>]);</span><br><span class="line">        <span class="atom">rhoCells</span>[<span class="atom">celli</span>] = <span class="atom">mixture_</span>.<span class="atom">rho</span>(<span class="atom">pCells</span>[<span class="atom">celli</span>], <span class="name">TCells</span>[<span class="atom">celli</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="atom">muCells</span>[<span class="atom">celli</span>] = <span class="atom">mixture_</span>.<span class="atom">mu</span>(<span class="atom">pCells</span>[<span class="atom">celli</span>], <span class="name">TCells</span>[<span class="atom">celli</span>]);</span><br><span class="line">        <span class="atom">alphaCells</span>[<span class="atom">celli</span>] = <span class="atom">mixture_</span>.<span class="atom">alphah</span>(<span class="atom">pCells</span>[<span class="atom">celli</span>], <span class="name">TCells</span>[<span class="atom">celli</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="atom">forAll</span>(<span class="atom">this</span>-&gt;<span class="name">T_</span>.<span class="atom">boundaryField</span>(), <span class="atom">patchi</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="atom">fvPatchScalarField</span>&amp; <span class="atom">pp</span> = <span class="atom">this</span>-&gt;<span class="atom">p_</span>.<span class="atom">boundaryField</span>()[<span class="atom">patchi</span>];</span><br><span class="line">        <span class="atom">fvPatchScalarField</span>&amp; <span class="atom">pT</span> = <span class="atom">this</span>-&gt;<span class="name">T_</span>.<span class="atom">boundaryField</span>()[<span class="atom">patchi</span>];</span><br><span class="line">        <span class="atom">fvPatchScalarField</span>&amp; <span class="atom">ppsi</span> = <span class="atom">this</span>-&gt;<span class="atom">psi_</span>.<span class="atom">boundaryField</span>()[<span class="atom">patchi</span>];</span><br><span class="line">        <span class="atom">fvPatchScalarField</span>&amp; <span class="atom">prho</span> = <span class="atom">this</span>-&gt;<span class="atom">rho_</span>.<span class="atom">boundaryField</span>()[<span class="atom">patchi</span>];</span><br><span class="line"></span><br><span class="line">        <span class="atom">fvPatchScalarField</span>&amp; <span class="atom">ph</span> = <span class="atom">this</span>-&gt;<span class="atom">he</span>().<span class="atom">boundaryField</span>()[<span class="atom">patchi</span>];</span><br><span class="line"></span><br><span class="line">        <span class="atom">fvPatchScalarField</span>&amp; <span class="atom">pmu</span> = <span class="atom">this</span>-&gt;<span class="atom">mu_</span>.<span class="atom">boundaryField</span>()[<span class="atom">patchi</span>];</span><br><span class="line">        <span class="atom">fvPatchScalarField</span>&amp; <span class="atom">palpha</span> = <span class="atom">this</span>-&gt;<span class="atom">alpha_</span>.<span class="atom">boundaryField</span>()[<span class="atom">patchi</span>];</span><br><span class="line"></span><br><span class="line">        <span class="atom">if</span> (<span class="atom">pT</span>.<span class="atom">fixesValue</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="atom">forAll</span>(<span class="atom">pT</span>, <span class="atom">facei</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="atom">const</span> <span class="atom">typename</span> <span class="name">MixtureType</span>::<span class="atom">thermoType</span>&amp; <span class="atom">mixture_</span> =</span><br><span class="line">                    <span class="atom">this</span>-&gt;<span class="atom">patchFaceMixture</span>(<span class="atom">patchi</span>, <span class="atom">facei</span>);</span><br><span class="line"></span><br><span class="line">                <span class="atom">ph</span>[<span class="atom">facei</span>] = <span class="atom">mixture_</span>.<span class="name">HE</span>(<span class="atom">pp</span>[<span class="atom">facei</span>], <span class="atom">pT</span>[<span class="atom">facei</span>]);</span><br><span class="line"></span><br><span class="line">                <span class="atom">ppsi</span>[<span class="atom">facei</span>] = <span class="atom">mixture_</span>.<span class="atom">psi</span>(<span class="atom">pp</span>[<span class="atom">facei</span>], <span class="atom">pT</span>[<span class="atom">facei</span>]);</span><br><span class="line">                <span class="atom">prho</span>[<span class="atom">facei</span>] = <span class="atom">mixture_</span>.<span class="atom">rho</span>(<span class="atom">pp</span>[<span class="atom">facei</span>], <span class="atom">pT</span>[<span class="atom">facei</span>]);</span><br><span class="line">                <span class="atom">pmu</span>[<span class="atom">facei</span>] = <span class="atom">mixture_</span>.<span class="atom">mu</span>(<span class="atom">pp</span>[<span class="atom">facei</span>], <span class="atom">pT</span>[<span class="atom">facei</span>]);</span><br><span class="line">                <span class="atom">palpha</span>[<span class="atom">facei</span>] = <span class="atom">mixture_</span>.<span class="atom">alphah</span>(<span class="atom">pp</span>[<span class="atom">facei</span>], <span class="atom">pT</span>[<span class="atom">facei</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="atom">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="atom">forAll</span>(<span class="atom">pT</span>, <span class="atom">facei</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="atom">const</span> <span class="atom">typename</span> <span class="name">MixtureType</span>::<span class="atom">thermoType</span>&amp; <span class="atom">mixture_</span> =</span><br><span class="line">                    <span class="atom">this</span>-&gt;<span class="atom">patchFaceMixture</span>(<span class="atom">patchi</span>, <span class="atom">facei</span>);</span><br><span class="line"></span><br><span class="line">                <span class="atom">pT</span>[<span class="atom">facei</span>] = <span class="atom">mixture_</span>.<span class="name">THE</span>(<span class="atom">ph</span>[<span class="atom">facei</span>], <span class="atom">pp</span>[<span class="atom">facei</span>], <span class="atom">pT</span>[<span class="atom">facei</span>]);</span><br><span class="line"></span><br><span class="line">                <span class="atom">ppsi</span>[<span class="atom">facei</span>] = <span class="atom">mixture_</span>.<span class="atom">psi</span>(<span class="atom">pp</span>[<span class="atom">facei</span>], <span class="atom">pT</span>[<span class="atom">facei</span>]);</span><br><span class="line">                <span class="atom">prho</span>[<span class="atom">facei</span>] = <span class="atom">mixture_</span>.<span class="atom">rho</span>(<span class="atom">pp</span>[<span class="atom">facei</span>], <span class="atom">pT</span>[<span class="atom">facei</span>]);</span><br><span class="line">                <span class="atom">pmu</span>[<span class="atom">facei</span>] = <span class="atom">mixture_</span>.<span class="atom">mu</span>(<span class="atom">pp</span>[<span class="atom">facei</span>], <span class="atom">pT</span>[<span class="atom">facei</span>]);</span><br><span class="line">                <span class="atom">palpha</span>[<span class="atom">facei</span>] = <span class="atom">mixture_</span>.<span class="atom">alphah</span>(<span class="atom">pp</span>[<span class="atom">facei</span>], <span class="atom">pT</span>[<span class="atom">facei</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数是在对几个热物理相关的量来进行更新，先更新内部场，再更新边界值。一个一个来看：</p>
<ul>
<li><p>he<br>he 前面讲了，这里需要注意的是其边界值的更新。由于 <code>he</code> 没有IO，其内部场量通过求解能量方程来更新，边界则需要根据情况特殊处理。两种情况，一种是设定了边界的温度值(pT.fixesValue())，这时需要更新边界上的 <code>he</code> 值： <code>ph[facei] = mixture_.HE(pp[facei], pT[facei]);</code> 否则，则边界上的 <code>he</code> 不需要特殊地更新。</p>
</li>
<li><p>psi<br>这个直接调用两参数的 <code>psi</code> 函数来更新，这个函数的定义在状态方程里，以 <code>perfaceGas</code> 为例，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Specie&gt;</span><br><span class="line"><span class="keyword">inline</span> Foam::scalar Foam::perfectGas&lt;Specie&gt;::psi(scalar, scalar T) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span>/(<span class="keyword">this</span>-&gt;R()*T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><code>psi</code> 是压缩因子，返回 $\frac{1}{RT}$。</p>
<ul>
<li>rho<br>这个调用的是两参数的 <code>rho</code> 函数，定义在状态方程类中，用于密度的更新，同样以 <code>perfaceGas</code> 为例，<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Specie</span>&gt;</span><br><span class="line">inline <span class="type">Foam</span>::scalar <span class="type">Foam</span>::perfectGas&lt;<span class="type">Specie</span>&gt;::rho(scalar p, scalar T) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> p/(this-&gt;R()*T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>返回 $\frac{p}{RT}$。</p>
<ul>
<li>mu<br>这个调用的是两参数的 <code>mu</code> 函数，其定义在 transport 类中，以 <code>constTransport</code> 为例，这个返回的是场量的层流粘度<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Thermo</span>&gt;</span><br><span class="line">inline <span class="type">Foam</span>::scalar <span class="type">Foam</span>::constTransport&lt;<span class="type">Thermo</span>&gt;::mu</span><br><span class="line">(</span><br><span class="line">     <span class="keyword">const</span> scalar p,</span><br><span class="line">     <span class="keyword">const</span> scalar T</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">return</span> mu_; // 常量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>alphah 上面说过了，不再重复。</p>
<p>最后，最复杂的就是温度的更新了</p>
<ul>
<li>T<br>温度的更新，调用的是三参数的 <code>THE</code> 函数，这个函数定义在 <code>species::thermo</code> 类中，<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Thermo</span>, <span class="keyword">template</span>&lt;class&gt; class <span class="type">Type</span>&gt;</span><br><span class="line">inline <span class="type">Foam</span>::scalar <span class="type">Foam</span>::species::thermo&lt;<span class="type">Thermo</span>, <span class="type">Type</span>&gt;::<span class="type">THE</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> scalar he,</span><br><span class="line">    <span class="keyword">const</span> scalar p,</span><br><span class="line">    <span class="keyword">const</span> scalar <span class="type">T0</span></span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Type</span>&lt;thermo&lt;<span class="type">Thermo</span>, <span class="type">Type</span>&gt; &gt;::<span class="type">THE</span>(*this, he, p, <span class="type">T0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这里，调用的是 <code>energy variable</code> 类的 <code>THE</code> 函数，以 <code>sensibleInternalEnergy</code> 为例，<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">scalar</span> THE</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> Thermo&amp; thermo,</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">scalar</span> <span class="keyword">e</span>,</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">scalar</span> p,</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">scalar</span> T0</span><br><span class="line"> ) <span class="keyword">const</span></span><br><span class="line"> &#123;</span><br><span class="line">    <span class="keyword">return</span> thermo.<span class="keyword">TEs</span>(<span class="keyword">e</span>, p, T0);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>可见，对于 <code>sensibleInternalEnergy</code> ， <code>THE</code> 函数实际上返回的是 <code>species::thermo</code> 类的 <code>TEs</code> 函数。<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Thermo</span>, <span class="keyword">template</span>&lt;class&gt; class <span class="type">Type</span>&gt;</span><br><span class="line">inline <span class="type">Foam</span>::scalar <span class="type">Foam</span>::species::thermo&lt;<span class="type">Thermo</span>, <span class="type">Type</span>&gt;::<span class="type">TEs</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> scalar es,</span><br><span class="line">    <span class="keyword">const</span> scalar p,</span><br><span class="line">    <span class="keyword">const</span> scalar <span class="type">T0</span></span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> T</span><br><span class="line">    (</span><br><span class="line">        es,</span><br><span class="line">        p,</span><br><span class="line">        <span class="type">T0</span>,</span><br><span class="line">        &amp;thermo&lt;<span class="type">Thermo</span>, <span class="type">Type</span>&gt;::<span class="type">Es</span>,</span><br><span class="line">        &amp;thermo&lt;<span class="type">Thermo</span>, <span class="type">Type</span>&gt;::<span class="type">Cv</span>,</span><br><span class="line">        &amp;thermo&lt;<span class="type">Thermo</span>, <span class="type">Type</span>&gt;::limit</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里，终于来到了这个六参数的 <code>T</code> 函数：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line"> inline <span class="keyword">scalar</span> T</span><br><span class="line">        (</span><br><span class="line">            <span class="keyword">scalar</span> f,</span><br><span class="line">            <span class="keyword">scalar</span> p,</span><br><span class="line">            <span class="keyword">scalar</span> T0,</span><br><span class="line">            <span class="keyword">scalar</span> (thermo::*F)(<span class="keyword">const</span> <span class="keyword">scalar</span>, <span class="keyword">const</span> <span class="keyword">scalar</span>) <span class="keyword">const</span>,</span><br><span class="line">            <span class="keyword">scalar</span> (thermo::*dFdT)(<span class="keyword">const</span> <span class="keyword">scalar</span>, <span class="keyword">const</span> <span class="keyword">scalar</span>) <span class="keyword">const</span>,</span><br><span class="line">            <span class="keyword">scalar</span> (thermo::*limit)(<span class="keyword">const</span> <span class="keyword">scalar</span>) <span class="keyword">const</span></span><br><span class="line">        ) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现</span></span><br><span class="line">template&lt;<span class="keyword">class</span> Thermo, template&lt;<span class="keyword">class</span>&gt; <span class="keyword">class</span> <span class="keyword">Type</span>&gt;</span><br><span class="line">inline Foam::<span class="keyword">scalar</span> Foam::species::thermo&lt;Thermo, <span class="keyword">Type</span>&gt;::T</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">scalar</span> f,</span><br><span class="line">    <span class="keyword">scalar</span> p,</span><br><span class="line">    <span class="keyword">scalar</span> T0,</span><br><span class="line">    <span class="keyword">scalar</span> (thermo&lt;Thermo, <span class="keyword">Type</span>&gt;::*F)(<span class="keyword">const</span> <span class="keyword">scalar</span>, <span class="keyword">const</span> <span class="keyword">scalar</span>) <span class="keyword">const</span>,</span><br><span class="line">    <span class="keyword">scalar</span> (thermo&lt;Thermo, <span class="keyword">Type</span>&gt;::*dFdT)(<span class="keyword">const</span> <span class="keyword">scalar</span>, <span class="keyword">const</span> <span class="keyword">scalar</span>)</span><br><span class="line">        <span class="keyword">const</span>,</span><br><span class="line">    <span class="keyword">scalar</span> (thermo&lt;Thermo, <span class="keyword">Type</span>&gt;::*limit)(<span class="keyword">const</span> <span class="keyword">scalar</span>) <span class="keyword">const</span></span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">scalar</span> <span class="keyword">Test</span> = T0;</span><br><span class="line">    <span class="keyword">scalar</span> Tnew = T0;</span><br><span class="line">    <span class="keyword">scalar</span> Ttol = T0*tol_;</span><br><span class="line">    int    iter = 0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">Test</span> = Tnew;</span><br><span class="line">        Tnew =</span><br><span class="line">            (this-&gt;*limit)</span><br><span class="line">            (<span class="keyword">Test</span> - ((this-&gt;*F)(p, <span class="keyword">Test</span>) - f)/(this-&gt;*dFdT)(p, <span class="keyword">Test</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (iter++ &gt; maxIter_)</span><br><span class="line">        &#123;</span><br><span class="line">            FatalErrorIn</span><br><span class="line">            (</span><br><span class="line">                <span class="string">"thermo&lt;Thermo, Type&gt;::T(scalar f, scalar T0, "</span></span><br><span class="line">                <span class="string">"scalar (thermo&lt;Thermo, Type&gt;::*F)"</span></span><br><span class="line">                <span class="string">"(const scalar) const, "</span></span><br><span class="line">                <span class="string">"scalar (thermo&lt;Thermo, Type&gt;::*dFdT)"</span></span><br><span class="line">                <span class="string">"(const scalar) const, "</span></span><br><span class="line">                <span class="string">"scalar (thermo&lt;Thermo, Type&gt;::*limit)"</span></span><br><span class="line">                <span class="string">"(const scalar) const"</span></span><br><span class="line">                <span class="string">") const"</span></span><br><span class="line">            )   &lt;&lt; <span class="string">"Maximum number of iterations exceeded"</span></span><br><span class="line">                &lt;&lt; abort(FatalError);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (mag(Tnew - <span class="keyword">Test</span>) &gt; Ttol);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Tnew;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数，前三个参数是普通的 scalar 类型变量，后三个参数，是函数指针，并且都指向当前类 <code>species::thermo</code> 的成员函数。以 <code>TEs</code> 为例，后三个参数分别代入的是 <code>Es</code> ， <code>Cv</code> 以及 <code>limit</code> 三个函数。 <code>Es</code> 和 <code>Cv</code> 前面都看过了， <code>limit</code> 定义在 thermo 类中，以 <code>hConst</code> 为例，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> EquationOfState&gt;</span><br><span class="line"><span class="keyword">inline</span> Foam::scalar Foam::hConstThermo&lt;EquationOfState&gt;::limit</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> scalar T</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>直接返回温度 <code>T</code> 。事实上，除了 <code>janaf</code> 模型，其他的都是返回 <code>T</code> 。 <code>janaf</code> 模型中， 如果温度没有超出 [Tlow,Thigh]，则会出来警告信息，并且，若 <code>T &lt; Tlow</code> 则返回 <code>Tlow</code>，而 <code>T &gt; Thigh</code> 时，则返回 <code>Thigh</code>。</p>
<p>下面仔细来分析六参数 <code>T</code> 函数的核心部分。经过摸索，发现这个其实是一个牛顿迭代的过程，目的是根据 <code>Es</code> 函数，从内能 <code>es</code> 来计算温度 <code>T</code>，即求解 $E_s(p,T) - E_s = 0$ 。令 $F(T)= E_s(p,T) - E_s $，则牛顿迭代法的递推公式为<br>$$<br>T_{New} = T_{old} - \dfrac{F(T_{old})}{F\prime(T_{old})} = T_{old} - \dfrac{E_s(p, T_{old)} - E_s}{dE_s(p,T)/dT |_{T=T_{old}}}<br>$$<br>对于 <code>sensibleInternalEnergy</code> ，$dE_s(p,T)/dT = C_v(p,T)$<br>所以最终得到递推公式为<br>$$<br>T_{New} = T_{old} - \dfrac{E_s(p, T_{old)} - E_s}{C_v(p, T_{old})}<br>$$<br>这里设置了最大迭代次数为 100，超过将报那个涉及到能量的模拟中最容易见到的崩溃信息：”Maximum number of iterations exceeded” 。</p>
<p>当能量变量是焓时，则 $E_s$ 要换成 $H_s$， $C_v$ 要换成 $C_p$ 。 </p>
<p>至此便分析完了一个具体的能量方程实例。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本篇来看一个具体的能量方程，以 <code>twoPhaseEulerFoam</code> 的 <code>EEqn.H</code> 为例。</p>]]>
    
    </summary>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="thermophysicalModels" scheme="http://xiaopingqiu.github.io/tags/thermophysicalModels/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenFOAM 中的热物理类之继承派生关系]]></title>
    <link href="http://xiaopingqiu.github.io/2016/06/25/thermophysics3/"/>
    <id>http://xiaopingqiu.github.io/2016/06/25/thermophysics3/</id>
    <published>2016-06-25T07:14:28.000Z</published>
    <updated>2016-06-25T07:44:54.491Z</updated>
    <content type="html"><![CDATA[<p>根据上一篇的介绍，我们已经知道<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">thermoType</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title">type</span>             heRhoThermo;</span><br><span class="line">    <span class="title">mixture</span>          pureMixture;</span><br><span class="line">    <span class="title">transport</span>        const;</span><br><span class="line">    <span class="title">thermo</span>           hConst;</span><br><span class="line">    <span class="title">equationOfState</span>  perfectGas;</span><br><span class="line">    <span class="title">specie</span>           specie;</span><br><span class="line">    <span class="title">energy</span>           sensibleInternalEnergy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个设置对应的是下述类：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">heRhoThermo                                                                 </span><br><span class="line">&lt;                                                                        </span><br><span class="line">    rhoThermo,                                                          </span><br><span class="line">    pureMixture</span><br><span class="line">    &lt;</span><br><span class="line">        constTransport&lt;<span class="symbol">species:</span><span class="symbol">:thermo&lt;hConstThermo&lt;perfectGas&lt;specie&gt;&gt;</span>,sensibleInternalEnergy<span class="prompt">&gt;&gt;</span><br><span class="line">    </span>&gt;                 </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p>
<p>接下来就能来看看具体的类的继承派生关系了。</p>
<a id="more"></a>
<p>经过前面的分析，最终指针 <code>thermo_</code> 指向的是 <code>heRhoThermo</code> 类的对象，所以先来看一下 <code>heRhoThermo</code> 类。<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">BasicPsiThermo</span>, class <span class="type">MixtureType</span>&gt;</span><br><span class="line">class heRhoThermo</span><br><span class="line">:</span><br><span class="line">    public heThermo&lt;<span class="type">BasicPsiThermo</span>, <span class="type">MixtureType</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    // <span class="type">Private</span> <span class="type">Member</span> <span class="type">Functions</span></span><br><span class="line"></span><br><span class="line">        //- <span class="type">Calculate</span> the thermo variables</span><br><span class="line">        <span class="type">void</span> calculate();</span><br><span class="line"></span><br><span class="line">        //- <span class="type">Construct</span> <span class="keyword">as</span> copy (<span class="keyword">not</span> implemented)</span><br><span class="line">        heRhoThermo(<span class="keyword">const</span> heRhoThermo&lt;<span class="type">BasicPsiThermo</span>, <span class="type">MixtureType</span>&gt;&amp;);</span><br></pre></td></tr></table></figure></p>
<p><code>heRhoThermo</code> 类很简单，它继承自 <code>heThermo</code> 类，并且和 <code>heThermo</code> 类用同样的模板参数。<br>接下来看看 <code>heThermo</code> 类：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">BasicThermo</span>, class <span class="type">MixtureType</span>&gt;</span><br><span class="line">class heThermo</span><br><span class="line">:</span><br><span class="line">    public <span class="type">BasicThermo</span>,</span><br><span class="line">    public <span class="type">MixtureType</span></span><br><span class="line">&#123;</span><br><span class="line">protected:</span><br><span class="line"></span><br><span class="line">    // <span class="type">Protected</span> data</span><br><span class="line"></span><br><span class="line">        //- <span class="type">Energy</span> field</span><br><span class="line">        volScalarField he_;</span><br></pre></td></tr></table></figure></p>
<p>这里，前面多次提到的“继承其模板参数代表的类”这种模式又出现了。有了前两篇分析的基础，我们已经知晓了 <code>thermophysicalProperties</code> 文件里的设置将对应着怎么的一个具体的模型，所有的模板参数都一目了然。知道了模板参数，就能将模板类实例化，再分析其继承派生关系就不是问题了。探索的中间过程这里不详述了，只列出文章开头的那个实例对应的继承派生关系：</p>
<p><img src="/image/thermos/thermo.png" alt="继承派生关系"></p>
<p>注意几点：</p>
<ol>
<li>上图中有两个继承派生关系，其中 <code>constTransport</code> 这个类是作为 <code>pureMixture</code> 类的模板参数的，从而将这两个部分联系起来。</li>
<li><code>species::thermo</code> 中， <code>species</code> 是命名空间， <code>thermo</code> 是类名，具体定义在 <code>src/thermophysicalModels/specie/thermo/thermo/thermo.H</code>。</li>
<li><code>sensibleInternalEnergy</code> 类的模板参数中，某种程度上讲，包含了它自己！</li>
<li>mixture，transport，thermo，equationOfstate，specie，energy 这 6 个子模型有哪些可选的，这一点在 UserGuide 的第 7 章已经介绍得很清楚了，这里就不再重复了。</li>
</ol>
<p>了解了这些，就能理解热物理类的框架了。下一部分将针对 <code>twoPhaseEulerFoam</code> 的热物理相关的模块，来梳理一下热物理模型的流程，主要是，能量方程的构建，如何从能量来得到温度，其他依赖于温度的量包括粘度、密度、压力等又是如何更新的，希望能对传热的模拟有些指导作用，尤其是当出问题的时候，能大概知道可能的原因。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>根据上一篇的介绍，我们已经知道<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">thermoType</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title">type</span>             heRhoThermo;</span><br><span class="line">    <span class="title">mixture</span>          pureMixture;</span><br><span class="line">    <span class="title">transport</span>        const;</span><br><span class="line">    <span class="title">thermo</span>           hConst;</span><br><span class="line">    <span class="title">equationOfState</span>  perfectGas;</span><br><span class="line">    <span class="title">specie</span>           specie;</span><br><span class="line">    <span class="title">energy</span>           sensibleInternalEnergy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个设置对应的是下述类：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">heRhoThermo                                                                 </span><br><span class="line">&lt;                                                                        </span><br><span class="line">    rhoThermo,                                                          </span><br><span class="line">    pureMixture</span><br><span class="line">    &lt;</span><br><span class="line">        constTransport&lt;<span class="symbol">species:</span><span class="symbol">:thermo&lt;hConstThermo&lt;perfectGas&lt;specie&gt;&gt;</span>,sensibleInternalEnergy<span class="prompt">&gt;&gt;</span><br><span class="line">    </span>&gt;                 </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p>
<p>接下来就能来看看具体的类的继承派生关系了。</p>]]>
    
    </summary>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="thermophysicalModels" scheme="http://xiaopingqiu.github.io/tags/thermophysicalModels/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenFOAM 中的热物理类之 hashTable 的创建]]></title>
    <link href="http://xiaopingqiu.github.io/2016/06/25/thermophysics2/"/>
    <id>http://xiaopingqiu.github.io/2016/06/25/thermophysics2/</id>
    <published>2016-06-25T06:46:48.000Z</published>
    <updated>2016-06-25T07:25:49.472Z</updated>
    <content type="html"><![CDATA[<p>这一篇来看一下热物理类是如何编译并创建储存了可选模型的 hashTable 的。</p>
<a id="more"></a>
<p>根据以前的经验，编译和构建 hashTable 肯定是跟这个源文件有关：<code>src/thermophysicalModels/basic/rhoThermo/rhoThermos</code>。<br>这个文件里，全部都是在调用宏函数。而且，从宏函数的参数来看，似乎就是个排列组合的游戏，把所有可用的组合都写了一遍。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">makeThermo</span><br><span class="line">(</span><br><span class="line">    rhoThermo,</span><br><span class="line">    heRhoThermo,</span><br><span class="line">    pureMixture,</span><br><span class="line">    constTransport,</span><br><span class="line">    sensibleInternalEnergy,</span><br><span class="line">    hConstThermo,</span><br><span class="line">    perfectGas,</span><br><span class="line">    specie</span><br><span class="line">);</span><br><span class="line">......</span><br></pre></td></tr></table></figure></p>
<p>为了弄清这部分内容，需要先理解 <code>makeThermo</code> 这个宏函数的定义，见 <code>src/thermophysicalModels/basic/fluidThermo/makeThermo.H</code>：<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define makeThermoTypedefs(BaseThermo,Cthermo,Mixture,Transport,Type,Thermo,EqnOfState,Specie)\</span></span><br><span class="line">                                                                              <span class="string">\</span></span><br><span class="line">typedef                                                                       <span class="string">\</span></span><br><span class="line">    Transport                                                                 <span class="string">\</span></span><br><span class="line">    &lt;                                                                         <span class="string">\</span></span><br><span class="line">        <span class="attribute">species</span>::thermo                                                       <span class="string">\</span></span><br><span class="line">        &lt;                                                                     <span class="string">\</span></span><br><span class="line">            Thermo                                                            <span class="string">\</span></span><br><span class="line">            &lt;                                                                 <span class="string">\</span></span><br><span class="line">                EqnOfState                                                    <span class="string">\</span></span><br><span class="line">                &lt;                                                             <span class="string">\</span></span><br><span class="line">                    Specie                                                    <span class="string">\</span></span><br><span class="line">                &gt;                                                             <span class="string">\</span></span><br><span class="line">            &gt;,                                                                <span class="string">\</span></span><br><span class="line">            Type                                                              <span class="string">\</span></span><br><span class="line">        &gt;                                                                     <span class="string">\</span></span><br><span class="line">    &gt; Transport<span class="comment">##Type##Thermo##EqnOfState##Specie;                            \</span></span><br><span class="line">                                                                              <span class="string">\</span></span><br><span class="line">typedef                                                                       <span class="string">\</span></span><br><span class="line">    Cthermo                                                                   <span class="string">\</span></span><br><span class="line">    &lt;                                                                         <span class="string">\</span></span><br><span class="line">        BaseThermo,                                                           <span class="string">\</span></span><br><span class="line">        Mixture&lt;Transport<span class="comment">##Type##Thermo##EqnOfState##Specie&gt;                  \</span></span><br><span class="line">    &gt; Cthermo<span class="comment">##Mixture##Transport##Type##Thermo##EqnOfState##Specie;          \</span></span><br><span class="line">                                                                              <span class="string">\</span></span><br><span class="line">defineTemplateTypeNameAndDebugWithName                                        <span class="string">\</span></span><br><span class="line">(                                                                             <span class="string">\</span></span><br><span class="line">    Cthermo<span class="comment">##Mixture##Transport##Type##Thermo##EqnOfState##Specie,            \</span></span><br><span class="line">    (                                                                         <span class="string">\</span></span><br><span class="line">        <span class="comment">#Cthermo"&lt;"#Mixture"&lt;"                                                \</span></span><br><span class="line">      + Transport<span class="comment">##Type##Thermo##EqnOfState##Specie::typeName()               \</span></span><br><span class="line">      + <span class="string">"&gt;&gt;"</span>                                                                  <span class="string">\</span></span><br><span class="line">    ).c_str(),                                                                <span class="string">\</span></span><br><span class="line">    <span class="number">0</span>                                                                         <span class="string">\</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#define makeThermo(BaseThermo,Cthermo,Mixture,Transport,Type,Thermo,EqnOfState,Specie)\</span></span><br><span class="line">                                                                              <span class="string">\</span></span><br><span class="line">makeThermoTypedefs                                                            <span class="string">\</span></span><br><span class="line">(                                                                             <span class="string">\</span></span><br><span class="line">    BaseThermo,                                                               <span class="string">\</span></span><br><span class="line">    Cthermo,                                                                  <span class="string">\</span></span><br><span class="line">    Mixture,                                                                  <span class="string">\</span></span><br><span class="line">    Transport,                                                                <span class="string">\</span></span><br><span class="line">    Type,                                                                     <span class="string">\</span></span><br><span class="line">    Thermo,                                                                   <span class="string">\</span></span><br><span class="line">    EqnOfState,                                                               <span class="string">\</span></span><br><span class="line">    Specie                                                                    <span class="string">\</span></span><br><span class="line">)                                                                             <span class="string">\</span></span><br><span class="line">                                                                              <span class="string">\</span></span><br><span class="line">addToRunTimeSelectionTable                                                    <span class="string">\</span></span><br><span class="line">(                                                                             <span class="string">\</span></span><br><span class="line">    basicThermo,                                                              <span class="string">\</span></span><br><span class="line">    Cthermo<span class="comment">##Mixture##Transport##Type##Thermo##EqnOfState##Specie,            \</span></span><br><span class="line">    fvMesh                                                                    <span class="string">\</span></span><br><span class="line">);                                                                            <span class="string">\</span></span><br><span class="line">                                                                              <span class="string">\</span></span><br><span class="line">addToRunTimeSelectionTable                                                    <span class="string">\</span></span><br><span class="line">(                                                                             <span class="string">\</span></span><br><span class="line">    fluidThermo,                                                              <span class="string">\</span></span><br><span class="line">    Cthermo<span class="comment">##Mixture##Transport##Type##Thermo##EqnOfState##Specie,            \</span></span><br><span class="line">    fvMesh                                                                    <span class="string">\</span></span><br><span class="line">);                                                                            <span class="string">\</span></span><br><span class="line">                                                                              <span class="string">\</span></span><br><span class="line">addToRunTimeSelectionTable                                                    <span class="string">\</span></span><br><span class="line">(                                                                             <span class="string">\</span></span><br><span class="line">    BaseThermo,                                                               <span class="string">\</span></span><br><span class="line">    Cthermo<span class="comment">##Mixture##Transport##Type##Thermo##EqnOfState##Specie,            \</span></span><br><span class="line">    fvMesh                                                                    <span class="string">\</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>可见，在 <code>makeThermo</code> 这个宏函数里，先调用了 <code>makeThermoTypedefs</code> 宏函数，然后调用 <code>addToRunTimeSelectionTable</code> 函数。按照之前对 RTS 机制的理解，调用 <code>addToRunTimeSelectionTable</code> 函数的作用是往 hashTable 里插入元素，细节不需再赘述。这里主要来看看 <code>makeThermoTypedefs</code> 函数的功能，以上文列举的这个实例为例。先来看第一个 typedef：将实例中的参数代入后，<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef                                                                       \</span><br><span class="line">    constTransport&lt;<span class="symbol">species:</span><span class="symbol">:thermo&lt;hConstThermo&lt;perfectGas&lt;specie&gt;&gt;</span>,sensibleInternalEnergy<span class="prompt">&gt;&gt;  </span>\</span><br><span class="line">    constTransportsensibleEnthalpyhConstThermoperfectGasspecie;</span><br></pre></td></tr></table></figure></p>
<p>第二个 typedef<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef                                                                       <span class="string">\</span></span><br><span class="line">    heRhoThermo                                                                   <span class="string">\</span></span><br><span class="line">    &lt;                                                                         <span class="string">\</span></span><br><span class="line">        rhoThermo,                                                           <span class="string">\</span></span><br><span class="line">        pureMixture&lt;constTransportsensibleEnthalpyhConstThermoperfectGasspecie&gt;                  <span class="string">\</span></span><br><span class="line">    &gt;                                                                                       <span class="string">\</span>   heRhoThermopureMixtureconstTransportsensibleEnthalpyhConstThermoperfectGasspecie;          <span class="string">\</span></span><br></pre></td></tr></table></figure></p>
<p>除了这两个 typedef，还调用了 <code>defineTemplateTypeNameAndDebugWithName</code> 宏函数，这个函数的定义在 <code>src/OpenFOAM/db/typeInfo/className.H</code>：<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#define defineTemplateTypeNameAndDebugWithName(<span class="keyword">Type</span>, <span class="keyword">Name</span>, DebugSwitch)       \</span><br><span class="line">    defineTemplateTypeNameWithName(<span class="keyword">Type</span>, <span class="keyword">Name</span>);                               \</span><br><span class="line">    defineTemplateDebugSwitchWithName(<span class="keyword">Type</span>, <span class="keyword">Name</span>, DebugSwitch)</span><br><span class="line"></span><br><span class="line"># define defineTemplateTypeNameWithName(<span class="keyword">Type</span>, <span class="keyword">Name</span>)                           \</span><br><span class="line">    defineTypeNameWithName(<span class="keyword">Type</span>, <span class="keyword">Name</span>)</span><br><span class="line"></span><br><span class="line">#define defineTypeNameWithName(<span class="keyword">Type</span>, <span class="keyword">Name</span>)                                    \</span><br><span class="line">    const ::Foam::word <span class="keyword">Type</span>::typeName(<span class="keyword">Name</span>)</span><br></pre></td></tr></table></figure></p>
<p>很显然，这个宏函数的作用是修改类对应的 <code>typeName</code> 和 debug 选项。在 OpenFOAM 中，很多类中都会调用<br><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TypeName</span>(<span class="string">"xxxxx"</span>)</span><br><span class="line"><span class="string">``</span><span class="string">` </span><br><span class="line">这里的 `</span><span class="built_in">TypeName</span><span class="string">` 也是一个宏函数，定义在 `</span>src/OpenFOAM/db/typeInfo/className.H<span class="string">`:</span></span><br></pre></td></tr></table></figure></p>
<h1 id="define_TypeName(TypeNameString)_\">define TypeName(TypeNameString)                                              \</h1><pre><code>ClassName(TypeNameString);                                                \
<span class="keyword">virtual</span> <span class="keyword">const</span> word&amp; type() <span class="keyword">const</span> { <span class="keyword">return</span> typeName; }
</code></pre><h1 id="define_ClassName(TypeNameString)_\">define ClassName(TypeNameString)                                             \</h1><pre><code>ClassNameNoDebug(TypeNameString);                                         \
<span class="keyword">static</span> <span class="keyword">int</span> <span class="keyword">debug</span>
</code></pre><h1 id="define_ClassNameNoDebug(TypeNameString)_\">define ClassNameNoDebug(TypeNameString)                                      \</h1><pre><code><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* typeName_() { <span class="keyword">return</span> TypeNameString; }                 \
<span class="keyword">static</span> <span class="keyword">const</span> ::Foam::word typeName
</code></pre><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">可见， <span class="escape">`T</span>ypeName<span class="escape">` </span>这个宏函数，声明了一个类静态变量 <span class="escape">`t</span>ypeName<span class="escape">`，</span>定义了一个函数 <span class="escape">`t</span>ype<span class="escape">` </span>用于返回 <span class="escape">`t</span>ypeName<span class="escape">` </span>的值，并定义了一个静态变量 <span class="escape">`d</span>ebug<span class="escape">` </span>用于存储 debug 选项。这里与 RTS 机制有关的是 <span class="escape">`t</span>ypeName<span class="escape">` </span>这个变量。</span><br><span class="line"></span><br><span class="line">绕了半圈，回到 <span class="escape">`d</span>efineTemplateTypeNameAndDebugWithName<span class="escape">` </span>函数。了解了 <span class="escape">`t</span>ypeName<span class="escape">` </span>这个变量的定义，很容易就能看出来， <span class="escape">`d</span>efineTemplateTypeNameAndDebugWithName<span class="escape">` </span>这个函数其实就是在对类的静态变量 <span class="escape">`t</span>ypeName<span class="escape">` </span>进行赋值。根据上文的实例提供的参数，宏函数 <span class="escape">`d</span>efineTemplateTypeNameAndDebugWithName<span class="escape">` </span>可以理解为：对 <span class="escape">`h</span>eRhoThermopureMixtureconstTransportsensibleEnthalpyhConstThermoperfectGasspecie<span class="escape">` </span>对应的类的静态变量 <span class="escape">`t</span>ypeName<span class="escape">` </span>进行赋值，赋值结果为：</span><br><span class="line"><span class="escape">`h</span>eRhoThermo&lt;pureMixture&lt; + constTransport&lt;species::thermo&lt;hConstThermo&lt;perfectGas&lt;specie&gt;&gt;,sensibleInternalEnergy&gt;&gt;::typeName() + &gt;&gt;<span class="escape">`</span><br><span class="line"></span>。这里调用了 <span class="escape">`c</span>onstTransport<span class="escape">` </span>类的成员函数 <span class="escape">`t</span>ypeName()<span class="escape">`。</span></span><br><span class="line">经过一番冗长的函数调用，得到的最终结果是：将 <span class="escape">`h</span>eRhoThermopureMixtureconstTransportsensibleEnthalpyhConstThermoperfectGasspecie<span class="escape">` </span>对应的类的静态变量 <span class="escape">`t</span>ypeName<span class="escape">` </span>赋值为：<span class="escape">`h</span>eRhoThermo&lt;pureMixture&lt;const&lt;hConst&lt;perfectGas&lt;specie&gt;&gt;,sensiblesensibleEnthalpy&gt;&gt;&gt;<span class="escape">`。</span></span><br><span class="line"></span><br><span class="line">至此，经过一番宏函数的调用，得到了 <span class="escape">`a</span>ddToRunTimeSelectionTable<span class="escape">` </span>宏函数的参数。前面 RTS 机制部分讲过，这个函数的作用就是对 hashTable 增加元素，以</span><br></pre></td></tr></table></figure>
<p>addToRunTimeSelectionTable                                                    \<br>(                                                                             \<br>    BaseThermo,                                                               \<br>    Cthermo##Mixture##Transport##Type##Thermo##EqnOfState##Specie,            \<br>    fvMesh                                                                    \<br>);<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">为例，第一个参数，表示元素将增加到 <span class="escape">`B</span>aseThermo<span class="escape">` </span>类（这里是 <span class="escape">`r</span>hoThermo<span class="escape">` </span>）中声明的 hashTable，第二个参数，表示将要添加的类，添加成功以后，这个类的 <span class="escape">`t</span>ypeName<span class="escape">` </span>将是 hashTable 的 key，而返回这个类的对象的一个函数，将是 hashTable 的 value。第三个参数对应着 hashTable 对象的名字，fvMesh 对应的 hashTable 对象名为 <span class="escape">`f</span>vMeshConstructorTable<span class="escape">`，</span>这与在 <span class="escape">`r</span>hoThermo<span class="escape">` </span>中声明的名字是对应的。</span><br><span class="line"></span><br><span class="line">最后总结如下：</span><br><span class="line">宏函数</span><br></pre></td></tr></table></figure></p>
<p>makeThermo<br>(<br>    rhoThermo,<br>    heRhoThermo,<br>    pureMixture,<br>    constTransport,<br>    sensibleInternalEnergy,<br>    hConstThermo,<br>    perfectGas,<br>    specie<br>);<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">调用以后，向 <span class="escape">`r</span>hoThermo<span class="escape">` </span>类中声明的 hashTable 中增加了一组元素，其 key 为 <span class="escape">`h</span>eRhoThermo&lt;pureMixture&lt;const&lt;hConst&lt;perfectGas&lt;specie&gt;&gt;,sensibleInternalEnergy&gt;&gt;&gt;<span class="escape">` </span>，value 对应的函数返回的是类</span><br></pre></td></tr></table></figure></p>
<p>heRhoThermo<br>&lt;<br>    rhoThermo,<br>    pureMixture<br>    &lt;<br>        constTransport<species::thermo<hconstthermo<perfectgas<specie>&gt;,sensibleInternalEnergy&gt;&gt;</species::thermo<hconstthermo<perfectgas<specie></p>
<pre><code><span class="blockquote">&gt;                 </span>
</code></pre><blockquote>
<p>```<br>的对象。</p>
</blockquote>
<p>每调用一次 <code>makeThermo</code> 函数，就增加了一个新组元素，也即增加了一个可选的模型。不同的参数，其实对应的是不同的模板实例。<br>至此，就知道了在 <code>twoPhaseEulerFoam</code> 的 <code>phaseModel</code> 中定义的热物理类接口 <code>thermo_</code> 最终指向的是 <code>heRhoThermo</code> 类的对象。虽然代入的模板数很复杂，但整个架构仍然是基于 RTS 机制的。</p>
<p>接下来，要想理解能量方程，理解温度，粘度，压力等这些热物理相关的量是怎么计算更新的，就需要仔细看一下 <code>heRhoThermo</code> 类的继承派生关系了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这一篇来看一下热物理类是如何编译并创建储存了可选模型的 hashTable 的。</p>]]>
    
    </summary>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="thermophysicalModels" scheme="http://xiaopingqiu.github.io/tags/thermophysicalModels/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenFOAM 中的热物理类之接口]]></title>
    <link href="http://xiaopingqiu.github.io/2016/06/25/thermophysics1/"/>
    <id>http://xiaopingqiu.github.io/2016/06/25/thermophysics1/</id>
    <published>2016-06-25T06:27:14.000Z</published>
    <updated>2016-06-25T06:38:57.428Z</updated>
    <content type="html"><![CDATA[<p>本系列来看一下 OpenFOAM 中的热物理类。热物理类比较繁杂，这里先看一下纯物质的热物理模型。本篇先来看看热物理类在求解器中的接口，以2.3.x 版的 <code>twoPhaseEulerFoam</code> 为例。</p>
<a id="more"></a>
<p><code>twoPhaseEulerFoam</code> 中的热物理类的接口在 <code>phaseModel</code> 类中声明：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//- Thermophysical properties</span><br><span class="line">autoPtr&lt;rhoThermo&gt; thermo_<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">thermo_<span class="list">(<span class="keyword">rhoThermo</span>:<span class="keyword">:New</span><span class="list">(<span class="keyword">fluid</span>.mesh<span class="list">()</span>, name_)</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>可见，接口是 <code>rhoThermo</code> 类的指针。</p>
<p>接着看 <code>rhoThermo</code> 类的 <code>New</code> 函数。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//- Selector</span></span><br><span class="line"><span class="keyword">static</span> autoPtr&lt;rhoThermo&gt; <span class="keyword">New</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> fvMesh&amp;,</span><br><span class="line">    <span class="keyword">const</span> word&amp; phaseName=word::null</span><br><span class="line">);</span><br><span class="line">    </span><br><span class="line">Foam::autoPtr&lt;Foam::rhoThermo&gt; Foam::rhoThermo::New</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> fvMesh&amp; mesh,</span><br><span class="line">    <span class="keyword">const</span> word&amp; phaseName</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> basicThermo::New&lt;rhoThermo&gt;(mesh, phaseName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里调用的是 <code>basicThermo</code> 类的 <code>New</code> 函数。 这里先提一下继承关系，后面再细说：<code>rhoThermo</code> 类继承自 <code>fluidThermo</code> ， <code>fluidThermo</code> 类继承自 <code>basicThermo</code>。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//- <span class="type">Generic</span> <span class="type">New</span> <span class="keyword">for</span> each <span class="keyword">of</span> the related thermodynamics packages</span><br><span class="line">// basicThermo.C</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Thermo</span>&gt;</span><br><span class="line"><span class="keyword">static</span> autoPtr&lt;<span class="type">Thermo</span>&gt; <span class="type">New</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> fvMesh&amp;,</span><br><span class="line">    <span class="keyword">const</span> word&amp; phaseName=word::null</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Thermo</span>&gt;</span><br><span class="line"><span class="type">Foam</span>::autoPtr&lt;<span class="type">Thermo</span>&gt; <span class="type">Foam</span>::basicThermo::<span class="type">New</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> fvMesh&amp; mesh,</span><br><span class="line">    <span class="keyword">const</span> word&amp; phaseName</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">IOdictionary</span> thermoDict</span><br><span class="line">    (</span><br><span class="line">        <span class="type">IOobject</span></span><br><span class="line">        (</span><br><span class="line">            phasePropertyName(dictName, phaseName),</span><br><span class="line">            mesh.time().constant(),</span><br><span class="line">            mesh,</span><br><span class="line">            <span class="type">IOobject</span>::<span class="type">MUST_READ_IF_MODIFIED</span>,</span><br><span class="line">            <span class="type">IOobject</span>::<span class="type">NO_WRITE</span>,</span><br><span class="line">            <span class="literal">false</span></span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    typename <span class="type">Thermo</span>::fvMeshConstructorTable::<span class="keyword">iterator</span> cstrIter =</span><br><span class="line">        lookupThermo&lt;<span class="type">Thermo</span>, typename <span class="type">Thermo</span>::fvMeshConstructorTable&gt;</span><br><span class="line">        (</span><br><span class="line">            thermoDict,</span><br><span class="line">            <span class="type">Thermo</span>::fvMeshConstructorTablePtr_</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> autoPtr&lt;<span class="type">Thermo</span>&gt;(cstrIter()(mesh, phaseName));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据 RTS 机制的惯例， <code>New</code> 函数的功能是模型选择(<code>selector</code>)，即根据用户指定的关键字来选择对应的模型。 <code>New</code> 函数中先定义了一个 <code>IOdictionary</code> 类的对象， <code>thermoDict</code>，这个对象对应的正是热物理类的配置文件 <code>thermophysicalProperties</code>。<code>New</code> 函数里调用了 <code>lookupThermo</code> 函数，这个函数是关键：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// basicThermoTemplates.C</span></span><br><span class="line">template&lt;<span class="keyword">class</span> Thermo, <span class="keyword">class</span> <span class="keyword">Table</span>&gt;</span><br><span class="line">typename <span class="keyword">Table</span>::iterator Foam::basicThermo::lookupThermo</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> dictionary&amp; thermoDict,</span><br><span class="line">    <span class="keyword">Table</span>* tablePtr</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    word thermoTypeName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (thermoDict.isDict(<span class="string">"thermoType"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> dictionary&amp; thermoTypeDict(thermoDict.subDict(<span class="string">"thermoType"</span>));</span><br><span class="line"></span><br><span class="line">        Info&lt;&lt; <span class="string">"Selecting thermodynamics package "</span> &lt;&lt; thermoTypeDict &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> int nCmpt = 7;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* cmptNames[nCmpt] =</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"type"</span>,</span><br><span class="line">            <span class="string">"mixture"</span>,</span><br><span class="line">            <span class="string">"transport"</span>,</span><br><span class="line">            <span class="string">"thermo"</span>,</span><br><span class="line">            <span class="string">"equationOfState"</span>,</span><br><span class="line">            <span class="string">"specie"</span>,</span><br><span class="line">            <span class="string">"energy"</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Construct the name of the thermo package from the components</span></span><br><span class="line">        thermoTypeName =</span><br><span class="line">            <span class="literal">word</span>(thermoTypeDict.<span class="keyword">lookup</span>(<span class="string">"type"</span>)) + '&lt;'</span><br><span class="line">          + <span class="literal">word</span>(thermoTypeDict.<span class="keyword">lookup</span>(<span class="string">"mixture"</span>)) + '&lt;'</span><br><span class="line">          + <span class="literal">word</span>(thermoTypeDict.<span class="keyword">lookup</span>(<span class="string">"transport"</span>)) + '&lt;'</span><br><span class="line">          + <span class="literal">word</span>(thermoTypeDict.<span class="keyword">lookup</span>(<span class="string">"thermo"</span>)) + '&lt;'</span><br><span class="line">          + <span class="literal">word</span>(thermoTypeDict.<span class="keyword">lookup</span>(<span class="string">"equationOfState"</span>)) + '&lt;'</span><br><span class="line">          + <span class="literal">word</span>(thermoTypeDict.<span class="keyword">lookup</span>(<span class="string">"specie"</span>)) + <span class="string">"&gt;&gt;,"</span></span><br><span class="line">          + <span class="literal">word</span>(thermoTypeDict.<span class="keyword">lookup</span>(<span class="string">"energy"</span>)) + <span class="string">"&gt;&gt;&gt;"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Lookup the thermo package</span></span><br><span class="line">        typename <span class="keyword">Table</span>::iterator cstrIter = tablePtr-&gt;find(thermoTypeName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Print error message if package not found in the table</span></span><br><span class="line">        <span class="keyword">if</span> (cstrIter == tablePtr-&gt;end())</span><br><span class="line">        &#123;</span><br><span class="line">            FatalErrorIn(Thermo::typeName + <span class="string">"::New"</span>)</span><br><span class="line">                &lt;&lt; <span class="string">"Unknown "</span> &lt;&lt; Thermo::typeName &lt;&lt; <span class="string">" type "</span> &lt;&lt; <span class="keyword">nl</span></span><br><span class="line">                &lt;&lt; <span class="string">"thermoType"</span> &lt;&lt; thermoTypeDict &lt;&lt; <span class="keyword">nl</span> &lt;&lt; <span class="keyword">nl</span></span><br><span class="line">                &lt;&lt; <span class="string">"Valid "</span> &lt;&lt; Thermo::typeName &lt;&lt; <span class="string">" types are:"</span> &lt;&lt; <span class="keyword">nl</span> &lt;&lt; <span class="keyword">nl</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Get the list of all the suitable thermo packages available</span></span><br><span class="line">            wordList validThermoTypeNames</span><br><span class="line">            (</span><br><span class="line">                tablePtr-&gt;sortedToc()</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Build a table of the thermo packages constituent parts</span></span><br><span class="line">            <span class="comment">// Note: row-0 contains the names of constituent parts</span></span><br><span class="line">            <span class="keyword">List</span>&lt;wordList&gt; validThermoTypeNameCmpts</span><br><span class="line">            (</span><br><span class="line">                validThermoTypeNames.size() + 1</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            validThermoTypeNameCmpts[0].setSize(nCmpt);</span><br><span class="line">            forAll(validThermoTypeNameCmpts[0], j)</span><br><span class="line">            &#123;</span><br><span class="line">                validThermoTypeNameCmpts[0][j] = cmptNames[j];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Split the thermo package names into their constituent parts</span></span><br><span class="line">            forAll(validThermoTypeNames, i)</span><br><span class="line">            &#123;</span><br><span class="line">                validThermoTypeNameCmpts[i+1] =</span><br><span class="line">                    Thermo::splitThermoName(validThermoTypeNames[i], nCmpt);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Print the table of available packages</span></span><br><span class="line">            <span class="comment">// in terms of their constituent parts</span></span><br><span class="line">            printTable(validThermoTypeNameCmpts, FatalError);</span><br><span class="line"></span><br><span class="line">            FatalError&lt;&lt; <span class="keyword">exit</span>(FatalError);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cstrIter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        thermoTypeName = <span class="literal">word</span>(thermoDict.<span class="keyword">lookup</span>(<span class="string">"thermoType"</span>));</span><br><span class="line"></span><br><span class="line">        Info&lt;&lt; <span class="string">"Selecting thermodynamics package "</span> &lt;&lt; thermoTypeName &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        typename <span class="keyword">Table</span>::iterator cstrIter = tablePtr-&gt;find(thermoTypeName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cstrIter == tablePtr-&gt;end())</span><br><span class="line">        &#123;</span><br><span class="line">            FatalErrorIn(Thermo::typeName + <span class="string">"::New"</span>)</span><br><span class="line">                &lt;&lt; <span class="string">"Unknown "</span> &lt;&lt; Thermo::typeName &lt;&lt; <span class="string">" type "</span></span><br><span class="line">                &lt;&lt; thermoTypeName &lt;&lt; <span class="keyword">nl</span> &lt;&lt; <span class="keyword">nl</span></span><br><span class="line">                &lt;&lt; <span class="string">"Valid "</span> &lt;&lt; Thermo::typeName &lt;&lt; <span class="string">" types are:"</span> &lt;&lt; <span class="keyword">nl</span></span><br><span class="line">                &lt;&lt; tablePtr-&gt;sortedToc() &lt;&lt; <span class="keyword">nl</span></span><br><span class="line">                &lt;&lt; <span class="keyword">exit</span>(FatalError);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cstrIter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可见， <code>loopupThermo</code> 分两种情况处理，一种是 <code>thermophysicalProperties</code> 文件里有一个名为 <code>thermoType</code> 的 <code>subdict</code>，例如<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">thermoType</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title">type</span>            heRhoThermo;</span><br><span class="line">    <span class="title">mixture</span>         pureMixture;</span><br><span class="line">    <span class="title">transport</span>       const;</span><br><span class="line">    <span class="title">thermo</span>          hConst;</span><br><span class="line">    <span class="title">equationOfState</span> perfectGas;</span><br><span class="line">    <span class="title">specie</span>          specie;</span><br><span class="line">    <span class="title">energy</span>          sensibleInternalEnergy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种情况下， <code>subdict</code> 里的 7 个关键字将逐一读入，最终将合并起来，得到一个字符串，并赋值给 <code>thermoTypeName</code><br>以上面的那种情况为例，最终得到的<code>thermoTypeName</code> 为<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heRhoThermo&lt;pureMixture&lt;const&lt;hConst&lt;perfectGas&lt;specie<span class="prompt">&gt;&gt;</span>,sensibleInternalEnergy&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p>
<p>然后，根据这个关键词，从 hashTable 中找到对应的元素。如果找不到对应的，则报错，并输出所有可选的方案(由 <code>splitThermoName</code> 和 <code>printTable</code> 两个函数完成，细节这里暂且不表)。</p>
<p>另一种情况，直接从 <code>thermophysicalProperties</code> 读取 <code>thermoType</code> 对应的字符串并赋值给 <code>thermoTypeName</code>，然后据此来从 hashTable 中找到对应的元素。</p>
<p>OpenFOAM 自带的算例中，<code>thermophysicalProperties</code> 文件绝大部分采用前一种方式，因为更直观。后一种方式我在 OpenFOAM-2.3.x 版中只找到一个例子：tutorials/mesh/foamyQuadMesh/OpenCFD/constant/thermophysicalProperties<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thermoType      hePsiThermo&lt;pureMixture&lt;const&lt;hConst&lt;perfectGas&lt;specie<span class="prompt">&gt;&gt;</span>,sensibleEnthalpy&gt;&gt;&gt;;</span><br></pre></td></tr></table></figure></p>
<p>至此，大致就知道热物理类的接口定义是怎么回事了。但是，这个存储了可选模型的 hashTable 里有哪些内容，又是怎么构建起来的，还有待进一步深入探索。另外，从 <code>thermoType</code> 对应的字符串的样式，能猜到最终热物理类的接口 <code>thermo_</code> 指向的可能是类似 <code>heRhoThermo</code> 类的对象，而且这些类多半是模板类，并有着复杂的继承派生关系，这部分也还有待深入探索。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本系列来看一下 OpenFOAM 中的热物理类。热物理类比较繁杂，这里先看一下纯物质的热物理模型。本篇先来看看热物理类在求解器中的接口，以2.3.x 版的 <code>twoPhaseEulerFoam</code> 为例。</p>]]>
    
    </summary>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="thermophysicalModels" scheme="http://xiaopingqiu.github.io/tags/thermophysicalModels/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[涡结构提取]]></title>
    <link href="http://xiaopingqiu.github.io/2016/05/22/QAndLambda/"/>
    <id>http://xiaopingqiu.github.io/2016/05/22/QAndLambda/</id>
    <published>2016-05-22T11:35:16.000Z</published>
    <updated>2016-05-22T14:31:52.155Z</updated>
    <content type="html"><![CDATA[<p>为了研究湍流的涡结构，需要有一些方法来将涡结构提取出来，比图在文章中常见类似这种图：<br><img src="/image/vortex/Lambda2.png" alt="涡结构"></p>
<p>本篇介绍怎么在 OpenFOAM 中提取涡结构。</p>
<a id="more"></a>
<p>历史上曾用过的涡结构提取有以下几种：</p>
<ol>
<li><p>压强的局部极小值<br>在形成涡的地方，通常伴随着压强的极小值。比如:<br><img src="/image/vortex/p.png" alt=""><br>这种方法的缺点在于，缺乏客观的压力阈值来捕捉所有的涡结构，而且，压力出现极值的地方不见得就真的有涡。</p>
</li>
<li><p>流线<br>通过流线的封闭来显示涡的结构也是一种常见方法，比如<br><img src="/image/vortex/s.png" alt=""><br>这种方法有一个最明显的缺点是，流线不满足伽利略不变性，即，如果换一个参考系，则可能显示出来的“涡结构”就完全不一样了。另外，这种方法也难以分辨两个很靠近的涡。</p>
</li>
<li><p>涡量的模<br>用涡量的模来显示涡结构是一种很常用的方法，类似这样<br><img src="/image/vortex/magVor.png" alt=""><br>这种方法在自由剪切流中很有效，不过，对于壁面束缚流动则不太适用，原因是背景流动的剪切性导致的涡量模可以达到跟涡结构处的涡量的模差不多大小，这就使得涡结构难以从背景流动中分离出来了。并且，涡量的模的最大值通常发生在壁面上，而涡的核心显然不可能出现在壁面上。所以这种方法不适合用于提取边界层附近的涡结构。</p>
<p>OpenFOAM 中提供了两种方法来提取涡结构：Q 和 Lambda2。</p>
</li>
</ol>
<ul>
<li>速度梯度张量的二阶不变量<br>速度梯度 $\nabla \mathbf{U}$ 的二阶不变量 $Q$ 的定义为<br>$$<br>Q = \frac{1}{2}\Big ( ||\mathbf{W}||^2 - ||\mathbf{S}||^2 \Big )<br>$$<br>其中<br>$$<br>\mathbf{W} = \frac{1}{2} \Big ( \nabla \mathbf{U} - (\nabla \mathbf{U}) ^{\mathrm{T}} \Big ) \\<br>||\mathbf{W}|| = (\mathbf{W}:\mathbf{W})^{1/2} \\<br>\mathbf{S} = \frac{1}{2} \Big ( \nabla \mathbf{U} + (\nabla \mathbf{U}) ^{\mathrm{T}} \Big ) \\<br>||\mathbf{S}|| = (\mathbf{S}:\mathbf{S})^{1/2}<br>$$</li>
</ul>
<p>可以用 $Q &gt; 0$ 来作为涡结构存在的盘踞。<br>在 OpenFOAM 中，有一个程序用来计算 $Q$，名字就叫 <code>Q</code>。在流场计算完毕以后，可以运行 <code>Q</code>，然后在 paraview 中显示 <code>Q</code> 值大于 0 的等值面来显示涡的结构。只是，OpenFOAM 中 $Q$ 的计算用的是另一种方法：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Q.C </span></span><br><span class="line">volTensorField <span class="function">gradU</span>(fvc<span class="value">::<span class="function">grad</span>(U));</span></span><br><span class="line"></span><br><span class="line">volScalarField <span class="tag">Q</span></span><br><span class="line">(</span><br><span class="line">    IOobject</span><br><span class="line">    (</span><br><span class="line">        "<span class="tag">Q</span>",</span><br><span class="line">        runTime<span class="class">.timeName</span>(),</span><br><span class="line">        mesh,</span><br><span class="line">        IOobject<span class="value">::NO_READ,</span><br><span class="line">        IOobject::NO_WRITE</span><br><span class="line">    ),</span><br><span class="line">    <span class="number">0.5</span>*(<span class="function">sqr</span>(<span class="function">tr</span>(gradU)) - <span class="function">tr</span>(((gradU)&amp;(gradU))))</span><br><span class="line">);</span></span><br></pre></td></tr></table></figure>
<p>代码里注释说这是另一种计算 $Q$ 的方法，与上面公式的计算方法差别很小。</p>
<ul>
<li>张量 $\mathbf{W} \cdot \mathbf{W} + \mathbf{S} \cdot \mathbf{S}$ 的第二大特征值</li>
</ul>
<p>另一种判据是 $\mathbf{W} \cdot \mathbf{W} + \mathbf{S} \cdot \mathbf{S}$ 的第二大特征值 $\lambda _ 2 &lt; 0$。<br>在 OpenFOAM 中有一个程序用来计算 $\lambda _ 2$ ：<code>Lambda2</code>。<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Lambda2.C</span></span><br><span class="line"> const volTensorField <span class="function">gradU</span>(fvc<span class="value">::<span class="function">grad</span>(U));</span></span><br><span class="line"></span><br><span class="line">        volTensorField SSplusWW</span><br><span class="line">        (</span><br><span class="line">            (<span class="function">symm</span>(gradU) &amp; <span class="function">symm</span>(gradU)) + (<span class="function">skew</span>(gradU) &amp; <span class="function">skew</span>(gradU))</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        volScalarField Lambda2</span><br><span class="line">        (</span><br><span class="line">            IOobject</span><br><span class="line">            (</span><br><span class="line">                "Lambda2",</span><br><span class="line">                runTime<span class="class">.timeName</span>(),</span><br><span class="line">                mesh,</span><br><span class="line">                IOobject<span class="value">::NO_READ,</span><br><span class="line">                IOobject::NO_WRITE</span><br><span class="line">            ),</span><br><span class="line">            <span class="function">-eigenValues</span>(SSplusWW)().<span class="function">component</span>(vector::Y)</span><br><span class="line">        );</span></span><br><span class="line"></span><br><span class="line">        Info&lt;&lt; "    Writing -Lambda2" &lt;&lt; endl;</span><br><span class="line">        Lambda2<span class="class">.write</span>();</span><br></pre></td></tr></table></figure></p>
<p>注意，OpenFOAM 返回的是 $- \lambda _ 2$，所以，在计算了 <code>Lambda2</code> 后，需要通过 <code>Lambda2</code> 大于 0 的等值面来显示涡结构。本篇开头第一张图片，显示的是圆柱绕流的 <code>Lambda2 = 500</code> 等值面。</p>
<p><strong>参考</strong><br>Eugene de Villiers, The Potential of Large Eddy Simulation for the Modeling of Wall Bounded Flows, Ph.D Thesis, Imperial College of Science, 2005.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>为了研究湍流的涡结构，需要有一些方法来将涡结构提取出来，比图在文章中常见类似这种图：<br><img src="/image/vortex/Lambda2.png" alt="涡结构"></p>
<p>本篇介绍怎么在 OpenFOAM 中提取涡结构。</p>]]>
    
    </summary>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/tags/OpenFOAM/"/>
    
      <category term="Postprocessing" scheme="http://xiaopingqiu.github.io/tags/Postprocessing/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenFOAM 不可压缩湍流模型的 divDevReff 函数]]></title>
    <link href="http://xiaopingqiu.github.io/2016/05/03/divDevReff/"/>
    <id>http://xiaopingqiu.github.io/2016/05/03/divDevReff/</id>
    <published>2016-05-03T05:39:44.000Z</published>
    <updated>2016-05-03T05:58:35.645Z</updated>
    <content type="html"><![CDATA[<p>3.0 版本之前，OpenFOAM 的单相流求解器如 pisoFoam 的动量方程中调用的是湍流模型的 <code>divDevReff</code> 函数来考虑雷诺应力项的作用。只是，细究起来，这个函数似乎有点小问题，本篇来探讨一下这些小问题。</p>
<a id="more"></a>
<p>OpenFOAM 中单相不可压缩求解器中，雷诺应力项调用的是湍流模型中的 <code>divDevReff</code> 函数。这个函数的返回值为<br>$$<br>\nabla \cdot(\nu_{eff}\nabla U)+\nabla \cdot\left [\nu_{eff}\nabla U^\mathrm{T}-\frac{1}{3} \nu_{eff} (\nabla \cdot U) \mathbf{I} \right ]<br>$$<br>这里有两个疑问，第一是为什么是 $\frac{1}{3}$ 而不是 $\frac{2}{3}$，对应到代码，即为什么用 <code>dev</code> 函数而不是 <code>dev2</code> 函数？第二个问题，根据涡粘度的 Boussinesq approximation，雷诺应力项<br>$$<br>\overline{u’_iu’_j}= -\nu_t \left( \frac{\partial \bar{u}_i}{\partial x_j} + \frac{\partial \bar{u}_j}{\partial x_i} \right) + \frac{2}{3}k \delta_{ij}<br>$$<br>中应该还包含湍动能 $k$，而 OpenFOAM 中的 <code>divDefReff</code> 函数是没有 $k$ 这一项的。<br>这个话题，在 cfd-online 上的<a href="http://www.cfd-online.com/Forums/openfoam-solving/58214-calculating-divdevreff-2.html" target="_blank" rel="external">一篇帖子</a>里有深入的讨论。</p>
<p>对于第一个问题，我跟<a href="http://www.holzmann-cfd.de/index.php/en/tutorials-en" target="_blank" rel="external">Holtzmann CFD</a> 博客的博主 Tobias Holzmann 持同样观点，即$\frac{1}{3}$ 或 $\frac{2}{3}$ 不重要，因为对于不可压缩流动，连续方程为<br>$$<br>\nabla \cdot U = 0<br>$$<br>所以，收敛以后，$\frac{1}{3} \nu_{eff} (\nabla \cdot U)$ 这一项等于0. 但是在开始阶段，或者说还没有达到满足连续性的流场之前，这一项不为零。这里加上这一项是出于数值稳定性以及收敛速度的考虑，这一项不对收敛后的结果几乎没有影响。所以，$\frac{1}{3}$ 或 $\frac{2}{3}$ 不是很重要。<br>但是，可压缩湍流模型里必须是 $\frac{2}{3}$ ，因为这个 $\frac{2}{3}$ 是从 N-S 方程中严格推导而来的，而且，在可压缩的情形下，即使收敛以后，也有 $\nabla \cdot U \neq 0$ 。在 OpenFOAM=3.0 以后的版本里，不可压和可压缩湍流模型纳入到一个框架下了，两种情形下，都是用的 $\frac{2}{3}$ 这个系数。</p>
<p>对于第二个问题，有两种观点，一种认为 $k$ 的值相对很小，可以直接忽略不计。另一种观点认为，$k$ 被放到了压力项里，即，动量方程中的压力是雷诺时均压力与雷诺应力的各向同性分量（即 $\frac{2}{3}k$）之和：<br>$$<br>\bar{u}_j\frac{\partial\bar{u}_i}{\partial\bar{u}_j} =<br>-\frac{1}{\rho}\frac{\partial}{\partial x_i} \underbrace{\left[p + \frac{2}{3}k \right]}_{p^\prime}<br>+ \frac{\partial}{\partial x_j} \left[(\nu+\nu_{t}) \left( \frac{\partial \bar{u}_i}{\partial x_j} + \frac{\partial \bar{u}_j}{\partial x_i}\right) \right]<br>$$<br>这种观点可以在 Pope 2000 书第 88 页找到依据。在 “ The Finite Volume Method in Computational Fluid Dynamics: An Advanced Introduction with OpenFOAM® and Matlab®” 这本书的第 699 页，也提到 $k$ 是被放到压力项里去了，目的在于使动量方程中只含有 $\nu_t$ 这一个跟湍流有关的未知量。</p>
<p>不过，Tobias Holzmann 最后仍持前一种观点，即 $k$ 项被忽略了。理由是 OpenFOAM 中似乎找不到关于修改的压力场的代码，而且 OpenFOAM 那边也没见有人讨论说 OpenFOAM 中使用的是修改的压力场。<br>第二个问题目前还没有确切的结论，也尚不清楚这样处理对结果有多大影响。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>3.0 版本之前，OpenFOAM 的单相流求解器如 pisoFoam 的动量方程中调用的是湍流模型的 <code>divDevReff</code> 函数来考虑雷诺应力项的作用。只是，细究起来，这个函数似乎有点小问题，本篇来探讨一下这些小问题。</p>]]>
    
    </summary>
    
      <category term="turbulence model" scheme="http://xiaopingqiu.github.io/tags/turbulence-model/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LIGGGHTS tips]]></title>
    <link href="http://xiaopingqiu.github.io/2016/05/03/liggghts-howto/"/>
    <id>http://xiaopingqiu.github.io/2016/05/03/liggghts-howto/</id>
    <published>2016-05-03T04:38:31.000Z</published>
    <updated>2016-05-25T12:49:30.143Z</updated>
    <content type="html"><![CDATA[<p>本篇介绍几个 LIGGGHTS 技巧，read_data，freeze，move，modify_timing，neigh_modify。</p>
<a id="more"></a>
<p>LIGGGHTS 中可以用 STL 格式的几何面来模拟复杂边界的问题。如果想用冻结粒子当作壁面，可以采用如下方法。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span>_data test.dat</span><br><span class="line"></span><br><span class="line">group    Par_wall id &lt;&gt; <span class="number">1</span> <span class="number">1000</span>  </span><br><span class="line">fix       fr Par_wall freeze</span><br></pre></td></tr></table></figure></p>
<p>上述代码中，第一行是从外部文件中读取颗粒的信息；第二行是将ID在 1 到 1000 的粒子放到一个 group 里；第三行是将 Par_wall 这个 group 里的粒子冻结起来，具体的操作其实是将这些粒子的力归零，这样粒子将保持最初始的速度。如果将壁面粒子预先生成好，并将其初始速度设置为 0，便可以实现冻结粒子壁面了。</p>
<p>test.data 文件的数据格式如下，每一列数据的含义见注释：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">LAMMPS data file via write_data, version Version LIGGGHTS-PUBLIC <span class="number">3.2</span>.<span class="number">0</span>, git commit <span class="number">6</span>de550fbf3b8451f51246aa3c76374012e935340 based on LAMMPS <span class="number">23</span> Nov <span class="number">2013</span>, timestep = <span class="number">0</span>  <span class="comment">## 第一行随便是什么</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span> atoms  <span class="comment">## 颗粒数</span></span><br><span class="line"><span class="number">1</span> atom types <span class="comment">## 颗粒的 type 数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 模拟区域的大小</span></span><br><span class="line">-<span class="number">5.0009999999999999</span>e-<span class="number">01</span> <span class="number">5.0009999999999999</span>e-<span class="number">01</span> xlo xhi</span><br><span class="line">-<span class="number">2.0004000000000002</span>e-<span class="number">01</span> <span class="number">2.0004000000000002</span>e-<span class="number">01</span> ylo yhi</span><br><span class="line">-<span class="number">2.0005500000000001</span>e-<span class="number">01</span> <span class="number">3.4999999999999998</span>e-<span class="number">01</span> zlo zhi</span><br><span class="line"></span><br><span class="line">Atoms</span><br><span class="line"><span class="comment">#id type diameter density x y z i j k</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2.9999999999999999</span>e-<span class="number">02</span> <span class="number">2.5000000000000005</span>e+<span class="number">03</span> -<span class="number">2.9626205235821884</span>e-<span class="number">01</span> -<span class="number">1.7191257603378007</span>e-<span class="number">01</span> -<span class="number">5.2585560979625336</span>e-<span class="number">02</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">2.9999999999999999</span>e-<span class="number">02</span> <span class="number">2.5000000000000005</span>e+<span class="number">03</span> -<span class="number">3.1357080694177836</span>e-<span class="number">01</span> -<span class="number">8.1292507237863978</span>e-<span class="number">02</span> -<span class="number">3.0941241635135643</span>e-<span class="number">02</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">2.9999999999999999</span>e-<span class="number">02</span> <span class="number">2.5000000000000005</span>e+<span class="number">03</span> -<span class="number">3.4986005571676082</span>e-<span class="number">01</span> -<span class="number">4.6564797686740017</span>e-<span class="number">02</span> -<span class="number">5.0161637377833301</span>e-<span class="number">02</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">4</span> <span class="number">1</span> <span class="number">2.9999999999999999</span>e-<span class="number">02</span> <span class="number">2.5000000000000005</span>e+<span class="number">03</span> -<span class="number">3.2901105748658366</span>e-<span class="number">01</span> <span class="number">1.1629149478965480</span>e-<span class="number">01</span> -<span class="number">2.8537062345934828</span>e-<span class="number">02</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">5</span> <span class="number">1</span> <span class="number">5.0000000000000003</span>e-<span class="number">02</span> <span class="number">2.5000000000000000</span>e+<span class="number">03</span> -<span class="number">3.9692279707164302</span>e-<span class="number">01</span> <span class="number">1.5000972515153915</span>e-<span class="number">01</span> -<span class="number">3.5647118241865984</span>e-<span class="number">02</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Velocities <span class="comment">## 如果粒子的初始速度为零，这一段可以删去。</span></span><br><span class="line"><span class="comment">#id vx vy vz omegax omegay omegaz</span></span><br><span class="line"><span class="number">1</span> -<span class="number">1.5290519507823870</span>e+<span class="number">00</span> <span class="number">1.0245516532619933</span>e-<span class="number">01</span> -<span class="number">1.1594445288149451</span>e+<span class="number">00</span> <span class="number">6.3791250045904881</span>e+<span class="number">00</span> <span class="number">2.0674456758001139</span>e+<span class="number">02</span> <span class="number">1.0276923966595568</span>e+<span class="number">02</span></span><br><span class="line"><span class="number">2</span> -<span class="number">2.1385398568904033</span>e+<span class="number">00</span> -<span class="number">1.8858415304542153</span>e-<span class="number">01</span> -<span class="number">9.4897293591801291</span>e-<span class="number">01</span> <span class="number">1.2732686070189061</span>e+<span class="number">01</span> <span class="number">1.9114652955524940</span>e+<span class="number">02</span> -<span class="number">4.8862922016708987</span>e+<span class="number">00</span></span><br><span class="line"><span class="number">3</span> -<span class="number">2.1931823490540205</span>e+<span class="number">00</span> <span class="number">1.2314081721772643</span>e-<span class="number">01</span> -<span class="number">1.1305039942880526</span>e+<span class="number">00</span> -<span class="number">7.7211996358126047</span>e+<span class="number">00</span> <span class="number">1.8655504536271400</span>e+<span class="number">02</span> -<span class="number">3.5674698533544941</span>e+<span class="number">01</span></span><br><span class="line"><span class="number">4</span> -<span class="number">2.3661710510727509</span>e+<span class="number">00</span> <span class="number">6.5301832663338024</span>e-<span class="number">03</span> -<span class="number">9.2367025774174294</span>e-<span class="number">01</span> -<span class="number">5.7926985652143115</span>e-<span class="number">01</span> <span class="number">1.7594397127744105</span>e+<span class="number">02</span> <span class="number">6.1151183183219171</span>e+<span class="number">00</span></span><br><span class="line"><span class="number">5</span> -<span class="number">2.6032940321288258</span>e+<span class="number">00</span> <span class="number">1.7791968545582579</span>e-<span class="number">01</span> -<span class="number">1.0893683893889663</span>e+<span class="number">00</span> -<span class="number">1.6450273309025711</span>e+<span class="number">01</span> <span class="number">6.8599979334439681</span>e+<span class="number">01</span> <span class="number">3.4617478295022179</span>e+<span class="number">00</span></span><br></pre></td></tr></table></figure></p>
<p>上述能实现静止的壁面，如果希望用粒子来实现运动壁面（比如旋转），则可以用 move 命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">group rotateWall id &lt;&gt; <span class="number">1001</span> <span class="number">2000</span> <span class="comment"># 将 1001 &lt;= id &lt;= 2000 的粒子放到 group rotateWall 里</span></span><br><span class="line">fix mov rotateWall move rotate -<span class="number">19.8</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">8</span></span><br></pre></td></tr></table></figure></p>
<p>move 命令有不同的模式，这里用的是 rotate，用这个命令以后，rotateWall 这个 group 里的粒子，将按照指定的参数来进行旋转运动，而不再是根据其受力来更新速度和位置。参数的含义分别为：起始点坐标(x,y,z)；旋转轴的指向(x,y,z)；周期(转一圈的时间)。</p>
<p>最后再介绍几个小 tips：</p>
<ol>
<li>有时候想知道程序中哪一部分耗时最多，并据此来优化程序，这时可以在输入脚本的最开头，添加一句 modify_timing on ，之后在程序运行结束后会统计出每一条 fix 命令的耗时信息。</li>
<li>上述提到的冻结粒子壁面，在使用中会有一个问题：壁面粒子之间的距离通常是很小的，在建立粒子碰撞对的时候，壁面粒子之间通常会形成碰撞对，但壁面粒子之间没必要建立碰撞对，如果壁面粒子很多，这个建立过程是很耗时的。这种情况下，可以通过修改 neigh_modify 命令的参数来防止壁面粒子之间建立碰撞对：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">neigh_modify delay <span class="number">0</span> exclude group  Par_wall Par_wall</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这条命令将防止在 Par_wall 这个 group 里的粒子彼此之间建立碰撞对。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本篇介绍几个 LIGGGHTS 技巧，read_data，freeze，move，modify_timing，neigh_modify。</p>]]>
    
    </summary>
    
      <category term="LIGGGHTS" scheme="http://xiaopingqiu.github.io/tags/LIGGGHTS/"/>
    
      <category term="DEM" scheme="http://xiaopingqiu.github.io/categories/DEM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenFOAM 中的壁面函数（四）]]></title>
    <link href="http://xiaopingqiu.github.io/2016/04/25/wallFunctions4/"/>
    <id>http://xiaopingqiu.github.io/2016/04/25/wallFunctions4/</id>
    <published>2016-04-24T16:43:40.000Z</published>
    <updated>2016-04-25T03:14:35.521Z</updated>
    <content type="html"><![CDATA[<p>这篇来看看可能是最关键的 $\nu_t$ 的壁面函数。</p>
<a id="more"></a>
<h5 id="5-_湍流粘度_$\nu_t$_的壁面函数">5. 湍流粘度 $\nu_t$ 的壁面函数</h5><p>这个类型的壁面函数，结构比较简单，计算的是每一个壁面边界面上的湍流粘度 $\nu_t$。<br><code>nutWallFunction</code> 是虚基类，其中定义了一个纯虚函数 <code>calcNut</code><br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> tmp&lt;scalarField&gt; <span class="title">calcNut</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<p>并且在 <code>updateCoeffs</code> 函数中，将 <code>calcNut</code> 的返回值赋值给边界面<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> nutWallFunctionFvPatchScalarField::updateCoeffs()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (updated())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span>==(calcNut());</span><br><span class="line"></span><br><span class="line">    fixedValueFvPatchScalarField::updateCoeffs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样，在具体的那些计算 $\nu_t$ 的壁面函数中，只需要看 <code>calcNut</code> 的返回值就可以了。</p>
<ul>
<li>(1). nutkWallFunction<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">tmp&lt;scalarField&gt; nutkWallFunctionFvPatchScalarField::calcNut() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">label</span> patchi = patch().<span class="literal">index</span>();</span><br><span class="line">    <span class="keyword">const</span> turbulenceModel&amp; turbModel =</span><br><span class="line">        <span class="keyword">db</span>().lookupObject&lt;turbulenceModel&gt;(<span class="string">"turbulenceModel"</span>);</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; y = turbModel.<span class="literal">y</span>()[patchi];</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tk = turbModel.k();</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; k = tk();</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tnu = turbModel.nu();</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; nu = tnu();</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; nuw = nu.boundaryField()[patchi];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">scalar</span> Cmu25 = pow025(Cmu_);</span><br><span class="line">    tmp&lt;scalarField&gt; tnutw(new scalarField(patch().size(), 0.0));</span><br><span class="line">    scalarField&amp; nutw = tnutw();</span><br><span class="line">    forAll(nutw, faceI)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">label</span> faceCellI = patch().faceCells()[faceI];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">scalar</span> yPlus = Cmu25*y[faceI]*<span class="literal">sqrt</span>(k[faceCellI])/nuw[faceI];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (yPlus &gt; yPlusLam_)</span><br><span class="line">        &#123;</span><br><span class="line">            nutw[faceI] = nuw[faceI]*(yPlus*kappa_/<span class="literal">log</span>(E_*yPlus) - 1.0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tnutw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这里，仍然是分情况处理<br><code>yPlus &lt; yPlusLam_</code> 时，壁面上的 <code>nut</code> 设为0；<br><code>yPlus &gt; yPlusLam_</code> 时<br>$$<br>\nu_t = \nu \cdot \left( \frac{\kappa y^+}{\ln(Ey^+)}-1 \right)<br>$$<br>这里实现的其实就是标准壁面函数。理论上讲，这里的计算只在粘性底层和对数区是有效的，所以，使用这个壁面条件的时候，要尽量壁面网格落在过渡区，否则可能会引入较大误差。</p>
<p>顺带提一下，这里还定义了一个 <code>yPlus</code> 函数，用来计算 $y^+$，这个函数在这里没有调用，不过在其他代码中需要 $y^+$ 的时候会调用这个函数。比如，计算 $y^+$ 的应用 <code>yPlusRAS</code> 就是调用这里的 <code>yPlus</code> 函数来计算 $y^+$。<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">tmp&lt;scalarField&gt; nutkWallFunctionFvPatchScalarField::yPlus() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">label</span> patchi = patch().<span class="literal">index</span>();</span><br><span class="line">    <span class="keyword">const</span> turbulenceModel&amp; turbModel =</span><br><span class="line">        <span class="keyword">db</span>().lookupObject&lt;turbulenceModel&gt;(<span class="string">"turbulenceModel"</span>);</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; y = turbModel.<span class="literal">y</span>()[patchi];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tk = turbModel.k();</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; k = tk();</span><br><span class="line">    tmp&lt;scalarField&gt; kwc = k.boundaryField()[patchi].patchInternalField();</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tnu = turbModel.nu();</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; nu = tnu();</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; nuw = nu.boundaryField()[patchi];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pow025(Cmu_)*y*<span class="literal">sqrt</span>(kwc)/nuw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>(2). nutUWallFunction<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">tmp&lt;scalarField&gt; nutUWallFunctionFvPatchScalarField::calcNut() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">label</span> patchi = patch().<span class="literal">index</span>();</span><br><span class="line">    <span class="keyword">const</span> turbulenceModel&amp; turbModel =</span><br><span class="line">        <span class="keyword">db</span>().lookupObject&lt;turbulenceModel&gt;(<span class="string">"turbulenceModel"</span>);</span><br><span class="line">    <span class="keyword">const</span> fvPatchVectorField&amp; Uw = turbModel.<span class="keyword">U</span>().boundaryField()[patchi];</span><br><span class="line">    <span class="keyword">const</span> scalarField magUp(mag(Uw.patchInternalField() - Uw));</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tnu = turbModel.nu();</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; nu = tnu();</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; nuw = nu.boundaryField()[patchi];</span><br><span class="line">    tmp&lt;scalarField&gt; tyPlus = calcYPlus(magUp);</span><br><span class="line">    scalarField&amp; yPlus = tyPlus();</span><br><span class="line">    tmp&lt;scalarField&gt; tnutw(new scalarField(patch().size(), 0.0));</span><br><span class="line">    scalarField&amp; nutw = tnutw();</span><br><span class="line"></span><br><span class="line">    forAll(yPlus, facei)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (yPlus[facei] &gt; yPlusLam_)</span><br><span class="line">        &#123;</span><br><span class="line">            nutw[facei] =</span><br><span class="line">                nuw[facei]*(yPlus[facei]*kappa_/<span class="literal">log</span>(E_*yPlus[facei]) - 1.0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tnutw;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tmp&lt;scalarField&gt; nutUWallFunctionFvPatchScalarField::calcYPlus</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; magUp</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">label</span> patchi = patch().<span class="literal">index</span>();</span><br><span class="line">    <span class="keyword">const</span> turbulenceModel&amp; turbModel =</span><br><span class="line">        <span class="keyword">db</span>().lookupObject&lt;turbulenceModel&gt;(<span class="string">"turbulenceModel"</span>);</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; y = turbModel.<span class="literal">y</span>()[patchi];</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tnu = turbModel.nu();</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; nu = tnu();</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; nuw = nu.boundaryField()[patchi];</span><br><span class="line">    tmp&lt;scalarField&gt; tyPlus(new scalarField(patch().size(), 0.0));</span><br><span class="line">    scalarField&amp; yPlus = tyPlus();</span><br><span class="line">    forAll(yPlus, facei)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">scalar</span> kappaRe = kappa_*magUp[facei]*y[facei]/nuw[facei];</span><br><span class="line">        <span class="keyword">scalar</span> yp = yPlusLam_;</span><br><span class="line">        <span class="keyword">scalar</span> ryPlusLam = 1.0/yp;</span><br><span class="line">        int iter = 0;</span><br><span class="line">        <span class="keyword">scalar</span> yPlusLast = 0.0;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            yPlusLast = yp;</span><br><span class="line">            yp = (kappaRe + yp)/(1.0 + <span class="literal">log</span>(E_*yp));</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">while</span> (mag(ryPlusLam*(yp - yPlusLast)) &gt; 0.01 &amp;&amp; ++iter &lt; 10 );</span><br><span class="line"></span><br><span class="line">        yPlus[facei] = <span class="literal">max</span>(0.0, yp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tyPlus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这个壁函数的 $y^+$ 的计算方式跟 <code>nutkWallFunction</code> 有点区别。经过摸索，这里 <code>calcYPlus</code> 函数中的那段 <code>do ... while</code> 循环的原理如下：<br>对数律可以表达如下：<br>$$<br>U^+ = \frac{U_p}{u_\tau}=\frac{1}{\kappa}\ln(Ey^+)<br>$$<br>其中 $U_p$ 等于壁面上的速度减去壁面所属网格中心的速度。<br>经过简单变形<br>$$<br>\frac{U_p}{ y u_\tau/\nu }\cdot (y/\nu)=\frac{U_p}{ y^+}\cdot (y/\nu)=\frac{1}{\kappa}\ln(Ey^+)<br>$$<br>整理得<br>$$<br>y^+ \ln(Ey^+) - \frac{\kappa y U_p}{\nu}=0<br>$$<br>这是一个 $y^+$ 的一元方程，可以通过牛顿迭代来求解<br>$$<br>y^+_{n+1} = y^+_{n} - \frac{f(y^+)}{f^{\prime}(y+)} = y^+_{n}-\frac{y_n^+ \ln(Ey_n^+) - \frac{\kappa y U_p}{\nu}}{1+\ln(Ey_n^+)} = \frac{y_n^+ + \frac{\kappa y U_p}{\nu}}{1+\ln(Ey_n^+)}<br>$$<br>上面代码里的 <code>do ... while</code> 循环，正是在做这个迭代求解，初始值选择的是 <code>yPlusLam</code>，这个值在前面提过了。<br>求出 $y^+$ 以后，$\nu_t$ 计算如下<br>$$<br>\nu_t = \nu \cdot \left( \frac{\kappa y^+}{\ln(Ey^+)}-1 \right)<br>$$<br>与 <code>nutkWallFunction</code> 形式是一样的。</p>
<p>这个壁面函数，求壁面上的 $\nu_t$ 时使用的对数律方程，所以，理论上这个壁面函数应该只适用于第一层网格落在对数层的情形。</p>
<ul>
<li>(3). nutLowReWallFunction<br>这个壁面函数直接将壁面上的 $\nu_t$ 的值设为0。<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">tmp</span>&lt;<span class="tag">scalarField</span>&gt; <span class="rule"><span class="attribute">nutLowReWallFunctionFvPatchScalarField</span>:<span class="value">:<span class="function">calcNut</span>() const</span><br><span class="line">&#123;</span><br><span class="line">    return tmp&lt;scalarField&gt;(new <span class="function">scalarField</span>(<span class="function">patch</span>().<span class="function">size</span>(), <span class="number">0.0</span>))</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>$y^+$ 的计算也值得注意：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">tmp&lt;scalarField&gt; nutLowReWallFunctionFvPatchScalarField::yPlus() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">label</span> patchi = patch().<span class="literal">index</span>();</span><br><span class="line">    <span class="keyword">const</span> turbulenceModel&amp; turbModel =</span><br><span class="line">        <span class="keyword">db</span>().lookupObject&lt;turbulenceModel&gt;(<span class="string">"turbulenceModel"</span>);</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; y = turbModel.<span class="literal">y</span>()[patchi];</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tnu = turbModel.nu();</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; nu = tnu();</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; nuw = nu.boundaryField()[patchi];</span><br><span class="line">    <span class="keyword">const</span> fvPatchVectorField&amp; Uw = turbModel.<span class="keyword">U</span>().boundaryField()[patchi];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y*<span class="literal">sqrt</span>(nuw*mag(Uw.snGrad()))/nuw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>$$<br>y^+ = \frac{y\sqrt{\nu \cdot |\frac{U_w-U_c}{d}|}}{\nu}<br>$$<br>注意由于 $\nu_t = 0$ ，所以 $\frac{\tau_w}{\rho} = \nu \cdot |\frac{U_w-U_c}{d}|$，所以，$\sqrt{\nu \cdot |\frac{U_w-U_c}{d}|}=\sqrt{\frac{\tau_w}{\rho}}=u_\tau$ 。</p>
<ul>
<li>(4). nutUSpaldingWallFunction<br>这个壁函数基于 Spalding 提出的一个拟合的 $y^+$ 与 $u^+$ 的关系式，见文献 <em>A Single Formula for the “Law of the Wall” </em> 。<br>$$<br>y^+ = u^+ + \frac{1}{E}\left[ e^{\kappa u^+} -1-\kappa u^+ -\frac{1}{2}(\kappa u^+)^2 - \frac{1}{6}(\kappa u^+)^3 \right]<br>$$<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">tmp&lt;scalarField&gt; nutUSpaldingWallFunctionFvPatchScalarField::calcNut() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">label</span> patchI = patch().<span class="literal">index</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> turbulenceModel&amp; turbModel =</span><br><span class="line">        <span class="keyword">db</span>().lookupObject&lt;turbulenceModel&gt;(<span class="string">"turbulenceModel"</span>);</span><br><span class="line">    <span class="keyword">const</span> fvPatchVectorField&amp; Uw = turbModel.<span class="keyword">U</span>().boundaryField()[patchI];</span><br><span class="line">    <span class="keyword">const</span> scalarField magGradU(mag(Uw.snGrad()));</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tnu = turbModel.nu();</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; nu = tnu();</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; nuw = nu.boundaryField()[patchI];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">max</span></span><br><span class="line">    (</span><br><span class="line">        <span class="literal">scalar</span>(0),</span><br><span class="line">        sqr(calcUTau(magGradU))/(magGradU + ROOTVSMALL) - nuw</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tmp&lt;scalarField&gt; nutUSpaldingWallFunctionFvPatchScalarField::calcUTau</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; magGradU</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">label</span> patchI = patch().<span class="literal">index</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> turbulenceModel&amp; turbModel =</span><br><span class="line">        <span class="keyword">db</span>().lookupObject&lt;turbulenceModel&gt;(<span class="string">"turbulenceModel"</span>);</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; y = turbModel.<span class="literal">y</span>()[patchI];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> fvPatchVectorField&amp; Uw = turbModel.<span class="keyword">U</span>().boundaryField()[patchI];</span><br><span class="line">    <span class="keyword">const</span> scalarField magUp(mag(Uw.patchInternalField() - Uw));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tnu = turbModel.nu();</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; nu = tnu();</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; nuw = nu.boundaryField()[patchI];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; nutw = *this;</span><br><span class="line"></span><br><span class="line">    tmp&lt;scalarField&gt; tuTau(new scalarField(patch().size(), 0.0));</span><br><span class="line">    scalarField&amp; uTau = tuTau();</span><br><span class="line"></span><br><span class="line">    forAll(uTau, faceI)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">scalar</span> ut = <span class="literal">sqrt</span>((nutw[faceI] + nuw[faceI])*magGradU[faceI]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ut &gt; ROOTVSMALL)</span><br><span class="line">        &#123;</span><br><span class="line">            int iter = 0;</span><br><span class="line">            <span class="keyword">scalar</span> <span class="keyword">err</span> = GREAT;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">scalar</span> kUu = <span class="literal">min</span>(kappa_*magUp[faceI]/ut, 50);</span><br><span class="line">                <span class="keyword">scalar</span> fkUu = <span class="literal">exp</span>(kUu) - 1 - kUu*(1 + 0.5*kUu);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">scalar</span> f =</span><br><span class="line">                    - ut*y[faceI]/nuw[faceI]</span><br><span class="line">                    + magUp[faceI]/ut</span><br><span class="line">                    + 1/E_*(fkUu - 1.0/6.0*kUu*sqr(kUu));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">scalar</span> df =</span><br><span class="line">                    y[faceI]/nuw[faceI]</span><br><span class="line">                  + magUp[faceI]/sqr(ut)</span><br><span class="line">                  + 1/E_*kUu*fkUu/ut;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">scalar</span> uTauNew = ut + f/df;</span><br><span class="line">                <span class="keyword">err</span> = mag((ut - uTauNew)/ut);</span><br><span class="line">                ut = uTauNew;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">while</span> (ut &gt; ROOTVSMALL &amp;&amp; <span class="keyword">err</span> &gt; 0.01 &amp;&amp; ++iter &lt; 10);</span><br><span class="line"></span><br><span class="line">            uTau[faceI] = <span class="literal">max</span>(0.0, ut);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tuTau;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><code>calcUtau</code> 函数，其实是在用牛顿法迭代求解 $y^+$，进而得到 $u_\tau$ 的值。<code>calcNut</code> 函数中<br>$$<br>\frac{u_\tau ^2}{|\frac{U_w-U_c}{d}|} - \nu = \frac{\tau_w}{|\frac{U_w-U_c}{d}|} -\nu = \nu_{eff} - \nu = \nu_t<br>$$</p>
<p>这个壁面函数使用的是从粘性底层连续变化到对数层的 $y^+ \text{-} u^+$ 关系式，所以，这个可以认为是网格无关的，即不管第一层网格落在哪个区，都是有效的。如果网格无法做到全部位于粘性层或者对数区，建议用这个壁面条件。</p>
<ul>
<li>(5). nutUTabulatedWallFunction</li>
</ul>
<p>这个壁面函数，需要从外部读取一个 $U^+ \text{-}\,Re_y$ 数据表，通过从这个数据表插值来得到 $U^+$ 的值。其中 $Re_y=yU/\nu$ 。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">nutUTabulatedWallFunctionFvPatchScalarField::</span><br><span class="line">nutUTabulatedWallFunctionFvPatchScalarField</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> fvPatch&amp; p,</span><br><span class="line">    <span class="keyword">const</span> DimensionedField&lt;scalar, volMesh&gt;&amp; iF,</span><br><span class="line">    <span class="keyword">const</span> dictionary&amp; dict</span><br><span class="line">)</span><br><span class="line">:</span><br><span class="line">    nutWallFunctionFvPatchScalarField(p, iF, dict),</span><br><span class="line">    uPlusTableName_(dict.lookup(<span class="string">"uPlusTable"</span>)),</span><br><span class="line">    uPlusTable_</span><br><span class="line">    (</span><br><span class="line">        IOobject</span><br><span class="line">        (</span><br><span class="line">            uPlusTableName_,</span><br><span class="line">            patch().boundaryMesh().mesh().time().constant(),</span><br><span class="line">            patch().boundaryMesh().mesh(),</span><br><span class="line">            IOobject::MUST_READ_IF_MODIFIED,</span><br><span class="line">            IOobject::NO_WRITE,</span><br><span class="line">            <span class="keyword">false</span></span><br><span class="line">        ),</span><br><span class="line">        <span class="keyword">true</span></span><br><span class="line">    )</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>$U^+$ 和 $\nu_t$ 分别由函数 <code>calcUPlus</code> 和 <code>calcNut</code> 来计算。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">tmp&lt;scalarField&gt; nutUTabulatedWallFunctionFvPatchScalarField::calcNut() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">label</span> patchi = patch().<span class="literal">index</span>();</span><br><span class="line">    <span class="keyword">const</span> turbulenceModel&amp; turbModel =</span><br><span class="line">        <span class="keyword">db</span>().lookupObject&lt;turbulenceModel&gt;(<span class="string">"turbulenceModel"</span>);</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; y = turbModel.<span class="literal">y</span>()[patchi];</span><br><span class="line">    <span class="keyword">const</span> fvPatchVectorField&amp; Uw = turbModel.<span class="keyword">U</span>().boundaryField()[patchi];</span><br><span class="line">    <span class="keyword">const</span> scalarField magUp(mag(Uw.patchInternalField() - Uw));</span><br><span class="line">    <span class="keyword">const</span> scalarField magGradU(mag(Uw.snGrad()));</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tnu = turbModel.nu();</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; nu = tnu();</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; nuw = nu.boundaryField()[patchi];</span><br><span class="line">    <span class="literal">return</span></span><br><span class="line">        <span class="literal">max</span></span><br><span class="line">        (</span><br><span class="line">            <span class="literal">scalar</span>(0),</span><br><span class="line">            sqr(magUp/(calcUPlus(magUp*y/nuw) + ROOTVSMALL))</span><br><span class="line">           /(magGradU + ROOTVSMALL)</span><br><span class="line">          - nuw</span><br><span class="line">        );</span><br><span class="line">    <span class="comment">// magUp/UPlus = utau, sqr(utau) = tauw, tauw/magGradU = nuEff = nut + nu</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tmp&lt;scalarField&gt; nutUTabulatedWallFunctionFvPatchScalarField::calcUPlus</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; Rey</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    tmp&lt;scalarField&gt; tuPlus(new scalarField(patch().size(), 0.0));</span><br><span class="line">    scalarField&amp; uPlus = tuPlus();</span><br><span class="line">    forAll(uPlus, faceI)</span><br><span class="line">    &#123;</span><br><span class="line">        uPlus[faceI] = uPlusTable_.interpolateLog10(Rey[faceI]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tuPlus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这里 <code>calcUPlus</code> 用的是 <code>interpolateLog10</code> 函数来插值，这个函数的定义为<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">template&lt;<span class="keyword">class</span> <span class="keyword">Type</span>&gt;</span><br><span class="line"><span class="keyword">Type</span> Foam::uniformInterpolationTable&lt;<span class="keyword">Type</span>&gt;::interpolateLog10</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">scalar</span> x</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (log10_)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            x = ::<span class="literal">log10</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (bound_ &amp;&amp; (x &lt;= 0))</span><br><span class="line">        &#123;</span><br><span class="line">            x = x0_;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            FatalErrorIn</span><br><span class="line">            (</span><br><span class="line">                <span class="string">"uniformInterpolationTable&lt;Type&gt;::interpolateLog10(scalar x)"</span></span><br><span class="line">            )   &lt;&lt; <span class="string">"Table "</span> &lt;&lt; name() &lt;&lt; <span class="keyword">nl</span></span><br><span class="line">                &lt;&lt; <span class="string">"Supplied value must be greater than 0 when in log10 mode"</span></span><br><span class="line">                &lt;&lt; <span class="keyword">nl</span> &lt;&lt; <span class="string">"x="</span> &lt;&lt; x &lt;&lt; <span class="keyword">nl</span> &lt;&lt; <span class="keyword">exit</span>(FatalError);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> interpolate(x); <span class="comment">// 这个是普通的线性插值函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>即计算 <code>x</code> 的对数（log10），在将计算结果用来进行线性插值。所以，用这个壁面函数的时候，要注意你所提供的数据表是普通线性坐标的还是对数坐标的。</p>
<p>基本上常见的处理壁面上的湍流粘度的方法就是以上几种了。OpenFOAM 中还提供了几个能处理粗糙壁面的壁面函数( <code>nutURoughWallFunction</code> ， <code>nutkRoughWallFunction</code> )，以及处理大气层边界的(<code>nutkAtmRoughWallFunction</code>，需要跟 <code>atmBoundaryLayerInletVelocity</code> 这个入口边界配合使用 )，细节这里不再详述了，有需要时可以去看相关代码，代码结构是类似的，只是具体计算公式不一样。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这篇来看看可能是最关键的 $\nu_t$ 的壁面函数。</p>]]>
    
    </summary>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="wall functions" scheme="http://xiaopingqiu.github.io/tags/wall-functions/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenFOAM 中的壁面函数（三）]]></title>
    <link href="http://xiaopingqiu.github.io/2016/04/25/wallFunctions3/"/>
    <id>http://xiaopingqiu.github.io/2016/04/25/wallFunctions3/</id>
    <published>2016-04-24T16:43:34.000Z</published>
    <updated>2016-04-25T03:05:53.080Z</updated>
    <content type="html"><![CDATA[<p>这篇来看看计算湍动能 $\varepsilon$  和 $\omega$ 的壁面函数。</p>
<a id="more"></a>
<h5 id="3-_湍动能耗散_$\varepsilon$_的壁面函数">3. 湍动能耗散 $\varepsilon$ 的壁面函数</h5><p>本篇来看看 OpenFOAM 中的 <code>epsilonWallFunction</code>，共有两个： <code>epsilonWallFunction</code> 和 <code>epsilonLowReWallFunction</code>。</p>
<ul>
<li>(1). epsilonWallFunction</li>
</ul>
<p><code>epsilonWallFunction</code> 代码比前面的 <code>kqRWallFunction</code> 复杂多了，主要原因在于这里需要得到的是 <code>epsilon</code> 在临近网格的值，而且，需要考虑包含两个边界面的网格。这里先来梳理代码的脉络，然后再看具体的计算细节。<br>外部调用的主要是 <code>updateCoeffs()</code> 函数，所以，从这个函数看起。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> epsilonWallFunctionFvPatchScalarField::updateCoeffs()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (updated())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> turbulenceModel&amp; turbulence =</span><br><span class="line">        db().lookupObject&lt;turbulenceModel&gt;(turbulenceModel::typeName);</span><br><span class="line"></span><br><span class="line">    setMaster();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (patch().index() == master_)</span><br><span class="line">    &#123;</span><br><span class="line">        createAveragingWeights();</span><br><span class="line">        calculateTurbulenceFields(turbulence, G(<span class="keyword">true</span>), epsilon(<span class="keyword">true</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; G0 = <span class="keyword">this</span>-&gt;G();</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; epsilon0 = <span class="keyword">this</span>-&gt;epsilon();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> DimensionedField&lt;scalar, volMesh&gt; FieldType;</span><br><span class="line"></span><br><span class="line">    FieldType&amp; G =</span><br><span class="line">        <span class="keyword">const_cast</span>&lt;FieldType&amp;&gt;</span><br><span class="line">        (</span><br><span class="line">            db().lookupObject&lt;FieldType&gt;(turbulence.GName())</span><br><span class="line">        );</span><br><span class="line">    <span class="comment">//这里是获取内部场，所以，修改这里的引用 "epsilon",相当于修改 epsilon 的内部场值。</span></span><br><span class="line">    FieldType&amp; epsilon = <span class="keyword">const_cast</span>&lt;FieldType&amp;&gt;(dimensionedInternalField());</span><br><span class="line"></span><br><span class="line">    forAll(*<span class="keyword">this</span>, faceI)</span><br><span class="line">    &#123;</span><br><span class="line">        label cellI = patch().faceCells()[faceI];</span><br><span class="line"></span><br><span class="line">        G[cellI] = G0[cellI];</span><br><span class="line">        epsilon[cellI] = epsilon0[cellI];</span><br><span class="line">    &#125;</span><br><span class="line">    fvPatchField&lt;scalar&gt;::updateCoeffs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 一步一步来看。首先是调用了 <code>setMaster()</code> 函数，来看看这个函数以及相关的一个函数 <code>epsilonPatch</code> 的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> epsilonWallFunctionFvPatchScalarField::setMaster()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (master_ != -<span class="number">1</span>) <span class="comment">// 如果当前处理的边界的 master_ != -1，说明它已被处理过，直接返回</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; epsilon =</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> volScalarField&amp;&gt;(<span class="keyword">this</span>-&gt;dimensionedInternalField());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> volScalarField::GeometricBoundaryField&amp; bf = epsilon.boundaryField();</span><br><span class="line"></span><br><span class="line">    label master = -<span class="number">1</span>;</span><br><span class="line">    forAll(bf, patchI)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isA&lt;epsilonWallFunctionFvPatchScalarField&gt;(bf[patchI]))</span><br><span class="line">        &#123;</span><br><span class="line">            epsilonWallFunctionFvPatchScalarField&amp; epf = epsilonPatch(patchI);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (master == -<span class="number">1</span>) <span class="comment">// 只有头一个被处理的边界满足这个条件</span></span><br><span class="line">            &#123;</span><br><span class="line">                master = patchI;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            epf.master() = master; <span class="comment">// 这意味着所有边界的 master_ 数据成员都将赋值为头一个被处理的边界的编号，即第一个被处理的边界是master</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">epsilonWallFunctionFvPatchScalarField&amp;</span><br><span class="line">epsilonWallFunctionFvPatchScalarField::epsilonPatch(<span class="keyword">const</span> label patchI)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; epsilon =</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> volScalarField&amp;&gt;(<span class="keyword">this</span>-&gt;dimensionedInternalField());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> volScalarField::GeometricBoundaryField&amp; bf = epsilon.boundaryField();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> epsilonWallFunctionFvPatchScalarField&amp; epf =</span><br><span class="line">        refCast&lt;<span class="keyword">const</span> epsilonWallFunctionFvPatchScalarField&gt;(bf[patchI]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;epsilonWallFunctionFvPatchScalarField&amp;&gt;(epf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 从上述代码可以看出， <code>epsilonPatch</code> 函数需要一个参数，这个参数的含义是某一个边界的序号，返回的是指向这个边界的一个 <code>epsilonWallFunctionFvPatchScalarField</code> 类型的引用。<br>在此基础上，再来看 <code>setMaster</code>。先判断当前边界的数据成员 <code>master_</code> 是否不等于-1，如果成立则不做任何操作，直接返回；否则，先获取到 <code>epsilon</code> 的所有边界，存在变量 <code>bf</code> 中，然后，遍历 <code>bf</code> ，如果边界的类型是 <code>epsilonWallFunctionFvPatchScalarField</code>，则判断临时变量 <code>master</code> 是否等于 <code>-1</code>，等于则将边界的序号 <code>patchI</code>  赋值给 <code>master</code>，并临时变量 <code>master</code> 的值赋给 <code>patchI</code> 对应边界的数据成员 <code>master_</code>。 举个例子，假设有一个算例，有两个边界上使用了 <code>epsilonWallFunctionFvPatchScalarField</code> 类型的边界条件，两个边界的编号分别是 <code>patchI = 0</code> 和 <code>patchI = 1</code>。则在上述循环过程中，当 <code>patchI = 0</code>时， <code>master == -1</code> 肯定成立。于是，<code>patchI = 0</code> 对应边界的数据成员 <code>master_</code> 被赋值为0；而当遍历到 <code>patchI = 1</code> 时， 此时<code>master = 0</code>，所以，结果是 <code>patchI = 1</code> 的边界的数据成员 <code>master_</code> 也被赋值为0。 </p>
<p> 继续向下看，如果 <code>patch.index() == master_</code> ，则调用两个函数。这个怎么理解呢？还以上面的那个简单例子来说明。注意，在外部调用边界条件的时候，也是会依次调用一个场的所有边界的边界条件的。在这里的简单例子中，有两个边界的类型是 <code>epsilonWallFunctionFvPatchScalarField</code> ，所以，我们假设调用 <code>patchI = 0</code> 对应的边界时，由于初始化时数据成员 <code>master_</code> 赋值为 <code>-1</code> ，所以，调用 <code>patchI = 0</code> 的边界时， <code>setMaster</code> 函数中的操作会进行。而根据上面的分析，调用 <code>patchI = 0</code> 的边界时， <code>setMaster</code> 函数同时也将 <code>patchI = 1</code> 边界的数据成员 <code>master_</code> 赋值为 <code>0</code>了，所以，在外部调用 <code>patchI = 1</code> 的边界时， <code>setMaster</code> 函数将不作任何操作，直接返回。同样的，在外部调用 <code>patchI = 0</code> 的边界时，<code>patch.index() == master_</code> 条件是成立的，所以 <code>createAveragingWeights()</code> 和 <code>calculateTurbulenceFields(turbulence, G(true), epsilon(true));</code> 两个语句将会执行；而在外部调用 <code>patchI = 1</code> 边界时，由于 <code>patch.index() == master_</code> 不成立，这两个语句将不执行。</p>
<p> 再继续往前看， <code>const scalarField&amp; G0 = this-&gt;G();    const scalarField&amp; epsilon0 = this-&gt;epsilon();</code> ，这里是将成员函数 <code>G</code> 和 <code>epsilon</code> 的返回值分别赋给变量 <code>G0</code> 和 <code>epsilon0</code>。开看一下成员函数的定义<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">scalarField&amp; epsilonWallFunctionFvPatchScalarField::<span class="type">G</span>(bool <span class="keyword">init</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (patch().index() == master_) <span class="comment">// 只有头一个被处理的边界满足这个条件</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">init</span>) <span class="comment">// init 缺省值是 false </span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">G_</span> = <span class="number">0.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">G_</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> epsilonPatch(master_).<span class="type">G</span>(); <span class="comment">// 对于不是 master 的边界，返回master边界的数据成员 G_</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">scalarField&amp; epsilonWallFunctionFvPatchScalarField::epsilon(bool <span class="keyword">init</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (patch().index() == master_)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">init</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            epsilon_ = <span class="number">0.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> epsilon_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> epsilonPatch(master_).epsilon(<span class="keyword">init</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>类似的，对于 <code>patchI = 0</code>， <code>patch().index() == master_</code> ，所以返回值为 <code>patchI = 0</code> 边界的数据成员 <code>G_</code> 或  <code>epsilon_</code> (<code>init</code> 的缺省值是 <code>false</code>)；而对于 <code>patchI = 1</code>边界，返回的是 <code>patchI = master_</code> 对应边界的数据成员 <code>G_</code> 或  <code>epsilon_</code>，而根据上面的分析， <code>patchI= 1</code> 的边界的数据成员 <code>master_ = 0</code>，因此， <code>patchI = 1</code> 的边界的成员函数返回的是 <code>patchI = 0</code>边界的相应的数据成员。</p>
<p>再往下的内容就很简单了，只是将得到的 <code>G0</code> 和 <code>epsilon0</code> 的值分别赋给当前边界的临近边界网格而已。</p>
<p>到此，代码的框架就基本清晰了，小结一下就是，如果对于某个算例，有多个边界上需要用到 <code>epsilonWallFunctionFvPatchScalarField</code> 类型的边界条件，则，编号更小的那个边界将会被设置成 <code>master</code>。所有的相关计算都在调用 <code>master</code> 边界的时候进行，非 <code>master</code> 的边界，则只需要从 <code>master</code> 那里读取结果即可！ </p>
<p>接下来看看外部调用 <code>master</code> 边界的时候，具体做了哪些计算，主要就是看 <code>createAveragingWeights()</code> 和 <code>calculateTurbulenceFields(turbulence, G(true), epsilon(true));</code> 这两条语句了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> epsilonWallFunctionFvPatchScalarField::createAveragingWeights()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; epsilon =</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> volScalarField&amp;&gt;(<span class="keyword">this</span>-&gt;dimensionedInternalField());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> volScalarField::GeometricBoundaryField&amp; bf = epsilon.boundaryField();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> fvMesh&amp; mesh = epsilon.mesh();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (initialised_ &amp;&amp; !mesh.changing())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">volScalarField <span class="title">weights</span></span><br><span class="line">    <span class="params">(</span><br><span class="line">        IOobject</span><br><span class="line">        (</span><br><span class="line">            "weights",</span><br><span class="line">            mesh.time()</span>.<span class="title">timeName</span><span class="params">()</span>,</span><br><span class="line">            mesh,</span><br><span class="line">            IOobject::NO_READ,</span><br><span class="line">            IOobject::NO_WRITE,</span><br><span class="line">            <span class="keyword">false</span> <span class="comment">// do not register</span></span><br><span class="line">        ),</span><br><span class="line">        mesh,</span><br><span class="line">        <span class="title">dimensionedScalar</span><span class="params">("zero", dimless, 0.0)</span></span><br><span class="line">    )</span>;</span><br><span class="line"></span><br><span class="line">    DynamicList&lt;label&gt; epsilonPatches(bf.size());</span><br><span class="line">    <span class="comment">//遍历所有边界，如果边界类型是 epsilonWallFunctionFvPatchScalarField 则将该边界放到 epsilonPatches 这个动态 list 中。</span></span><br><span class="line">    forAll(bf, patchI)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isA&lt;epsilonWallFunctionFvPatchScalarField&gt;(bf[patchI]))</span><br><span class="line">        &#123;</span><br><span class="line">            epsilonPatches.append(patchI);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> labelUList&amp; faceCells = bf[patchI].patch().faceCells();</span><br><span class="line">            forAll(faceCells, i)</span><br><span class="line">            &#123;</span><br><span class="line">                label cellI = faceCells[i];</span><br><span class="line">            <span class="comment">// weight 衡量的是网格cellI有多少个边界面使用了 epsilonWallFunctionFvPatchScalarField 类型的边界条件</span></span><br><span class="line">                 weights[cellI]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cornerWeights_.setSize(bf.size());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历所有 epsilonWallFunctionFvPatchScalarField 类型的边界</span></span><br><span class="line">    forAll(epsilonPatches, i)</span><br><span class="line">    &#123;</span><br><span class="line">        label patchI = epsilonPatches[i];</span><br><span class="line">        <span class="keyword">const</span> fvPatchScalarField&amp; wf = weights.boundaryField()[patchI];</span><br><span class="line">    <span class="comment">//cornerWeights_存储的所有边界面的weight的倒数，边界面的weight等于其所属网格的weight。所以，如果有一个网格包含两个使用epsilonWallFunction的边界面，那么根据上面的计算，这个网格的weight将是 2，而这两个边界面的 cornerWeights_ 则都是 1/2。 </span></span><br><span class="line">        cornerWeights_[patchI] = <span class="number">1.0</span>/wf.patchInternalField();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将数据成员 G_ 和 epsilon_ 初始化为0</span></span><br><span class="line">    G_.setSize(dimensionedInternalField().size(), <span class="number">0.0</span>);</span><br><span class="line">    epsilon_.setSize(dimensionedInternalField().size(), <span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">    initialised_ = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> epsilonWallFunctionFvPatchScalarField::calculateTurbulenceFields</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> turbulenceModel&amp; turbulence,</span><br><span class="line">    scalarField&amp; G0,</span><br><span class="line">    scalarField&amp; epsilon0</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// accumulate all of the G and epsilon contributions</span></span><br><span class="line">    <span class="comment">//cornerWeights_ 是一个二维 list，这里是遍历这个list 的第一层</span></span><br><span class="line">    forAll(cornerWeights_, patchI)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!cornerWeights_[patchI].empty()) <span class="comment">// 如果是empty，意味着这个对应的边界不是epsilonWallFunction类型，所以就不需要考虑</span></span><br><span class="line">        &#123;</span><br><span class="line">            epsilonWallFunctionFvPatchScalarField&amp; epf = epsilonPatch(patchI);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> List&lt;scalar&gt;&amp; w = cornerWeights_[patchI];</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 非 empty 则调用 calculate 函数更新 G0 和 epsilon 的值</span></span><br><span class="line">            epf.calculate(turbulence, w, epf.patch(), G0, epsilon0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// apply zero-gradient condition for epsilon</span></span><br><span class="line">    forAll(cornerWeights_, patchI)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!cornerWeights_[patchI].empty())</span><br><span class="line">        &#123;</span><br><span class="line">            epsilonWallFunctionFvPatchScalarField&amp; epf = epsilonPatch(patchI);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对 epsilon 使用 零梯度边界条件，即将上面计算得到的临近壁面网格的epsilon的值存储在壁面。</span></span><br><span class="line">            epf == scalarField(epsilon0, epf.patch().faceCells());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> epsilonWallFunctionFvPatchScalarField::calculate</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> turbulenceModel&amp; turbulence,</span><br><span class="line">    <span class="keyword">const</span> List&lt;scalar&gt;&amp; cornerWeights,</span><br><span class="line">    <span class="keyword">const</span> fvPatch&amp; patch,</span><br><span class="line">    scalarField&amp; G,</span><br><span class="line">    scalarField&amp; epsilon</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> label patchI = patch.index();</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; y = turbulence.y()[patchI];</span><br><span class="line">    <span class="keyword">const</span> scalar Cmu25 = pow025(Cmu_);</span><br><span class="line">    <span class="keyword">const</span> scalar Cmu75 = <span class="built_in">pow</span>(Cmu_, <span class="number">0.75</span>);</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tk = turbulence.k();</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; k = tk();</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tnu = turbulence.nu();</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; nuw = tnu().boundaryField()[patchI];</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tnut = turbulence.nut();</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; nut = tnut();</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; nutw = nut.boundaryField()[patchI];</span><br><span class="line">    <span class="keyword">const</span> fvPatchVectorField&amp; Uw = turbulence.U().boundaryField()[patchI];</span><br><span class="line">    <span class="function"><span class="keyword">const</span> scalarField <span class="title">magGradUw</span><span class="params">(mag(Uw.snGrad()</span>))</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set epsilon and G</span></span><br><span class="line">    遍历参数 patch 对应的边界的每一个面</span><br><span class="line">    forAll(nutw, faceI)</span><br><span class="line">    &#123;</span><br><span class="line">        label cellI = patch.faceCells()[faceI];</span><br><span class="line">        scalar w = cornerWeights[faceI];</span><br><span class="line">        </span><br><span class="line">        epsilon[cellI] += w*Cmu75*<span class="built_in">pow</span>(k[cellI], <span class="number">1.5</span>)/(kappa_*y[faceI]);</span><br><span class="line">        G[cellI] +=</span><br><span class="line">            w</span><br><span class="line">           *(nutw[faceI] + nuw[faceI])</span><br><span class="line">           *magGradUw[faceI]</span><br><span class="line">           *Cmu25*<span class="built_in">sqrt</span>(k[cellI])</span><br><span class="line">           /(kappa_*y[faceI]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>calculate</code> 函数中进行的是实际的计算过程，主要是更新了临近壁面网格的 <code>epsilon</code> 和 <code>G</code> 的值，计算公式如下：<br>$$<br>\varepsilon_c = \frac{1}{N} \sum_{f=i}^{N}\left( \frac{c_\mu^{3/4} k_C^{3/2}}{\kappa y_i}\right) \\<br>\text{相当于} \quad \quad \quad<br>\varepsilon ^+ = \frac{1}{\kappa y^+} \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad<br>$$</p>
<p>$$<br>G_c = \frac{1}{N} \sum_{f=i}^{N}\left( \frac{(\nu + \nu_t)\cdot |\tfrac{U_i-U_c}{d}|\cdot c_\mu^{1/4} k_C^{1/2}}{\kappa y_i}\right)<br>$$<br>这里的 <code>Uw.snGrad()</code> 是 <code>fvPatchFields&lt;Type&gt;</code> 类的成员函数：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class <span class="constant">Type&gt;</span></span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:tmp&lt;Foam</span><span class="symbol">:</span><span class="symbol">:Field&lt;Type&gt;</span> &gt; <span class="constant">Foam:</span><span class="symbol">:fvPatchField&lt;Type&gt;</span><span class="symbol">:</span><span class="symbol">:snGrad</span>() const</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">return</span> patch<span class="constant">_</span>.deltaCoeffs()*(*this - patchInternalField());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>公式中下标 <code>c</code> 表示临近边界的网格， <code>i</code> 表示网格 <code>c</code> 包含的某个边界面元。<code>y</code> 和 <code>d</code> 都表示边界面元所属网格中心到该面元的垂直距离。 </p>
<p>还有一个重要的函数， <code>manipulateMatrix</code><br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void epsilonWallFunctionFvPatchScalarField::manipulateMatrix</span><br><span class="line">(</span><br><span class="line">    fvMatrix&lt;<span class="keyword">scalar</span>&gt;&amp; <span class="literal">matrix</span></span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (manipulatedMatrix())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">matrix</span>.setValues(patch().faceCells(), patchInternalField());</span><br><span class="line"></span><br><span class="line">    fvPatchField&lt;<span class="keyword">scalar</span>&gt;::manipulateMatrix(<span class="keyword">matrix</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数的功能是修改 matrix 中的值，将当前 patch 每一个面所属网格的值更新到 matrix 中，参考<a href="http://www.cfd-online.com/Forums/openfoam-solving/132703-boundarymanipulate.html" target="_blank" rel="external">这个帖子</a>。</p>
<p>如果不是使用的低雷诺数湍流模型，则 $\varepsilon$ 应该使用这个边界条件。理论上，边界第一层网格应该设置在对数区。什么是低雷诺数湍流模型呢？<a href="http://www.cfd-online.com/Forums/openfoam/125473-low-reynolds-turbulence-models.html" target="_blank" rel="external">这篇帖子</a>的三楼有精彩的解释。</p>
<ul>
<li>(2). epsilonLowReWallFunction</li>
</ul>
<p><code>epsilonLowReWallFunction</code> 继承自 <code>epsilonWallFunction</code> ，在此基础上，增加了一个成员函数 <code>yPlusLam</code>，并重新定义了 <code>calculate</code> 函数<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">scalar</span> epsilonLowReWallFunctionFvPatchScalarField::yPlusLam</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">scalar</span> <span class="keyword">kappa</span>,</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">scalar</span> <span class="literal">E</span></span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">scalar</span> ypl = 11.0;</span><br><span class="line">    <span class="keyword">for</span> (int i=0; i&lt;10; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ypl = <span class="literal">log</span>(<span class="literal">max</span>(<span class="keyword">E</span>*ypl, 1))/<span class="keyword">kappa</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ypl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个跟 <code>kLowReWallFunction</code> 里是一样的，不再赘述。<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">void epsilonLowReWallFunctionFvPatchScalarField::calculate</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> turbulenceModel&amp; turbulence,</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">List</span>&lt;<span class="keyword">scalar</span>&gt;&amp; cornerWeights,</span><br><span class="line">    <span class="keyword">const</span> fvPatch&amp; patch,</span><br><span class="line">    scalarField&amp; <span class="keyword">G</span>,</span><br><span class="line">    scalarField&amp; epsilon</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">label</span> patchI = patch.<span class="literal">index</span>();</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; y = turbulence.<span class="literal">y</span>()[patchI];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">scalar</span> Cmu25 = pow025(Cmu_);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">scalar</span> Cmu75 = pow(Cmu_, 0.75);</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tk = turbulence.k();</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; k = tk();</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tnu = turbulence.nu();</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; nuw = tnu().boundaryField()[patchI];</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tnut = turbulence.nut();</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; nut = tnut();</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; nutw = nut.boundaryField()[patchI];</span><br><span class="line">    <span class="keyword">const</span> fvPatchVectorField&amp; Uw = turbulence.<span class="keyword">U</span>().boundaryField()[patchI];</span><br><span class="line">    <span class="keyword">const</span> scalarField magGradUw(mag(Uw.snGrad()));</span><br><span class="line">    </span><br><span class="line"><span class="comment">// Set epsilon and G</span></span><br><span class="line">    forAll(nutw, faceI)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">label</span> cellI = patch.faceCells()[faceI];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">scalar</span> yPlus = Cmu25*<span class="literal">sqrt</span>(k[cellI])*y[faceI]/nuw[faceI];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">scalar</span> w = cornerWeights[faceI];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (yPlus &gt; yPlusLam_)</span><br><span class="line">        &#123;</span><br><span class="line">            epsilon[cellI] = w*Cmu75*pow(k[cellI], 1.5)/(kappa_*y[faceI]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            epsilon[cellI] = w*2.0*k[cellI]*nuw[faceI]/sqr(y[faceI]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">G</span>[cellI] =</span><br><span class="line">            <span class="literal">w</span></span><br><span class="line"><span class="comment">           *(nutw[faceI] + nuw[faceI])</span></span><br><span class="line"><span class="comment">           *magGradUw[faceI]</span></span><br><span class="line"><span class="comment">           *Cmu25*sqrt(k[cellI])</span></span><br><span class="line">           /(kappa_*y[faceI]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里需要根据 <code>yPlus</code> 和 <code>yPlusLam_</code> 的相对大小来选择不同的计算方式。只是，上面这段来自 OpenFOAM-2.3.1 的代码是有问题的！在OpenFOAM-3.0.1 中已经修复成如下<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="atom">forAll</span>(<span class="atom">nutw</span>, <span class="atom">facei</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="atom">label</span> <span class="atom">celli</span> = <span class="atom">patch</span>.<span class="atom">faceCells</span>()[<span class="atom">facei</span>];</span><br><span class="line"></span><br><span class="line">        <span class="atom">scalar</span> <span class="atom">yPlus</span> = <span class="name">Cmu25</span>*<span class="atom">sqrt</span>(<span class="atom">k</span>[<span class="atom">celli</span>])*<span class="atom">y</span>[<span class="atom">facei</span>]/<span class="atom">nuw</span>[<span class="atom">facei</span>];</span><br><span class="line"></span><br><span class="line">        <span class="atom">scalar</span> <span class="atom">w</span> = <span class="atom">cornerWeights</span>[<span class="atom">facei</span>];</span><br><span class="line"></span><br><span class="line">        <span class="atom">if</span> (<span class="atom">yPlus</span> &gt; <span class="atom">yPlusLam_</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="atom">epsilon0</span>[<span class="atom">celli</span>] += <span class="atom">w</span>*<span class="name">Cmu75</span>*<span class="atom">pow</span>(<span class="atom">k</span>[<span class="atom">celli</span>], <span class="number">1.5</span>)/(<span class="atom">kappa_</span>*<span class="atom">y</span>[<span class="atom">facei</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="name">G0</span>[<span class="atom">celli</span>] +=</span><br><span class="line">                <span class="atom">w</span></span><br><span class="line">               *(<span class="atom">nutw</span>[<span class="atom">facei</span>] + <span class="atom">nuw</span>[<span class="atom">facei</span>])</span><br><span class="line">               *<span class="atom">magGradUw</span>[<span class="atom">facei</span>]</span><br><span class="line">               *<span class="name">Cmu25</span>*<span class="atom">sqrt</span>(<span class="atom">k</span>[<span class="atom">celli</span>])</span><br><span class="line">               /(<span class="atom">kappa_</span>*<span class="atom">y</span>[<span class="atom">facei</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="atom">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="atom">epsilon0</span>[<span class="atom">celli</span>] += <span class="atom">w</span>*<span class="number">2.0</span>*<span class="atom">k</span>[<span class="atom">celli</span>]*<span class="atom">nuw</span>[<span class="atom">facei</span>]/<span class="atom">sqr</span>(<span class="atom">y</span>[<span class="atom">facei</span>]);</span><br><span class="line">            <span class="name">G0</span>[<span class="atom">celli</span>] += <span class="name">G</span>[<span class="atom">celli</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>yPlus &gt; yPlusLam_</code> 时，与 <code>epsilonWallFunction</code> 是一样的；<br><code>yPlus &lt; yPlusLam_</code> 时<br>$$<br>\varepsilon_c = \frac{1}{N} \sum_{f=i}^{N}\left( \frac{2\cdot k_C \nu_i}{y^2_i}\right)<br>$$<br>这个公式等价于<br>$$<br>\varepsilon ^+ = 2\frac{k^+}{(y^+)^2}<br>$$</p>
<p><code>G</code> 则取在湍流模型中定义的值，不作修改。 不过，这里 <code>G0[celli] += G[celli]</code> 意味着假设有一个网格有两个边界面，则这个网格的中计算得到的 <code>G0</code> ，将是在湍流模型中定义的该网格中的 G 值的 2 倍，即认为每一个边界面对都该网格内的湍动能生成有贡献。</p>
<p>这个边界是给低雷诺数的 $k-\varepsilon$ 模型以及 $v^2\text{-}f$ 模型使用的。用 OpenFOAM-3.0 以下版本的注意了，这些版本的 <code>epsilonLowReWallFunction</code> 有问题，<strong>一定不要忘了修正一下上面提到的那个bug </strong>！</p>
<h5 id="4-_$\omega$_的壁面函数">4. $\omega$ 的壁面函数</h5><p>OpenFOAM 中只提供了一个 <code>omegaWallFunction</code>，这个壁面函数，属于一种自动壁面函数，能自动地根据 $y^+$ 的值来在粘性层和对数层切换，过渡层则采用粘性层和对数层混合的结果。<br><code>omegaWallFunction</code> 与 <code>epsilonWallFunction</code> 类似，也是需要计算 $\omega$ 和 $P_k$ 在临近边界网格里的值，因此也需要考虑一个网格包含两个以上边界面的情况。具体处理方法跟 <code>epsilonWallFunction</code> 是一样的 ，所以这里就不重复了，只看具体的计算 $\omega$ 和 $P_k$ 的公式<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">void omegaWallFunctionFvPatchScalarField::calculate</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> turbulenceModel&amp; turbulence,</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">List</span>&lt;<span class="keyword">scalar</span>&gt;&amp; cornerWeights,</span><br><span class="line">    <span class="keyword">const</span> fvPatch&amp; patch,</span><br><span class="line">    scalarField&amp; <span class="keyword">G</span>,</span><br><span class="line">    scalarField&amp; omega</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">label</span> patchI = patch.<span class="literal">index</span>();</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; y = turbulence.<span class="literal">y</span>()[patchI];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">scalar</span> Cmu25 = pow025(Cmu_);</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tk = turbulence.k();</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; k = tk();</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tnu = turbulence.nu();</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; nuw = tnu().boundaryField()[patchI];</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tnut = turbulence.nut();</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; nut = tnut();</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; nutw = nut.boundaryField()[patchI];</span><br><span class="line">    <span class="keyword">const</span> fvPatchVectorField&amp; Uw = turbulence.<span class="keyword">U</span>().boundaryField()[patchI];</span><br><span class="line">    <span class="keyword">const</span> scalarField magGradUw(mag(Uw.snGrad()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set omega and G</span></span><br><span class="line">    forAll(nutw, faceI)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">label</span> cellI = patch.faceCells()[faceI];</span><br><span class="line">        <span class="keyword">scalar</span> w = cornerWeights[faceI];</span><br><span class="line">        <span class="keyword">scalar</span> omegaVis = 6.0*nuw[faceI]/(beta1_*sqr(y[faceI]));</span><br><span class="line">        <span class="keyword">scalar</span> omegaLog = <span class="literal">sqrt</span>(k[cellI])/(Cmu25*kappa_*y[faceI]);</span><br><span class="line">        omega[cellI] += w*<span class="literal">sqrt</span>(sqr(omegaVis) + sqr(omegaLog));</span><br><span class="line">        <span class="keyword">G</span>[cellI] +=</span><br><span class="line">            <span class="literal">w</span></span><br><span class="line"><span class="comment">           *(nutw[faceI] + nuw[faceI])</span></span><br><span class="line"><span class="comment">           *magGradUw[faceI]</span></span><br><span class="line"><span class="comment">           *Cmu25*sqrt(k[cellI])</span></span><br><span class="line">           /(kappa_*y[faceI]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里， <code>omegaVis</code> 和 <code>omegaLog</code> 分别指的是在假定第一层网格位于粘性底层和对数层时得到的 <code>omega</code> 的解析解<br>$$<br>\omega_{Vis} = \frac{6.0\nu}{\beta_1y^2} \<br>\omega_{Log} = \frac{k_C^{1/2}}{C_\mu^{1/4}\kappa y}<br>$$<br>然后，将 $\omega_{Vis}$ 和 $\omega_{Log}$ 用一个函数混合起来，就得到了<br>$$<br>\omega = \sqrt{\omega_{Vis}^2 + \omega_{Log}^2}<br>$$<br>只是，这里的湍动能生成项，却似乎并没有使用混合的方法，而是用的基于对数律的公式：<br>$$<br>G = \frac{(\nu + \nu_t)\cdot |\frac{U_c-U_w}{d}|\cdot C_\mu^{1/4}k_C^{1/2}}{\kappa y}<br>$$</p>
<p>$omega$ 方程是能直接积分到壁面，所以，如果使用基于 $\omega$ 的湍流模型，$\omega$ 变量直接使用这个边界条件就可以了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这篇来看看计算湍动能 $\varepsilon$  和 $\omega$ 的壁面函数。</p>]]>
    
    </summary>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="wall functions" scheme="http://xiaopingqiu.github.io/tags/wall-functions/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenFOAM 中的壁面函数（二）]]></title>
    <link href="http://xiaopingqiu.github.io/2016/04/25/wallFunctions2/"/>
    <id>http://xiaopingqiu.github.io/2016/04/25/wallFunctions2/</id>
    <published>2016-04-24T16:43:29.000Z</published>
    <updated>2016-04-25T02:49:07.183Z</updated>
    <content type="html"><![CDATA[<p>这篇来看看计算湍动能 $k$ 的壁面函数。</p>
<a id="more"></a>
<h5 id="2-_湍流动能_$k$_的壁面函数">2. 湍流动能 $k$ 的壁面函数</h5><p>OpenFOAM 中提供了两种 $k$ 的壁面函数， <code>kqRWallFunction</code> 和 <code>kLowReWallFunction</code> 。</p>
<ul>
<li><p><code>kqRWallFunction</code><br>其实就是 <code>zeroGradient</code> ，无需多言。除非使用 $v^2\text{-}f$ 模型，一般情况下 $k$ 应该使用这个边界条件。</p>
</li>
<li><p><code>kLowReWallFunction</code><br>这个壁面函数应该是可以用于低雷诺数模型的。该壁面函数继承自 <code>fixedValue</code> ：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> kLowReWallFunctionFvPatchScalarField</span><br><span class="line">:</span><br><span class="line">    public fixedValueFvPatchField&lt;<span class="keyword">scalar</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">protected:</span><br><span class="line">       <span class="comment">//- Cmu coefficient</span></span><br><span class="line">        <span class="keyword">scalar</span> Cmu_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Von Karman constant</span></span><br><span class="line">        <span class="keyword">scalar</span> kappa_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- E coefficient</span></span><br><span class="line">        <span class="keyword">scalar</span> E_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Ceps2 coefficient</span></span><br><span class="line">        <span class="keyword">scalar</span> Ceps2_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Y+ at the edge of the laminar sublayer</span></span><br><span class="line">        <span class="keyword">scalar</span> yPlusLam_;</span><br><span class="line">        ......</span><br><span class="line">        </span><br><span class="line">kLowReWallFunctionFvPatchScalarField::kLowReWallFunctionFvPatchScalarField</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> fvPatch&amp; p,</span><br><span class="line">    <span class="keyword">const</span> DimensionedField&lt;<span class="keyword">scalar</span>, volMesh&gt;&amp; <span class="keyword">iF</span>,</span><br><span class="line">    <span class="keyword">const</span> dictionary&amp; dict</span><br><span class="line">)</span><br><span class="line">:</span><br><span class="line">    fixedValueFvPatchField&lt;<span class="keyword">scalar</span>&gt;(p, <span class="keyword">iF</span>, dict),</span><br><span class="line">    Cmu_(dict.lookupOrDefault&lt;<span class="keyword">scalar</span>&gt;(<span class="string">"Cmu"</span>, 0.09)),</span><br><span class="line">    kappa_(dict.lookupOrDefault&lt;<span class="keyword">scalar</span>&gt;(<span class="string">"kappa"</span>, 0.41)),</span><br><span class="line">    E_(dict.lookupOrDefault&lt;<span class="keyword">scalar</span>&gt;(<span class="string">"E"</span>, 9.8)),</span><br><span class="line">    Ceps2_(dict.lookupOrDefault&lt;<span class="keyword">scalar</span>&gt;(<span class="string">"Ceps2"</span>, 1.9)),</span><br><span class="line">    yPlusLam_(yPlusLam(kappa_, E_))</span><br><span class="line">    &#123;</span><br><span class="line">        checkType();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>核心的函数是以下两个：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">scalar kLowReWallFunctionFvPatchScalarField::yPlusLam</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> scalar kappa,</span><br><span class="line">    <span class="keyword">const</span> scalar E</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    scalar ypl = <span class="number">11.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ypl = <span class="built_in">log</span>(max(E*ypl, <span class="number">1</span>))/kappa;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ypl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> kLowReWallFunctionFvPatchScalarField::updateCoeffs()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (updated())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> label patchI = patch().index();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> turbulenceModel&amp; turbulence =</span><br><span class="line">        db().lookupObject&lt;turbulenceModel&gt;(<span class="string">"turbulenceModel"</span>);</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; y = turbulence.y()[patchI];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tk = turbulence.k();</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; k = tk();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tnu = turbulence.nu();</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; nuw = tnu().boundaryField()[patchI];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> scalar Cmu25 = pow025(Cmu_);</span><br><span class="line"></span><br><span class="line">    scalarField&amp; kw = *<span class="keyword">this</span>; <span class="comment">// 更新 kw 相当于更新壁面上的 k 值。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set k wall values</span></span><br><span class="line">    forAll(kw, faceI)</span><br><span class="line">    &#123;</span><br><span class="line">        label faceCellI = patch().faceCells()[faceI];</span><br><span class="line"></span><br><span class="line">        scalar uTau = Cmu25*<span class="built_in">sqrt</span>(k[faceCellI]);</span><br><span class="line"></span><br><span class="line">        scalar yPlus = uTau*y[faceI]/nuw[faceI];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (yPlus &gt; yPlusLam_)</span><br><span class="line">        &#123;</span><br><span class="line">            scalar Ck = -<span class="number">0.416</span>;</span><br><span class="line">            scalar Bk = <span class="number">8.366</span>;</span><br><span class="line">            kw[faceI] = Ck/kappa_*<span class="built_in">log</span>(yPlus) + Bk;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            scalar C = <span class="number">11.0</span>;</span><br><span class="line">            scalar Cf = (<span class="number">1.0</span>/sqr(yPlus + C) + <span class="number">2.0</span>*yPlus/pow3(C) - <span class="number">1.0</span>/sqr(C));</span><br><span class="line">            kw[faceI] = <span class="number">2400.0</span>/sqr(Ceps2_)*Cf;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        kw[faceI] *= sqr(uTau);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fixedValueFvPatchField&lt;scalar&gt;::updateCoeffs();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO: perform averaging for cells sharing more than one boundary face</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>先在函数里计算 <code>ypl</code> 的值， <code>updateCoeffs</code> 函数里根据 <code>yPlus</code> 与这个 <code>ypl</code> 的值来相对大小而采取不同的方法来计算壁面上的 $k_w$。 <code>ypl</code> 的计算是一个迭代过程<br>$$<br>ypl = \frac{\log(\max(E*ypl,1.0))}{\kappa}<br>$$<br>初始值为 <code>ypl = 11.0</code>，迭代10次，最终结果应该是 <code>ypl = 11.5301073043272</code>。<br>$y^+$ 定义为：<br>$$<br>u_\tau = C_\mu^{1/4 }\sqrt{k_c} \<br>y^+ = \frac{u_\tau \cdot y}{\nu_w}<br>$$<br>壁面上的k计算方法如下：如果 $y^+ &gt; ypl$，则<br>$$<br>k^+ _w = \frac{C_k}{\kappa}\ln(y^+) + B_k<br>$$<br>否则<br>$$<br>k^+ _w = \frac{2400}{C_{eps2}^2}\cdot \left[ \frac{1}{(y^+ + C)^2} + \frac{2y^+}{C^3} - \frac{1}{C^2}\right ]<br>$$<br>最终，壁面上的值为 $k_w=k^+ _w u_\tau ^2 =k^+ _w C_\mu^{1/2}k_c$ 。<br>以上公式中，下标 $c$ 表示壁面单元所述网格的值，下标 $w$ 表示当前壁面上的值。<br>这个壁面函数参考文献 “Kalitzin, G., Medic, G., Iaccarino, G., Durbin, P., 2005. Near-wall behavior of RANS turbulence models and implications for wall functions. J. Comput. Phys. 204, 265–291. doi:10.1016/j.jcp.2004.10.018”，是为 $v^2\text{-}f$ 模型设计的。 </p>
<h5 id="$v^2$_和_$f$_的壁面函数">$v^2$ 和 $f$ 的壁面函数</h5><p>上面提到了 $v^2\text{-}f$ 模型，所以这里顺便来看看$v^2$ 和 $f$ 的壁面函数。这里参考的也是上面提到的那篇参考文献。</p>
<ul>
<li>$v^2$ 的壁函数<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">forAll(v2, faceI)</span><br><span class="line">    &#123;</span><br><span class="line">        label faceCellI = patch().faceCells()[faceI];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">scalar</span> uTau = Cmu25*<span class="keyword">sqrt</span>(k[faceCellI]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">scalar</span> yPlus = uTau*<span class="keyword">y</span>[faceI]/nuw[faceI];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (yPlus &gt; yPlusLam<span class="number">_</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">scalar</span> Cv2 = <span class="number">0</span>.<span class="number">193</span>;</span><br><span class="line">            <span class="keyword">scalar</span> Bv2 = -<span class="number">0</span>.<span class="number">94</span>;</span><br><span class="line">            v2[faceI] = Cv2/kappa<span class="number">_</span>*<span class="keyword">log</span>(yPlus) + Bv2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">scalar</span> Cv2 = <span class="number">0</span>.<span class="number">193</span>;</span><br><span class="line">            v2[faceI] = Cv2*pow4(yPlus);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        v2[faceI] *= <span class="keyword">s</span><span class="string">qr(uTau)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fixedValueFvPatchField&lt;<span class="keyword">scalar</span>&gt;::updateCoeffs();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><code>yPlus &gt; yPlusLam_</code> 时，<br>$$<br>v^2 = u_\tau^2 \cdot \left[ \frac{C_{v2}}{\kappa}\ln(y^+) + B_{v2} \right]<br>$$<br>与文献中的无量纲形式 $(\overline{v^2})^{^+} = \frac{C_{v2}}{\kappa}\ln(y^+) + B_{v2} $ 一致。</p>
<p><code>yPlus &lt; yPlusLam\_</code> 时，<br>$$<br>v^2 = u_\tau^2 \cdot C_{v2}(y^+)^2<br>$$<br>与无量纲形式 $(\overline{v^2})^{^+} = C_{v2}(y^+)^2$ 一致。</p>
<ul>
<li>$f$ 的壁函数<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">forAll(f, faceI)</span><br><span class="line">    &#123;</span><br><span class="line">        label faceCellI = patch().faceCells()[faceI];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">scalar</span> uTau = Cmu25*<span class="keyword">sqrt</span>(k[faceCellI]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">scalar</span> yPlus = uTau*<span class="keyword">y</span>[faceI]/nuw[faceI];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (yPlus &gt; yPlusLam<span class="number">_</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">scalar</span> N = <span class="number">6.0</span>;</span><br><span class="line">            <span class="keyword">scalar</span> v2c = v2[faceCellI];</span><br><span class="line">            <span class="keyword">scalar</span> epsc = epsilon[faceCellI];</span><br><span class="line">            <span class="keyword">scalar</span> kc = k[faceCellI];</span><br><span class="line"></span><br><span class="line">            f[faceI] = N*v2c*epsc/(<span class="keyword">s</span><span class="string">qr(kc)</span> + ROOTVSMALL);</span><br><span class="line">            f[faceI] /= <span class="keyword">s</span><span class="string">qr(uTau)</span> + ROOTVSMALL;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            f[faceI] = <span class="number">0</span>.<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><code>yPlus &gt; yPlusLam_</code> 时，<br>$$<br>f = \frac{N \cdot v^2\cdot \varepsilon}{k^2 u_\tau^2}<br>$$<br>这似乎与文献中的无量纲形式<br>$$<br>f^+ = N \frac{(\overline{v^2})^{^+}}{(k^+)^2}\varepsilon^+<br>$$<br>不一致！是 bug 还是我推导出错了？存疑…</p>
<p><code>yPlus &lt; yPlusLam_</code> 时，文献给出的公式是<br>$$<br>f^+ = \frac{-4(6-N)(\overline{v^2})^{^+}}{\varepsilon^+ (y^+)^4}<br>$$<br>当 <code>N=6</code> 时，可以得到 $f^+ = 0$ 。</p>
<p>按理说，$v^2$ 和 $f$ 应该跟 $\varepsilon$ 和 $\omega$ 那样（见后文），计算第一层网格内的值，并且考虑一个网格有多个边界面的情形。OpenFOAM 目前计算的是每一个边界面元上的值，不知道这两种方式对结果有多大影响。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这篇来看看计算湍动能 $k$ 的壁面函数。</p>]]>
    
    </summary>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="wall functions" scheme="http://xiaopingqiu.github.io/tags/wall-functions/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenFOAM 中的壁面函数（一）]]></title>
    <link href="http://xiaopingqiu.github.io/2016/04/25/wallFunctions1/"/>
    <id>http://xiaopingqiu.github.io/2016/04/25/wallFunctions1/</id>
    <published>2016-04-24T16:36:27.000Z</published>
    <updated>2016-04-26T15:12:44.864Z</updated>
    <content type="html"><![CDATA[<p>本系列来看看 OpenFOAM 中的壁面函数。壁面函数的本质，是边界条件。这里主要来看看壁面函数的基本原理，OpenFOAM 中实现了的壁面函数，以及选择壁面函数的一些参考依据。</p>
<a id="more"></a>
<h5 id="1-_壁面函数的基本原理">1. 壁面函数的基本原理</h5><p>湍流模拟中，需要对近壁区域进行处理。一般来讲，壁面处理方法包含两类，一类是使用很细的网格，使靠近壁面的第一层网格在粘性层内（$y^+ <1$），然后里可以直接解析到粘性层的低雷诺湍流模型；另一类，不直接解析粘性层，而是将第一层网格设置在对数区（$y^+> 30$），然后用经验公式来将粘性层和对数区关联起来。下图是一个典型的壁面附近的 $U^+ \text{-} y^+$ 关系图。<br><img src="/image/wallFunctions/Law_of_the_wall.png" alt="壁面律"><br>图片来自 <a href="https://en.wikipedia.org/wiki/Law_of_the_wall" target="_blank" rel="external">Wikipedia:Law of the wall </a>。<br>在粘性层，满足如下关系<br>$$<br>u^+ = y^+<br>$$<br>而在对数区，则满足<br>$$<br>U^+ = \frac{1}{\kappa}\ln(Ey^+)<br>$$<br>其中 $U^+ = U/u_\tau$， $y^+ = yu_\tau/\nu$， $u_\tau = \sqrt{\tau_w/\rho}$，$\kappa\approx 0.41$，$E \approx 9.8$，$y$ 表示与壁面的距离。</1$），然后里可以直接解析到粘性层的低雷诺湍流模型；另一类，不直接解析粘性层，而是将第一层网格设置在对数区（$y^+></p>
<p>本篇以标准壁面函数法来讨论一下壁面函数方法的基本原理，以及壁面函数在 OpenFOAM 中的实现。下面的讨论，先局限在 $k-\varepsilon$ 模型，且第一层网格在对数区的情形。<br>先来看一下壁面函数方法需要解决什么问题。<br>有限体积方法中，扩散项的离散可以表示如下：<br>$$<br>\nabla \cdot (\nu \nabla U) = \sum_f \left [\nu_f \cdot (\nabla U)_f \right]<br>$$<br>当 $f$ 表示的是壁面边界单元时，这时就需要知道在壁面上的速度梯度 $(\nabla U)_f$。壁面上一般对速度 $U$ 采用无滑移条件，如何得到正确的壁面速度梯度，这就是一个问题。这个问题有两个解决思路，一是通过实验或者 DNS 模拟等，得到一条连续的 $U-y$ 曲线，然后从这个曲线求壁面上的导数 $dU/dy$ 来得到壁面上的速度梯度；还有一种思路是，由于最终需要得到的是正确的 $\nu_f \cdot (\nabla U)_f$ ，即壁面上的剪应力，虽然<br>$$<br>\tau_w = \nu \cdot \frac{\partial U}{\partial n}\left. \right|_w \neq \nu \frac{U_p-U_w}{y}<br>$$<br>其中 $U_p$ 表示第一层网格中心的速度，$U_w$ 表示壁面上的速度。<br>但是，可以构造一个壁面上的有效粘度 $\nu_{eff}$，以使下式成立<br>$$<br>\tau_w = \nu \cdot  \frac{\partial U}{\partial n} \left. \right |_w = \nu_{eff} \frac{U_p-U_w}{y} = (\nu + \nu_t ) \cdot \frac{U_p-U_w}{y}<br>$$</p>
<p>后一种解决方法的好处是，不需要修改动量方程，直接使用 $\frac{U_p-U_w}{y}$ 来代替 $\frac{\partial U}{\partial n} \left. \right |_w  $，然后通过设置合适的湍流粘度 $\nu_t$ 的边界条件来修正壁面应力 $\tau_w$。</p>
<p>另一方面，在对数区，$k^+$ 是常数<br>$$<br>k^+ = \frac{1}{\sqrt{C_\mu}} \\<br>$$<br>其中 $k^+ = k/u_\tau^2$。<br>由<br>$$<br>k^+ = \frac{1}{\sqrt{C_\mu}} = k/u_\tau^2<br>$$<br>得<br>$$<br>u_\tau = C_\mu^{1/4}k^{1/2}<br>$$<br>于是<br>$$<br>\tau_w = \rho u_\tau^2 = \rho u_\tau \cdot \frac{U}{U^+} = \frac{\rho u_\tau (U_p-U_w)}{\frac{1}{\kappa}\ln(Ey^+)}<br>$$<br>若令<br>$$<br>\nu_{eff} = \frac{u_\tau y}{\frac{1}{\kappa}\ln(Ey^+)}<br>$$<br>则<br>$$<br>\tau_w = \rho \nu_{eff}\cdot \frac{U_p-U_w}{y}<br>$$<br>这正是上文提到的第二种解决壁面速度问题的形式。<br>而<br>$$<br>\nu_{eff} = \frac{ u_\tau y}{\frac{1}{\kappa}\ln(Ey^+)} = \frac{ y^+ \nu}{\frac{1}{\kappa}\ln(Ey^+)} = \nu + \nu_{tw}<br>$$<br>于是得到壁面上的湍流粘度为<br>$$<br>\nu_{tw} = \nu \cdot \left(\frac{\kappa y^+}{\ln(Ey^+)} -1 \right)<br>$$</p>
<p>$y^+$ 可以通过不同的方式来得到，具体的计算方法，见后文的 <code>nutWallFunctions</code> 部分。</p>
<p>除了得到壁面上的等效湍流粘度，还需要计算靠近壁面第一层网格的湍动能生成和湍动能耗散项。</p>
<p>湍动能生成项计算如下：<br>$$<br>G \approx \tau_w\cdot \frac{\partial (U_p -U_w)}{\partial y}<br>$$<br>由速度的壁面律<br>$$<br>U^+ = \frac{U_p - U_w}{u_\tau} = \frac{1}{\kappa}\ln(Ey^+) = \frac{1}{\kappa} \ln(E\frac{yu_\tau}{\nu})<br>$$<br>注意，$G$ 求的是第一层网格内的值，所以，由<br>$$<br>U_p -U_w = \frac{u_\tau}{\kappa} \ln(E\frac{yu_\tau}{\nu})<br>$$<br>可以求得第一层网格内的梯度<br>$$<br>\frac{\partial (U_p -U_w)}{\partial y} \left. \right|_p = \frac{u_\tau}{\kappa y_p}<br>$$<br>于是<br>$$<br>G = \tau_w \cdot \frac{u_\tau}{\kappa y_p}<br>$$<br>注意，这里的 $\frac{U_p-U_w}{d}$，其实是速度在壁面法向方向的梯度的近似值，这一点见上文 $\nu_t$ 的边界条件部分。</p>
<p>再来看 $\varepsilon$，$\varepsilon$ 的计算基于第一层网格内的湍动生成与湍动能耗散项守恒的假设，即<br>$$<br> \rho \varepsilon_p = G = \tau_w \cdot \frac{u_\tau}{\kappa y_p} =\rho\cdot \frac{u_\tau^3}{\kappa y_p}<br>$$<br>于是得<br>$$<br>\varepsilon_p = \frac{u_\tau^3}{\kappa y_p} = \frac{C_\mu^{3/4}k_p^{3/2}}{\kappa y_p}<br>$$</p>
<p>至于 $k$，一般认为当第一层网格位于对数区时，不需要在壁面上对 $k$ 加任何限制，用零梯度边界条件即可。</p>
<h5 id="2-_在_OpenFOAM_中的实现">2. 在 OpenFOAM 中的实现</h5><p>在 OpenFOAM 中，$k$，$\varepsilon$ 和 $\nu_t$ 分别有对应的边界条件可以选择，壁面函数的实现是在这些边界条件里进行的。具体地说， <code>k***WallFunction</code> 用于指定 $k$ 的边界条件， <code>epsilon***WallFunction</code> 用于计算 $\varepsilon$ 和 $G$ 在第一层网格内的值， <code>nut***WallFunction</code> 用来计算 $\nu_t$ 在壁面上的值。 还有就是一个要关心的问题是这些边界条件的调用顺序，这需要通过湍流模型的一段代码来说明，以 <code>kEpsilon</code> 为例：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> kEpsilon::correct()</span><br><span class="line">&#123;</span><br><span class="line">    RASModel::correct();</span><br><span class="line">    <span class="keyword">if</span> (!turbulence_)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    volScalarField G(GName(), nut_*<span class="number">2</span>*magSqr(symm(fvc::grad(U_))));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update epsilon and G at the wall</span></span><br><span class="line">    epsilon_.boundaryField().updateCoeffs();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dissipation equation</span></span><br><span class="line">    tmp&lt;fvScalarMatrix&gt; epsEqn</span><br><span class="line">    (</span><br><span class="line">        fvm::ddt(epsilon_)</span><br><span class="line">      + fvm::div(phi_, epsilon_)</span><br><span class="line">      - fvm::laplacian(DepsilonEff(), epsilon_)</span><br><span class="line">     ==</span><br><span class="line">        C1_*G*epsilon_/k_</span><br><span class="line">      - fvm::Sp(C2_*epsilon_/k_, epsilon_)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    epsEqn().relax();</span><br><span class="line">    epsEqn().boundaryManipulate(epsilon_.boundaryField());</span><br><span class="line"></span><br><span class="line">    solve(epsEqn);</span><br><span class="line">    bound(epsilon_, epsilonMin_);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Turbulent kinetic energy equation</span></span><br><span class="line">    tmp&lt;fvScalarMatrix&gt; kEqn</span><br><span class="line">    (</span><br><span class="line">        fvm::ddt(k_)</span><br><span class="line">      + fvm::div(phi_, k_)</span><br><span class="line">      - fvm::laplacian(DkEff(), k_)</span><br><span class="line">     ==</span><br><span class="line">        G</span><br><span class="line">      - fvm::Sp(epsilon_/k_, k_)</span><br><span class="line">    );</span><br><span class="line">    kEqn().relax();</span><br><span class="line">    solve(kEqn);</span><br><span class="line">    bound(k_, kMin_);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-calculate viscosity</span></span><br><span class="line">    nut_ = Cmu_*sqr(k_)/epsilon_;</span><br><span class="line">    nut_.correctBoundaryConditions();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上述代码，可以将湍流模型的具体计算过程归纳如下：</p>
<ol>
<li>计算湍动能生成项 $G$，并修正 $G$ 在第一层网格的值。修正是通过 <code>epsilon_.boundaryField().updateCoeffs();</code> 来实现的，这里调用 <code>epsilon</code> 的边界条件的 <code>updateCoeffs</code> 函数，实现的操作是修正 $G$ 和 $\varepsilon$ 在第一层网格的值。</li>
<li>利用更新的 $G$ 构建 <code>epsEqn</code>，然后修改 <code>epsEqn</code>（ <code>epsEqn().boundaryManipulate(epsilon_.boundaryField());</code> ），这样做的目的是保证在下一步 <code>solve(epsEqn)</code>的时候，<code>epsilonWallFunction</code> 类型的边界所属的网格的值不会变化，而是保持在 <code>epsilon_.boundaryField().updateCoeffs();</code> 这一步里设置的值（参考 <a href="http://www.cfd-online.com/Forums/openfoam-solving/132703-boundarymanipulate.html" target="_blank" rel="external">cfd-online 的这个帖子</a>）。</li>
<li>求解 <code>epsEqn</code>，得到更新的 $\varepsilon$ 场。</li>
<li>利用更新的 $\varepsilon$ 场构建并求解 <code>kEqn</code>，得到更新的 $k$ 场。</li>
<li>计算 $\nu_t$，并更新 $\nu_t$ 在边界上的值（<code>nut_.correctBoundaryConditions()</code>） </li>
</ol>
<p>至于具体的 $k$，$\varepsilon$，以及 $\nu_t$ 的边界条件的实现，见后文。 </p>
<p><strong>参考</strong></p>
<ol>
<li>The Finite Volume Method in Computational Fluid Dynamics An Advanced Introduction with OpenFOAM® and Matlab®</li>
<li><a href="http://www.slideshare.net/fumiyanozaki96/openfoam-36426892" target="_blank" rel="external">http://www.slideshare.net/fumiyanozaki96/openfoam-36426892</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>本系列来看看 OpenFOAM 中的壁面函数。壁面函数的本质，是边界条件。这里主要来看看壁面函数的基本原理，OpenFOAM 中实现了的壁面函数，以及选择壁面函数的一些参考依据。</p>]]>
    
    </summary>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="wall functions" scheme="http://xiaopingqiu.github.io/tags/wall-functions/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenFOAM-3.0 的湍流模型（四）]]></title>
    <link href="http://xiaopingqiu.github.io/2016/04/25/TurbulenceModel-30-macro/"/>
    <id>http://xiaopingqiu.github.io/2016/04/25/TurbulenceModel-30-macro/</id>
    <published>2016-04-24T16:11:08.000Z</published>
    <updated>2016-04-25T01:44:22.363Z</updated>
    <content type="html"><![CDATA[<p>最后来看一个小问题：OpenFOAM-3.0 中的湍流模型是怎么编译的。在这之前，湍流模型的编译很直观，将需要编译的湍流模型的代码的 <code>.C</code> 文件写到 <code>Make/files</code> 里就好了。可是，在 OpenFOAM-3.0 里，很多湍流模型代码的 <code>.C</code> 文件并没有写到 <code>Make/files</code> 里，而是在 <code>makeTurbulenceModels.C</code>里类似这样写<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "mykEpsilon.H"</span></span><br><span class="line">makeRASModel(mykEpsilon);</span><br></pre></td></tr></table></figure></p>
<p>然后在 <code>Make/files</code> 里写的是这个 <code>makeTurbulenceModels.C</code> 文件。为什么呢？</p>
<p>这里来分析一下这个问题。</p>
<a id="more"></a>
<p>这个问题，说起来也简单，不过我经过很多摸索从想明白。其实，这个问题用一个概念就可以解释清楚：条件编译。</p>
<p>条件编译常用于头文件，格式如下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//filename: kEpsilon.H</span></span><br><span class="line"><span class="preprocessor">#ifndef  kEpsilon_H</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span>  kEpsilon_H</span></span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>这样能避免头文件重复引用的导致变量或者类重复定义的问题，原因在于，第一次 <code>#include &quot;kEpsilon.H&quot;</code> 时，会触发 <code>#define  kEpsilon_H</code> 的操作，之后如果代码中再出现 <code>#include &quot;kEpsilon.H&quot;</code> 则  <code>#ifndef  kEpsilon_H</code> 将不再成立，所以， <code>#ifndef ... #endif</code> 之间的内容将不会再度被引入。</p>
<p>OpenFOAM 的模板类中，还常见的一种用法是<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#ifdef NoRepository</span></span><br><span class="line"><span class="preprocessor">#   <span class="keyword">include</span> "kEpsilon.C"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>这个怎么理解呢？ 本来也不难理解，无非就是如果定义了宏 <code>NoRepository</code> 则在头文件里将类的具体定义部分也引入到头文件里。问题是，翻遍 OpenFOAM 的 <code>src</code> 目录下的源码，也找不到 <code>NoRepository</code> 的定义。经过搜索，原来这个 <code>NoRepository</code> 是通过 g++ 的 <code>-D</code> 选项来定义的！在编译过程中，使用<br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -c -DNoRepository ...</span><br></pre></td></tr></table></figure></p>
<p>相当于进行了 <code>#define NoRepository 1</code> 的操作，所以， <code>#ifdef NoRepository</code> 这个条件是满足的。<br>OpenFOAM 中，编译选项的定义在 <code>wmake/rules</code> 下，具体的定义取决于你用的编译器，以 <code>linux64Gcc/c++</code> 为例<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">c++WARN     = -Wall -Wextra -Wno-unused-parameter -Wold-style-cast -Wnon-virtual-dtor</span><br><span class="line"></span><br><span class="line"><span class="constant">CC</span>          = g++ -m64</span><br><span class="line"></span><br><span class="line">include $(RULES)/c++$(WM_COMPILE_OPTION)</span><br><span class="line"></span><br><span class="line"><span class="constant">ptFLAGS</span>     = -DNoRepository -ftemplate-depth-100</span><br><span class="line"></span><br><span class="line">c++FLAGS    = $(GFLAGS) $(c++WARN) $(c++OPT) $(c++DBUG) $(ptFLAGS) $(LIB_HEADER_DIRS) -fPIC</span><br><span class="line"></span><br><span class="line"><span class="constant">Ctoo</span>        = <span class="variable">$(WM_SCHEDULER)</span> <span class="variable">$(CC)</span> <span class="variable">$(c++FLAGS)</span> -c $$SOURCE -o $@</span><br><span class="line"><span class="constant">cxxtoo</span>      = <span class="variable">$(Ctoo)</span></span><br><span class="line"><span class="constant">cctoo</span>       = <span class="variable">$(Ctoo)</span></span><br><span class="line"><span class="constant">cpptoo</span>      = <span class="variable">$(Ctoo)</span></span><br><span class="line"></span><br><span class="line"><span class="constant">LINK_LIBS</span>   = <span class="variable">$(c++DBUG)</span></span><br><span class="line"></span><br><span class="line"><span class="constant">LINKLIBSO</span>   = <span class="variable">$(CC)</span> <span class="variable">$(c++FLAGS)</span> -shared -Xlinker --add-needed -Xlinker --no-as-needed</span><br><span class="line"><span class="constant">LINKEXE</span>     = <span class="variable">$(CC)</span> <span class="variable">$(c++FLAGS)</span> -Xlinker --add-needed -Xlinker --no-as-needed</span><br></pre></td></tr></table></figure></p>
<p>可见这里的确是使用了 <code>-DNoRepository</code> 选项。</p>
<p>为什么要在头文件里 <code>#include &quot;kEpsilon.C&quot;</code> 呢？这就涉及到模板类的实例化的问题。<a href="http://www.codeproject.com/Articles/3515/How-To-Organize-Template-Source-Code" target="_blank" rel="external">这篇文章</a>详细地探讨了模板类实例化过程中会遇到的问题，以及解决的办法。简单地说，<strong>模板类不是一种类型，而是一种模板</strong>，模板类通过代入模板参数来实例化，以得到具体的类（这个具体的类就可以看作是一种“数据类型”了）。在示例化过程中，编译器不光需要模板类的声明部分，还需要知道模板类的成员函数的具体定义部分，所以，如果在进行模板类声明的地方只包含了模板类的声明部分（一般是头文件），那实例化就会失败，编译器会报类似“undefined reference to …” 的错误。<br><a href="http://www.cfd-online.com/Forums/openfoam-programming-development/90676-norepository.html" target="_blank" rel="external">cfd-online 上的这个帖子</a>也探讨了关于 <code>NoRepository</code> 的问题。</p>
<p>最后，<code>makeTurbulenceModels.C</code> 里的 <code>#include  &quot;kEpsilon.H&quot;</code>，其实相当于也 <code>#include &quot;kEpsilon.C&quot;</code>，而且，要注意<strong>这里 include 进来的是一个模板类，是用来建立实例化的模型的</strong>！实例化的过程，在 <code>makeRASModel(kEpsilon)</code> 里，详细的参考前一篇，看看这个宏函数的展开，就知道模型参数是怎么代入进去来得到实例化的湍流模型类的。 </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最后来看一个小问题：OpenFOAM-3.0 中的湍流模型是怎么编译的。在这之前，湍流模型的编译很直观，将需要编译的湍流模型的代码的 <code>.C</code> 文件写到 <code>Make/files</code> 里就好了。可是，在 OpenFOAM-3.0 里，很多湍流模型代码的 <code>.C</code> 文件并没有写到 <code>Make/files</code> 里，而是在 <code>makeTurbulenceModels.C</code>里类似这样写<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "mykEpsilon.H"</span></span><br><span class="line">makeRASModel(mykEpsilon);</span><br></pre></td></tr></table></figure></p>
<p>然后在 <code>Make/files</code> 里写的是这个 <code>makeTurbulenceModels.C</code> 文件。为什么呢？</p>
<p>这里来分析一下这个问题。</p>]]>
    
    </summary>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="turbulence model" scheme="http://xiaopingqiu.github.io/tags/turbulence-model/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenFOAM-3.0 的湍流模型（三）]]></title>
    <link href="http://xiaopingqiu.github.io/2016/04/24/TurbulenceModel-30-NewModels/"/>
    <id>http://xiaopingqiu.github.io/2016/04/24/TurbulenceModel-30-NewModels/</id>
    <published>2016-04-24T15:34:01.000Z</published>
    <updated>2016-04-25T02:07:48.763Z</updated>
    <content type="html"><![CDATA[<p>有了上一篇的基础，就很容易做到添加新的湍流模型了，这里分别给出对四类湍流模型增加新模型的方法。探索过程不详述了，仅给出结果。</p>
<a id="more"></a>
<h5 id="3-_添加新模型的方法。">3. 添加新模型的方法。</h5><p>添加湍流模型，关键的有两个，一是如果将新湍流模型添加到合适的 hashTable，以便能被求解器调用，另一个是 Make/files 和 Make/options 的写法以使湍流模型能被编译。</p>
<p>这里不给出具体湍流模型的代码，仅给出 Make 的写法，以及一个 <code>.C</code> 文件。编译湍流模型的时候，新建一个目录，将需要编译的湍流模型代码、这里给出的对应类型的 <code>.C</code> 文件和 Make 文件夹都拷贝到新建的目录，然后运行 <code>wmake libso</code> 即可。</p>
<h6 id="3-1_单相不可压缩湍流模型">3.1 单相不可压缩湍流模型</h6><ul>
<li>makeTuebulenceModels.C</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "IncompressibleTurbulenceModel.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "incompressible/transportModel/transportModel.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "addToRunTimeSelectionTable.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "makeTurbulenceModel.H"</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "RASModel.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "LESModel.H"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 宏函数定义</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> makeRASModel(Type)                                                     \</span><br><span class="line">    makeTemplatedTurbulenceModel                                               \</span><br><span class="line">    (transportModelIncompressibleTurbulenceModel, RAS, Type)</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> makeLESModel(Type)                                                     \</span><br><span class="line">    makeTemplatedTurbulenceModel                                               \</span><br><span class="line">    (transportModelIncompressibleTurbulenceModel, LES, Type)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------------------------------------------------- //</span></span><br><span class="line"><span class="comment">// RAS models</span></span><br><span class="line"><span class="comment">// -------------------------------------------------------------------------- //</span></span><br><span class="line"><span class="keyword">namespace</span> Foam</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> IncompressibleTurbulenceModel&lt;transportModel&gt; transportModelIncompressibleTurbulenceModel; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">typedef</span> RASModel&lt;transportModelIncompressibleTurbulenceModel&gt; RAStransportModelIncompressibleTurbulenceModel;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">typedef</span> LESModel&lt;transportModelIncompressibleTurbulenceModel&gt; LEStransportModelIncompressibleTurbulenceModel; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里说明一下，编译新的模型，最重要的是将作为模板类的通用湍流模型代入合适的模板参数以实例化，然后将实例化的模型添加到合适的　hashTable。</span></span><br><span class="line"><span class="comment">// 上面定义的几个别名，是为了下面将模型添加到 hashTable 而服务的，至于为什么要定义这几个别名，参考前一篇的 `makeBaseTurbulenceModel` 宏函数的展开部分。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "mykEpsilon.H"</span></span><br><span class="line">makeRASModel(mykEpsilon); <span class="comment">// 如前篇所属，这个宏函数，先对模板类进行了实例化，然后调用 `addToRunTimeSelectionTable` 宏函数，将实例化模型添加到 hashTable。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------------------------------------------------- //</span></span><br><span class="line"><span class="comment">// LES models</span></span><br><span class="line"><span class="comment">// -------------------------------------------------------------------------- //</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "mySmagorinsky.H"</span></span><br><span class="line">makeLESModel(mySmagorinsky);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Make/files</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">makeTuebulenceModels.C</span><br><span class="line"></span><br><span class="line"><span class="constant">LIB</span> = <span class="variable">$(FOAM_USER_LIBBIN)</span>/libTestincompressibleTurbulenceModels</span><br></pre></td></tr></table></figure>
</li>
<li><p>Make/options</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">EXE_INC = \</span><br><span class="line">    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/<span class="constant">TurbulenceModels</span>/turbulenceModels/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/<span class="constant">TurbulenceModels</span>/incompressible/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/transportModels \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/finiteVolume/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/meshTools/lnInclude \</span><br><span class="line"></span></span><br><span class="line">LIB_LIBS = \</span><br><span class="line">    -<span class="ruby">lincompressibleTransportModels \</span><br><span class="line"></span>    -<span class="ruby">lturbulenceModels \</span><br><span class="line"></span>    -<span class="ruby">lfiniteVolume \</span><br><span class="line"></span>    -<span class="ruby">lmeshTools</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h6 id="3-2_单相可压缩湍流模型">3.2 单相可压缩湍流模型</h6><ul>
<li><p>makeTurbulenceModels.C</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "CompressibleTurbulenceModel.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "compressibleTransportModel.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "fluidThermo.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "addToRunTimeSelectionTable.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "makeTurbulenceModel.H"</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "ThermalDiffusivity.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "EddyDiffusivity.H"</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "RASModel.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "LESModel.H"</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> makeRASModel(Type)                                                     \</span><br><span class="line">    makeTemplatedTurbulenceModel                                               \</span><br><span class="line">    (fluidThermoCompressibleTurbulenceModel, RAS, Type)</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> makeLESModel(Type)                                                     \</span><br><span class="line">    makeTemplatedTurbulenceModel                                               \</span><br><span class="line">    (fluidThermoCompressibleTurbulenceModel, LES, Type)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Foam</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> ThermalDiffusivity&lt;CompressibleTurbulenceModel&lt;fluidThermo&gt; &gt;  fluidThermoCompressibleTurbulenceModel;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> RASModel&lt;EddyDiffusivity&lt;fluidThermoCompressibleTurbulenceModel&gt; &gt;  RASfluidThermoCompressibleTurbulenceModel;       </span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> LESModel&lt;EddyDiffusivity&lt;fluidThermoCompressibleTurbulenceModel&gt; &gt;  LESfluidThermoCompressibleTurbulenceModel;       </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------------------------------------------------- //</span></span><br><span class="line"><span class="comment">// RAS models</span></span><br><span class="line"><span class="comment">// -------------------------------------------------------------------------- //</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "mykEpsilon.H"</span></span><br><span class="line">makeRASModel(mykEpsilon);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "mybuoyantKEpsilon.H"</span></span><br><span class="line">makeRASModel(mybuoyantKEpsilon);</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------------------------------------------------- //</span></span><br><span class="line"><span class="comment">// LES models</span></span><br><span class="line"><span class="comment">// -------------------------------------------------------------------------- //</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "mySmagorinsky.H"</span></span><br><span class="line">makeLESModel(mySmagorinsky);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Make/files</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">makeTurbulenceModels.C</span><br><span class="line"></span><br><span class="line"><span class="constant">LIB</span> = <span class="variable">$(FOAM_USER_LIBBIN)</span>/libTestcompressibleTurbulenceModels</span><br></pre></td></tr></table></figure>
</li>
<li><p>Make/options</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">EXE_INC = \</span><br><span class="line">    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/<span class="constant">TurbulenceModels</span>/compressible/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/<span class="constant">TurbulenceModels</span>/turbulenceModels/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/transportModels/compressible/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/thermophysicalModels/basic/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/thermophysicalModels/specie/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/thermophysicalModels/solidThermo/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/thermophysicalModels/solidSpecie/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/finiteVolume/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/meshTools/lnInclude \</span><br><span class="line"></span></span><br><span class="line">LIB_LIBS = \</span><br><span class="line">    -<span class="ruby">lcompressibleTransportModels \</span><br><span class="line"></span>    -<span class="ruby">lfluidThermophysicalModels \</span><br><span class="line"></span>    -<span class="ruby">lsolidThermo \</span><br><span class="line"></span>    -<span class="ruby">lsolidSpecie \</span><br><span class="line"></span>    -<span class="ruby">lturbulenceModels \</span><br><span class="line"></span>    -<span class="ruby">lspecie \</span><br><span class="line"></span>    -<span class="ruby">lfiniteVolume \</span><br><span class="line"></span>    -<span class="ruby">lmeshTools</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>注意，由于在 <code>TurbulenceModels/compressible/lnInclude</code> 和 <code>TurbulenceModels/turbulenceModels/lnInclude</code> 两个目录下，都存在 <code>makeTurbulenceModel.H</code> 头文件，内容是不一样的，这里需要 include 的是前者，所以在 <code>Make/options</code> 里， <code>TurbulenceModels/compressible/lnInclude</code> 一定要写在前面才能编译成功。</p>
<h6 id="3-3_多相不可压缩湍流模型">3.3 多相不可压缩湍流模型</h6><ul>
<li><p>DPMTurbulenceModels.C</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "PhaseIncompressibleTurbulenceModel.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "singlePhaseTransportModel.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "addToRunTimeSelectionTable.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "makeTurbulenceModel.H"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#include "laminar.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "turbulentTransportModel.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "LESModel.H"</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> makeRASModel(Type)                                                     \</span><br><span class="line">    makeTemplatedTurbulenceModel                                               \</span><br><span class="line">    (singlePhaseTransportModelPhaseIncompressibleTurbulenceModel, RAS, Type)</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> makeLESModel(Type)                                                     \</span><br><span class="line">    makeTemplatedTurbulenceModel                                               \</span><br><span class="line">    (singlePhaseTransportModelPhaseIncompressibleTurbulenceModel, LES, Type)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Foam</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> PhaseIncompressibleTurbulenceModel&lt;singlePhaseTransportModel&gt; singlePhaseTransportModelPhaseIncompressibleTurbulenceModel; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">typedef</span> RASModel&lt;singlePhaseTransportModelPhaseIncompressibleTurbulenceModel&gt; RASsinglePhaseTransportModelPhaseIncompressibleTurbulenceModel;      </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">typedef</span> LESModel&lt;singlePhaseTransportModelPhaseIncompressibleTurbulenceModel&gt; LESsinglePhaseTransportModelPhaseIncompressibleTurbulenceModel;      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "mykEpsilon.H"</span></span><br><span class="line">makeRASModel(mykEpsilon);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "mySmagorinsky.H"</span></span><br><span class="line">makeLESModel(mySmagorinsky);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Make/files</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DPMTurbulenceModels.C</span><br><span class="line"></span><br><span class="line"><span class="constant">LIB</span> = <span class="variable">$(FOAM_USER_LIBBIN)</span>/libTestDPMTurbulenceModels</span><br></pre></td></tr></table></figure>
</li>
<li><p>Make/options</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">EXE_INC = \</span><br><span class="line">    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/transportModels/compressible/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/thermophysicalModels/basic/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/transportModels \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/transportModels/incompressible/singlePhaseTransportModel \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/<span class="constant">TurbulenceModels</span>/turbulenceModels/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/<span class="constant">TurbulenceModels</span>/incompressible/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/<span class="constant">TurbulenceModels</span>/phaseIncompressible/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/finiteVolume/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/meshTools/lnInclude</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>注意，这里的湍流模型是给 <code>DPMFoam</code> 求解器用的，如果要给其他求解器写湍流模型，可能需要做些修改。</p>
<h6 id="3-4_多相可压缩湍流模型">3.4 多相可压缩湍流模型</h6><ul>
<li><p>phaseCompressibleTurbulenceModels.C</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "PhaseCompressibleTurbulenceModel.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "phaseModel.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "twoPhaseSystem.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "addToRunTimeSelectionTable.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "makeTurbulenceModel.H"</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "ThermalDiffusivity.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "EddyDiffusivity.H"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#include "laminar.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "RASModel.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "LESModel.H"</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> makeRASModel(Type)                                                     \</span><br><span class="line">    makeTemplatedTurbulenceModel                                               \</span><br><span class="line">    (phaseModelPhaseCompressibleTurbulenceModel, RAS, Type)</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> makeLESModel(Type)                                                     \</span><br><span class="line">    makeTemplatedTurbulenceModel                                               \</span><br><span class="line">    (phaseModelPhaseCompressibleTurbulenceModel, LES, Type)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Foam</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> ThermalDiffusivity&lt;PhaseCompressibleTurbulenceModel&lt;phaseModel&gt; &gt;  phaseModelPhaseCompressibleTurbulenceModel;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> RASModel&lt;EddyDiffusivity&lt;phaseModelPhaseCompressibleTurbulenceModel&gt; &gt;  RASphaseModelPhaseCompressibleTurbulenceModel;           </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">typedef</span> LESModel&lt;EddyDiffusivity&lt;phaseModelPhaseCompressibleTurbulenceModel&gt; &gt;   LESphaseModelPhaseCompressibleTurbulenceModel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "mykEpsilon.H"</span></span><br><span class="line">makeRASModel(mykEpsilon);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "mySmagorinsky.H"</span></span><br><span class="line">makeLESModel(mySmagorinsky);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "myphasePressureModel.H"</span></span><br><span class="line">makeTurbulenceModel</span><br><span class="line">(phaseModelPhaseCompressibleTurbulenceModel, RAS, myphasePressureModel);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Make/files</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">phaseCompressibleTurbulenceModels<span class="class">.C</span></span><br><span class="line">phasePressureModel/myphasePressureModel<span class="class">.C</span></span><br><span class="line"></span><br><span class="line">LIB = $(FOAM_USER_LIBBIN)/libTestphaseCompressibleTurbulenceModels</span><br></pre></td></tr></table></figure>
</li>
<li><p>Make/options</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">EXE_INC = \</span><br><span class="line">    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">WM_PROJECT_DIR</span>)/applications/solvers/multiphase/twoPhaseEulerFoam/twoPhaseSystem/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">WM_PROJECT_DIR</span>)/applications/solvers/multiphase/twoPhaseEulerFoam/interfacialModels/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/transportModels/compressible/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/thermophysicalModels/basic/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/transportModels/incompressible/transportModel \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/<span class="constant">TurbulenceModels</span>/compressible/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/<span class="constant">TurbulenceModels</span>/turbulenceModels/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/<span class="constant">TurbulenceModels</span>/phaseCompressible/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/finiteVolume/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/meshTools/lnInclude</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>注意，这里的湍流模型是给求解器 <code>twoPhaseEulerFoam</code> 用的，如果要给其他求解器开发湍流模型，可能需要做些修改。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>有了上一篇的基础，就很容易做到添加新的湍流模型了，这里分别给出对四类湍流模型增加新模型的方法。探索过程不详述了，仅给出结果。</p>]]>
    
    </summary>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="turbulence model" scheme="http://xiaopingqiu.github.io/tags/turbulence-model/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
</feed>