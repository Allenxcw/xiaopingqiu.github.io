<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Giskard's CFD Learning Tricks]]></title>
  <subtitle><![CDATA[CFD and Scientific Computing]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://xiaopingqiu.github.io/"/>
  <updated>2016-06-25T08:03:40.062Z</updated>
  <id>http://xiaopingqiu.github.io/</id>
  
  <author>
    <name><![CDATA[Giskard Q.]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[一个具体能量方程的解析]]></title>
    <link href="http://xiaopingqiu.github.io/2016/06/25/thermophysics4/"/>
    <id>http://xiaopingqiu.github.io/2016/06/25/thermophysics4/</id>
    <published>2016-06-25T07:48:02.000Z</published>
    <updated>2016-06-25T08:03:40.062Z</updated>
    <content type="html"><![CDATA[<p>本篇来看一个具体的能量方程，以 <code>twoPhaseEulerFoam</code> 的 <code>EEqn.H</code> 为例。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    volScalarField&amp; he1 = thermo1.he();</span><br><span class="line">    volScalarField&amp; he2 = thermo2.he();</span><br><span class="line"></span><br><span class="line">    <span class="function">volScalarField <span class="title">Cpv1</span><span class="params">("Cpv1", thermo1.Cpv()</span>)</span>;</span><br><span class="line">    <span class="function">volScalarField <span class="title">Cpv2</span><span class="params">("Cpv2", thermo2.Cpv()</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">volScalarField <span class="title">heatTransferCoeff</span><span class="params">(fluid.heatTransferCoeff()</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">fvScalarMatrix <span class="title">he1Eqn</span></span><br><span class="line">    <span class="params">(</span><br><span class="line">        fvm::ddt(alpha1, rho1, he1)</span> + fvm::<span class="title">div</span><span class="params">(alphaRhoPhi1, he1)</span></span><br><span class="line">      - fvm::<span class="title">Sp</span><span class="params">(contErr1, he1)</span></span><br><span class="line"></span><br><span class="line">      + fvc::<span class="title">ddt</span><span class="params">(alpha1, rho1, K1)</span> + fvc::<span class="title">div</span><span class="params">(alphaRhoPhi1, K1)</span></span><br><span class="line">      - contErr1*K1</span><br><span class="line">      + <span class="params">(</span><br><span class="line">            he1.name()</span> </span>== thermo1.phasePropertyName(<span class="string">"e"</span>)</span><br><span class="line">          ? fvc::ddt(alpha1)*p + fvc::div(alphaPhi1, p)</span><br><span class="line">          : -alpha1*dpdt</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">      - fvm::laplacian</span><br><span class="line">        (</span><br><span class="line">            fvc::interpolate(alpha1)</span><br><span class="line">           *fvc::interpolate(thermo1.alphaEff(phase1.turbulence().mut())),</span><br><span class="line">            he1</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    he1Eqn.relax();</span><br><span class="line"></span><br><span class="line">    he1Eqn -=</span><br><span class="line">    (</span><br><span class="line">        heatTransferCoeff*(thermo2.T() - thermo1.T())</span><br><span class="line">      + heatTransferCoeff*he1/Cpv1</span><br><span class="line">      - fvm::Sp(heatTransferCoeff/Cpv1, he1)</span><br><span class="line">      + fvOptions(alpha1, rho1, he1)</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<p>对应的能量方程为（忽略fvOptions）<br>$$<br>\alpha \rho \frac{\partial (\mathrm{he})}{\partial t} + \alpha \rho U\cdot \nabla(\mathrm{he}) + \alpha \rho \frac{\partial (\mathrm{K})}{\partial t} + \alpha \rho U\cdot \nabla\mathrm{K} + \\<br>\begin{cases}<br>p\cdot\dfrac{\partial \alpha}{\partial t} + \nabla \cdot (\alpha U p) , &amp; \mbox{ if } he.name == \mbox{“e”} \\<br>-\alpha \dfrac{\partial p}{\partial t}, &amp; \mbox{  if } he.name == \mbox{“h”}<br>\end{cases} \\<br>-\nabla \cdot \big(\alpha \cdot \alpha_{eff} \nabla (\mathrm{he}) \big) - \gamma(T_2 - T_1) = 0<br>$$</p>
<p>代码里剩下的两项，<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ heatTransferCoeff*he1/Cpv1</span><br><span class="line">- fvm::<span class="function"><span class="title">Sp</span><span class="params">(heatTransferCoeff/Cpv1, he1)</span></span></span><br></pre></td></tr></table></figure></p>
<p>含义暂不明。这两项，其实是同一个公式，只是前者是显示处理，后者用了隐式源项，估计是为了数值稳定性的目的而构建的。</p>
<p>前面提过，对于如下设置，<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">thermoType</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title">type</span>             heRhoThermo;</span><br><span class="line">    <span class="title">mixture</span>          pureMixture;</span><br><span class="line">    <span class="title">transport</span>        const;</span><br><span class="line">    <span class="title">thermo</span>           hConst;</span><br><span class="line">    <span class="title">equationOfState</span>  perfectGas;</span><br><span class="line">    <span class="title">specie</span>           specie;</span><br><span class="line">    <span class="title">energy</span>           sensibleInternalEnergy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最终，<code>thermo</code> 指针指向的是 <code>heRhoThermo</code> 类的对象，所以，从 <code>heRhoThermo</code> 类的构造函数看起：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">BasicPsiThermo</span>, class <span class="type">MixtureType</span>&gt;</span><br><span class="line"><span class="type">Foam</span>::heRhoThermo&lt;<span class="type">BasicPsiThermo</span>, <span class="type">MixtureType</span>&gt;::heRhoThermo</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> fvMesh&amp; mesh,</span><br><span class="line">    <span class="keyword">const</span> word&amp; phaseName</span><br><span class="line">)</span><br><span class="line">:</span><br><span class="line">    heThermo&lt;<span class="type">BasicPsiThermo</span>, <span class="type">MixtureType</span>&gt;(mesh, phaseName)</span><br><span class="line">&#123;</span><br><span class="line">    calculate(); // 构造函数调用 calculate 函数来初始化所有的热物理相关量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可见，构造函数里调用了 <code>calculate</code> 函数，前面提过，这个函数的作用是更新各个热物理相关量。</p>
<p>接下来一个一个来看里面涉及到的函数。</p>
<h5 id="he"><code>he</code></h5><p><code>he</code> 其实是 “h or e”，具体是焓，还是内能，取决于 <code>energy</code> 这一项的设置。 <code>he</code> 函数在 <code>heThermo</code> 类中定义，返回的是数据成员 <code>he_</code>，所以这里需要看一下数据成员 <code>he_</code> 的初始化：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> BasicThermo, <span class="keyword">class</span> MixtureType&gt;</span><br><span class="line">Foam::heThermo&lt;BasicThermo, MixtureType&gt;::heThermo</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> fvMesh&amp; mesh,</span><br><span class="line">    <span class="keyword">const</span> dictionary&amp; dict,</span><br><span class="line">    <span class="keyword">const</span> word&amp; phaseName</span><br><span class="line">)</span><br><span class="line">:</span><br><span class="line">    BasicThermo(mesh, dict, phaseName),</span><br><span class="line">    MixtureType(*<span class="keyword">this</span>, mesh),</span><br><span class="line"></span><br><span class="line">    he_</span><br><span class="line">    (</span><br><span class="line">        IOobject</span><br><span class="line">        (</span><br><span class="line">            BasicThermo::phasePropertyName</span><br><span class="line">            (</span><br><span class="line">                MixtureType::thermoType::heName()</span><br><span class="line">            ),</span><br><span class="line">            mesh.time().timeName(),</span><br><span class="line">            mesh,</span><br><span class="line">            IOobject::NO_READ,</span><br><span class="line">            IOobject::NO_WRITE</span><br><span class="line">        ),</span><br><span class="line">        mesh,</span><br><span class="line">        dimEnergy/dimMass,</span><br><span class="line">        <span class="keyword">this</span>-&gt;heBoundaryTypes(),</span><br><span class="line">        <span class="keyword">this</span>-&gt;heBoundaryBaseTypes()</span><br><span class="line">    )</span><br><span class="line">&#123;</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里调用的 <code>init</code> 函数的内容为<br><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">template&lt;<span class="keyword">class</span> <span class="type">BasicThermo</span>, <span class="keyword">class</span> <span class="type">MixtureType</span>&gt;</span><br><span class="line">void <span class="type">Foam</span>::heThermo&lt;<span class="type">BasicThermo</span>, <span class="type">MixtureType</span>&gt;::init<span class="literal">()</span></span><br><span class="line">&#123;</span><br><span class="line">    scalarField&amp; heCells = he_.internalField<span class="literal">()</span>;</span><br><span class="line">    const scalarField&amp; pCells = this-&gt;p_.internalField<span class="literal">()</span>;</span><br><span class="line">    const scalarField&amp; <span class="type">TCells</span> = this-&gt;<span class="type">T_</span>.internalField<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">    forAll(heCells, celli)</span><br><span class="line">    &#123;</span><br><span class="line">        heCells[celli] =</span><br><span class="line">            this-&gt;cellMixture(celli).<span class="type">HE</span>(pCells[celli], <span class="type">TCells</span>[celli]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    forAll(he_.boundaryField<span class="literal">()</span>, patchi)</span><br><span class="line">    &#123;</span><br><span class="line">        he_.boundaryField<span class="literal">()</span>[patchi] == he</span><br><span class="line">        (</span><br><span class="line">            this-&gt;p_.boundaryField<span class="literal">()</span>[patchi],</span><br><span class="line">            this-&gt;<span class="type">T_</span>.boundaryField<span class="literal">()</span>[patchi],</span><br><span class="line">            patchi</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this-&gt;heBoundaryCorrection(he_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里调用了 <code>HE</code> 函数来初始化 <code>he_</code> 的内部场，并对调用另一个三个数的 <code>he</code> 函数其边界条件进行了修正：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> BasicThermo, <span class="keyword">class</span> MixtureType&gt;</span><br><span class="line">Foam::tmp&lt;Foam::scalarField&gt; Foam::heThermo&lt;BasicThermo, MixtureType&gt;::he</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; p,</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; T,</span><br><span class="line">    <span class="keyword">const</span> label patchi</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    tmp&lt;scalarField&gt; the(<span class="keyword">new</span> scalarField(T.size()));</span><br><span class="line">    scalarField&amp; he = the();</span><br><span class="line"></span><br><span class="line">    forAll(T, facei)</span><br><span class="line">    &#123;</span><br><span class="line">        he[facei] =</span><br><span class="line">            <span class="keyword">this</span>-&gt;patchFaceMixture(patchi, facei).HE(p[facei], T[facei]);</span><br><span class="line">            <span class="comment">// 本质上还是调用了 HE 函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> the;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再来看 <code>HE</code> 函数，这个函数看名字和参数，应该是根据压力和温度来计算能量的，其定义在 <code>species::thermo</code> 类：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Thermo, <span class="keyword">template</span>&lt;<span class="keyword">class</span>&gt; <span class="keyword">class</span> Type&gt;</span><br><span class="line"><span class="keyword">inline</span> Foam::scalar</span><br><span class="line">Foam::species::thermo&lt;Thermo, Type&gt;::HE(<span class="keyword">const</span> scalar p, <span class="keyword">const</span> scalar T) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Type&lt;thermo&lt;Thermo, Type&gt; &gt;::HE(*<span class="keyword">this</span>, p, T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里，由于能量最终是什么形式，取决于 <code>energy</code> 关键字对应的类，所以，这里也是调用了定义在前面提到的 <code>energy variable</code> 类中的 <code>HE</code> 函数，以 <code>sensibleInternalEnergy</code> 为例：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">scalar</span> <span class="keyword">HE</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> Thermo&amp; thermo,</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">scalar</span> p,</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">scalar</span> T</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> thermo.Es(p, T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可见，其返回的是 <code>species::thermo</code> 类的 <code>Es</code> 函数，<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Thermo</span>, <span class="keyword">template</span>&lt;class&gt; class <span class="type">Type</span>&gt;</span><br><span class="line">inline <span class="type">Foam</span>::scalar</span><br><span class="line"><span class="type">Foam</span>::species::thermo&lt;<span class="type">Thermo</span>, <span class="type">Type</span>&gt;::<span class="type">Es</span>(<span class="keyword">const</span> scalar p, <span class="keyword">const</span> scalar T) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> this-&gt;es(p, T)/this-&gt;W();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Thermo</span>, <span class="keyword">template</span>&lt;class&gt; class <span class="type">Type</span>&gt;</span><br><span class="line">inline <span class="type">Foam</span>::scalar</span><br><span class="line"><span class="type">Foam</span>::species::thermo&lt;<span class="type">Thermo</span>, <span class="type">Type</span>&gt;::es(<span class="keyword">const</span> scalar p, <span class="keyword">const</span> scalar T) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> this-&gt;hs(p, T) - p*this-&gt;W()/this-&gt;rho(p, T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> <code>hs</code> 函数定义在 <code>thermo</code> 类型的类中，以 <code>hConstThermo</code> 类为例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> equationOfState&gt;</span><br><span class="line"><span class="keyword">inline</span> Foam::scalar Foam::hConstThermo&lt;equationOfState&gt;::hs</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> scalar p, <span class="keyword">const</span> scalar T</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Cp_*T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>hs</code> 表示的是显焓，等于 <code>Cp_*T</code> 。 <code>es</code> 是内能，根据焓的定义，$H=U+pV$。代码中的 <code>hs</code> 和 <code>es</code> 都是 <code>J/kMol</code> 的量纲，所以，$es=hs-pV/n$ 。以理想气体状态方程为例，$pV=nRT$，或者写成 $pM=\rho RT$，得 $pV/n = RT = pM/\rho$ 。</p>
<p>注意，这里的 <code>Cp_</code>，在字典文件里给的是 <code>J/(kg.K)</code> 量纲的，但是在构造函数中，将其转成了 <code>J/(kmol.K)</code> 的量纲：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class equationOfState&gt;</span><br><span class="line"><span class="type">Foam</span>::hConstThermo&lt;equationOfState&gt;::hConstThermo(<span class="keyword">const</span> dictionary&amp; dict)</span><br><span class="line">:</span><br><span class="line">    equationOfState(dict),</span><br><span class="line">    <span class="type">Cp_</span>(readScalar(dict.subDict(<span class="string">"thermodynamics"</span>).lookup(<span class="string">"Cp"</span>))),</span><br><span class="line">    <span class="type">Hf_</span>(readScalar(dict.subDict(<span class="string">"thermodynamics"</span>).lookup(<span class="string">"Hf"</span>)))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">Cp_</span> *= this-&gt;W();</span><br><span class="line">    <span class="type">Hf_</span> *= this-&gt;W();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以，<code>hs</code>， <code>es</code> 是 <code>J/kmol</code> ； <code>Es</code>， <code>HE</code> 是 <code>J/kg</code>。</p>
<h5 id="Cpv">Cpv</h5><p>这个函数定义在 <code>heThermo</code> 类中。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> BasicThermo, <span class="keyword">class</span> MixtureType&gt;</span><br><span class="line">Foam::tmp&lt;Foam::volScalarField&gt;</span><br><span class="line">Foam::heThermo&lt;BasicThermo, MixtureType&gt;::Cpv() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> fvMesh&amp; mesh = <span class="keyword">this</span>-&gt;T_.mesh();</span><br><span class="line"></span><br><span class="line">    tmp&lt;volScalarField&gt; tCpv</span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">new</span> volScalarField</span><br><span class="line">        (</span><br><span class="line">            IOobject</span><br><span class="line">            (</span><br><span class="line">                <span class="string">"Cpv"</span>,</span><br><span class="line">                mesh.time().timeName(),</span><br><span class="line">                mesh,</span><br><span class="line">                IOobject::NO_READ,</span><br><span class="line">                IOobject::NO_WRITE</span><br><span class="line">            ),</span><br><span class="line">            mesh,</span><br><span class="line">            dimEnergy/dimMass/dimTemperature</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">    volScalarField&amp; cpv = tCpv();</span><br><span class="line"></span><br><span class="line">    forAll(<span class="keyword">this</span>-&gt;T_, celli)</span><br><span class="line">    &#123;</span><br><span class="line">        cpv[celli] =</span><br><span class="line">            <span class="keyword">this</span>-&gt;cellMixture(celli).Cpv(<span class="keyword">this</span>-&gt;p_[celli], <span class="keyword">this</span>-&gt;T_[celli]);</span><br><span class="line">    &#125;</span><br><span class="line">    forAll(<span class="keyword">this</span>-&gt;T_.boundaryField(), patchi)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> fvPatchScalarField&amp; pp = <span class="keyword">this</span>-&gt;p_.boundaryField()[patchi];</span><br><span class="line">        <span class="keyword">const</span> fvPatchScalarField&amp; pT = <span class="keyword">this</span>-&gt;T_.boundaryField()[patchi];</span><br><span class="line">        fvPatchScalarField&amp; pCpv = cpv.boundaryField()[patchi];</span><br><span class="line"></span><br><span class="line">        forAll(pT, facei)</span><br><span class="line">        &#123;</span><br><span class="line">            pCpv[facei] =</span><br><span class="line">                <span class="keyword">this</span>-&gt;patchFaceMixture(patchi, facei).Cpv(pp[facei], pT[facei]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tCpv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数，创建了一个 <code>tmp&lt;volScalarField&gt;</code>，然后调用定义在 <code>species::thermo</code> 类中的两参数 <code>Cpv</code> 函数来对场量进行初始化，这个函数的形式如下<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Thermo</span>, <span class="keyword">template</span>&lt;class&gt; class <span class="type">Type</span>&gt;</span><br><span class="line">inline <span class="type">Foam</span>::scalar</span><br><span class="line"><span class="type">Foam</span>::species::thermo&lt;<span class="type">Thermo</span>, <span class="type">Type</span>&gt;::<span class="type">Cpv</span>(<span class="keyword">const</span> scalar p, <span class="keyword">const</span> scalar T) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> this-&gt;cpv(p, T)/this-&gt;W();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Thermo</span>, <span class="keyword">template</span>&lt;class&gt; class <span class="type">Type</span>&gt;</span><br><span class="line">inline <span class="type">Foam</span>::scalar</span><br><span class="line"><span class="type">Foam</span>::species::thermo&lt;<span class="type">Thermo</span>, <span class="type">Type</span>&gt;::cpv(<span class="keyword">const</span> scalar p, <span class="keyword">const</span> scalar T) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Type</span>&lt;thermo&lt;<span class="type">Thermo</span>, <span class="type">Type</span>&gt; &gt;::cpv(*this, p, T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>cpv</code> 函数返回的是定义在 <code>energy variable</code> 类中的三参数 <code>cpv</code> 函数，对于 <code>sensibleInternalEnergy</code>，<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">scalar</span> cpv</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> Thermo&amp; thermo,</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">scalar</span> p,</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">scalar</span> T</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> thermo.cv(p, T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里返回的是 <code>species::thermo</code> 类的 <code>cv</code> 函数，<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Thermo</span>, <span class="keyword">template</span>&lt;class&gt; class <span class="type">Type</span>&gt;</span><br><span class="line">inline <span class="type">Foam</span>::scalar</span><br><span class="line"><span class="type">Foam</span>::species::thermo&lt;<span class="type">Thermo</span>, <span class="type">Type</span>&gt;::cv(<span class="keyword">const</span> scalar p, <span class="keyword">const</span> scalar T) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> this-&gt;cp(p, T) - this-&gt;cpMcv(p, T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的 <code>cp</code> 函数定义在 <code>thermo</code> 类型的类中，以 <code>hConst</code> 为例<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class equationOfState&gt;</span><br><span class="line">inline <span class="type">Foam</span>::scalar <span class="type">Foam</span>::hConstThermo&lt;equationOfState&gt;::cp</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> scalar p,</span><br><span class="line">    <span class="keyword">const</span> scalar T</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Cp_</span>; // 量纲是 J/(kmol.K)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>cpMcv</code> 的定义在状态方程类中，以 <code>perfectGas</code> 为例<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Specie</span>&gt;</span><br><span class="line">inline <span class="type">Foam</span>::scalar <span class="type">Foam</span>::perfectGas&lt;<span class="type">Specie</span>&gt;::cpMcv(scalar, scalar) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> this-&gt;<span class="type">RR</span>; // 量纲是 J/(kmol.K)，所以值应该是 <span class="number">8314</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="alphaEff">alphaEff</h5><p>这个函数需要一个参数，其定义在 <code>heThermo</code> 类中<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class <span class="constant">BasicThermo,</span> class <span class="constant">MixtureType&gt;</span></span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:tmp&lt;Foam</span><span class="symbol">:</span><span class="symbol">:volScalarField&gt;</span></span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:heThermo&lt;BasicThermo</span>, <span class="constant">MixtureType&gt;</span><span class="symbol">:</span><span class="symbol">:alphaEff</span></span><br><span class="line">(</span><br><span class="line">    const volScalarField&amp; alphat</span><br><span class="line">) const</span><br><span class="line">&#123;</span><br><span class="line">    tmp&lt;<span class="constant">Foam:</span><span class="symbol">:volScalarField&gt;</span> alphaEff(this-&gt;<span class="constant">CpByCpv(</span>)*(this-&gt;alpha<span class="constant">_</span> + alphat));</span><br><span class="line">    alphaEff().rename(<span class="string">"alphaEff"</span>);</span><br><span class="line">    <span class="keyword">return</span> alphaEff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里， 无参数的 <code>CpByCpv</code> 函数定义在 <code>species::thermo</code> 类中，最终调用的是 <code>energy varialble</code> 类中的 <code>CpByCpv</code> 函数，如果是内能形式的，则返回 <code>thermo.gamma(p, T)</code> ，焓形式则返回 <code>1</code>。 <code>gamma</code> 的定义在 <code>species::thermo</code><br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Thermo</span>, <span class="keyword">template</span>&lt;class&gt; class <span class="type">Type</span>&gt;</span><br><span class="line">inline <span class="type">Foam</span>::scalar</span><br><span class="line"><span class="type">Foam</span>::species::thermo&lt;<span class="type">Thermo</span>, <span class="type">Type</span>&gt;::gamma(<span class="keyword">const</span> scalar p, <span class="keyword">const</span> scalar T) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    scalar cp = this-&gt;cp(p, T);</span><br><span class="line">    <span class="keyword">return</span> cp/(cp - this-&gt;cpMcv(p, T));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>alpha_</code> 是层流能量扩散系数，定义在 <code>basicThermo</code> 类，并在该类的构造函数中初始化为零。在 <code>heRhoThermo</code> 类的 <code>calculate</code> 函数中，对其进行了更新<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="atom">scalarField</span>&amp; <span class="atom">alphaCells</span> = <span class="atom">this</span>-&gt;<span class="atom">alpha_</span>.<span class="atom">internalField</span>();</span><br><span class="line"><span class="atom">alphaCells</span>[<span class="atom">celli</span>] = <span class="atom">mixture_</span>.<span class="atom">alphah</span>(<span class="atom">pCells</span>[<span class="atom">celli</span>], <span class="name">TCells</span>[<span class="atom">celli</span>]);</span><br><span class="line"></span><br><span class="line"><span class="atom">fvPatchScalarField</span>&amp; <span class="atom">palpha</span> = <span class="atom">this</span>-&gt;<span class="atom">alpha_</span>.<span class="atom">boundaryField</span>()[<span class="atom">patchi</span>];</span><br><span class="line"><span class="atom">palpha</span>[<span class="atom">facei</span>] = <span class="atom">mixture_</span>.<span class="atom">alphah</span>(<span class="atom">pp</span>[<span class="atom">facei</span>], <span class="atom">pT</span>[<span class="atom">facei</span>]);</span><br></pre></td></tr></table></figure></p>
<p>可见， <code>alpha_</code> 的值是通过 <code>alphah</code> 函数来计算更新的，这个函数的定义在 <code>trasnport</code> 模型里，以 <code>constTransport</code> 为例<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Thermo</span>&gt;</span><br><span class="line">inline <span class="type">Foam</span>::scalar <span class="type">Foam</span>::constTransport&lt;<span class="type">Thermo</span>&gt;::alphah</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> scalar p,</span><br><span class="line">    <span class="keyword">const</span> scalar T</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> mu(p, T)*rPr_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>返回粘度与普朗特数的比值。<br>至于 <code>alphat</code> ，则是函数 <code>alphaEff</code> 的参数，根据开头的代码可知， <code>alphat</code> 其实是 <code>mut</code> 。<br>只是，暂时不知道为什么有效热扩散系数 <code>alphaEff = CpByCpv * (alpha + alphat)</code>。</p>
<p>构建起能量方程后，就该对其进行求解了。<br><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fvOptions.constrain(he1Eqn);</span><br><span class="line">   he1Eqn.solve<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">   fvOptions.constrain(he2Eqn);</span><br><span class="line">   he2Eqn.solve<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">   thermo1.correct<span class="literal">()</span>;</span><br><span class="line">   <span class="type">Info</span>&lt;&lt; <span class="string">"min "</span> &lt;&lt; thermo1.<span class="type">T</span><span class="literal">()</span>.name<span class="literal">()</span></span><br><span class="line">       &lt;&lt; <span class="string">" "</span> &lt;&lt; min(thermo1.<span class="type">T</span><span class="literal">()</span>).<span class="keyword">value</span><span class="literal">()</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">   thermo2.correct<span class="literal">()</span>;</span><br><span class="line">   <span class="type">Info</span>&lt;&lt; <span class="string">"min "</span> &lt;&lt; thermo2.<span class="type">T</span><span class="literal">()</span>.name<span class="literal">()</span></span><br><span class="line">       &lt;&lt; <span class="string">" "</span> &lt;&lt; min(thermo2.<span class="type">T</span><span class="literal">()</span>).<span class="keyword">value</span><span class="literal">()</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p>
<p>这里， <code>solve</code> 函数值得细说，重点是看 <code>correct()</code> 函数，以及 <code>T()</code> 函数。</p>
<p><code>corretc()</code> 函数指的是定义在 <code>heRhoThermo</code> 类中的 <code>correct()</code> 函数：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">BasicPsiThermo</span>, class <span class="type">MixtureType</span>&gt;</span><br><span class="line"><span class="type">void</span> <span class="type">Foam</span>::heRhoThermo&lt;<span class="type">BasicPsiThermo</span>, <span class="type">MixtureType</span>&gt;::correct()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (debug)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Info</span>&lt;&lt; <span class="string">"entering heRhoThermo&lt;MixtureType&gt;::correct()"</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    calculate();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (debug)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Info</span>&lt;&lt; <span class="string">"exiting heRhoThermo&lt;MixtureType&gt;::correct()"</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可见， <code>correct()</code> 函数，其实就是对 <code>calculate</code> 函数进行了一次调用而已。<br>看来最核心最关键的就在 <code>calculate</code> 函数中了。在仔细看这个函数之前，先把 <code>T()</code> 的定义看完。 <code>T()</code> 定义在 <code>basicThermo</code> 类中，其作用仅是返回同样定义在 <code>basicThermo</code> 类中定义的数据成员 <code>T_</code> 而已。</p>
<p>下面深入分析一下 <code>heRhoThermo</code> 类中的 <code>calculate</code> 函数，这里再将它列出来一次：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="atom">template</span>&lt;<span class="atom">class</span> <span class="name">BasicPsiThermo</span>, <span class="atom">class</span> <span class="name">MixtureType</span>&gt;</span><br><span class="line"><span class="atom">void</span> <span class="name">Foam</span>::<span class="atom">heRhoThermo</span>&lt;<span class="name">BasicPsiThermo</span>, <span class="name">MixtureType</span>&gt;::<span class="atom">calculate</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="atom">const</span> <span class="atom">scalarField</span>&amp; <span class="atom">hCells</span> = <span class="atom">this</span>-&gt;<span class="atom">he</span>().<span class="atom">internalField</span>();</span><br><span class="line">    <span class="atom">const</span> <span class="atom">scalarField</span>&amp; <span class="atom">pCells</span> = <span class="atom">this</span>-&gt;<span class="atom">p_</span>.<span class="atom">internalField</span>();</span><br><span class="line"></span><br><span class="line">    <span class="atom">scalarField</span>&amp; <span class="name">TCells</span> = <span class="atom">this</span>-&gt;<span class="name">T_</span>.<span class="atom">internalField</span>();</span><br><span class="line">    <span class="atom">scalarField</span>&amp; <span class="atom">psiCells</span> = <span class="atom">this</span>-&gt;<span class="atom">psi_</span>.<span class="atom">internalField</span>();</span><br><span class="line">    <span class="atom">scalarField</span>&amp; <span class="atom">rhoCells</span> = <span class="atom">this</span>-&gt;<span class="atom">rho_</span>.<span class="atom">internalField</span>();</span><br><span class="line">    <span class="atom">scalarField</span>&amp; <span class="atom">muCells</span> = <span class="atom">this</span>-&gt;<span class="atom">mu_</span>.<span class="atom">internalField</span>();</span><br><span class="line">    <span class="atom">scalarField</span>&amp; <span class="atom">alphaCells</span> = <span class="atom">this</span>-&gt;<span class="atom">alpha_</span>.<span class="atom">internalField</span>();</span><br><span class="line"></span><br><span class="line">    <span class="atom">forAll</span>(<span class="name">TCells</span>, <span class="atom">celli</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="atom">const</span> <span class="atom">typename</span> <span class="name">MixtureType</span>::<span class="atom">thermoType</span>&amp; <span class="atom">mixture_</span> =</span><br><span class="line">            <span class="atom">this</span>-&gt;<span class="atom">cellMixture</span>(<span class="atom">celli</span>);</span><br><span class="line"></span><br><span class="line">        <span class="name">TCells</span>[<span class="atom">celli</span>] = <span class="atom">mixture_</span>.<span class="name">THE</span></span><br><span class="line">        (</span><br><span class="line">            <span class="atom">hCells</span>[<span class="atom">celli</span>],</span><br><span class="line">            <span class="atom">pCells</span>[<span class="atom">celli</span>],</span><br><span class="line">            <span class="name">TCells</span>[<span class="atom">celli</span>]</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="atom">psiCells</span>[<span class="atom">celli</span>] = <span class="atom">mixture_</span>.<span class="atom">psi</span>(<span class="atom">pCells</span>[<span class="atom">celli</span>], <span class="name">TCells</span>[<span class="atom">celli</span>]);</span><br><span class="line">        <span class="atom">rhoCells</span>[<span class="atom">celli</span>] = <span class="atom">mixture_</span>.<span class="atom">rho</span>(<span class="atom">pCells</span>[<span class="atom">celli</span>], <span class="name">TCells</span>[<span class="atom">celli</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="atom">muCells</span>[<span class="atom">celli</span>] = <span class="atom">mixture_</span>.<span class="atom">mu</span>(<span class="atom">pCells</span>[<span class="atom">celli</span>], <span class="name">TCells</span>[<span class="atom">celli</span>]);</span><br><span class="line">        <span class="atom">alphaCells</span>[<span class="atom">celli</span>] = <span class="atom">mixture_</span>.<span class="atom">alphah</span>(<span class="atom">pCells</span>[<span class="atom">celli</span>], <span class="name">TCells</span>[<span class="atom">celli</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="atom">forAll</span>(<span class="atom">this</span>-&gt;<span class="name">T_</span>.<span class="atom">boundaryField</span>(), <span class="atom">patchi</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="atom">fvPatchScalarField</span>&amp; <span class="atom">pp</span> = <span class="atom">this</span>-&gt;<span class="atom">p_</span>.<span class="atom">boundaryField</span>()[<span class="atom">patchi</span>];</span><br><span class="line">        <span class="atom">fvPatchScalarField</span>&amp; <span class="atom">pT</span> = <span class="atom">this</span>-&gt;<span class="name">T_</span>.<span class="atom">boundaryField</span>()[<span class="atom">patchi</span>];</span><br><span class="line">        <span class="atom">fvPatchScalarField</span>&amp; <span class="atom">ppsi</span> = <span class="atom">this</span>-&gt;<span class="atom">psi_</span>.<span class="atom">boundaryField</span>()[<span class="atom">patchi</span>];</span><br><span class="line">        <span class="atom">fvPatchScalarField</span>&amp; <span class="atom">prho</span> = <span class="atom">this</span>-&gt;<span class="atom">rho_</span>.<span class="atom">boundaryField</span>()[<span class="atom">patchi</span>];</span><br><span class="line"></span><br><span class="line">        <span class="atom">fvPatchScalarField</span>&amp; <span class="atom">ph</span> = <span class="atom">this</span>-&gt;<span class="atom">he</span>().<span class="atom">boundaryField</span>()[<span class="atom">patchi</span>];</span><br><span class="line"></span><br><span class="line">        <span class="atom">fvPatchScalarField</span>&amp; <span class="atom">pmu</span> = <span class="atom">this</span>-&gt;<span class="atom">mu_</span>.<span class="atom">boundaryField</span>()[<span class="atom">patchi</span>];</span><br><span class="line">        <span class="atom">fvPatchScalarField</span>&amp; <span class="atom">palpha</span> = <span class="atom">this</span>-&gt;<span class="atom">alpha_</span>.<span class="atom">boundaryField</span>()[<span class="atom">patchi</span>];</span><br><span class="line"></span><br><span class="line">        <span class="atom">if</span> (<span class="atom">pT</span>.<span class="atom">fixesValue</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="atom">forAll</span>(<span class="atom">pT</span>, <span class="atom">facei</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="atom">const</span> <span class="atom">typename</span> <span class="name">MixtureType</span>::<span class="atom">thermoType</span>&amp; <span class="atom">mixture_</span> =</span><br><span class="line">                    <span class="atom">this</span>-&gt;<span class="atom">patchFaceMixture</span>(<span class="atom">patchi</span>, <span class="atom">facei</span>);</span><br><span class="line"></span><br><span class="line">                <span class="atom">ph</span>[<span class="atom">facei</span>] = <span class="atom">mixture_</span>.<span class="name">HE</span>(<span class="atom">pp</span>[<span class="atom">facei</span>], <span class="atom">pT</span>[<span class="atom">facei</span>]);</span><br><span class="line"></span><br><span class="line">                <span class="atom">ppsi</span>[<span class="atom">facei</span>] = <span class="atom">mixture_</span>.<span class="atom">psi</span>(<span class="atom">pp</span>[<span class="atom">facei</span>], <span class="atom">pT</span>[<span class="atom">facei</span>]);</span><br><span class="line">                <span class="atom">prho</span>[<span class="atom">facei</span>] = <span class="atom">mixture_</span>.<span class="atom">rho</span>(<span class="atom">pp</span>[<span class="atom">facei</span>], <span class="atom">pT</span>[<span class="atom">facei</span>]);</span><br><span class="line">                <span class="atom">pmu</span>[<span class="atom">facei</span>] = <span class="atom">mixture_</span>.<span class="atom">mu</span>(<span class="atom">pp</span>[<span class="atom">facei</span>], <span class="atom">pT</span>[<span class="atom">facei</span>]);</span><br><span class="line">                <span class="atom">palpha</span>[<span class="atom">facei</span>] = <span class="atom">mixture_</span>.<span class="atom">alphah</span>(<span class="atom">pp</span>[<span class="atom">facei</span>], <span class="atom">pT</span>[<span class="atom">facei</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="atom">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="atom">forAll</span>(<span class="atom">pT</span>, <span class="atom">facei</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="atom">const</span> <span class="atom">typename</span> <span class="name">MixtureType</span>::<span class="atom">thermoType</span>&amp; <span class="atom">mixture_</span> =</span><br><span class="line">                    <span class="atom">this</span>-&gt;<span class="atom">patchFaceMixture</span>(<span class="atom">patchi</span>, <span class="atom">facei</span>);</span><br><span class="line"></span><br><span class="line">                <span class="atom">pT</span>[<span class="atom">facei</span>] = <span class="atom">mixture_</span>.<span class="name">THE</span>(<span class="atom">ph</span>[<span class="atom">facei</span>], <span class="atom">pp</span>[<span class="atom">facei</span>], <span class="atom">pT</span>[<span class="atom">facei</span>]);</span><br><span class="line"></span><br><span class="line">                <span class="atom">ppsi</span>[<span class="atom">facei</span>] = <span class="atom">mixture_</span>.<span class="atom">psi</span>(<span class="atom">pp</span>[<span class="atom">facei</span>], <span class="atom">pT</span>[<span class="atom">facei</span>]);</span><br><span class="line">                <span class="atom">prho</span>[<span class="atom">facei</span>] = <span class="atom">mixture_</span>.<span class="atom">rho</span>(<span class="atom">pp</span>[<span class="atom">facei</span>], <span class="atom">pT</span>[<span class="atom">facei</span>]);</span><br><span class="line">                <span class="atom">pmu</span>[<span class="atom">facei</span>] = <span class="atom">mixture_</span>.<span class="atom">mu</span>(<span class="atom">pp</span>[<span class="atom">facei</span>], <span class="atom">pT</span>[<span class="atom">facei</span>]);</span><br><span class="line">                <span class="atom">palpha</span>[<span class="atom">facei</span>] = <span class="atom">mixture_</span>.<span class="atom">alphah</span>(<span class="atom">pp</span>[<span class="atom">facei</span>], <span class="atom">pT</span>[<span class="atom">facei</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数是在对几个热物理相关的量来进行更新，先更新内部场，再更新边界值。一个一个来看：</p>
<ul>
<li><p>he<br>he 前面讲了，这里需要注意的是其边界值的更新。由于 <code>he</code> 没有IO，其内部场量通过求解能量方程来更新，边界则需要根据情况特殊处理。两种情况，一种是设定了边界的温度值(pT.fixesValue())，这时需要更新边界上的 <code>he</code> 值： <code>ph[facei] = mixture_.HE(pp[facei], pT[facei]);</code> 否则，则边界上的 <code>he</code> 不需要特殊地更新。</p>
</li>
<li><p>psi<br>这个直接调用两参数的 <code>psi</code> 函数来更新，这个函数的定义在状态方程里，以 <code>perfaceGas</code> 为例，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Specie&gt;</span><br><span class="line"><span class="keyword">inline</span> Foam::scalar Foam::perfectGas&lt;Specie&gt;::psi(scalar, scalar T) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span>/(<span class="keyword">this</span>-&gt;R()*T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><code>psi</code> 是压缩因子，返回 $\frac{1}{RT}$。</p>
<ul>
<li>rho<br>这个调用的是两参数的 <code>rho</code> 函数，定义在状态方程类中，用于密度的更新，同样以 <code>perfaceGas</code> 为例，<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Specie</span>&gt;</span><br><span class="line">inline <span class="type">Foam</span>::scalar <span class="type">Foam</span>::perfectGas&lt;<span class="type">Specie</span>&gt;::rho(scalar p, scalar T) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> p/(this-&gt;R()*T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>返回 $\frac{p}{RT}$。</p>
<ul>
<li>mu<br>这个调用的是两参数的 <code>mu</code> 函数，其定义在 transport 类中，以 <code>constTransport</code> 为例，这个返回的是场量的层流粘度<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Thermo</span>&gt;</span><br><span class="line">inline <span class="type">Foam</span>::scalar <span class="type">Foam</span>::constTransport&lt;<span class="type">Thermo</span>&gt;::mu</span><br><span class="line">(</span><br><span class="line">     <span class="keyword">const</span> scalar p,</span><br><span class="line">     <span class="keyword">const</span> scalar T</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">return</span> mu_; // 常量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>alphah 上面说过了，不再重复。</p>
<p>最后，最复杂的就是温度的更新了</p>
<ul>
<li>T<br>温度的更新，调用的是三参数的 <code>THE</code> 函数，这个函数定义在 <code>species::thermo</code> 类中，<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Thermo</span>, <span class="keyword">template</span>&lt;class&gt; class <span class="type">Type</span>&gt;</span><br><span class="line">inline <span class="type">Foam</span>::scalar <span class="type">Foam</span>::species::thermo&lt;<span class="type">Thermo</span>, <span class="type">Type</span>&gt;::<span class="type">THE</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> scalar he,</span><br><span class="line">    <span class="keyword">const</span> scalar p,</span><br><span class="line">    <span class="keyword">const</span> scalar <span class="type">T0</span></span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Type</span>&lt;thermo&lt;<span class="type">Thermo</span>, <span class="type">Type</span>&gt; &gt;::<span class="type">THE</span>(*this, he, p, <span class="type">T0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这里，调用的是 <code>energy variable</code> 类的 <code>THE</code> 函数，以 <code>sensibleInternalEnergy</code> 为例，<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">scalar</span> THE</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> Thermo&amp; thermo,</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">scalar</span> <span class="keyword">e</span>,</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">scalar</span> p,</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">scalar</span> T0</span><br><span class="line"> ) <span class="keyword">const</span></span><br><span class="line"> &#123;</span><br><span class="line">    <span class="keyword">return</span> thermo.<span class="keyword">TEs</span>(<span class="keyword">e</span>, p, T0);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>可见，对于 <code>sensibleInternalEnergy</code> ， <code>THE</code> 函数实际上返回的是 <code>species::thermo</code> 类的 <code>TEs</code> 函数。<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Thermo</span>, <span class="keyword">template</span>&lt;class&gt; class <span class="type">Type</span>&gt;</span><br><span class="line">inline <span class="type">Foam</span>::scalar <span class="type">Foam</span>::species::thermo&lt;<span class="type">Thermo</span>, <span class="type">Type</span>&gt;::<span class="type">TEs</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> scalar es,</span><br><span class="line">    <span class="keyword">const</span> scalar p,</span><br><span class="line">    <span class="keyword">const</span> scalar <span class="type">T0</span></span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> T</span><br><span class="line">    (</span><br><span class="line">        es,</span><br><span class="line">        p,</span><br><span class="line">        <span class="type">T0</span>,</span><br><span class="line">        &amp;thermo&lt;<span class="type">Thermo</span>, <span class="type">Type</span>&gt;::<span class="type">Es</span>,</span><br><span class="line">        &amp;thermo&lt;<span class="type">Thermo</span>, <span class="type">Type</span>&gt;::<span class="type">Cv</span>,</span><br><span class="line">        &amp;thermo&lt;<span class="type">Thermo</span>, <span class="type">Type</span>&gt;::limit</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里，终于来到了这个六参数的 <code>T</code> 函数：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line"> inline <span class="keyword">scalar</span> T</span><br><span class="line">        (</span><br><span class="line">            <span class="keyword">scalar</span> f,</span><br><span class="line">            <span class="keyword">scalar</span> p,</span><br><span class="line">            <span class="keyword">scalar</span> T0,</span><br><span class="line">            <span class="keyword">scalar</span> (thermo::*F)(<span class="keyword">const</span> <span class="keyword">scalar</span>, <span class="keyword">const</span> <span class="keyword">scalar</span>) <span class="keyword">const</span>,</span><br><span class="line">            <span class="keyword">scalar</span> (thermo::*dFdT)(<span class="keyword">const</span> <span class="keyword">scalar</span>, <span class="keyword">const</span> <span class="keyword">scalar</span>) <span class="keyword">const</span>,</span><br><span class="line">            <span class="keyword">scalar</span> (thermo::*limit)(<span class="keyword">const</span> <span class="keyword">scalar</span>) <span class="keyword">const</span></span><br><span class="line">        ) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现</span></span><br><span class="line">template&lt;<span class="keyword">class</span> Thermo, template&lt;<span class="keyword">class</span>&gt; <span class="keyword">class</span> <span class="keyword">Type</span>&gt;</span><br><span class="line">inline Foam::<span class="keyword">scalar</span> Foam::species::thermo&lt;Thermo, <span class="keyword">Type</span>&gt;::T</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">scalar</span> f,</span><br><span class="line">    <span class="keyword">scalar</span> p,</span><br><span class="line">    <span class="keyword">scalar</span> T0,</span><br><span class="line">    <span class="keyword">scalar</span> (thermo&lt;Thermo, <span class="keyword">Type</span>&gt;::*F)(<span class="keyword">const</span> <span class="keyword">scalar</span>, <span class="keyword">const</span> <span class="keyword">scalar</span>) <span class="keyword">const</span>,</span><br><span class="line">    <span class="keyword">scalar</span> (thermo&lt;Thermo, <span class="keyword">Type</span>&gt;::*dFdT)(<span class="keyword">const</span> <span class="keyword">scalar</span>, <span class="keyword">const</span> <span class="keyword">scalar</span>)</span><br><span class="line">        <span class="keyword">const</span>,</span><br><span class="line">    <span class="keyword">scalar</span> (thermo&lt;Thermo, <span class="keyword">Type</span>&gt;::*limit)(<span class="keyword">const</span> <span class="keyword">scalar</span>) <span class="keyword">const</span></span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">scalar</span> <span class="keyword">Test</span> = T0;</span><br><span class="line">    <span class="keyword">scalar</span> Tnew = T0;</span><br><span class="line">    <span class="keyword">scalar</span> Ttol = T0*tol_;</span><br><span class="line">    int    iter = 0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">Test</span> = Tnew;</span><br><span class="line">        Tnew =</span><br><span class="line">            (this-&gt;*limit)</span><br><span class="line">            (<span class="keyword">Test</span> - ((this-&gt;*F)(p, <span class="keyword">Test</span>) - f)/(this-&gt;*dFdT)(p, <span class="keyword">Test</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (iter++ &gt; maxIter_)</span><br><span class="line">        &#123;</span><br><span class="line">            FatalErrorIn</span><br><span class="line">            (</span><br><span class="line">                <span class="string">"thermo&lt;Thermo, Type&gt;::T(scalar f, scalar T0, "</span></span><br><span class="line">                <span class="string">"scalar (thermo&lt;Thermo, Type&gt;::*F)"</span></span><br><span class="line">                <span class="string">"(const scalar) const, "</span></span><br><span class="line">                <span class="string">"scalar (thermo&lt;Thermo, Type&gt;::*dFdT)"</span></span><br><span class="line">                <span class="string">"(const scalar) const, "</span></span><br><span class="line">                <span class="string">"scalar (thermo&lt;Thermo, Type&gt;::*limit)"</span></span><br><span class="line">                <span class="string">"(const scalar) const"</span></span><br><span class="line">                <span class="string">") const"</span></span><br><span class="line">            )   &lt;&lt; <span class="string">"Maximum number of iterations exceeded"</span></span><br><span class="line">                &lt;&lt; abort(FatalError);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (mag(Tnew - <span class="keyword">Test</span>) &gt; Ttol);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Tnew;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数，前三个参数是普通的 scalar 类型变量，后三个参数，是函数指针，并且都指向当前类 <code>species::thermo</code> 的成员函数。以 <code>TEs</code> 为例，后三个参数分别代入的是 <code>Es</code> ， <code>Cv</code> 以及 <code>limit</code> 三个函数。 <code>Es</code> 和 <code>Cv</code> 前面都看过了， <code>limit</code> 定义在 thermo 类中，以 <code>hConst</code> 为例，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> EquationOfState&gt;</span><br><span class="line"><span class="keyword">inline</span> Foam::scalar Foam::hConstThermo&lt;EquationOfState&gt;::limit</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> scalar T</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>直接返回温度 <code>T</code> 。事实上，除了 <code>janaf</code> 模型，其他的都是返回 <code>T</code> 。 <code>janaf</code> 模型中， 如果温度没有超出 [Tlow,Thigh]，则会出来警告信息，并且，若 <code>T &lt; Tlow</code> 则返回 <code>Tlow</code>，而 <code>T &gt; Thigh</code> 时，则返回 <code>Thigh</code>。</p>
<p>下面仔细来分析六参数 <code>T</code> 函数的核心部分。经过摸索，发现这个其实是一个牛顿迭代的过程，目的是根据 <code>Es</code> 函数，从内能 <code>es</code> 来计算温度 <code>T</code>，即求解 $E_s(p,T) - E_s = 0$ 。令 $F(T)= E_s(p,T) - E_s $，则牛顿迭代法的递推公式为<br>$$<br>T_{New} = T_{old} - \dfrac{F(T_{old})}{F\prime(T_{old})} = T_{old} - \dfrac{E_s(p, T_{old)} - E_s}{dE_s(p,T)/dT |_{T=T_{old}}}<br>$$<br>对于 <code>sensibleInternalEnergy</code> ，$dE_s(p,T)/dT = C_v(p,T)$<br>所以最终得到递推公式为<br>$$<br>T_{New} = T_{old} - \dfrac{E_s(p, T_{old)} - E_s}{C_v(p, T_{old})}<br>$$<br>这里设置了最大迭代次数为 100，超过将报那个涉及到能量的模拟中最容易见到的崩溃信息：”Maximum number of iterations exceeded” 。</p>
<p>当能量变量是焓时，则 $E_s$ 要换成 $H_s$， $C_v$ 要换成 $C_p$ 。 </p>
<p>至此便分析完了一个具体的能量方程实例。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本篇来看一个具体的能量方程，以 <code>twoPhaseEulerFoam</code> 的 <code>EEqn.H</code> 为例。</p>]]>
    
    </summary>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="thermophysicalModels" scheme="http://xiaopingqiu.github.io/tags/thermophysicalModels/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenFOAM 中的热物理类之继承派生关系]]></title>
    <link href="http://xiaopingqiu.github.io/2016/06/25/thermophysics3/"/>
    <id>http://xiaopingqiu.github.io/2016/06/25/thermophysics3/</id>
    <published>2016-06-25T07:14:28.000Z</published>
    <updated>2016-06-25T07:44:54.491Z</updated>
    <content type="html"><![CDATA[<p>根据上一篇的介绍，我们已经知道<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">thermoType</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title">type</span>             heRhoThermo;</span><br><span class="line">    <span class="title">mixture</span>          pureMixture;</span><br><span class="line">    <span class="title">transport</span>        const;</span><br><span class="line">    <span class="title">thermo</span>           hConst;</span><br><span class="line">    <span class="title">equationOfState</span>  perfectGas;</span><br><span class="line">    <span class="title">specie</span>           specie;</span><br><span class="line">    <span class="title">energy</span>           sensibleInternalEnergy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个设置对应的是下述类：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">heRhoThermo                                                                 </span><br><span class="line">&lt;                                                                        </span><br><span class="line">    rhoThermo,                                                          </span><br><span class="line">    pureMixture</span><br><span class="line">    &lt;</span><br><span class="line">        constTransport&lt;<span class="symbol">species:</span><span class="symbol">:thermo&lt;hConstThermo&lt;perfectGas&lt;specie&gt;&gt;</span>,sensibleInternalEnergy<span class="prompt">&gt;&gt;</span><br><span class="line">    </span>&gt;                 </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p>
<p>接下来就能来看看具体的类的继承派生关系了。</p>
<a id="more"></a>
<p>经过前面的分析，最终指针 <code>thermo_</code> 指向的是 <code>heRhoThermo</code> 类的对象，所以先来看一下 <code>heRhoThermo</code> 类。<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">BasicPsiThermo</span>, class <span class="type">MixtureType</span>&gt;</span><br><span class="line">class heRhoThermo</span><br><span class="line">:</span><br><span class="line">    public heThermo&lt;<span class="type">BasicPsiThermo</span>, <span class="type">MixtureType</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    // <span class="type">Private</span> <span class="type">Member</span> <span class="type">Functions</span></span><br><span class="line"></span><br><span class="line">        //- <span class="type">Calculate</span> the thermo variables</span><br><span class="line">        <span class="type">void</span> calculate();</span><br><span class="line"></span><br><span class="line">        //- <span class="type">Construct</span> <span class="keyword">as</span> copy (<span class="keyword">not</span> implemented)</span><br><span class="line">        heRhoThermo(<span class="keyword">const</span> heRhoThermo&lt;<span class="type">BasicPsiThermo</span>, <span class="type">MixtureType</span>&gt;&amp;);</span><br></pre></td></tr></table></figure></p>
<p><code>heRhoThermo</code> 类很简单，它继承自 <code>heThermo</code> 类，并且和 <code>heThermo</code> 类用同样的模板参数。<br>接下来看看 <code>heThermo</code> 类：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">BasicThermo</span>, class <span class="type">MixtureType</span>&gt;</span><br><span class="line">class heThermo</span><br><span class="line">:</span><br><span class="line">    public <span class="type">BasicThermo</span>,</span><br><span class="line">    public <span class="type">MixtureType</span></span><br><span class="line">&#123;</span><br><span class="line">protected:</span><br><span class="line"></span><br><span class="line">    // <span class="type">Protected</span> data</span><br><span class="line"></span><br><span class="line">        //- <span class="type">Energy</span> field</span><br><span class="line">        volScalarField he_;</span><br></pre></td></tr></table></figure></p>
<p>这里，前面多次提到的“继承其模板参数代表的类”这种模式又出现了。有了前两篇分析的基础，我们已经知晓了 <code>thermophysicalProperties</code> 文件里的设置将对应着怎么的一个具体的模型，所有的模板参数都一目了然。知道了模板参数，就能将模板类实例化，再分析其继承派生关系就不是问题了。探索的中间过程这里不详述了，只列出文章开头的那个实例对应的继承派生关系：</p>
<p><img src="/image/thermos/thermo.png" alt="继承派生关系"></p>
<p>注意几点：</p>
<ol>
<li>上图中有两个继承派生关系，其中 <code>constTransport</code> 这个类是作为 <code>pureMixture</code> 类的模板参数的，从而将这两个部分联系起来。</li>
<li><code>species::thermo</code> 中， <code>species</code> 是命名空间， <code>thermo</code> 是类名，具体定义在 <code>src/thermophysicalModels/specie/thermo/thermo/thermo.H</code>。</li>
<li><code>sensibleInternalEnergy</code> 类的模板参数中，某种程度上讲，包含了它自己！</li>
<li>mixture，transport，thermo，equationOfstate，specie，energy 这 6 个子模型有哪些可选的，这一点在 UserGuide 的第 7 章已经介绍得很清楚了，这里就不再重复了。</li>
</ol>
<p>了解了这些，就能理解热物理类的框架了。下一部分将针对 <code>twoPhaseEulerFoam</code> 的热物理相关的模块，来梳理一下热物理模型的流程，主要是，能量方程的构建，如何从能量来得到温度，其他依赖于温度的量包括粘度、密度、压力等又是如何更新的，希望能对传热的模拟有些指导作用，尤其是当出问题的时候，能大概知道可能的原因。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>根据上一篇的介绍，我们已经知道<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">thermoType</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title">type</span>             heRhoThermo;</span><br><span class="line">    <span class="title">mixture</span>          pureMixture;</span><br><span class="line">    <span class="title">transport</span>        const;</span><br><span class="line">    <span class="title">thermo</span>           hConst;</span><br><span class="line">    <span class="title">equationOfState</span>  perfectGas;</span><br><span class="line">    <span class="title">specie</span>           specie;</span><br><span class="line">    <span class="title">energy</span>           sensibleInternalEnergy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个设置对应的是下述类：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">heRhoThermo                                                                 </span><br><span class="line">&lt;                                                                        </span><br><span class="line">    rhoThermo,                                                          </span><br><span class="line">    pureMixture</span><br><span class="line">    &lt;</span><br><span class="line">        constTransport&lt;<span class="symbol">species:</span><span class="symbol">:thermo&lt;hConstThermo&lt;perfectGas&lt;specie&gt;&gt;</span>,sensibleInternalEnergy<span class="prompt">&gt;&gt;</span><br><span class="line">    </span>&gt;                 </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p>
<p>接下来就能来看看具体的类的继承派生关系了。</p>]]>
    
    </summary>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="thermophysicalModels" scheme="http://xiaopingqiu.github.io/tags/thermophysicalModels/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenFOAM 中的热物理类之 hashTable 的创建]]></title>
    <link href="http://xiaopingqiu.github.io/2016/06/25/thermophysics2/"/>
    <id>http://xiaopingqiu.github.io/2016/06/25/thermophysics2/</id>
    <published>2016-06-25T06:46:48.000Z</published>
    <updated>2016-06-25T07:25:49.472Z</updated>
    <content type="html"><![CDATA[<p>这一篇来看一下热物理类是如何编译并创建储存了可选模型的 hashTable 的。</p>
<a id="more"></a>
<p>根据以前的经验，编译和构建 hashTable 肯定是跟这个源文件有关：<code>src/thermophysicalModels/basic/rhoThermo/rhoThermos</code>。<br>这个文件里，全部都是在调用宏函数。而且，从宏函数的参数来看，似乎就是个排列组合的游戏，把所有可用的组合都写了一遍。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">makeThermo</span><br><span class="line">(</span><br><span class="line">    rhoThermo,</span><br><span class="line">    heRhoThermo,</span><br><span class="line">    pureMixture,</span><br><span class="line">    constTransport,</span><br><span class="line">    sensibleInternalEnergy,</span><br><span class="line">    hConstThermo,</span><br><span class="line">    perfectGas,</span><br><span class="line">    specie</span><br><span class="line">);</span><br><span class="line">......</span><br></pre></td></tr></table></figure></p>
<p>为了弄清这部分内容，需要先理解 <code>makeThermo</code> 这个宏函数的定义，见 <code>src/thermophysicalModels/basic/fluidThermo/makeThermo.H</code>：<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define makeThermoTypedefs(BaseThermo,Cthermo,Mixture,Transport,Type,Thermo,EqnOfState,Specie)\</span></span><br><span class="line">                                                                              <span class="string">\</span></span><br><span class="line">typedef                                                                       <span class="string">\</span></span><br><span class="line">    Transport                                                                 <span class="string">\</span></span><br><span class="line">    &lt;                                                                         <span class="string">\</span></span><br><span class="line">        <span class="attribute">species</span>::thermo                                                       <span class="string">\</span></span><br><span class="line">        &lt;                                                                     <span class="string">\</span></span><br><span class="line">            Thermo                                                            <span class="string">\</span></span><br><span class="line">            &lt;                                                                 <span class="string">\</span></span><br><span class="line">                EqnOfState                                                    <span class="string">\</span></span><br><span class="line">                &lt;                                                             <span class="string">\</span></span><br><span class="line">                    Specie                                                    <span class="string">\</span></span><br><span class="line">                &gt;                                                             <span class="string">\</span></span><br><span class="line">            &gt;,                                                                <span class="string">\</span></span><br><span class="line">            Type                                                              <span class="string">\</span></span><br><span class="line">        &gt;                                                                     <span class="string">\</span></span><br><span class="line">    &gt; Transport<span class="comment">##Type##Thermo##EqnOfState##Specie;                            \</span></span><br><span class="line">                                                                              <span class="string">\</span></span><br><span class="line">typedef                                                                       <span class="string">\</span></span><br><span class="line">    Cthermo                                                                   <span class="string">\</span></span><br><span class="line">    &lt;                                                                         <span class="string">\</span></span><br><span class="line">        BaseThermo,                                                           <span class="string">\</span></span><br><span class="line">        Mixture&lt;Transport<span class="comment">##Type##Thermo##EqnOfState##Specie&gt;                  \</span></span><br><span class="line">    &gt; Cthermo<span class="comment">##Mixture##Transport##Type##Thermo##EqnOfState##Specie;          \</span></span><br><span class="line">                                                                              <span class="string">\</span></span><br><span class="line">defineTemplateTypeNameAndDebugWithName                                        <span class="string">\</span></span><br><span class="line">(                                                                             <span class="string">\</span></span><br><span class="line">    Cthermo<span class="comment">##Mixture##Transport##Type##Thermo##EqnOfState##Specie,            \</span></span><br><span class="line">    (                                                                         <span class="string">\</span></span><br><span class="line">        <span class="comment">#Cthermo"&lt;"#Mixture"&lt;"                                                \</span></span><br><span class="line">      + Transport<span class="comment">##Type##Thermo##EqnOfState##Specie::typeName()               \</span></span><br><span class="line">      + <span class="string">"&gt;&gt;"</span>                                                                  <span class="string">\</span></span><br><span class="line">    ).c_str(),                                                                <span class="string">\</span></span><br><span class="line">    <span class="number">0</span>                                                                         <span class="string">\</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#define makeThermo(BaseThermo,Cthermo,Mixture,Transport,Type,Thermo,EqnOfState,Specie)\</span></span><br><span class="line">                                                                              <span class="string">\</span></span><br><span class="line">makeThermoTypedefs                                                            <span class="string">\</span></span><br><span class="line">(                                                                             <span class="string">\</span></span><br><span class="line">    BaseThermo,                                                               <span class="string">\</span></span><br><span class="line">    Cthermo,                                                                  <span class="string">\</span></span><br><span class="line">    Mixture,                                                                  <span class="string">\</span></span><br><span class="line">    Transport,                                                                <span class="string">\</span></span><br><span class="line">    Type,                                                                     <span class="string">\</span></span><br><span class="line">    Thermo,                                                                   <span class="string">\</span></span><br><span class="line">    EqnOfState,                                                               <span class="string">\</span></span><br><span class="line">    Specie                                                                    <span class="string">\</span></span><br><span class="line">)                                                                             <span class="string">\</span></span><br><span class="line">                                                                              <span class="string">\</span></span><br><span class="line">addToRunTimeSelectionTable                                                    <span class="string">\</span></span><br><span class="line">(                                                                             <span class="string">\</span></span><br><span class="line">    basicThermo,                                                              <span class="string">\</span></span><br><span class="line">    Cthermo<span class="comment">##Mixture##Transport##Type##Thermo##EqnOfState##Specie,            \</span></span><br><span class="line">    fvMesh                                                                    <span class="string">\</span></span><br><span class="line">);                                                                            <span class="string">\</span></span><br><span class="line">                                                                              <span class="string">\</span></span><br><span class="line">addToRunTimeSelectionTable                                                    <span class="string">\</span></span><br><span class="line">(                                                                             <span class="string">\</span></span><br><span class="line">    fluidThermo,                                                              <span class="string">\</span></span><br><span class="line">    Cthermo<span class="comment">##Mixture##Transport##Type##Thermo##EqnOfState##Specie,            \</span></span><br><span class="line">    fvMesh                                                                    <span class="string">\</span></span><br><span class="line">);                                                                            <span class="string">\</span></span><br><span class="line">                                                                              <span class="string">\</span></span><br><span class="line">addToRunTimeSelectionTable                                                    <span class="string">\</span></span><br><span class="line">(                                                                             <span class="string">\</span></span><br><span class="line">    BaseThermo,                                                               <span class="string">\</span></span><br><span class="line">    Cthermo<span class="comment">##Mixture##Transport##Type##Thermo##EqnOfState##Specie,            \</span></span><br><span class="line">    fvMesh                                                                    <span class="string">\</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>可见，在 <code>makeThermo</code> 这个宏函数里，先调用了 <code>makeThermoTypedefs</code> 宏函数，然后调用 <code>addToRunTimeSelectionTable</code> 函数。按照之前对 RTS 机制的理解，调用 <code>addToRunTimeSelectionTable</code> 函数的作用是往 hashTable 里插入元素，细节不需再赘述。这里主要来看看 <code>makeThermoTypedefs</code> 函数的功能，以上文列举的这个实例为例。先来看第一个 typedef：将实例中的参数代入后，<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef                                                                       \</span><br><span class="line">    constTransport&lt;<span class="symbol">species:</span><span class="symbol">:thermo&lt;hConstThermo&lt;perfectGas&lt;specie&gt;&gt;</span>,sensibleInternalEnergy<span class="prompt">&gt;&gt;  </span>\</span><br><span class="line">    constTransportsensibleEnthalpyhConstThermoperfectGasspecie;</span><br></pre></td></tr></table></figure></p>
<p>第二个 typedef<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef                                                                       <span class="string">\</span></span><br><span class="line">    heRhoThermo                                                                   <span class="string">\</span></span><br><span class="line">    &lt;                                                                         <span class="string">\</span></span><br><span class="line">        rhoThermo,                                                           <span class="string">\</span></span><br><span class="line">        pureMixture&lt;constTransportsensibleEnthalpyhConstThermoperfectGasspecie&gt;                  <span class="string">\</span></span><br><span class="line">    &gt;                                                                                       <span class="string">\</span>   heRhoThermopureMixtureconstTransportsensibleEnthalpyhConstThermoperfectGasspecie;          <span class="string">\</span></span><br></pre></td></tr></table></figure></p>
<p>除了这两个 typedef，还调用了 <code>defineTemplateTypeNameAndDebugWithName</code> 宏函数，这个函数的定义在 <code>src/OpenFOAM/db/typeInfo/className.H</code>：<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#define defineTemplateTypeNameAndDebugWithName(<span class="keyword">Type</span>, <span class="keyword">Name</span>, DebugSwitch)       \</span><br><span class="line">    defineTemplateTypeNameWithName(<span class="keyword">Type</span>, <span class="keyword">Name</span>);                               \</span><br><span class="line">    defineTemplateDebugSwitchWithName(<span class="keyword">Type</span>, <span class="keyword">Name</span>, DebugSwitch)</span><br><span class="line"></span><br><span class="line"># define defineTemplateTypeNameWithName(<span class="keyword">Type</span>, <span class="keyword">Name</span>)                           \</span><br><span class="line">    defineTypeNameWithName(<span class="keyword">Type</span>, <span class="keyword">Name</span>)</span><br><span class="line"></span><br><span class="line">#define defineTypeNameWithName(<span class="keyword">Type</span>, <span class="keyword">Name</span>)                                    \</span><br><span class="line">    const ::Foam::word <span class="keyword">Type</span>::typeName(<span class="keyword">Name</span>)</span><br></pre></td></tr></table></figure></p>
<p>很显然，这个宏函数的作用是修改类对应的 <code>typeName</code> 和 debug 选项。在 OpenFOAM 中，很多类中都会调用<br><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TypeName</span>(<span class="string">"xxxxx"</span>)</span><br><span class="line"><span class="string">``</span><span class="string">` </span><br><span class="line">这里的 `</span><span class="built_in">TypeName</span><span class="string">` 也是一个宏函数，定义在 `</span>src/OpenFOAM/db/typeInfo/className.H<span class="string">`:</span></span><br></pre></td></tr></table></figure></p>
<h1 id="define_TypeName(TypeNameString)_\">define TypeName(TypeNameString)                                              \</h1><pre><code>ClassName(TypeNameString);                                                \
<span class="keyword">virtual</span> <span class="keyword">const</span> word&amp; type() <span class="keyword">const</span> { <span class="keyword">return</span> typeName; }
</code></pre><h1 id="define_ClassName(TypeNameString)_\">define ClassName(TypeNameString)                                             \</h1><pre><code>ClassNameNoDebug(TypeNameString);                                         \
<span class="keyword">static</span> <span class="keyword">int</span> <span class="keyword">debug</span>
</code></pre><h1 id="define_ClassNameNoDebug(TypeNameString)_\">define ClassNameNoDebug(TypeNameString)                                      \</h1><pre><code><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* typeName_() { <span class="keyword">return</span> TypeNameString; }                 \
<span class="keyword">static</span> <span class="keyword">const</span> ::Foam::word typeName
</code></pre><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">可见， <span class="escape">`T</span>ypeName<span class="escape">` </span>这个宏函数，声明了一个类静态变量 <span class="escape">`t</span>ypeName<span class="escape">`，</span>定义了一个函数 <span class="escape">`t</span>ype<span class="escape">` </span>用于返回 <span class="escape">`t</span>ypeName<span class="escape">` </span>的值，并定义了一个静态变量 <span class="escape">`d</span>ebug<span class="escape">` </span>用于存储 debug 选项。这里与 RTS 机制有关的是 <span class="escape">`t</span>ypeName<span class="escape">` </span>这个变量。</span><br><span class="line"></span><br><span class="line">绕了半圈，回到 <span class="escape">`d</span>efineTemplateTypeNameAndDebugWithName<span class="escape">` </span>函数。了解了 <span class="escape">`t</span>ypeName<span class="escape">` </span>这个变量的定义，很容易就能看出来， <span class="escape">`d</span>efineTemplateTypeNameAndDebugWithName<span class="escape">` </span>这个函数其实就是在对类的静态变量 <span class="escape">`t</span>ypeName<span class="escape">` </span>进行赋值。根据上文的实例提供的参数，宏函数 <span class="escape">`d</span>efineTemplateTypeNameAndDebugWithName<span class="escape">` </span>可以理解为：对 <span class="escape">`h</span>eRhoThermopureMixtureconstTransportsensibleEnthalpyhConstThermoperfectGasspecie<span class="escape">` </span>对应的类的静态变量 <span class="escape">`t</span>ypeName<span class="escape">` </span>进行赋值，赋值结果为：</span><br><span class="line"><span class="escape">`h</span>eRhoThermo&lt;pureMixture&lt; + constTransport&lt;species::thermo&lt;hConstThermo&lt;perfectGas&lt;specie&gt;&gt;,sensibleInternalEnergy&gt;&gt;::typeName() + &gt;&gt;<span class="escape">`</span><br><span class="line"></span>。这里调用了 <span class="escape">`c</span>onstTransport<span class="escape">` </span>类的成员函数 <span class="escape">`t</span>ypeName()<span class="escape">`。</span></span><br><span class="line">经过一番冗长的函数调用，得到的最终结果是：将 <span class="escape">`h</span>eRhoThermopureMixtureconstTransportsensibleEnthalpyhConstThermoperfectGasspecie<span class="escape">` </span>对应的类的静态变量 <span class="escape">`t</span>ypeName<span class="escape">` </span>赋值为：<span class="escape">`h</span>eRhoThermo&lt;pureMixture&lt;const&lt;hConst&lt;perfectGas&lt;specie&gt;&gt;,sensiblesensibleEnthalpy&gt;&gt;&gt;<span class="escape">`。</span></span><br><span class="line"></span><br><span class="line">至此，经过一番宏函数的调用，得到了 <span class="escape">`a</span>ddToRunTimeSelectionTable<span class="escape">` </span>宏函数的参数。前面 RTS 机制部分讲过，这个函数的作用就是对 hashTable 增加元素，以</span><br></pre></td></tr></table></figure>
<p>addToRunTimeSelectionTable                                                    \<br>(                                                                             \<br>    BaseThermo,                                                               \<br>    Cthermo##Mixture##Transport##Type##Thermo##EqnOfState##Specie,            \<br>    fvMesh                                                                    \<br>);<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">为例，第一个参数，表示元素将增加到 <span class="escape">`B</span>aseThermo<span class="escape">` </span>类（这里是 <span class="escape">`r</span>hoThermo<span class="escape">` </span>）中声明的 hashTable，第二个参数，表示将要添加的类，添加成功以后，这个类的 <span class="escape">`t</span>ypeName<span class="escape">` </span>将是 hashTable 的 key，而返回这个类的对象的一个函数，将是 hashTable 的 value。第三个参数对应着 hashTable 对象的名字，fvMesh 对应的 hashTable 对象名为 <span class="escape">`f</span>vMeshConstructorTable<span class="escape">`，</span>这与在 <span class="escape">`r</span>hoThermo<span class="escape">` </span>中声明的名字是对应的。</span><br><span class="line"></span><br><span class="line">最后总结如下：</span><br><span class="line">宏函数</span><br></pre></td></tr></table></figure></p>
<p>makeThermo<br>(<br>    rhoThermo,<br>    heRhoThermo,<br>    pureMixture,<br>    constTransport,<br>    sensibleInternalEnergy,<br>    hConstThermo,<br>    perfectGas,<br>    specie<br>);<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">调用以后，向 <span class="escape">`r</span>hoThermo<span class="escape">` </span>类中声明的 hashTable 中增加了一组元素，其 key 为 <span class="escape">`h</span>eRhoThermo&lt;pureMixture&lt;const&lt;hConst&lt;perfectGas&lt;specie&gt;&gt;,sensibleInternalEnergy&gt;&gt;&gt;<span class="escape">` </span>，value 对应的函数返回的是类</span><br></pre></td></tr></table></figure></p>
<p>heRhoThermo<br>&lt;<br>    rhoThermo,<br>    pureMixture<br>    &lt;<br>        constTransport<species::thermo<hconstthermo<perfectgas<specie>&gt;,sensibleInternalEnergy&gt;&gt;</species::thermo<hconstthermo<perfectgas<specie></p>
<pre><code><span class="blockquote">&gt;                 </span>
</code></pre><blockquote>
<p>```<br>的对象。</p>
</blockquote>
<p>每调用一次 <code>makeThermo</code> 函数，就增加了一个新组元素，也即增加了一个可选的模型。不同的参数，其实对应的是不同的模板实例。<br>至此，就知道了在 <code>twoPhaseEulerFoam</code> 的 <code>phaseModel</code> 中定义的热物理类接口 <code>thermo_</code> 最终指向的是 <code>heRhoThermo</code> 类的对象。虽然代入的模板数很复杂，但整个架构仍然是基于 RTS 机制的。</p>
<p>接下来，要想理解能量方程，理解温度，粘度，压力等这些热物理相关的量是怎么计算更新的，就需要仔细看一下 <code>heRhoThermo</code> 类的继承派生关系了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这一篇来看一下热物理类是如何编译并创建储存了可选模型的 hashTable 的。</p>]]>
    
    </summary>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="thermophysicalModels" scheme="http://xiaopingqiu.github.io/tags/thermophysicalModels/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenFOAM 中的热物理类之接口]]></title>
    <link href="http://xiaopingqiu.github.io/2016/06/25/thermophysics1/"/>
    <id>http://xiaopingqiu.github.io/2016/06/25/thermophysics1/</id>
    <published>2016-06-25T06:27:14.000Z</published>
    <updated>2016-06-25T06:38:57.428Z</updated>
    <content type="html"><![CDATA[<p>本系列来看一下 OpenFOAM 中的热物理类。热物理类比较繁杂，这里先看一下纯物质的热物理模型。本篇先来看看热物理类在求解器中的接口，以2.3.x 版的 <code>twoPhaseEulerFoam</code> 为例。</p>
<a id="more"></a>
<p><code>twoPhaseEulerFoam</code> 中的热物理类的接口在 <code>phaseModel</code> 类中声明：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//- Thermophysical properties</span><br><span class="line">autoPtr&lt;rhoThermo&gt; thermo_<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">thermo_<span class="list">(<span class="keyword">rhoThermo</span>:<span class="keyword">:New</span><span class="list">(<span class="keyword">fluid</span>.mesh<span class="list">()</span>, name_)</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>可见，接口是 <code>rhoThermo</code> 类的指针。</p>
<p>接着看 <code>rhoThermo</code> 类的 <code>New</code> 函数。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//- Selector</span></span><br><span class="line"><span class="keyword">static</span> autoPtr&lt;rhoThermo&gt; <span class="keyword">New</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> fvMesh&amp;,</span><br><span class="line">    <span class="keyword">const</span> word&amp; phaseName=word::null</span><br><span class="line">);</span><br><span class="line">    </span><br><span class="line">Foam::autoPtr&lt;Foam::rhoThermo&gt; Foam::rhoThermo::New</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> fvMesh&amp; mesh,</span><br><span class="line">    <span class="keyword">const</span> word&amp; phaseName</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> basicThermo::New&lt;rhoThermo&gt;(mesh, phaseName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里调用的是 <code>basicThermo</code> 类的 <code>New</code> 函数。 这里先提一下继承关系，后面再细说：<code>rhoThermo</code> 类继承自 <code>fluidThermo</code> ， <code>fluidThermo</code> 类继承自 <code>basicThermo</code>。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//- <span class="type">Generic</span> <span class="type">New</span> <span class="keyword">for</span> each <span class="keyword">of</span> the related thermodynamics packages</span><br><span class="line">// basicThermo.C</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Thermo</span>&gt;</span><br><span class="line"><span class="keyword">static</span> autoPtr&lt;<span class="type">Thermo</span>&gt; <span class="type">New</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> fvMesh&amp;,</span><br><span class="line">    <span class="keyword">const</span> word&amp; phaseName=word::null</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Thermo</span>&gt;</span><br><span class="line"><span class="type">Foam</span>::autoPtr&lt;<span class="type">Thermo</span>&gt; <span class="type">Foam</span>::basicThermo::<span class="type">New</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> fvMesh&amp; mesh,</span><br><span class="line">    <span class="keyword">const</span> word&amp; phaseName</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">IOdictionary</span> thermoDict</span><br><span class="line">    (</span><br><span class="line">        <span class="type">IOobject</span></span><br><span class="line">        (</span><br><span class="line">            phasePropertyName(dictName, phaseName),</span><br><span class="line">            mesh.time().constant(),</span><br><span class="line">            mesh,</span><br><span class="line">            <span class="type">IOobject</span>::<span class="type">MUST_READ_IF_MODIFIED</span>,</span><br><span class="line">            <span class="type">IOobject</span>::<span class="type">NO_WRITE</span>,</span><br><span class="line">            <span class="literal">false</span></span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    typename <span class="type">Thermo</span>::fvMeshConstructorTable::<span class="keyword">iterator</span> cstrIter =</span><br><span class="line">        lookupThermo&lt;<span class="type">Thermo</span>, typename <span class="type">Thermo</span>::fvMeshConstructorTable&gt;</span><br><span class="line">        (</span><br><span class="line">            thermoDict,</span><br><span class="line">            <span class="type">Thermo</span>::fvMeshConstructorTablePtr_</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> autoPtr&lt;<span class="type">Thermo</span>&gt;(cstrIter()(mesh, phaseName));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据 RTS 机制的惯例， <code>New</code> 函数的功能是模型选择(<code>selector</code>)，即根据用户指定的关键字来选择对应的模型。 <code>New</code> 函数中先定义了一个 <code>IOdictionary</code> 类的对象， <code>thermoDict</code>，这个对象对应的正是热物理类的配置文件 <code>thermophysicalProperties</code>。<code>New</code> 函数里调用了 <code>lookupThermo</code> 函数，这个函数是关键：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// basicThermoTemplates.C</span></span><br><span class="line">template&lt;<span class="keyword">class</span> Thermo, <span class="keyword">class</span> <span class="keyword">Table</span>&gt;</span><br><span class="line">typename <span class="keyword">Table</span>::iterator Foam::basicThermo::lookupThermo</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> dictionary&amp; thermoDict,</span><br><span class="line">    <span class="keyword">Table</span>* tablePtr</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    word thermoTypeName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (thermoDict.isDict(<span class="string">"thermoType"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> dictionary&amp; thermoTypeDict(thermoDict.subDict(<span class="string">"thermoType"</span>));</span><br><span class="line"></span><br><span class="line">        Info&lt;&lt; <span class="string">"Selecting thermodynamics package "</span> &lt;&lt; thermoTypeDict &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> int nCmpt = 7;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* cmptNames[nCmpt] =</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"type"</span>,</span><br><span class="line">            <span class="string">"mixture"</span>,</span><br><span class="line">            <span class="string">"transport"</span>,</span><br><span class="line">            <span class="string">"thermo"</span>,</span><br><span class="line">            <span class="string">"equationOfState"</span>,</span><br><span class="line">            <span class="string">"specie"</span>,</span><br><span class="line">            <span class="string">"energy"</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Construct the name of the thermo package from the components</span></span><br><span class="line">        thermoTypeName =</span><br><span class="line">            <span class="literal">word</span>(thermoTypeDict.<span class="keyword">lookup</span>(<span class="string">"type"</span>)) + '&lt;'</span><br><span class="line">          + <span class="literal">word</span>(thermoTypeDict.<span class="keyword">lookup</span>(<span class="string">"mixture"</span>)) + '&lt;'</span><br><span class="line">          + <span class="literal">word</span>(thermoTypeDict.<span class="keyword">lookup</span>(<span class="string">"transport"</span>)) + '&lt;'</span><br><span class="line">          + <span class="literal">word</span>(thermoTypeDict.<span class="keyword">lookup</span>(<span class="string">"thermo"</span>)) + '&lt;'</span><br><span class="line">          + <span class="literal">word</span>(thermoTypeDict.<span class="keyword">lookup</span>(<span class="string">"equationOfState"</span>)) + '&lt;'</span><br><span class="line">          + <span class="literal">word</span>(thermoTypeDict.<span class="keyword">lookup</span>(<span class="string">"specie"</span>)) + <span class="string">"&gt;&gt;,"</span></span><br><span class="line">          + <span class="literal">word</span>(thermoTypeDict.<span class="keyword">lookup</span>(<span class="string">"energy"</span>)) + <span class="string">"&gt;&gt;&gt;"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Lookup the thermo package</span></span><br><span class="line">        typename <span class="keyword">Table</span>::iterator cstrIter = tablePtr-&gt;find(thermoTypeName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Print error message if package not found in the table</span></span><br><span class="line">        <span class="keyword">if</span> (cstrIter == tablePtr-&gt;end())</span><br><span class="line">        &#123;</span><br><span class="line">            FatalErrorIn(Thermo::typeName + <span class="string">"::New"</span>)</span><br><span class="line">                &lt;&lt; <span class="string">"Unknown "</span> &lt;&lt; Thermo::typeName &lt;&lt; <span class="string">" type "</span> &lt;&lt; <span class="keyword">nl</span></span><br><span class="line">                &lt;&lt; <span class="string">"thermoType"</span> &lt;&lt; thermoTypeDict &lt;&lt; <span class="keyword">nl</span> &lt;&lt; <span class="keyword">nl</span></span><br><span class="line">                &lt;&lt; <span class="string">"Valid "</span> &lt;&lt; Thermo::typeName &lt;&lt; <span class="string">" types are:"</span> &lt;&lt; <span class="keyword">nl</span> &lt;&lt; <span class="keyword">nl</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Get the list of all the suitable thermo packages available</span></span><br><span class="line">            wordList validThermoTypeNames</span><br><span class="line">            (</span><br><span class="line">                tablePtr-&gt;sortedToc()</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Build a table of the thermo packages constituent parts</span></span><br><span class="line">            <span class="comment">// Note: row-0 contains the names of constituent parts</span></span><br><span class="line">            <span class="keyword">List</span>&lt;wordList&gt; validThermoTypeNameCmpts</span><br><span class="line">            (</span><br><span class="line">                validThermoTypeNames.size() + 1</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            validThermoTypeNameCmpts[0].setSize(nCmpt);</span><br><span class="line">            forAll(validThermoTypeNameCmpts[0], j)</span><br><span class="line">            &#123;</span><br><span class="line">                validThermoTypeNameCmpts[0][j] = cmptNames[j];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Split the thermo package names into their constituent parts</span></span><br><span class="line">            forAll(validThermoTypeNames, i)</span><br><span class="line">            &#123;</span><br><span class="line">                validThermoTypeNameCmpts[i+1] =</span><br><span class="line">                    Thermo::splitThermoName(validThermoTypeNames[i], nCmpt);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Print the table of available packages</span></span><br><span class="line">            <span class="comment">// in terms of their constituent parts</span></span><br><span class="line">            printTable(validThermoTypeNameCmpts, FatalError);</span><br><span class="line"></span><br><span class="line">            FatalError&lt;&lt; <span class="keyword">exit</span>(FatalError);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cstrIter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        thermoTypeName = <span class="literal">word</span>(thermoDict.<span class="keyword">lookup</span>(<span class="string">"thermoType"</span>));</span><br><span class="line"></span><br><span class="line">        Info&lt;&lt; <span class="string">"Selecting thermodynamics package "</span> &lt;&lt; thermoTypeName &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        typename <span class="keyword">Table</span>::iterator cstrIter = tablePtr-&gt;find(thermoTypeName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cstrIter == tablePtr-&gt;end())</span><br><span class="line">        &#123;</span><br><span class="line">            FatalErrorIn(Thermo::typeName + <span class="string">"::New"</span>)</span><br><span class="line">                &lt;&lt; <span class="string">"Unknown "</span> &lt;&lt; Thermo::typeName &lt;&lt; <span class="string">" type "</span></span><br><span class="line">                &lt;&lt; thermoTypeName &lt;&lt; <span class="keyword">nl</span> &lt;&lt; <span class="keyword">nl</span></span><br><span class="line">                &lt;&lt; <span class="string">"Valid "</span> &lt;&lt; Thermo::typeName &lt;&lt; <span class="string">" types are:"</span> &lt;&lt; <span class="keyword">nl</span></span><br><span class="line">                &lt;&lt; tablePtr-&gt;sortedToc() &lt;&lt; <span class="keyword">nl</span></span><br><span class="line">                &lt;&lt; <span class="keyword">exit</span>(FatalError);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cstrIter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可见， <code>loopupThermo</code> 分两种情况处理，一种是 <code>thermophysicalProperties</code> 文件里有一个名为 <code>thermoType</code> 的 <code>subdict</code>，例如<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">thermoType</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title">type</span>            heRhoThermo;</span><br><span class="line">    <span class="title">mixture</span>         pureMixture;</span><br><span class="line">    <span class="title">transport</span>       const;</span><br><span class="line">    <span class="title">thermo</span>          hConst;</span><br><span class="line">    <span class="title">equationOfState</span> perfectGas;</span><br><span class="line">    <span class="title">specie</span>          specie;</span><br><span class="line">    <span class="title">energy</span>          sensibleInternalEnergy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种情况下， <code>subdict</code> 里的 7 个关键字将逐一读入，最终将合并起来，得到一个字符串，并赋值给 <code>thermoTypeName</code><br>以上面的那种情况为例，最终得到的<code>thermoTypeName</code> 为<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heRhoThermo&lt;pureMixture&lt;const&lt;hConst&lt;perfectGas&lt;specie<span class="prompt">&gt;&gt;</span>,sensibleInternalEnergy&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p>
<p>然后，根据这个关键词，从 hashTable 中找到对应的元素。如果找不到对应的，则报错，并输出所有可选的方案(由 <code>splitThermoName</code> 和 <code>printTable</code> 两个函数完成，细节这里暂且不表)。</p>
<p>另一种情况，直接从 <code>thermophysicalProperties</code> 读取 <code>thermoType</code> 对应的字符串并赋值给 <code>thermoTypeName</code>，然后据此来从 hashTable 中找到对应的元素。</p>
<p>OpenFOAM 自带的算例中，<code>thermophysicalProperties</code> 文件绝大部分采用前一种方式，因为更直观。后一种方式我在 OpenFOAM-2.3.x 版中只找到一个例子：tutorials/mesh/foamyQuadMesh/OpenCFD/constant/thermophysicalProperties<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thermoType      hePsiThermo&lt;pureMixture&lt;const&lt;hConst&lt;perfectGas&lt;specie<span class="prompt">&gt;&gt;</span>,sensibleEnthalpy&gt;&gt;&gt;;</span><br></pre></td></tr></table></figure></p>
<p>至此，大致就知道热物理类的接口定义是怎么回事了。但是，这个存储了可选模型的 hashTable 里有哪些内容，又是怎么构建起来的，还有待进一步深入探索。另外，从 <code>thermoType</code> 对应的字符串的样式，能猜到最终热物理类的接口 <code>thermo_</code> 指向的可能是类似 <code>heRhoThermo</code> 类的对象，而且这些类多半是模板类，并有着复杂的继承派生关系，这部分也还有待深入探索。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本系列来看一下 OpenFOAM 中的热物理类。热物理类比较繁杂，这里先看一下纯物质的热物理模型。本篇先来看看热物理类在求解器中的接口，以2.3.x 版的 <code>twoPhaseEulerFoam</code> 为例。</p>]]>
    
    </summary>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="thermophysicalModels" scheme="http://xiaopingqiu.github.io/tags/thermophysicalModels/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[涡结构提取]]></title>
    <link href="http://xiaopingqiu.github.io/2016/05/22/QAndLambda/"/>
    <id>http://xiaopingqiu.github.io/2016/05/22/QAndLambda/</id>
    <published>2016-05-22T11:35:16.000Z</published>
    <updated>2016-05-22T14:31:52.155Z</updated>
    <content type="html"><![CDATA[<p>为了研究湍流的涡结构，需要有一些方法来将涡结构提取出来，比图在文章中常见类似这种图：<br><img src="/image/vortex/Lambda2.png" alt="涡结构"></p>
<p>本篇介绍怎么在 OpenFOAM 中提取涡结构。</p>
<a id="more"></a>
<p>历史上曾用过的涡结构提取有以下几种：</p>
<ol>
<li><p>压强的局部极小值<br>在形成涡的地方，通常伴随着压强的极小值。比如:<br><img src="/image/vortex/p.png" alt=""><br>这种方法的缺点在于，缺乏客观的压力阈值来捕捉所有的涡结构，而且，压力出现极值的地方不见得就真的有涡。</p>
</li>
<li><p>流线<br>通过流线的封闭来显示涡的结构也是一种常见方法，比如<br><img src="/image/vortex/s.png" alt=""><br>这种方法有一个最明显的缺点是，流线不满足伽利略不变性，即，如果换一个参考系，则可能显示出来的“涡结构”就完全不一样了。另外，这种方法也难以分辨两个很靠近的涡。</p>
</li>
<li><p>涡量的模<br>用涡量的模来显示涡结构是一种很常用的方法，类似这样<br><img src="/image/vortex/magVor.png" alt=""><br>这种方法在自由剪切流中很有效，不过，对于壁面束缚流动则不太适用，原因是背景流动的剪切性导致的涡量模可以达到跟涡结构处的涡量的模差不多大小，这就使得涡结构难以从背景流动中分离出来了。并且，涡量的模的最大值通常发生在壁面上，而涡的核心显然不可能出现在壁面上。所以这种方法不适合用于提取边界层附近的涡结构。</p>
<p>OpenFOAM 中提供了两种方法来提取涡结构：Q 和 Lambda2。</p>
</li>
</ol>
<ul>
<li>速度梯度张量的二阶不变量<br>速度梯度 $\nabla \mathbf{U}$ 的二阶不变量 $Q$ 的定义为<br>$$<br>Q = \frac{1}{2}\Big ( ||\mathbf{W}||^2 - ||\mathbf{S}||^2 \Big )<br>$$<br>其中<br>$$<br>\mathbf{W} = \frac{1}{2} \Big ( \nabla \mathbf{U} - (\nabla \mathbf{U}) ^{\mathrm{T}} \Big ) \\<br>||\mathbf{W}|| = (\mathbf{W}:\mathbf{W})^{1/2} \\<br>\mathbf{S} = \frac{1}{2} \Big ( \nabla \mathbf{U} + (\nabla \mathbf{U}) ^{\mathrm{T}} \Big ) \\<br>||\mathbf{S}|| = (\mathbf{S}:\mathbf{S})^{1/2}<br>$$</li>
</ul>
<p>可以用 $Q &gt; 0$ 来作为涡结构存在的盘踞。<br>在 OpenFOAM 中，有一个程序用来计算 $Q$，名字就叫 <code>Q</code>。在流场计算完毕以后，可以运行 <code>Q</code>，然后在 paraview 中显示 <code>Q</code> 值大于 0 的等值面来显示涡的结构。只是，OpenFOAM 中 $Q$ 的计算用的是另一种方法：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Q.C </span></span><br><span class="line">volTensorField <span class="function">gradU</span>(fvc<span class="value">::<span class="function">grad</span>(U));</span></span><br><span class="line"></span><br><span class="line">volScalarField <span class="tag">Q</span></span><br><span class="line">(</span><br><span class="line">    IOobject</span><br><span class="line">    (</span><br><span class="line">        "<span class="tag">Q</span>",</span><br><span class="line">        runTime<span class="class">.timeName</span>(),</span><br><span class="line">        mesh,</span><br><span class="line">        IOobject<span class="value">::NO_READ,</span><br><span class="line">        IOobject::NO_WRITE</span><br><span class="line">    ),</span><br><span class="line">    <span class="number">0.5</span>*(<span class="function">sqr</span>(<span class="function">tr</span>(gradU)) - <span class="function">tr</span>(((gradU)&amp;(gradU))))</span><br><span class="line">);</span></span><br></pre></td></tr></table></figure>
<p>代码里注释说这是另一种计算 $Q$ 的方法，与上面公式的计算方法差别很小。</p>
<ul>
<li>张量 $\mathbf{W} \cdot \mathbf{W} + \mathbf{S} \cdot \mathbf{S}$ 的第二大特征值</li>
</ul>
<p>另一种判据是 $\mathbf{W} \cdot \mathbf{W} + \mathbf{S} \cdot \mathbf{S}$ 的第二大特征值 $\lambda _ 2 &lt; 0$。<br>在 OpenFOAM 中有一个程序用来计算 $\lambda _ 2$ ：<code>Lambda2</code>。<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Lambda2.C</span></span><br><span class="line"> const volTensorField <span class="function">gradU</span>(fvc<span class="value">::<span class="function">grad</span>(U));</span></span><br><span class="line"></span><br><span class="line">        volTensorField SSplusWW</span><br><span class="line">        (</span><br><span class="line">            (<span class="function">symm</span>(gradU) &amp; <span class="function">symm</span>(gradU)) + (<span class="function">skew</span>(gradU) &amp; <span class="function">skew</span>(gradU))</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        volScalarField Lambda2</span><br><span class="line">        (</span><br><span class="line">            IOobject</span><br><span class="line">            (</span><br><span class="line">                "Lambda2",</span><br><span class="line">                runTime<span class="class">.timeName</span>(),</span><br><span class="line">                mesh,</span><br><span class="line">                IOobject<span class="value">::NO_READ,</span><br><span class="line">                IOobject::NO_WRITE</span><br><span class="line">            ),</span><br><span class="line">            <span class="function">-eigenValues</span>(SSplusWW)().<span class="function">component</span>(vector::Y)</span><br><span class="line">        );</span></span><br><span class="line"></span><br><span class="line">        Info&lt;&lt; "    Writing -Lambda2" &lt;&lt; endl;</span><br><span class="line">        Lambda2<span class="class">.write</span>();</span><br></pre></td></tr></table></figure></p>
<p>注意，OpenFOAM 返回的是 $- \lambda _ 2$，所以，在计算了 <code>Lambda2</code> 后，需要通过 <code>Lambda2</code> 大于 0 的等值面来显示涡结构。本篇开头第一张图片，显示的是圆柱绕流的 <code>Lambda2 = 500</code> 等值面。</p>
<p><strong>参考</strong><br>Eugene de Villiers, The Potential of Large Eddy Simulation for the Modeling of Wall Bounded Flows, Ph.D Thesis, Imperial College of Science, 2005.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>为了研究湍流的涡结构，需要有一些方法来将涡结构提取出来，比图在文章中常见类似这种图：<br><img src="/image/vortex/Lambda2.png" alt="涡结构"></p>
<p>本篇介绍怎么在 OpenFOAM 中提取涡结构。</p>]]>
    
    </summary>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/tags/OpenFOAM/"/>
    
      <category term="Postprocessing" scheme="http://xiaopingqiu.github.io/tags/Postprocessing/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenFOAM 不可压缩湍流模型的 divDevReff 函数]]></title>
    <link href="http://xiaopingqiu.github.io/2016/05/03/divDevReff/"/>
    <id>http://xiaopingqiu.github.io/2016/05/03/divDevReff/</id>
    <published>2016-05-03T05:39:44.000Z</published>
    <updated>2016-05-03T05:58:35.645Z</updated>
    <content type="html"><![CDATA[<p>3.0 版本之前，OpenFOAM 的单相流求解器如 pisoFoam 的动量方程中调用的是湍流模型的 <code>divDevReff</code> 函数来考虑雷诺应力项的作用。只是，细究起来，这个函数似乎有点小问题，本篇来探讨一下这些小问题。</p>
<a id="more"></a>
<p>OpenFOAM 中单相不可压缩求解器中，雷诺应力项调用的是湍流模型中的 <code>divDevReff</code> 函数。这个函数的返回值为<br>$$<br>\nabla \cdot(\nu_{eff}\nabla U)+\nabla \cdot\left [\nu_{eff}\nabla U^\mathrm{T}-\frac{1}{3} \nu_{eff} (\nabla \cdot U) \mathbf{I} \right ]<br>$$<br>这里有两个疑问，第一是为什么是 $\frac{1}{3}$ 而不是 $\frac{2}{3}$，对应到代码，即为什么用 <code>dev</code> 函数而不是 <code>dev2</code> 函数？第二个问题，根据涡粘度的 Boussinesq approximation，雷诺应力项<br>$$<br>\overline{u’_iu’_j}= -\nu_t \left( \frac{\partial \bar{u}_i}{\partial x_j} + \frac{\partial \bar{u}_j}{\partial x_i} \right) + \frac{2}{3}k \delta_{ij}<br>$$<br>中应该还包含湍动能 $k$，而 OpenFOAM 中的 <code>divDefReff</code> 函数是没有 $k$ 这一项的。<br>这个话题，在 cfd-online 上的<a href="http://www.cfd-online.com/Forums/openfoam-solving/58214-calculating-divdevreff-2.html" target="_blank" rel="external">一篇帖子</a>里有深入的讨论。</p>
<p>对于第一个问题，我跟<a href="http://www.holzmann-cfd.de/index.php/en/tutorials-en" target="_blank" rel="external">Holtzmann CFD</a> 博客的博主 Tobias Holzmann 持同样观点，即$\frac{1}{3}$ 或 $\frac{2}{3}$ 不重要，因为对于不可压缩流动，连续方程为<br>$$<br>\nabla \cdot U = 0<br>$$<br>所以，收敛以后，$\frac{1}{3} \nu_{eff} (\nabla \cdot U)$ 这一项等于0. 但是在开始阶段，或者说还没有达到满足连续性的流场之前，这一项不为零。这里加上这一项是出于数值稳定性以及收敛速度的考虑，这一项不对收敛后的结果几乎没有影响。所以，$\frac{1}{3}$ 或 $\frac{2}{3}$ 不是很重要。<br>但是，可压缩湍流模型里必须是 $\frac{2}{3}$ ，因为这个 $\frac{2}{3}$ 是从 N-S 方程中严格推导而来的，而且，在可压缩的情形下，即使收敛以后，也有 $\nabla \cdot U \neq 0$ 。在 OpenFOAM=3.0 以后的版本里，不可压和可压缩湍流模型纳入到一个框架下了，两种情形下，都是用的 $\frac{2}{3}$ 这个系数。</p>
<p>对于第二个问题，有两种观点，一种认为 $k$ 的值相对很小，可以直接忽略不计。另一种观点认为，$k$ 被放到了压力项里，即，动量方程中的压力是雷诺时均压力与雷诺应力的各向同性分量（即 $\frac{2}{3}k$）之和：<br>$$<br>\bar{u}_j\frac{\partial\bar{u}_i}{\partial\bar{u}_j} =<br>-\frac{1}{\rho}\frac{\partial}{\partial x_i} \underbrace{\left[p + \frac{2}{3}k \right]}_{p^\prime}<br>+ \frac{\partial}{\partial x_j} \left[(\nu+\nu_{t}) \left( \frac{\partial \bar{u}_i}{\partial x_j} + \frac{\partial \bar{u}_j}{\partial x_i}\right) \right]<br>$$<br>这种观点可以在 Pope 2000 书第 88 页找到依据。在 “ The Finite Volume Method in Computational Fluid Dynamics: An Advanced Introduction with OpenFOAM® and Matlab®” 这本书的第 699 页，也提到 $k$ 是被放到压力项里去了，目的在于使动量方程中只含有 $\nu_t$ 这一个跟湍流有关的未知量。</p>
<p>不过，Tobias Holzmann 最后仍持前一种观点，即 $k$ 项被忽略了。理由是 OpenFOAM 中似乎找不到关于修改的压力场的代码，而且 OpenFOAM 那边也没见有人讨论说 OpenFOAM 中使用的是修改的压力场。<br>第二个问题目前还没有确切的结论，也尚不清楚这样处理对结果有多大影响。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>3.0 版本之前，OpenFOAM 的单相流求解器如 pisoFoam 的动量方程中调用的是湍流模型的 <code>divDevReff</code> 函数来考虑雷诺应力项的作用。只是，细究起来，这个函数似乎有点小问题，本篇来探讨一下这些小问题。</p>]]>
    
    </summary>
    
      <category term="turbulence model" scheme="http://xiaopingqiu.github.io/tags/turbulence-model/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LIGGGHTS tips]]></title>
    <link href="http://xiaopingqiu.github.io/2016/05/03/liggghts-howto/"/>
    <id>http://xiaopingqiu.github.io/2016/05/03/liggghts-howto/</id>
    <published>2016-05-03T04:38:31.000Z</published>
    <updated>2016-05-25T12:49:30.143Z</updated>
    <content type="html"><![CDATA[<p>本篇介绍几个 LIGGGHTS 技巧，read_data，freeze，move，modify_timing，neigh_modify。</p>
<a id="more"></a>
<p>LIGGGHTS 中可以用 STL 格式的几何面来模拟复杂边界的问题。如果想用冻结粒子当作壁面，可以采用如下方法。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span>_data test.dat</span><br><span class="line"></span><br><span class="line">group    Par_wall id &lt;&gt; <span class="number">1</span> <span class="number">1000</span>  </span><br><span class="line">fix       fr Par_wall freeze</span><br></pre></td></tr></table></figure></p>
<p>上述代码中，第一行是从外部文件中读取颗粒的信息；第二行是将ID在 1 到 1000 的粒子放到一个 group 里；第三行是将 Par_wall 这个 group 里的粒子冻结起来，具体的操作其实是将这些粒子的力归零，这样粒子将保持最初始的速度。如果将壁面粒子预先生成好，并将其初始速度设置为 0，便可以实现冻结粒子壁面了。</p>
<p>test.data 文件的数据格式如下，每一列数据的含义见注释：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">LAMMPS data file via write_data, version Version LIGGGHTS-PUBLIC <span class="number">3.2</span>.<span class="number">0</span>, git commit <span class="number">6</span>de550fbf3b8451f51246aa3c76374012e935340 based on LAMMPS <span class="number">23</span> Nov <span class="number">2013</span>, timestep = <span class="number">0</span>  <span class="comment">## 第一行随便是什么</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span> atoms  <span class="comment">## 颗粒数</span></span><br><span class="line"><span class="number">1</span> atom types <span class="comment">## 颗粒的 type 数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 模拟区域的大小</span></span><br><span class="line">-<span class="number">5.0009999999999999</span>e-<span class="number">01</span> <span class="number">5.0009999999999999</span>e-<span class="number">01</span> xlo xhi</span><br><span class="line">-<span class="number">2.0004000000000002</span>e-<span class="number">01</span> <span class="number">2.0004000000000002</span>e-<span class="number">01</span> ylo yhi</span><br><span class="line">-<span class="number">2.0005500000000001</span>e-<span class="number">01</span> <span class="number">3.4999999999999998</span>e-<span class="number">01</span> zlo zhi</span><br><span class="line"></span><br><span class="line">Atoms</span><br><span class="line"><span class="comment">#id type diameter density x y z i j k</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2.9999999999999999</span>e-<span class="number">02</span> <span class="number">2.5000000000000005</span>e+<span class="number">03</span> -<span class="number">2.9626205235821884</span>e-<span class="number">01</span> -<span class="number">1.7191257603378007</span>e-<span class="number">01</span> -<span class="number">5.2585560979625336</span>e-<span class="number">02</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">2.9999999999999999</span>e-<span class="number">02</span> <span class="number">2.5000000000000005</span>e+<span class="number">03</span> -<span class="number">3.1357080694177836</span>e-<span class="number">01</span> -<span class="number">8.1292507237863978</span>e-<span class="number">02</span> -<span class="number">3.0941241635135643</span>e-<span class="number">02</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">2.9999999999999999</span>e-<span class="number">02</span> <span class="number">2.5000000000000005</span>e+<span class="number">03</span> -<span class="number">3.4986005571676082</span>e-<span class="number">01</span> -<span class="number">4.6564797686740017</span>e-<span class="number">02</span> -<span class="number">5.0161637377833301</span>e-<span class="number">02</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">4</span> <span class="number">1</span> <span class="number">2.9999999999999999</span>e-<span class="number">02</span> <span class="number">2.5000000000000005</span>e+<span class="number">03</span> -<span class="number">3.2901105748658366</span>e-<span class="number">01</span> <span class="number">1.1629149478965480</span>e-<span class="number">01</span> -<span class="number">2.8537062345934828</span>e-<span class="number">02</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">5</span> <span class="number">1</span> <span class="number">5.0000000000000003</span>e-<span class="number">02</span> <span class="number">2.5000000000000000</span>e+<span class="number">03</span> -<span class="number">3.9692279707164302</span>e-<span class="number">01</span> <span class="number">1.5000972515153915</span>e-<span class="number">01</span> -<span class="number">3.5647118241865984</span>e-<span class="number">02</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Velocities <span class="comment">## 如果粒子的初始速度为零，这一段可以删去。</span></span><br><span class="line"><span class="comment">#id vx vy vz omegax omegay omegaz</span></span><br><span class="line"><span class="number">1</span> -<span class="number">1.5290519507823870</span>e+<span class="number">00</span> <span class="number">1.0245516532619933</span>e-<span class="number">01</span> -<span class="number">1.1594445288149451</span>e+<span class="number">00</span> <span class="number">6.3791250045904881</span>e+<span class="number">00</span> <span class="number">2.0674456758001139</span>e+<span class="number">02</span> <span class="number">1.0276923966595568</span>e+<span class="number">02</span></span><br><span class="line"><span class="number">2</span> -<span class="number">2.1385398568904033</span>e+<span class="number">00</span> -<span class="number">1.8858415304542153</span>e-<span class="number">01</span> -<span class="number">9.4897293591801291</span>e-<span class="number">01</span> <span class="number">1.2732686070189061</span>e+<span class="number">01</span> <span class="number">1.9114652955524940</span>e+<span class="number">02</span> -<span class="number">4.8862922016708987</span>e+<span class="number">00</span></span><br><span class="line"><span class="number">3</span> -<span class="number">2.1931823490540205</span>e+<span class="number">00</span> <span class="number">1.2314081721772643</span>e-<span class="number">01</span> -<span class="number">1.1305039942880526</span>e+<span class="number">00</span> -<span class="number">7.7211996358126047</span>e+<span class="number">00</span> <span class="number">1.8655504536271400</span>e+<span class="number">02</span> -<span class="number">3.5674698533544941</span>e+<span class="number">01</span></span><br><span class="line"><span class="number">4</span> -<span class="number">2.3661710510727509</span>e+<span class="number">00</span> <span class="number">6.5301832663338024</span>e-<span class="number">03</span> -<span class="number">9.2367025774174294</span>e-<span class="number">01</span> -<span class="number">5.7926985652143115</span>e-<span class="number">01</span> <span class="number">1.7594397127744105</span>e+<span class="number">02</span> <span class="number">6.1151183183219171</span>e+<span class="number">00</span></span><br><span class="line"><span class="number">5</span> -<span class="number">2.6032940321288258</span>e+<span class="number">00</span> <span class="number">1.7791968545582579</span>e-<span class="number">01</span> -<span class="number">1.0893683893889663</span>e+<span class="number">00</span> -<span class="number">1.6450273309025711</span>e+<span class="number">01</span> <span class="number">6.8599979334439681</span>e+<span class="number">01</span> <span class="number">3.4617478295022179</span>e+<span class="number">00</span></span><br></pre></td></tr></table></figure></p>
<p>上述能实现静止的壁面，如果希望用粒子来实现运动壁面（比如旋转），则可以用 move 命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">group rotateWall id &lt;&gt; <span class="number">1001</span> <span class="number">2000</span> <span class="comment"># 将 1001 &lt;= id &lt;= 2000 的粒子放到 group rotateWall 里</span></span><br><span class="line">fix mov rotateWall move rotate -<span class="number">19.8</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">8</span></span><br></pre></td></tr></table></figure></p>
<p>move 命令有不同的模式，这里用的是 rotate，用这个命令以后，rotateWall 这个 group 里的粒子，将按照指定的参数来进行旋转运动，而不再是根据其受力来更新速度和位置。参数的含义分别为：起始点坐标(x,y,z)；旋转轴的指向(x,y,z)；周期(转一圈的时间)。</p>
<p>最后再介绍几个小 tips：</p>
<ol>
<li>有时候想知道程序中哪一部分耗时最多，并据此来优化程序，这时可以在输入脚本的最开头，添加一句 modify_timing on ，之后在程序运行结束后会统计出每一条 fix 命令的耗时信息。</li>
<li>上述提到的冻结粒子壁面，在使用中会有一个问题：壁面粒子之间的距离通常是很小的，在建立粒子碰撞对的时候，壁面粒子之间通常会形成碰撞对，但壁面粒子之间没必要建立碰撞对，如果壁面粒子很多，这个建立过程是很耗时的。这种情况下，可以通过修改 neigh_modify 命令的参数来防止壁面粒子之间建立碰撞对：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">neigh_modify delay <span class="number">0</span> exclude group  Par_wall Par_wall</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这条命令将防止在 Par_wall 这个 group 里的粒子彼此之间建立碰撞对。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本篇介绍几个 LIGGGHTS 技巧，read_data，freeze，move，modify_timing，neigh_modify。</p>]]>
    
    </summary>
    
      <category term="LIGGGHTS" scheme="http://xiaopingqiu.github.io/tags/LIGGGHTS/"/>
    
      <category term="DEM" scheme="http://xiaopingqiu.github.io/categories/DEM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenFOAM 中的壁面函数（四）]]></title>
    <link href="http://xiaopingqiu.github.io/2016/04/25/wallFunctions4/"/>
    <id>http://xiaopingqiu.github.io/2016/04/25/wallFunctions4/</id>
    <published>2016-04-24T16:43:40.000Z</published>
    <updated>2016-04-25T03:14:35.521Z</updated>
    <content type="html"><![CDATA[<p>这篇来看看可能是最关键的 $\nu_t$ 的壁面函数。</p>
<a id="more"></a>
<h5 id="5-_湍流粘度_$\nu_t$_的壁面函数">5. 湍流粘度 $\nu_t$ 的壁面函数</h5><p>这个类型的壁面函数，结构比较简单，计算的是每一个壁面边界面上的湍流粘度 $\nu_t$。<br><code>nutWallFunction</code> 是虚基类，其中定义了一个纯虚函数 <code>calcNut</code><br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> tmp&lt;scalarField&gt; <span class="title">calcNut</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<p>并且在 <code>updateCoeffs</code> 函数中，将 <code>calcNut</code> 的返回值赋值给边界面<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> nutWallFunctionFvPatchScalarField::updateCoeffs()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (updated())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span>==(calcNut());</span><br><span class="line"></span><br><span class="line">    fixedValueFvPatchScalarField::updateCoeffs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样，在具体的那些计算 $\nu_t$ 的壁面函数中，只需要看 <code>calcNut</code> 的返回值就可以了。</p>
<ul>
<li>(1). nutkWallFunction<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">tmp&lt;scalarField&gt; nutkWallFunctionFvPatchScalarField::calcNut() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">label</span> patchi = patch().<span class="literal">index</span>();</span><br><span class="line">    <span class="keyword">const</span> turbulenceModel&amp; turbModel =</span><br><span class="line">        <span class="keyword">db</span>().lookupObject&lt;turbulenceModel&gt;(<span class="string">"turbulenceModel"</span>);</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; y = turbModel.<span class="literal">y</span>()[patchi];</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tk = turbModel.k();</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; k = tk();</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tnu = turbModel.nu();</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; nu = tnu();</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; nuw = nu.boundaryField()[patchi];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">scalar</span> Cmu25 = pow025(Cmu_);</span><br><span class="line">    tmp&lt;scalarField&gt; tnutw(new scalarField(patch().size(), 0.0));</span><br><span class="line">    scalarField&amp; nutw = tnutw();</span><br><span class="line">    forAll(nutw, faceI)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">label</span> faceCellI = patch().faceCells()[faceI];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">scalar</span> yPlus = Cmu25*y[faceI]*<span class="literal">sqrt</span>(k[faceCellI])/nuw[faceI];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (yPlus &gt; yPlusLam_)</span><br><span class="line">        &#123;</span><br><span class="line">            nutw[faceI] = nuw[faceI]*(yPlus*kappa_/<span class="literal">log</span>(E_*yPlus) - 1.0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tnutw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这里，仍然是分情况处理<br><code>yPlus &lt; yPlusLam_</code> 时，壁面上的 <code>nut</code> 设为0；<br><code>yPlus &gt; yPlusLam_</code> 时<br>$$<br>\nu_t = \nu \cdot \left( \frac{\kappa y^+}{\ln(Ey^+)}-1 \right)<br>$$<br>这里实现的其实就是标准壁面函数。理论上讲，这里的计算只在粘性底层和对数区是有效的，所以，使用这个壁面条件的时候，要尽量壁面网格落在过渡区，否则可能会引入较大误差。</p>
<p>顺带提一下，这里还定义了一个 <code>yPlus</code> 函数，用来计算 $y^+$，这个函数在这里没有调用，不过在其他代码中需要 $y^+$ 的时候会调用这个函数。比如，计算 $y^+$ 的应用 <code>yPlusRAS</code> 就是调用这里的 <code>yPlus</code> 函数来计算 $y^+$。<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">tmp&lt;scalarField&gt; nutkWallFunctionFvPatchScalarField::yPlus() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">label</span> patchi = patch().<span class="literal">index</span>();</span><br><span class="line">    <span class="keyword">const</span> turbulenceModel&amp; turbModel =</span><br><span class="line">        <span class="keyword">db</span>().lookupObject&lt;turbulenceModel&gt;(<span class="string">"turbulenceModel"</span>);</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; y = turbModel.<span class="literal">y</span>()[patchi];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tk = turbModel.k();</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; k = tk();</span><br><span class="line">    tmp&lt;scalarField&gt; kwc = k.boundaryField()[patchi].patchInternalField();</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tnu = turbModel.nu();</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; nu = tnu();</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; nuw = nu.boundaryField()[patchi];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pow025(Cmu_)*y*<span class="literal">sqrt</span>(kwc)/nuw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>(2). nutUWallFunction<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">tmp&lt;scalarField&gt; nutUWallFunctionFvPatchScalarField::calcNut() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">label</span> patchi = patch().<span class="literal">index</span>();</span><br><span class="line">    <span class="keyword">const</span> turbulenceModel&amp; turbModel =</span><br><span class="line">        <span class="keyword">db</span>().lookupObject&lt;turbulenceModel&gt;(<span class="string">"turbulenceModel"</span>);</span><br><span class="line">    <span class="keyword">const</span> fvPatchVectorField&amp; Uw = turbModel.<span class="keyword">U</span>().boundaryField()[patchi];</span><br><span class="line">    <span class="keyword">const</span> scalarField magUp(mag(Uw.patchInternalField() - Uw));</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tnu = turbModel.nu();</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; nu = tnu();</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; nuw = nu.boundaryField()[patchi];</span><br><span class="line">    tmp&lt;scalarField&gt; tyPlus = calcYPlus(magUp);</span><br><span class="line">    scalarField&amp; yPlus = tyPlus();</span><br><span class="line">    tmp&lt;scalarField&gt; tnutw(new scalarField(patch().size(), 0.0));</span><br><span class="line">    scalarField&amp; nutw = tnutw();</span><br><span class="line"></span><br><span class="line">    forAll(yPlus, facei)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (yPlus[facei] &gt; yPlusLam_)</span><br><span class="line">        &#123;</span><br><span class="line">            nutw[facei] =</span><br><span class="line">                nuw[facei]*(yPlus[facei]*kappa_/<span class="literal">log</span>(E_*yPlus[facei]) - 1.0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tnutw;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tmp&lt;scalarField&gt; nutUWallFunctionFvPatchScalarField::calcYPlus</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; magUp</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">label</span> patchi = patch().<span class="literal">index</span>();</span><br><span class="line">    <span class="keyword">const</span> turbulenceModel&amp; turbModel =</span><br><span class="line">        <span class="keyword">db</span>().lookupObject&lt;turbulenceModel&gt;(<span class="string">"turbulenceModel"</span>);</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; y = turbModel.<span class="literal">y</span>()[patchi];</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tnu = turbModel.nu();</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; nu = tnu();</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; nuw = nu.boundaryField()[patchi];</span><br><span class="line">    tmp&lt;scalarField&gt; tyPlus(new scalarField(patch().size(), 0.0));</span><br><span class="line">    scalarField&amp; yPlus = tyPlus();</span><br><span class="line">    forAll(yPlus, facei)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">scalar</span> kappaRe = kappa_*magUp[facei]*y[facei]/nuw[facei];</span><br><span class="line">        <span class="keyword">scalar</span> yp = yPlusLam_;</span><br><span class="line">        <span class="keyword">scalar</span> ryPlusLam = 1.0/yp;</span><br><span class="line">        int iter = 0;</span><br><span class="line">        <span class="keyword">scalar</span> yPlusLast = 0.0;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            yPlusLast = yp;</span><br><span class="line">            yp = (kappaRe + yp)/(1.0 + <span class="literal">log</span>(E_*yp));</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">while</span> (mag(ryPlusLam*(yp - yPlusLast)) &gt; 0.01 &amp;&amp; ++iter &lt; 10 );</span><br><span class="line"></span><br><span class="line">        yPlus[facei] = <span class="literal">max</span>(0.0, yp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tyPlus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这个壁函数的 $y^+$ 的计算方式跟 <code>nutkWallFunction</code> 有点区别。经过摸索，这里 <code>calcYPlus</code> 函数中的那段 <code>do ... while</code> 循环的原理如下：<br>对数律可以表达如下：<br>$$<br>U^+ = \frac{U_p}{u_\tau}=\frac{1}{\kappa}\ln(Ey^+)<br>$$<br>其中 $U_p$ 等于壁面上的速度减去壁面所属网格中心的速度。<br>经过简单变形<br>$$<br>\frac{U_p}{ y u_\tau/\nu }\cdot (y/\nu)=\frac{U_p}{ y^+}\cdot (y/\nu)=\frac{1}{\kappa}\ln(Ey^+)<br>$$<br>整理得<br>$$<br>y^+ \ln(Ey^+) - \frac{\kappa y U_p}{\nu}=0<br>$$<br>这是一个 $y^+$ 的一元方程，可以通过牛顿迭代来求解<br>$$<br>y^+_{n+1} = y^+_{n} - \frac{f(y^+)}{f^{\prime}(y+)} = y^+_{n}-\frac{y_n^+ \ln(Ey_n^+) - \frac{\kappa y U_p}{\nu}}{1+\ln(Ey_n^+)} = \frac{y_n^+ + \frac{\kappa y U_p}{\nu}}{1+\ln(Ey_n^+)}<br>$$<br>上面代码里的 <code>do ... while</code> 循环，正是在做这个迭代求解，初始值选择的是 <code>yPlusLam</code>，这个值在前面提过了。<br>求出 $y^+$ 以后，$\nu_t$ 计算如下<br>$$<br>\nu_t = \nu \cdot \left( \frac{\kappa y^+}{\ln(Ey^+)}-1 \right)<br>$$<br>与 <code>nutkWallFunction</code> 形式是一样的。</p>
<p>这个壁面函数，求壁面上的 $\nu_t$ 时使用的对数律方程，所以，理论上这个壁面函数应该只适用于第一层网格落在对数层的情形。</p>
<ul>
<li>(3). nutLowReWallFunction<br>这个壁面函数直接将壁面上的 $\nu_t$ 的值设为0。<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">tmp</span>&lt;<span class="tag">scalarField</span>&gt; <span class="rule"><span class="attribute">nutLowReWallFunctionFvPatchScalarField</span>:<span class="value">:<span class="function">calcNut</span>() const</span><br><span class="line">&#123;</span><br><span class="line">    return tmp&lt;scalarField&gt;(new <span class="function">scalarField</span>(<span class="function">patch</span>().<span class="function">size</span>(), <span class="number">0.0</span>))</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>$y^+$ 的计算也值得注意：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">tmp&lt;scalarField&gt; nutLowReWallFunctionFvPatchScalarField::yPlus() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">label</span> patchi = patch().<span class="literal">index</span>();</span><br><span class="line">    <span class="keyword">const</span> turbulenceModel&amp; turbModel =</span><br><span class="line">        <span class="keyword">db</span>().lookupObject&lt;turbulenceModel&gt;(<span class="string">"turbulenceModel"</span>);</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; y = turbModel.<span class="literal">y</span>()[patchi];</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tnu = turbModel.nu();</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; nu = tnu();</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; nuw = nu.boundaryField()[patchi];</span><br><span class="line">    <span class="keyword">const</span> fvPatchVectorField&amp; Uw = turbModel.<span class="keyword">U</span>().boundaryField()[patchi];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y*<span class="literal">sqrt</span>(nuw*mag(Uw.snGrad()))/nuw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>$$<br>y^+ = \frac{y\sqrt{\nu \cdot |\frac{U_w-U_c}{d}|}}{\nu}<br>$$<br>注意由于 $\nu_t = 0$ ，所以 $\frac{\tau_w}{\rho} = \nu \cdot |\frac{U_w-U_c}{d}|$，所以，$\sqrt{\nu \cdot |\frac{U_w-U_c}{d}|}=\sqrt{\frac{\tau_w}{\rho}}=u_\tau$ 。</p>
<ul>
<li>(4). nutUSpaldingWallFunction<br>这个壁函数基于 Spalding 提出的一个拟合的 $y^+$ 与 $u^+$ 的关系式，见文献 <em>A Single Formula for the “Law of the Wall” </em> 。<br>$$<br>y^+ = u^+ + \frac{1}{E}\left[ e^{\kappa u^+} -1-\kappa u^+ -\frac{1}{2}(\kappa u^+)^2 - \frac{1}{6}(\kappa u^+)^3 \right]<br>$$<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">tmp&lt;scalarField&gt; nutUSpaldingWallFunctionFvPatchScalarField::calcNut() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">label</span> patchI = patch().<span class="literal">index</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> turbulenceModel&amp; turbModel =</span><br><span class="line">        <span class="keyword">db</span>().lookupObject&lt;turbulenceModel&gt;(<span class="string">"turbulenceModel"</span>);</span><br><span class="line">    <span class="keyword">const</span> fvPatchVectorField&amp; Uw = turbModel.<span class="keyword">U</span>().boundaryField()[patchI];</span><br><span class="line">    <span class="keyword">const</span> scalarField magGradU(mag(Uw.snGrad()));</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tnu = turbModel.nu();</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; nu = tnu();</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; nuw = nu.boundaryField()[patchI];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">max</span></span><br><span class="line">    (</span><br><span class="line">        <span class="literal">scalar</span>(0),</span><br><span class="line">        sqr(calcUTau(magGradU))/(magGradU + ROOTVSMALL) - nuw</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tmp&lt;scalarField&gt; nutUSpaldingWallFunctionFvPatchScalarField::calcUTau</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; magGradU</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">label</span> patchI = patch().<span class="literal">index</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> turbulenceModel&amp; turbModel =</span><br><span class="line">        <span class="keyword">db</span>().lookupObject&lt;turbulenceModel&gt;(<span class="string">"turbulenceModel"</span>);</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; y = turbModel.<span class="literal">y</span>()[patchI];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> fvPatchVectorField&amp; Uw = turbModel.<span class="keyword">U</span>().boundaryField()[patchI];</span><br><span class="line">    <span class="keyword">const</span> scalarField magUp(mag(Uw.patchInternalField() - Uw));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tnu = turbModel.nu();</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; nu = tnu();</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; nuw = nu.boundaryField()[patchI];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; nutw = *this;</span><br><span class="line"></span><br><span class="line">    tmp&lt;scalarField&gt; tuTau(new scalarField(patch().size(), 0.0));</span><br><span class="line">    scalarField&amp; uTau = tuTau();</span><br><span class="line"></span><br><span class="line">    forAll(uTau, faceI)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">scalar</span> ut = <span class="literal">sqrt</span>((nutw[faceI] + nuw[faceI])*magGradU[faceI]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ut &gt; ROOTVSMALL)</span><br><span class="line">        &#123;</span><br><span class="line">            int iter = 0;</span><br><span class="line">            <span class="keyword">scalar</span> <span class="keyword">err</span> = GREAT;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">scalar</span> kUu = <span class="literal">min</span>(kappa_*magUp[faceI]/ut, 50);</span><br><span class="line">                <span class="keyword">scalar</span> fkUu = <span class="literal">exp</span>(kUu) - 1 - kUu*(1 + 0.5*kUu);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">scalar</span> f =</span><br><span class="line">                    - ut*y[faceI]/nuw[faceI]</span><br><span class="line">                    + magUp[faceI]/ut</span><br><span class="line">                    + 1/E_*(fkUu - 1.0/6.0*kUu*sqr(kUu));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">scalar</span> df =</span><br><span class="line">                    y[faceI]/nuw[faceI]</span><br><span class="line">                  + magUp[faceI]/sqr(ut)</span><br><span class="line">                  + 1/E_*kUu*fkUu/ut;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">scalar</span> uTauNew = ut + f/df;</span><br><span class="line">                <span class="keyword">err</span> = mag((ut - uTauNew)/ut);</span><br><span class="line">                ut = uTauNew;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">while</span> (ut &gt; ROOTVSMALL &amp;&amp; <span class="keyword">err</span> &gt; 0.01 &amp;&amp; ++iter &lt; 10);</span><br><span class="line"></span><br><span class="line">            uTau[faceI] = <span class="literal">max</span>(0.0, ut);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tuTau;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><code>calcUtau</code> 函数，其实是在用牛顿法迭代求解 $y^+$，进而得到 $u_\tau$ 的值。<code>calcNut</code> 函数中<br>$$<br>\frac{u_\tau ^2}{|\frac{U_w-U_c}{d}|} - \nu = \frac{\tau_w}{|\frac{U_w-U_c}{d}|} -\nu = \nu_{eff} - \nu = \nu_t<br>$$</p>
<p>这个壁面函数使用的是从粘性底层连续变化到对数层的 $y^+ \text{-} u^+$ 关系式，所以，这个可以认为是网格无关的，即不管第一层网格落在哪个区，都是有效的。如果网格无法做到全部位于粘性层或者对数区，建议用这个壁面条件。</p>
<ul>
<li>(5). nutUTabulatedWallFunction</li>
</ul>
<p>这个壁面函数，需要从外部读取一个 $U^+ \text{-}\,Re_y$ 数据表，通过从这个数据表插值来得到 $U^+$ 的值。其中 $Re_y=yU/\nu$ 。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">nutUTabulatedWallFunctionFvPatchScalarField::</span><br><span class="line">nutUTabulatedWallFunctionFvPatchScalarField</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> fvPatch&amp; p,</span><br><span class="line">    <span class="keyword">const</span> DimensionedField&lt;scalar, volMesh&gt;&amp; iF,</span><br><span class="line">    <span class="keyword">const</span> dictionary&amp; dict</span><br><span class="line">)</span><br><span class="line">:</span><br><span class="line">    nutWallFunctionFvPatchScalarField(p, iF, dict),</span><br><span class="line">    uPlusTableName_(dict.lookup(<span class="string">"uPlusTable"</span>)),</span><br><span class="line">    uPlusTable_</span><br><span class="line">    (</span><br><span class="line">        IOobject</span><br><span class="line">        (</span><br><span class="line">            uPlusTableName_,</span><br><span class="line">            patch().boundaryMesh().mesh().time().constant(),</span><br><span class="line">            patch().boundaryMesh().mesh(),</span><br><span class="line">            IOobject::MUST_READ_IF_MODIFIED,</span><br><span class="line">            IOobject::NO_WRITE,</span><br><span class="line">            <span class="keyword">false</span></span><br><span class="line">        ),</span><br><span class="line">        <span class="keyword">true</span></span><br><span class="line">    )</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>$U^+$ 和 $\nu_t$ 分别由函数 <code>calcUPlus</code> 和 <code>calcNut</code> 来计算。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">tmp&lt;scalarField&gt; nutUTabulatedWallFunctionFvPatchScalarField::calcNut() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">label</span> patchi = patch().<span class="literal">index</span>();</span><br><span class="line">    <span class="keyword">const</span> turbulenceModel&amp; turbModel =</span><br><span class="line">        <span class="keyword">db</span>().lookupObject&lt;turbulenceModel&gt;(<span class="string">"turbulenceModel"</span>);</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; y = turbModel.<span class="literal">y</span>()[patchi];</span><br><span class="line">    <span class="keyword">const</span> fvPatchVectorField&amp; Uw = turbModel.<span class="keyword">U</span>().boundaryField()[patchi];</span><br><span class="line">    <span class="keyword">const</span> scalarField magUp(mag(Uw.patchInternalField() - Uw));</span><br><span class="line">    <span class="keyword">const</span> scalarField magGradU(mag(Uw.snGrad()));</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tnu = turbModel.nu();</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; nu = tnu();</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; nuw = nu.boundaryField()[patchi];</span><br><span class="line">    <span class="literal">return</span></span><br><span class="line">        <span class="literal">max</span></span><br><span class="line">        (</span><br><span class="line">            <span class="literal">scalar</span>(0),</span><br><span class="line">            sqr(magUp/(calcUPlus(magUp*y/nuw) + ROOTVSMALL))</span><br><span class="line">           /(magGradU + ROOTVSMALL)</span><br><span class="line">          - nuw</span><br><span class="line">        );</span><br><span class="line">    <span class="comment">// magUp/UPlus = utau, sqr(utau) = tauw, tauw/magGradU = nuEff = nut + nu</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tmp&lt;scalarField&gt; nutUTabulatedWallFunctionFvPatchScalarField::calcUPlus</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; Rey</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    tmp&lt;scalarField&gt; tuPlus(new scalarField(patch().size(), 0.0));</span><br><span class="line">    scalarField&amp; uPlus = tuPlus();</span><br><span class="line">    forAll(uPlus, faceI)</span><br><span class="line">    &#123;</span><br><span class="line">        uPlus[faceI] = uPlusTable_.interpolateLog10(Rey[faceI]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tuPlus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这里 <code>calcUPlus</code> 用的是 <code>interpolateLog10</code> 函数来插值，这个函数的定义为<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">template&lt;<span class="keyword">class</span> <span class="keyword">Type</span>&gt;</span><br><span class="line"><span class="keyword">Type</span> Foam::uniformInterpolationTable&lt;<span class="keyword">Type</span>&gt;::interpolateLog10</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">scalar</span> x</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (log10_)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            x = ::<span class="literal">log10</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (bound_ &amp;&amp; (x &lt;= 0))</span><br><span class="line">        &#123;</span><br><span class="line">            x = x0_;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            FatalErrorIn</span><br><span class="line">            (</span><br><span class="line">                <span class="string">"uniformInterpolationTable&lt;Type&gt;::interpolateLog10(scalar x)"</span></span><br><span class="line">            )   &lt;&lt; <span class="string">"Table "</span> &lt;&lt; name() &lt;&lt; <span class="keyword">nl</span></span><br><span class="line">                &lt;&lt; <span class="string">"Supplied value must be greater than 0 when in log10 mode"</span></span><br><span class="line">                &lt;&lt; <span class="keyword">nl</span> &lt;&lt; <span class="string">"x="</span> &lt;&lt; x &lt;&lt; <span class="keyword">nl</span> &lt;&lt; <span class="keyword">exit</span>(FatalError);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> interpolate(x); <span class="comment">// 这个是普通的线性插值函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>即计算 <code>x</code> 的对数（log10），在将计算结果用来进行线性插值。所以，用这个壁面函数的时候，要注意你所提供的数据表是普通线性坐标的还是对数坐标的。</p>
<p>基本上常见的处理壁面上的湍流粘度的方法就是以上几种了。OpenFOAM 中还提供了几个能处理粗糙壁面的壁面函数( <code>nutURoughWallFunction</code> ， <code>nutkRoughWallFunction</code> )，以及处理大气层边界的(<code>nutkAtmRoughWallFunction</code>，需要跟 <code>atmBoundaryLayerInletVelocity</code> 这个入口边界配合使用 )，细节这里不再详述了，有需要时可以去看相关代码，代码结构是类似的，只是具体计算公式不一样。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这篇来看看可能是最关键的 $\nu_t$ 的壁面函数。</p>]]>
    
    </summary>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="wall functions" scheme="http://xiaopingqiu.github.io/tags/wall-functions/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenFOAM 中的壁面函数（三）]]></title>
    <link href="http://xiaopingqiu.github.io/2016/04/25/wallFunctions3/"/>
    <id>http://xiaopingqiu.github.io/2016/04/25/wallFunctions3/</id>
    <published>2016-04-24T16:43:34.000Z</published>
    <updated>2016-04-25T03:05:53.080Z</updated>
    <content type="html"><![CDATA[<p>这篇来看看计算湍动能 $\varepsilon$  和 $\omega$ 的壁面函数。</p>
<a id="more"></a>
<h5 id="3-_湍动能耗散_$\varepsilon$_的壁面函数">3. 湍动能耗散 $\varepsilon$ 的壁面函数</h5><p>本篇来看看 OpenFOAM 中的 <code>epsilonWallFunction</code>，共有两个： <code>epsilonWallFunction</code> 和 <code>epsilonLowReWallFunction</code>。</p>
<ul>
<li>(1). epsilonWallFunction</li>
</ul>
<p><code>epsilonWallFunction</code> 代码比前面的 <code>kqRWallFunction</code> 复杂多了，主要原因在于这里需要得到的是 <code>epsilon</code> 在临近网格的值，而且，需要考虑包含两个边界面的网格。这里先来梳理代码的脉络，然后再看具体的计算细节。<br>外部调用的主要是 <code>updateCoeffs()</code> 函数，所以，从这个函数看起。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> epsilonWallFunctionFvPatchScalarField::updateCoeffs()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (updated())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> turbulenceModel&amp; turbulence =</span><br><span class="line">        db().lookupObject&lt;turbulenceModel&gt;(turbulenceModel::typeName);</span><br><span class="line"></span><br><span class="line">    setMaster();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (patch().index() == master_)</span><br><span class="line">    &#123;</span><br><span class="line">        createAveragingWeights();</span><br><span class="line">        calculateTurbulenceFields(turbulence, G(<span class="keyword">true</span>), epsilon(<span class="keyword">true</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; G0 = <span class="keyword">this</span>-&gt;G();</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; epsilon0 = <span class="keyword">this</span>-&gt;epsilon();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> DimensionedField&lt;scalar, volMesh&gt; FieldType;</span><br><span class="line"></span><br><span class="line">    FieldType&amp; G =</span><br><span class="line">        <span class="keyword">const_cast</span>&lt;FieldType&amp;&gt;</span><br><span class="line">        (</span><br><span class="line">            db().lookupObject&lt;FieldType&gt;(turbulence.GName())</span><br><span class="line">        );</span><br><span class="line">    <span class="comment">//这里是获取内部场，所以，修改这里的引用 "epsilon",相当于修改 epsilon 的内部场值。</span></span><br><span class="line">    FieldType&amp; epsilon = <span class="keyword">const_cast</span>&lt;FieldType&amp;&gt;(dimensionedInternalField());</span><br><span class="line"></span><br><span class="line">    forAll(*<span class="keyword">this</span>, faceI)</span><br><span class="line">    &#123;</span><br><span class="line">        label cellI = patch().faceCells()[faceI];</span><br><span class="line"></span><br><span class="line">        G[cellI] = G0[cellI];</span><br><span class="line">        epsilon[cellI] = epsilon0[cellI];</span><br><span class="line">    &#125;</span><br><span class="line">    fvPatchField&lt;scalar&gt;::updateCoeffs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 一步一步来看。首先是调用了 <code>setMaster()</code> 函数，来看看这个函数以及相关的一个函数 <code>epsilonPatch</code> 的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> epsilonWallFunctionFvPatchScalarField::setMaster()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (master_ != -<span class="number">1</span>) <span class="comment">// 如果当前处理的边界的 master_ != -1，说明它已被处理过，直接返回</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; epsilon =</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> volScalarField&amp;&gt;(<span class="keyword">this</span>-&gt;dimensionedInternalField());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> volScalarField::GeometricBoundaryField&amp; bf = epsilon.boundaryField();</span><br><span class="line"></span><br><span class="line">    label master = -<span class="number">1</span>;</span><br><span class="line">    forAll(bf, patchI)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isA&lt;epsilonWallFunctionFvPatchScalarField&gt;(bf[patchI]))</span><br><span class="line">        &#123;</span><br><span class="line">            epsilonWallFunctionFvPatchScalarField&amp; epf = epsilonPatch(patchI);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (master == -<span class="number">1</span>) <span class="comment">// 只有头一个被处理的边界满足这个条件</span></span><br><span class="line">            &#123;</span><br><span class="line">                master = patchI;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            epf.master() = master; <span class="comment">// 这意味着所有边界的 master_ 数据成员都将赋值为头一个被处理的边界的编号，即第一个被处理的边界是master</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">epsilonWallFunctionFvPatchScalarField&amp;</span><br><span class="line">epsilonWallFunctionFvPatchScalarField::epsilonPatch(<span class="keyword">const</span> label patchI)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; epsilon =</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> volScalarField&amp;&gt;(<span class="keyword">this</span>-&gt;dimensionedInternalField());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> volScalarField::GeometricBoundaryField&amp; bf = epsilon.boundaryField();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> epsilonWallFunctionFvPatchScalarField&amp; epf =</span><br><span class="line">        refCast&lt;<span class="keyword">const</span> epsilonWallFunctionFvPatchScalarField&gt;(bf[patchI]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;epsilonWallFunctionFvPatchScalarField&amp;&gt;(epf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 从上述代码可以看出， <code>epsilonPatch</code> 函数需要一个参数，这个参数的含义是某一个边界的序号，返回的是指向这个边界的一个 <code>epsilonWallFunctionFvPatchScalarField</code> 类型的引用。<br>在此基础上，再来看 <code>setMaster</code>。先判断当前边界的数据成员 <code>master_</code> 是否不等于-1，如果成立则不做任何操作，直接返回；否则，先获取到 <code>epsilon</code> 的所有边界，存在变量 <code>bf</code> 中，然后，遍历 <code>bf</code> ，如果边界的类型是 <code>epsilonWallFunctionFvPatchScalarField</code>，则判断临时变量 <code>master</code> 是否等于 <code>-1</code>，等于则将边界的序号 <code>patchI</code>  赋值给 <code>master</code>，并临时变量 <code>master</code> 的值赋给 <code>patchI</code> 对应边界的数据成员 <code>master_</code>。 举个例子，假设有一个算例，有两个边界上使用了 <code>epsilonWallFunctionFvPatchScalarField</code> 类型的边界条件，两个边界的编号分别是 <code>patchI = 0</code> 和 <code>patchI = 1</code>。则在上述循环过程中，当 <code>patchI = 0</code>时， <code>master == -1</code> 肯定成立。于是，<code>patchI = 0</code> 对应边界的数据成员 <code>master_</code> 被赋值为0；而当遍历到 <code>patchI = 1</code> 时， 此时<code>master = 0</code>，所以，结果是 <code>patchI = 1</code> 的边界的数据成员 <code>master_</code> 也被赋值为0。 </p>
<p> 继续向下看，如果 <code>patch.index() == master_</code> ，则调用两个函数。这个怎么理解呢？还以上面的那个简单例子来说明。注意，在外部调用边界条件的时候，也是会依次调用一个场的所有边界的边界条件的。在这里的简单例子中，有两个边界的类型是 <code>epsilonWallFunctionFvPatchScalarField</code> ，所以，我们假设调用 <code>patchI = 0</code> 对应的边界时，由于初始化时数据成员 <code>master_</code> 赋值为 <code>-1</code> ，所以，调用 <code>patchI = 0</code> 的边界时， <code>setMaster</code> 函数中的操作会进行。而根据上面的分析，调用 <code>patchI = 0</code> 的边界时， <code>setMaster</code> 函数同时也将 <code>patchI = 1</code> 边界的数据成员 <code>master_</code> 赋值为 <code>0</code>了，所以，在外部调用 <code>patchI = 1</code> 的边界时， <code>setMaster</code> 函数将不作任何操作，直接返回。同样的，在外部调用 <code>patchI = 0</code> 的边界时，<code>patch.index() == master_</code> 条件是成立的，所以 <code>createAveragingWeights()</code> 和 <code>calculateTurbulenceFields(turbulence, G(true), epsilon(true));</code> 两个语句将会执行；而在外部调用 <code>patchI = 1</code> 边界时，由于 <code>patch.index() == master_</code> 不成立，这两个语句将不执行。</p>
<p> 再继续往前看， <code>const scalarField&amp; G0 = this-&gt;G();    const scalarField&amp; epsilon0 = this-&gt;epsilon();</code> ，这里是将成员函数 <code>G</code> 和 <code>epsilon</code> 的返回值分别赋给变量 <code>G0</code> 和 <code>epsilon0</code>。开看一下成员函数的定义<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">scalarField&amp; epsilonWallFunctionFvPatchScalarField::<span class="type">G</span>(bool <span class="keyword">init</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (patch().index() == master_) <span class="comment">// 只有头一个被处理的边界满足这个条件</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">init</span>) <span class="comment">// init 缺省值是 false </span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">G_</span> = <span class="number">0.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">G_</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> epsilonPatch(master_).<span class="type">G</span>(); <span class="comment">// 对于不是 master 的边界，返回master边界的数据成员 G_</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">scalarField&amp; epsilonWallFunctionFvPatchScalarField::epsilon(bool <span class="keyword">init</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (patch().index() == master_)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">init</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            epsilon_ = <span class="number">0.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> epsilon_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> epsilonPatch(master_).epsilon(<span class="keyword">init</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>类似的，对于 <code>patchI = 0</code>， <code>patch().index() == master_</code> ，所以返回值为 <code>patchI = 0</code> 边界的数据成员 <code>G_</code> 或  <code>epsilon_</code> (<code>init</code> 的缺省值是 <code>false</code>)；而对于 <code>patchI = 1</code>边界，返回的是 <code>patchI = master_</code> 对应边界的数据成员 <code>G_</code> 或  <code>epsilon_</code>，而根据上面的分析， <code>patchI= 1</code> 的边界的数据成员 <code>master_ = 0</code>，因此， <code>patchI = 1</code> 的边界的成员函数返回的是 <code>patchI = 0</code>边界的相应的数据成员。</p>
<p>再往下的内容就很简单了，只是将得到的 <code>G0</code> 和 <code>epsilon0</code> 的值分别赋给当前边界的临近边界网格而已。</p>
<p>到此，代码的框架就基本清晰了，小结一下就是，如果对于某个算例，有多个边界上需要用到 <code>epsilonWallFunctionFvPatchScalarField</code> 类型的边界条件，则，编号更小的那个边界将会被设置成 <code>master</code>。所有的相关计算都在调用 <code>master</code> 边界的时候进行，非 <code>master</code> 的边界，则只需要从 <code>master</code> 那里读取结果即可！ </p>
<p>接下来看看外部调用 <code>master</code> 边界的时候，具体做了哪些计算，主要就是看 <code>createAveragingWeights()</code> 和 <code>calculateTurbulenceFields(turbulence, G(true), epsilon(true));</code> 这两条语句了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> epsilonWallFunctionFvPatchScalarField::createAveragingWeights()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; epsilon =</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> volScalarField&amp;&gt;(<span class="keyword">this</span>-&gt;dimensionedInternalField());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> volScalarField::GeometricBoundaryField&amp; bf = epsilon.boundaryField();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> fvMesh&amp; mesh = epsilon.mesh();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (initialised_ &amp;&amp; !mesh.changing())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">volScalarField <span class="title">weights</span></span><br><span class="line">    <span class="params">(</span><br><span class="line">        IOobject</span><br><span class="line">        (</span><br><span class="line">            "weights",</span><br><span class="line">            mesh.time()</span>.<span class="title">timeName</span><span class="params">()</span>,</span><br><span class="line">            mesh,</span><br><span class="line">            IOobject::NO_READ,</span><br><span class="line">            IOobject::NO_WRITE,</span><br><span class="line">            <span class="keyword">false</span> <span class="comment">// do not register</span></span><br><span class="line">        ),</span><br><span class="line">        mesh,</span><br><span class="line">        <span class="title">dimensionedScalar</span><span class="params">("zero", dimless, 0.0)</span></span><br><span class="line">    )</span>;</span><br><span class="line"></span><br><span class="line">    DynamicList&lt;label&gt; epsilonPatches(bf.size());</span><br><span class="line">    <span class="comment">//遍历所有边界，如果边界类型是 epsilonWallFunctionFvPatchScalarField 则将该边界放到 epsilonPatches 这个动态 list 中。</span></span><br><span class="line">    forAll(bf, patchI)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isA&lt;epsilonWallFunctionFvPatchScalarField&gt;(bf[patchI]))</span><br><span class="line">        &#123;</span><br><span class="line">            epsilonPatches.append(patchI);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> labelUList&amp; faceCells = bf[patchI].patch().faceCells();</span><br><span class="line">            forAll(faceCells, i)</span><br><span class="line">            &#123;</span><br><span class="line">                label cellI = faceCells[i];</span><br><span class="line">            <span class="comment">// weight 衡量的是网格cellI有多少个边界面使用了 epsilonWallFunctionFvPatchScalarField 类型的边界条件</span></span><br><span class="line">                 weights[cellI]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cornerWeights_.setSize(bf.size());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历所有 epsilonWallFunctionFvPatchScalarField 类型的边界</span></span><br><span class="line">    forAll(epsilonPatches, i)</span><br><span class="line">    &#123;</span><br><span class="line">        label patchI = epsilonPatches[i];</span><br><span class="line">        <span class="keyword">const</span> fvPatchScalarField&amp; wf = weights.boundaryField()[patchI];</span><br><span class="line">    <span class="comment">//cornerWeights_存储的所有边界面的weight的倒数，边界面的weight等于其所属网格的weight。所以，如果有一个网格包含两个使用epsilonWallFunction的边界面，那么根据上面的计算，这个网格的weight将是 2，而这两个边界面的 cornerWeights_ 则都是 1/2。 </span></span><br><span class="line">        cornerWeights_[patchI] = <span class="number">1.0</span>/wf.patchInternalField();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将数据成员 G_ 和 epsilon_ 初始化为0</span></span><br><span class="line">    G_.setSize(dimensionedInternalField().size(), <span class="number">0.0</span>);</span><br><span class="line">    epsilon_.setSize(dimensionedInternalField().size(), <span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">    initialised_ = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> epsilonWallFunctionFvPatchScalarField::calculateTurbulenceFields</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> turbulenceModel&amp; turbulence,</span><br><span class="line">    scalarField&amp; G0,</span><br><span class="line">    scalarField&amp; epsilon0</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// accumulate all of the G and epsilon contributions</span></span><br><span class="line">    <span class="comment">//cornerWeights_ 是一个二维 list，这里是遍历这个list 的第一层</span></span><br><span class="line">    forAll(cornerWeights_, patchI)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!cornerWeights_[patchI].empty()) <span class="comment">// 如果是empty，意味着这个对应的边界不是epsilonWallFunction类型，所以就不需要考虑</span></span><br><span class="line">        &#123;</span><br><span class="line">            epsilonWallFunctionFvPatchScalarField&amp; epf = epsilonPatch(patchI);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> List&lt;scalar&gt;&amp; w = cornerWeights_[patchI];</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 非 empty 则调用 calculate 函数更新 G0 和 epsilon 的值</span></span><br><span class="line">            epf.calculate(turbulence, w, epf.patch(), G0, epsilon0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// apply zero-gradient condition for epsilon</span></span><br><span class="line">    forAll(cornerWeights_, patchI)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!cornerWeights_[patchI].empty())</span><br><span class="line">        &#123;</span><br><span class="line">            epsilonWallFunctionFvPatchScalarField&amp; epf = epsilonPatch(patchI);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对 epsilon 使用 零梯度边界条件，即将上面计算得到的临近壁面网格的epsilon的值存储在壁面。</span></span><br><span class="line">            epf == scalarField(epsilon0, epf.patch().faceCells());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> epsilonWallFunctionFvPatchScalarField::calculate</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> turbulenceModel&amp; turbulence,</span><br><span class="line">    <span class="keyword">const</span> List&lt;scalar&gt;&amp; cornerWeights,</span><br><span class="line">    <span class="keyword">const</span> fvPatch&amp; patch,</span><br><span class="line">    scalarField&amp; G,</span><br><span class="line">    scalarField&amp; epsilon</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> label patchI = patch.index();</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; y = turbulence.y()[patchI];</span><br><span class="line">    <span class="keyword">const</span> scalar Cmu25 = pow025(Cmu_);</span><br><span class="line">    <span class="keyword">const</span> scalar Cmu75 = <span class="built_in">pow</span>(Cmu_, <span class="number">0.75</span>);</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tk = turbulence.k();</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; k = tk();</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tnu = turbulence.nu();</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; nuw = tnu().boundaryField()[patchI];</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tnut = turbulence.nut();</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; nut = tnut();</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; nutw = nut.boundaryField()[patchI];</span><br><span class="line">    <span class="keyword">const</span> fvPatchVectorField&amp; Uw = turbulence.U().boundaryField()[patchI];</span><br><span class="line">    <span class="function"><span class="keyword">const</span> scalarField <span class="title">magGradUw</span><span class="params">(mag(Uw.snGrad()</span>))</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set epsilon and G</span></span><br><span class="line">    遍历参数 patch 对应的边界的每一个面</span><br><span class="line">    forAll(nutw, faceI)</span><br><span class="line">    &#123;</span><br><span class="line">        label cellI = patch.faceCells()[faceI];</span><br><span class="line">        scalar w = cornerWeights[faceI];</span><br><span class="line">        </span><br><span class="line">        epsilon[cellI] += w*Cmu75*<span class="built_in">pow</span>(k[cellI], <span class="number">1.5</span>)/(kappa_*y[faceI]);</span><br><span class="line">        G[cellI] +=</span><br><span class="line">            w</span><br><span class="line">           *(nutw[faceI] + nuw[faceI])</span><br><span class="line">           *magGradUw[faceI]</span><br><span class="line">           *Cmu25*<span class="built_in">sqrt</span>(k[cellI])</span><br><span class="line">           /(kappa_*y[faceI]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>calculate</code> 函数中进行的是实际的计算过程，主要是更新了临近壁面网格的 <code>epsilon</code> 和 <code>G</code> 的值，计算公式如下：<br>$$<br>\varepsilon_c = \frac{1}{N} \sum_{f=i}^{N}\left( \frac{c_\mu^{3/4} k_C^{3/2}}{\kappa y_i}\right) \\<br>\text{相当于} \quad \quad \quad<br>\varepsilon ^+ = \frac{1}{\kappa y^+} \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad<br>$$</p>
<p>$$<br>G_c = \frac{1}{N} \sum_{f=i}^{N}\left( \frac{(\nu + \nu_t)\cdot |\tfrac{U_i-U_c}{d}|\cdot c_\mu^{1/4} k_C^{1/2}}{\kappa y_i}\right)<br>$$<br>这里的 <code>Uw.snGrad()</code> 是 <code>fvPatchFields&lt;Type&gt;</code> 类的成员函数：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class <span class="constant">Type&gt;</span></span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:tmp&lt;Foam</span><span class="symbol">:</span><span class="symbol">:Field&lt;Type&gt;</span> &gt; <span class="constant">Foam:</span><span class="symbol">:fvPatchField&lt;Type&gt;</span><span class="symbol">:</span><span class="symbol">:snGrad</span>() const</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">return</span> patch<span class="constant">_</span>.deltaCoeffs()*(*this - patchInternalField());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>公式中下标 <code>c</code> 表示临近边界的网格， <code>i</code> 表示网格 <code>c</code> 包含的某个边界面元。<code>y</code> 和 <code>d</code> 都表示边界面元所属网格中心到该面元的垂直距离。 </p>
<p>还有一个重要的函数， <code>manipulateMatrix</code><br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void epsilonWallFunctionFvPatchScalarField::manipulateMatrix</span><br><span class="line">(</span><br><span class="line">    fvMatrix&lt;<span class="keyword">scalar</span>&gt;&amp; <span class="literal">matrix</span></span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (manipulatedMatrix())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">matrix</span>.setValues(patch().faceCells(), patchInternalField());</span><br><span class="line"></span><br><span class="line">    fvPatchField&lt;<span class="keyword">scalar</span>&gt;::manipulateMatrix(<span class="keyword">matrix</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数的功能是修改 matrix 中的值，将当前 patch 每一个面所属网格的值更新到 matrix 中，参考<a href="http://www.cfd-online.com/Forums/openfoam-solving/132703-boundarymanipulate.html" target="_blank" rel="external">这个帖子</a>。</p>
<p>如果不是使用的低雷诺数湍流模型，则 $\varepsilon$ 应该使用这个边界条件。理论上，边界第一层网格应该设置在对数区。什么是低雷诺数湍流模型呢？<a href="http://www.cfd-online.com/Forums/openfoam/125473-low-reynolds-turbulence-models.html" target="_blank" rel="external">这篇帖子</a>的三楼有精彩的解释。</p>
<ul>
<li>(2). epsilonLowReWallFunction</li>
</ul>
<p><code>epsilonLowReWallFunction</code> 继承自 <code>epsilonWallFunction</code> ，在此基础上，增加了一个成员函数 <code>yPlusLam</code>，并重新定义了 <code>calculate</code> 函数<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">scalar</span> epsilonLowReWallFunctionFvPatchScalarField::yPlusLam</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">scalar</span> <span class="keyword">kappa</span>,</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">scalar</span> <span class="literal">E</span></span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">scalar</span> ypl = 11.0;</span><br><span class="line">    <span class="keyword">for</span> (int i=0; i&lt;10; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ypl = <span class="literal">log</span>(<span class="literal">max</span>(<span class="keyword">E</span>*ypl, 1))/<span class="keyword">kappa</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ypl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个跟 <code>kLowReWallFunction</code> 里是一样的，不再赘述。<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">void epsilonLowReWallFunctionFvPatchScalarField::calculate</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> turbulenceModel&amp; turbulence,</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">List</span>&lt;<span class="keyword">scalar</span>&gt;&amp; cornerWeights,</span><br><span class="line">    <span class="keyword">const</span> fvPatch&amp; patch,</span><br><span class="line">    scalarField&amp; <span class="keyword">G</span>,</span><br><span class="line">    scalarField&amp; epsilon</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">label</span> patchI = patch.<span class="literal">index</span>();</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; y = turbulence.<span class="literal">y</span>()[patchI];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">scalar</span> Cmu25 = pow025(Cmu_);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">scalar</span> Cmu75 = pow(Cmu_, 0.75);</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tk = turbulence.k();</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; k = tk();</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tnu = turbulence.nu();</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; nuw = tnu().boundaryField()[patchI];</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tnut = turbulence.nut();</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; nut = tnut();</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; nutw = nut.boundaryField()[patchI];</span><br><span class="line">    <span class="keyword">const</span> fvPatchVectorField&amp; Uw = turbulence.<span class="keyword">U</span>().boundaryField()[patchI];</span><br><span class="line">    <span class="keyword">const</span> scalarField magGradUw(mag(Uw.snGrad()));</span><br><span class="line">    </span><br><span class="line"><span class="comment">// Set epsilon and G</span></span><br><span class="line">    forAll(nutw, faceI)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">label</span> cellI = patch.faceCells()[faceI];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">scalar</span> yPlus = Cmu25*<span class="literal">sqrt</span>(k[cellI])*y[faceI]/nuw[faceI];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">scalar</span> w = cornerWeights[faceI];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (yPlus &gt; yPlusLam_)</span><br><span class="line">        &#123;</span><br><span class="line">            epsilon[cellI] = w*Cmu75*pow(k[cellI], 1.5)/(kappa_*y[faceI]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            epsilon[cellI] = w*2.0*k[cellI]*nuw[faceI]/sqr(y[faceI]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">G</span>[cellI] =</span><br><span class="line">            <span class="literal">w</span></span><br><span class="line"><span class="comment">           *(nutw[faceI] + nuw[faceI])</span></span><br><span class="line"><span class="comment">           *magGradUw[faceI]</span></span><br><span class="line"><span class="comment">           *Cmu25*sqrt(k[cellI])</span></span><br><span class="line">           /(kappa_*y[faceI]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里需要根据 <code>yPlus</code> 和 <code>yPlusLam_</code> 的相对大小来选择不同的计算方式。只是，上面这段来自 OpenFOAM-2.3.1 的代码是有问题的！在OpenFOAM-3.0.1 中已经修复成如下<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="atom">forAll</span>(<span class="atom">nutw</span>, <span class="atom">facei</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="atom">label</span> <span class="atom">celli</span> = <span class="atom">patch</span>.<span class="atom">faceCells</span>()[<span class="atom">facei</span>];</span><br><span class="line"></span><br><span class="line">        <span class="atom">scalar</span> <span class="atom">yPlus</span> = <span class="name">Cmu25</span>*<span class="atom">sqrt</span>(<span class="atom">k</span>[<span class="atom">celli</span>])*<span class="atom">y</span>[<span class="atom">facei</span>]/<span class="atom">nuw</span>[<span class="atom">facei</span>];</span><br><span class="line"></span><br><span class="line">        <span class="atom">scalar</span> <span class="atom">w</span> = <span class="atom">cornerWeights</span>[<span class="atom">facei</span>];</span><br><span class="line"></span><br><span class="line">        <span class="atom">if</span> (<span class="atom">yPlus</span> &gt; <span class="atom">yPlusLam_</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="atom">epsilon0</span>[<span class="atom">celli</span>] += <span class="atom">w</span>*<span class="name">Cmu75</span>*<span class="atom">pow</span>(<span class="atom">k</span>[<span class="atom">celli</span>], <span class="number">1.5</span>)/(<span class="atom">kappa_</span>*<span class="atom">y</span>[<span class="atom">facei</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="name">G0</span>[<span class="atom">celli</span>] +=</span><br><span class="line">                <span class="atom">w</span></span><br><span class="line">               *(<span class="atom">nutw</span>[<span class="atom">facei</span>] + <span class="atom">nuw</span>[<span class="atom">facei</span>])</span><br><span class="line">               *<span class="atom">magGradUw</span>[<span class="atom">facei</span>]</span><br><span class="line">               *<span class="name">Cmu25</span>*<span class="atom">sqrt</span>(<span class="atom">k</span>[<span class="atom">celli</span>])</span><br><span class="line">               /(<span class="atom">kappa_</span>*<span class="atom">y</span>[<span class="atom">facei</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="atom">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="atom">epsilon0</span>[<span class="atom">celli</span>] += <span class="atom">w</span>*<span class="number">2.0</span>*<span class="atom">k</span>[<span class="atom">celli</span>]*<span class="atom">nuw</span>[<span class="atom">facei</span>]/<span class="atom">sqr</span>(<span class="atom">y</span>[<span class="atom">facei</span>]);</span><br><span class="line">            <span class="name">G0</span>[<span class="atom">celli</span>] += <span class="name">G</span>[<span class="atom">celli</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>yPlus &gt; yPlusLam_</code> 时，与 <code>epsilonWallFunction</code> 是一样的；<br><code>yPlus &lt; yPlusLam_</code> 时<br>$$<br>\varepsilon_c = \frac{1}{N} \sum_{f=i}^{N}\left( \frac{2\cdot k_C \nu_i}{y^2_i}\right)<br>$$<br>这个公式等价于<br>$$<br>\varepsilon ^+ = 2\frac{k^+}{(y^+)^2}<br>$$</p>
<p><code>G</code> 则取在湍流模型中定义的值，不作修改。 不过，这里 <code>G0[celli] += G[celli]</code> 意味着假设有一个网格有两个边界面，则这个网格的中计算得到的 <code>G0</code> ，将是在湍流模型中定义的该网格中的 G 值的 2 倍，即认为每一个边界面对都该网格内的湍动能生成有贡献。</p>
<p>这个边界是给低雷诺数的 $k-\varepsilon$ 模型以及 $v^2\text{-}f$ 模型使用的。用 OpenFOAM-3.0 以下版本的注意了，这些版本的 <code>epsilonLowReWallFunction</code> 有问题，<strong>一定不要忘了修正一下上面提到的那个bug </strong>！</p>
<h5 id="4-_$\omega$_的壁面函数">4. $\omega$ 的壁面函数</h5><p>OpenFOAM 中只提供了一个 <code>omegaWallFunction</code>，这个壁面函数，属于一种自动壁面函数，能自动地根据 $y^+$ 的值来在粘性层和对数层切换，过渡层则采用粘性层和对数层混合的结果。<br><code>omegaWallFunction</code> 与 <code>epsilonWallFunction</code> 类似，也是需要计算 $\omega$ 和 $P_k$ 在临近边界网格里的值，因此也需要考虑一个网格包含两个以上边界面的情况。具体处理方法跟 <code>epsilonWallFunction</code> 是一样的 ，所以这里就不重复了，只看具体的计算 $\omega$ 和 $P_k$ 的公式<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">void omegaWallFunctionFvPatchScalarField::calculate</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> turbulenceModel&amp; turbulence,</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">List</span>&lt;<span class="keyword">scalar</span>&gt;&amp; cornerWeights,</span><br><span class="line">    <span class="keyword">const</span> fvPatch&amp; patch,</span><br><span class="line">    scalarField&amp; <span class="keyword">G</span>,</span><br><span class="line">    scalarField&amp; omega</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">label</span> patchI = patch.<span class="literal">index</span>();</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; y = turbulence.<span class="literal">y</span>()[patchI];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">scalar</span> Cmu25 = pow025(Cmu_);</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tk = turbulence.k();</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; k = tk();</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tnu = turbulence.nu();</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; nuw = tnu().boundaryField()[patchI];</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tnut = turbulence.nut();</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; nut = tnut();</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; nutw = nut.boundaryField()[patchI];</span><br><span class="line">    <span class="keyword">const</span> fvPatchVectorField&amp; Uw = turbulence.<span class="keyword">U</span>().boundaryField()[patchI];</span><br><span class="line">    <span class="keyword">const</span> scalarField magGradUw(mag(Uw.snGrad()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set omega and G</span></span><br><span class="line">    forAll(nutw, faceI)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">label</span> cellI = patch.faceCells()[faceI];</span><br><span class="line">        <span class="keyword">scalar</span> w = cornerWeights[faceI];</span><br><span class="line">        <span class="keyword">scalar</span> omegaVis = 6.0*nuw[faceI]/(beta1_*sqr(y[faceI]));</span><br><span class="line">        <span class="keyword">scalar</span> omegaLog = <span class="literal">sqrt</span>(k[cellI])/(Cmu25*kappa_*y[faceI]);</span><br><span class="line">        omega[cellI] += w*<span class="literal">sqrt</span>(sqr(omegaVis) + sqr(omegaLog));</span><br><span class="line">        <span class="keyword">G</span>[cellI] +=</span><br><span class="line">            <span class="literal">w</span></span><br><span class="line"><span class="comment">           *(nutw[faceI] + nuw[faceI])</span></span><br><span class="line"><span class="comment">           *magGradUw[faceI]</span></span><br><span class="line"><span class="comment">           *Cmu25*sqrt(k[cellI])</span></span><br><span class="line">           /(kappa_*y[faceI]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里， <code>omegaVis</code> 和 <code>omegaLog</code> 分别指的是在假定第一层网格位于粘性底层和对数层时得到的 <code>omega</code> 的解析解<br>$$<br>\omega_{Vis} = \frac{6.0\nu}{\beta_1y^2} \<br>\omega_{Log} = \frac{k_C^{1/2}}{C_\mu^{1/4}\kappa y}<br>$$<br>然后，将 $\omega_{Vis}$ 和 $\omega_{Log}$ 用一个函数混合起来，就得到了<br>$$<br>\omega = \sqrt{\omega_{Vis}^2 + \omega_{Log}^2}<br>$$<br>只是，这里的湍动能生成项，却似乎并没有使用混合的方法，而是用的基于对数律的公式：<br>$$<br>G = \frac{(\nu + \nu_t)\cdot |\frac{U_c-U_w}{d}|\cdot C_\mu^{1/4}k_C^{1/2}}{\kappa y}<br>$$</p>
<p>$omega$ 方程是能直接积分到壁面，所以，如果使用基于 $\omega$ 的湍流模型，$\omega$ 变量直接使用这个边界条件就可以了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这篇来看看计算湍动能 $\varepsilon$  和 $\omega$ 的壁面函数。</p>]]>
    
    </summary>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="wall functions" scheme="http://xiaopingqiu.github.io/tags/wall-functions/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenFOAM 中的壁面函数（二）]]></title>
    <link href="http://xiaopingqiu.github.io/2016/04/25/wallFunctions2/"/>
    <id>http://xiaopingqiu.github.io/2016/04/25/wallFunctions2/</id>
    <published>2016-04-24T16:43:29.000Z</published>
    <updated>2016-04-25T02:49:07.183Z</updated>
    <content type="html"><![CDATA[<p>这篇来看看计算湍动能 $k$ 的壁面函数。</p>
<a id="more"></a>
<h5 id="2-_湍流动能_$k$_的壁面函数">2. 湍流动能 $k$ 的壁面函数</h5><p>OpenFOAM 中提供了两种 $k$ 的壁面函数， <code>kqRWallFunction</code> 和 <code>kLowReWallFunction</code> 。</p>
<ul>
<li><p><code>kqRWallFunction</code><br>其实就是 <code>zeroGradient</code> ，无需多言。除非使用 $v^2\text{-}f$ 模型，一般情况下 $k$ 应该使用这个边界条件。</p>
</li>
<li><p><code>kLowReWallFunction</code><br>这个壁面函数应该是可以用于低雷诺数模型的。该壁面函数继承自 <code>fixedValue</code> ：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> kLowReWallFunctionFvPatchScalarField</span><br><span class="line">:</span><br><span class="line">    public fixedValueFvPatchField&lt;<span class="keyword">scalar</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">protected:</span><br><span class="line">       <span class="comment">//- Cmu coefficient</span></span><br><span class="line">        <span class="keyword">scalar</span> Cmu_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Von Karman constant</span></span><br><span class="line">        <span class="keyword">scalar</span> kappa_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- E coefficient</span></span><br><span class="line">        <span class="keyword">scalar</span> E_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Ceps2 coefficient</span></span><br><span class="line">        <span class="keyword">scalar</span> Ceps2_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Y+ at the edge of the laminar sublayer</span></span><br><span class="line">        <span class="keyword">scalar</span> yPlusLam_;</span><br><span class="line">        ......</span><br><span class="line">        </span><br><span class="line">kLowReWallFunctionFvPatchScalarField::kLowReWallFunctionFvPatchScalarField</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> fvPatch&amp; p,</span><br><span class="line">    <span class="keyword">const</span> DimensionedField&lt;<span class="keyword">scalar</span>, volMesh&gt;&amp; <span class="keyword">iF</span>,</span><br><span class="line">    <span class="keyword">const</span> dictionary&amp; dict</span><br><span class="line">)</span><br><span class="line">:</span><br><span class="line">    fixedValueFvPatchField&lt;<span class="keyword">scalar</span>&gt;(p, <span class="keyword">iF</span>, dict),</span><br><span class="line">    Cmu_(dict.lookupOrDefault&lt;<span class="keyword">scalar</span>&gt;(<span class="string">"Cmu"</span>, 0.09)),</span><br><span class="line">    kappa_(dict.lookupOrDefault&lt;<span class="keyword">scalar</span>&gt;(<span class="string">"kappa"</span>, 0.41)),</span><br><span class="line">    E_(dict.lookupOrDefault&lt;<span class="keyword">scalar</span>&gt;(<span class="string">"E"</span>, 9.8)),</span><br><span class="line">    Ceps2_(dict.lookupOrDefault&lt;<span class="keyword">scalar</span>&gt;(<span class="string">"Ceps2"</span>, 1.9)),</span><br><span class="line">    yPlusLam_(yPlusLam(kappa_, E_))</span><br><span class="line">    &#123;</span><br><span class="line">        checkType();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>核心的函数是以下两个：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">scalar kLowReWallFunctionFvPatchScalarField::yPlusLam</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> scalar kappa,</span><br><span class="line">    <span class="keyword">const</span> scalar E</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    scalar ypl = <span class="number">11.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ypl = <span class="built_in">log</span>(max(E*ypl, <span class="number">1</span>))/kappa;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ypl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> kLowReWallFunctionFvPatchScalarField::updateCoeffs()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (updated())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> label patchI = patch().index();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> turbulenceModel&amp; turbulence =</span><br><span class="line">        db().lookupObject&lt;turbulenceModel&gt;(<span class="string">"turbulenceModel"</span>);</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; y = turbulence.y()[patchI];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tk = turbulence.k();</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; k = tk();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tnu = turbulence.nu();</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; nuw = tnu().boundaryField()[patchI];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> scalar Cmu25 = pow025(Cmu_);</span><br><span class="line"></span><br><span class="line">    scalarField&amp; kw = *<span class="keyword">this</span>; <span class="comment">// 更新 kw 相当于更新壁面上的 k 值。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set k wall values</span></span><br><span class="line">    forAll(kw, faceI)</span><br><span class="line">    &#123;</span><br><span class="line">        label faceCellI = patch().faceCells()[faceI];</span><br><span class="line"></span><br><span class="line">        scalar uTau = Cmu25*<span class="built_in">sqrt</span>(k[faceCellI]);</span><br><span class="line"></span><br><span class="line">        scalar yPlus = uTau*y[faceI]/nuw[faceI];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (yPlus &gt; yPlusLam_)</span><br><span class="line">        &#123;</span><br><span class="line">            scalar Ck = -<span class="number">0.416</span>;</span><br><span class="line">            scalar Bk = <span class="number">8.366</span>;</span><br><span class="line">            kw[faceI] = Ck/kappa_*<span class="built_in">log</span>(yPlus) + Bk;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            scalar C = <span class="number">11.0</span>;</span><br><span class="line">            scalar Cf = (<span class="number">1.0</span>/sqr(yPlus + C) + <span class="number">2.0</span>*yPlus/pow3(C) - <span class="number">1.0</span>/sqr(C));</span><br><span class="line">            kw[faceI] = <span class="number">2400.0</span>/sqr(Ceps2_)*Cf;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        kw[faceI] *= sqr(uTau);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fixedValueFvPatchField&lt;scalar&gt;::updateCoeffs();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO: perform averaging for cells sharing more than one boundary face</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>先在函数里计算 <code>ypl</code> 的值， <code>updateCoeffs</code> 函数里根据 <code>yPlus</code> 与这个 <code>ypl</code> 的值来相对大小而采取不同的方法来计算壁面上的 $k_w$。 <code>ypl</code> 的计算是一个迭代过程<br>$$<br>ypl = \frac{\log(\max(E*ypl,1.0))}{\kappa}<br>$$<br>初始值为 <code>ypl = 11.0</code>，迭代10次，最终结果应该是 <code>ypl = 11.5301073043272</code>。<br>$y^+$ 定义为：<br>$$<br>u_\tau = C_\mu^{1/4 }\sqrt{k_c} \<br>y^+ = \frac{u_\tau \cdot y}{\nu_w}<br>$$<br>壁面上的k计算方法如下：如果 $y^+ &gt; ypl$，则<br>$$<br>k^+ _w = \frac{C_k}{\kappa}\ln(y^+) + B_k<br>$$<br>否则<br>$$<br>k^+ _w = \frac{2400}{C_{eps2}^2}\cdot \left[ \frac{1}{(y^+ + C)^2} + \frac{2y^+}{C^3} - \frac{1}{C^2}\right ]<br>$$<br>最终，壁面上的值为 $k_w=k^+ _w u_\tau ^2 =k^+ _w C_\mu^{1/2}k_c$ 。<br>以上公式中，下标 $c$ 表示壁面单元所述网格的值，下标 $w$ 表示当前壁面上的值。<br>这个壁面函数参考文献 “Kalitzin, G., Medic, G., Iaccarino, G., Durbin, P., 2005. Near-wall behavior of RANS turbulence models and implications for wall functions. J. Comput. Phys. 204, 265–291. doi:10.1016/j.jcp.2004.10.018”，是为 $v^2\text{-}f$ 模型设计的。 </p>
<h5 id="$v^2$_和_$f$_的壁面函数">$v^2$ 和 $f$ 的壁面函数</h5><p>上面提到了 $v^2\text{-}f$ 模型，所以这里顺便来看看$v^2$ 和 $f$ 的壁面函数。这里参考的也是上面提到的那篇参考文献。</p>
<ul>
<li>$v^2$ 的壁函数<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">forAll(v2, faceI)</span><br><span class="line">    &#123;</span><br><span class="line">        label faceCellI = patch().faceCells()[faceI];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">scalar</span> uTau = Cmu25*<span class="keyword">sqrt</span>(k[faceCellI]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">scalar</span> yPlus = uTau*<span class="keyword">y</span>[faceI]/nuw[faceI];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (yPlus &gt; yPlusLam<span class="number">_</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">scalar</span> Cv2 = <span class="number">0</span>.<span class="number">193</span>;</span><br><span class="line">            <span class="keyword">scalar</span> Bv2 = -<span class="number">0</span>.<span class="number">94</span>;</span><br><span class="line">            v2[faceI] = Cv2/kappa<span class="number">_</span>*<span class="keyword">log</span>(yPlus) + Bv2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">scalar</span> Cv2 = <span class="number">0</span>.<span class="number">193</span>;</span><br><span class="line">            v2[faceI] = Cv2*pow4(yPlus);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        v2[faceI] *= <span class="keyword">s</span><span class="string">qr(uTau)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fixedValueFvPatchField&lt;<span class="keyword">scalar</span>&gt;::updateCoeffs();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><code>yPlus &gt; yPlusLam_</code> 时，<br>$$<br>v^2 = u_\tau^2 \cdot \left[ \frac{C_{v2}}{\kappa}\ln(y^+) + B_{v2} \right]<br>$$<br>与文献中的无量纲形式 $(\overline{v^2})^{^+} = \frac{C_{v2}}{\kappa}\ln(y^+) + B_{v2} $ 一致。</p>
<p><code>yPlus &lt; yPlusLam\_</code> 时，<br>$$<br>v^2 = u_\tau^2 \cdot C_{v2}(y^+)^2<br>$$<br>与无量纲形式 $(\overline{v^2})^{^+} = C_{v2}(y^+)^2$ 一致。</p>
<ul>
<li>$f$ 的壁函数<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">forAll(f, faceI)</span><br><span class="line">    &#123;</span><br><span class="line">        label faceCellI = patch().faceCells()[faceI];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">scalar</span> uTau = Cmu25*<span class="keyword">sqrt</span>(k[faceCellI]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">scalar</span> yPlus = uTau*<span class="keyword">y</span>[faceI]/nuw[faceI];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (yPlus &gt; yPlusLam<span class="number">_</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">scalar</span> N = <span class="number">6.0</span>;</span><br><span class="line">            <span class="keyword">scalar</span> v2c = v2[faceCellI];</span><br><span class="line">            <span class="keyword">scalar</span> epsc = epsilon[faceCellI];</span><br><span class="line">            <span class="keyword">scalar</span> kc = k[faceCellI];</span><br><span class="line"></span><br><span class="line">            f[faceI] = N*v2c*epsc/(<span class="keyword">s</span><span class="string">qr(kc)</span> + ROOTVSMALL);</span><br><span class="line">            f[faceI] /= <span class="keyword">s</span><span class="string">qr(uTau)</span> + ROOTVSMALL;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            f[faceI] = <span class="number">0</span>.<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><code>yPlus &gt; yPlusLam_</code> 时，<br>$$<br>f = \frac{N \cdot v^2\cdot \varepsilon}{k^2 u_\tau^2}<br>$$<br>这似乎与文献中的无量纲形式<br>$$<br>f^+ = N \frac{(\overline{v^2})^{^+}}{(k^+)^2}\varepsilon^+<br>$$<br>不一致！是 bug 还是我推导出错了？存疑…</p>
<p><code>yPlus &lt; yPlusLam_</code> 时，文献给出的公式是<br>$$<br>f^+ = \frac{-4(6-N)(\overline{v^2})^{^+}}{\varepsilon^+ (y^+)^4}<br>$$<br>当 <code>N=6</code> 时，可以得到 $f^+ = 0$ 。</p>
<p>按理说，$v^2$ 和 $f$ 应该跟 $\varepsilon$ 和 $\omega$ 那样（见后文），计算第一层网格内的值，并且考虑一个网格有多个边界面的情形。OpenFOAM 目前计算的是每一个边界面元上的值，不知道这两种方式对结果有多大影响。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这篇来看看计算湍动能 $k$ 的壁面函数。</p>]]>
    
    </summary>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="wall functions" scheme="http://xiaopingqiu.github.io/tags/wall-functions/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenFOAM 中的壁面函数（一）]]></title>
    <link href="http://xiaopingqiu.github.io/2016/04/25/wallFunctions1/"/>
    <id>http://xiaopingqiu.github.io/2016/04/25/wallFunctions1/</id>
    <published>2016-04-24T16:36:27.000Z</published>
    <updated>2016-04-26T15:12:44.864Z</updated>
    <content type="html"><![CDATA[<p>本系列来看看 OpenFOAM 中的壁面函数。壁面函数的本质，是边界条件。这里主要来看看壁面函数的基本原理，OpenFOAM 中实现了的壁面函数，以及选择壁面函数的一些参考依据。</p>
<a id="more"></a>
<h5 id="1-_壁面函数的基本原理">1. 壁面函数的基本原理</h5><p>湍流模拟中，需要对近壁区域进行处理。一般来讲，壁面处理方法包含两类，一类是使用很细的网格，使靠近壁面的第一层网格在粘性层内（$y^+ <1$），然后里可以直接解析到粘性层的低雷诺湍流模型；另一类，不直接解析粘性层，而是将第一层网格设置在对数区（$y^+> 30$），然后用经验公式来将粘性层和对数区关联起来。下图是一个典型的壁面附近的 $U^+ \text{-} y^+$ 关系图。<br><img src="/image/wallFunctions/Law_of_the_wall.png" alt="壁面律"><br>图片来自 <a href="https://en.wikipedia.org/wiki/Law_of_the_wall" target="_blank" rel="external">Wikipedia:Law of the wall </a>。<br>在粘性层，满足如下关系<br>$$<br>u^+ = y^+<br>$$<br>而在对数区，则满足<br>$$<br>U^+ = \frac{1}{\kappa}\ln(Ey^+)<br>$$<br>其中 $U^+ = U/u_\tau$， $y^+ = yu_\tau/\nu$， $u_\tau = \sqrt{\tau_w/\rho}$，$\kappa\approx 0.41$，$E \approx 9.8$，$y$ 表示与壁面的距离。</1$），然后里可以直接解析到粘性层的低雷诺湍流模型；另一类，不直接解析粘性层，而是将第一层网格设置在对数区（$y^+></p>
<p>本篇以标准壁面函数法来讨论一下壁面函数方法的基本原理，以及壁面函数在 OpenFOAM 中的实现。下面的讨论，先局限在 $k-\varepsilon$ 模型，且第一层网格在对数区的情形。<br>先来看一下壁面函数方法需要解决什么问题。<br>有限体积方法中，扩散项的离散可以表示如下：<br>$$<br>\nabla \cdot (\nu \nabla U) = \sum_f \left [\nu_f \cdot (\nabla U)_f \right]<br>$$<br>当 $f$ 表示的是壁面边界单元时，这时就需要知道在壁面上的速度梯度 $(\nabla U)_f$。壁面上一般对速度 $U$ 采用无滑移条件，如何得到正确的壁面速度梯度，这就是一个问题。这个问题有两个解决思路，一是通过实验或者 DNS 模拟等，得到一条连续的 $U-y$ 曲线，然后从这个曲线求壁面上的导数 $dU/dy$ 来得到壁面上的速度梯度；还有一种思路是，由于最终需要得到的是正确的 $\nu_f \cdot (\nabla U)_f$ ，即壁面上的剪应力，虽然<br>$$<br>\tau_w = \nu \cdot \frac{\partial U}{\partial n}\left. \right|_w \neq \nu \frac{U_p-U_w}{y}<br>$$<br>其中 $U_p$ 表示第一层网格中心的速度，$U_w$ 表示壁面上的速度。<br>但是，可以构造一个壁面上的有效粘度 $\nu_{eff}$，以使下式成立<br>$$<br>\tau_w = \nu \cdot  \frac{\partial U}{\partial n} \left. \right |_w = \nu_{eff} \frac{U_p-U_w}{y} = (\nu + \nu_t ) \cdot \frac{U_p-U_w}{y}<br>$$</p>
<p>后一种解决方法的好处是，不需要修改动量方程，直接使用 $\frac{U_p-U_w}{y}$ 来代替 $\frac{\partial U}{\partial n} \left. \right |_w  $，然后通过设置合适的湍流粘度 $\nu_t$ 的边界条件来修正壁面应力 $\tau_w$。</p>
<p>另一方面，在对数区，$k^+$ 是常数<br>$$<br>k^+ = \frac{1}{\sqrt{C_\mu}} \\<br>$$<br>其中 $k^+ = k/u_\tau^2$。<br>由<br>$$<br>k^+ = \frac{1}{\sqrt{C_\mu}} = k/u_\tau^2<br>$$<br>得<br>$$<br>u_\tau = C_\mu^{1/4}k^{1/2}<br>$$<br>于是<br>$$<br>\tau_w = \rho u_\tau^2 = \rho u_\tau \cdot \frac{U}{U^+} = \frac{\rho u_\tau (U_p-U_w)}{\frac{1}{\kappa}\ln(Ey^+)}<br>$$<br>若令<br>$$<br>\nu_{eff} = \frac{u_\tau y}{\frac{1}{\kappa}\ln(Ey^+)}<br>$$<br>则<br>$$<br>\tau_w = \rho \nu_{eff}\cdot \frac{U_p-U_w}{y}<br>$$<br>这正是上文提到的第二种解决壁面速度问题的形式。<br>而<br>$$<br>\nu_{eff} = \frac{ u_\tau y}{\frac{1}{\kappa}\ln(Ey^+)} = \frac{ y^+ \nu}{\frac{1}{\kappa}\ln(Ey^+)} = \nu + \nu_{tw}<br>$$<br>于是得到壁面上的湍流粘度为<br>$$<br>\nu_{tw} = \nu \cdot \left(\frac{\kappa y^+}{\ln(Ey^+)} -1 \right)<br>$$</p>
<p>$y^+$ 可以通过不同的方式来得到，具体的计算方法，见后文的 <code>nutWallFunctions</code> 部分。</p>
<p>除了得到壁面上的等效湍流粘度，还需要计算靠近壁面第一层网格的湍动能生成和湍动能耗散项。</p>
<p>湍动能生成项计算如下：<br>$$<br>G \approx \tau_w\cdot \frac{\partial (U_p -U_w)}{\partial y}<br>$$<br>由速度的壁面律<br>$$<br>U^+ = \frac{U_p - U_w}{u_\tau} = \frac{1}{\kappa}\ln(Ey^+) = \frac{1}{\kappa} \ln(E\frac{yu_\tau}{\nu})<br>$$<br>注意，$G$ 求的是第一层网格内的值，所以，由<br>$$<br>U_p -U_w = \frac{u_\tau}{\kappa} \ln(E\frac{yu_\tau}{\nu})<br>$$<br>可以求得第一层网格内的梯度<br>$$<br>\frac{\partial (U_p -U_w)}{\partial y} \left. \right|_p = \frac{u_\tau}{\kappa y_p}<br>$$<br>于是<br>$$<br>G = \tau_w \cdot \frac{u_\tau}{\kappa y_p}<br>$$<br>注意，这里的 $\frac{U_p-U_w}{d}$，其实是速度在壁面法向方向的梯度的近似值，这一点见上文 $\nu_t$ 的边界条件部分。</p>
<p>再来看 $\varepsilon$，$\varepsilon$ 的计算基于第一层网格内的湍动生成与湍动能耗散项守恒的假设，即<br>$$<br> \rho \varepsilon_p = G = \tau_w \cdot \frac{u_\tau}{\kappa y_p} =\rho\cdot \frac{u_\tau^3}{\kappa y_p}<br>$$<br>于是得<br>$$<br>\varepsilon_p = \frac{u_\tau^3}{\kappa y_p} = \frac{C_\mu^{3/4}k_p^{3/2}}{\kappa y_p}<br>$$</p>
<p>至于 $k$，一般认为当第一层网格位于对数区时，不需要在壁面上对 $k$ 加任何限制，用零梯度边界条件即可。</p>
<h5 id="2-_在_OpenFOAM_中的实现">2. 在 OpenFOAM 中的实现</h5><p>在 OpenFOAM 中，$k$，$\varepsilon$ 和 $\nu_t$ 分别有对应的边界条件可以选择，壁面函数的实现是在这些边界条件里进行的。具体地说， <code>k***WallFunction</code> 用于指定 $k$ 的边界条件， <code>epsilon***WallFunction</code> 用于计算 $\varepsilon$ 和 $G$ 在第一层网格内的值， <code>nut***WallFunction</code> 用来计算 $\nu_t$ 在壁面上的值。 还有就是一个要关心的问题是这些边界条件的调用顺序，这需要通过湍流模型的一段代码来说明，以 <code>kEpsilon</code> 为例：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> kEpsilon::correct()</span><br><span class="line">&#123;</span><br><span class="line">    RASModel::correct();</span><br><span class="line">    <span class="keyword">if</span> (!turbulence_)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    volScalarField G(GName(), nut_*<span class="number">2</span>*magSqr(symm(fvc::grad(U_))));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update epsilon and G at the wall</span></span><br><span class="line">    epsilon_.boundaryField().updateCoeffs();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dissipation equation</span></span><br><span class="line">    tmp&lt;fvScalarMatrix&gt; epsEqn</span><br><span class="line">    (</span><br><span class="line">        fvm::ddt(epsilon_)</span><br><span class="line">      + fvm::div(phi_, epsilon_)</span><br><span class="line">      - fvm::laplacian(DepsilonEff(), epsilon_)</span><br><span class="line">     ==</span><br><span class="line">        C1_*G*epsilon_/k_</span><br><span class="line">      - fvm::Sp(C2_*epsilon_/k_, epsilon_)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    epsEqn().relax();</span><br><span class="line">    epsEqn().boundaryManipulate(epsilon_.boundaryField());</span><br><span class="line"></span><br><span class="line">    solve(epsEqn);</span><br><span class="line">    bound(epsilon_, epsilonMin_);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Turbulent kinetic energy equation</span></span><br><span class="line">    tmp&lt;fvScalarMatrix&gt; kEqn</span><br><span class="line">    (</span><br><span class="line">        fvm::ddt(k_)</span><br><span class="line">      + fvm::div(phi_, k_)</span><br><span class="line">      - fvm::laplacian(DkEff(), k_)</span><br><span class="line">     ==</span><br><span class="line">        G</span><br><span class="line">      - fvm::Sp(epsilon_/k_, k_)</span><br><span class="line">    );</span><br><span class="line">    kEqn().relax();</span><br><span class="line">    solve(kEqn);</span><br><span class="line">    bound(k_, kMin_);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-calculate viscosity</span></span><br><span class="line">    nut_ = Cmu_*sqr(k_)/epsilon_;</span><br><span class="line">    nut_.correctBoundaryConditions();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上述代码，可以将湍流模型的具体计算过程归纳如下：</p>
<ol>
<li>计算湍动能生成项 $G$，并修正 $G$ 在第一层网格的值。修正是通过 <code>epsilon_.boundaryField().updateCoeffs();</code> 来实现的，这里调用 <code>epsilon</code> 的边界条件的 <code>updateCoeffs</code> 函数，实现的操作是修正 $G$ 和 $\varepsilon$ 在第一层网格的值。</li>
<li>利用更新的 $G$ 构建 <code>epsEqn</code>，然后修改 <code>epsEqn</code>（ <code>epsEqn().boundaryManipulate(epsilon_.boundaryField());</code> ），这样做的目的是保证在下一步 <code>solve(epsEqn)</code>的时候，<code>epsilonWallFunction</code> 类型的边界所属的网格的值不会变化，而是保持在 <code>epsilon_.boundaryField().updateCoeffs();</code> 这一步里设置的值（参考 <a href="http://www.cfd-online.com/Forums/openfoam-solving/132703-boundarymanipulate.html" target="_blank" rel="external">cfd-online 的这个帖子</a>）。</li>
<li>求解 <code>epsEqn</code>，得到更新的 $\varepsilon$ 场。</li>
<li>利用更新的 $\varepsilon$ 场构建并求解 <code>kEqn</code>，得到更新的 $k$ 场。</li>
<li>计算 $\nu_t$，并更新 $\nu_t$ 在边界上的值（<code>nut_.correctBoundaryConditions()</code>） </li>
</ol>
<p>至于具体的 $k$，$\varepsilon$，以及 $\nu_t$ 的边界条件的实现，见后文。 </p>
<p><strong>参考</strong></p>
<ol>
<li>The Finite Volume Method in Computational Fluid Dynamics An Advanced Introduction with OpenFOAM® and Matlab®</li>
<li><a href="http://www.slideshare.net/fumiyanozaki96/openfoam-36426892" target="_blank" rel="external">http://www.slideshare.net/fumiyanozaki96/openfoam-36426892</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>本系列来看看 OpenFOAM 中的壁面函数。壁面函数的本质，是边界条件。这里主要来看看壁面函数的基本原理，OpenFOAM 中实现了的壁面函数，以及选择壁面函数的一些参考依据。</p>]]>
    
    </summary>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="wall functions" scheme="http://xiaopingqiu.github.io/tags/wall-functions/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenFOAM-3.0 的湍流模型（四）]]></title>
    <link href="http://xiaopingqiu.github.io/2016/04/25/TurbulenceModel-30-macro/"/>
    <id>http://xiaopingqiu.github.io/2016/04/25/TurbulenceModel-30-macro/</id>
    <published>2016-04-24T16:11:08.000Z</published>
    <updated>2016-04-25T01:44:22.363Z</updated>
    <content type="html"><![CDATA[<p>最后来看一个小问题：OpenFOAM-3.0 中的湍流模型是怎么编译的。在这之前，湍流模型的编译很直观，将需要编译的湍流模型的代码的 <code>.C</code> 文件写到 <code>Make/files</code> 里就好了。可是，在 OpenFOAM-3.0 里，很多湍流模型代码的 <code>.C</code> 文件并没有写到 <code>Make/files</code> 里，而是在 <code>makeTurbulenceModels.C</code>里类似这样写<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "mykEpsilon.H"</span></span><br><span class="line">makeRASModel(mykEpsilon);</span><br></pre></td></tr></table></figure></p>
<p>然后在 <code>Make/files</code> 里写的是这个 <code>makeTurbulenceModels.C</code> 文件。为什么呢？</p>
<p>这里来分析一下这个问题。</p>
<a id="more"></a>
<p>这个问题，说起来也简单，不过我经过很多摸索从想明白。其实，这个问题用一个概念就可以解释清楚：条件编译。</p>
<p>条件编译常用于头文件，格式如下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//filename: kEpsilon.H</span></span><br><span class="line"><span class="preprocessor">#ifndef  kEpsilon_H</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span>  kEpsilon_H</span></span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>这样能避免头文件重复引用的导致变量或者类重复定义的问题，原因在于，第一次 <code>#include &quot;kEpsilon.H&quot;</code> 时，会触发 <code>#define  kEpsilon_H</code> 的操作，之后如果代码中再出现 <code>#include &quot;kEpsilon.H&quot;</code> 则  <code>#ifndef  kEpsilon_H</code> 将不再成立，所以， <code>#ifndef ... #endif</code> 之间的内容将不会再度被引入。</p>
<p>OpenFOAM 的模板类中，还常见的一种用法是<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#ifdef NoRepository</span></span><br><span class="line"><span class="preprocessor">#   <span class="keyword">include</span> "kEpsilon.C"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>这个怎么理解呢？ 本来也不难理解，无非就是如果定义了宏 <code>NoRepository</code> 则在头文件里将类的具体定义部分也引入到头文件里。问题是，翻遍 OpenFOAM 的 <code>src</code> 目录下的源码，也找不到 <code>NoRepository</code> 的定义。经过搜索，原来这个 <code>NoRepository</code> 是通过 g++ 的 <code>-D</code> 选项来定义的！在编译过程中，使用<br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -c -DNoRepository ...</span><br></pre></td></tr></table></figure></p>
<p>相当于进行了 <code>#define NoRepository 1</code> 的操作，所以， <code>#ifdef NoRepository</code> 这个条件是满足的。<br>OpenFOAM 中，编译选项的定义在 <code>wmake/rules</code> 下，具体的定义取决于你用的编译器，以 <code>linux64Gcc/c++</code> 为例<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">c++WARN     = -Wall -Wextra -Wno-unused-parameter -Wold-style-cast -Wnon-virtual-dtor</span><br><span class="line"></span><br><span class="line"><span class="constant">CC</span>          = g++ -m64</span><br><span class="line"></span><br><span class="line">include $(RULES)/c++$(WM_COMPILE_OPTION)</span><br><span class="line"></span><br><span class="line"><span class="constant">ptFLAGS</span>     = -DNoRepository -ftemplate-depth-100</span><br><span class="line"></span><br><span class="line">c++FLAGS    = $(GFLAGS) $(c++WARN) $(c++OPT) $(c++DBUG) $(ptFLAGS) $(LIB_HEADER_DIRS) -fPIC</span><br><span class="line"></span><br><span class="line"><span class="constant">Ctoo</span>        = <span class="variable">$(WM_SCHEDULER)</span> <span class="variable">$(CC)</span> <span class="variable">$(c++FLAGS)</span> -c $$SOURCE -o $@</span><br><span class="line"><span class="constant">cxxtoo</span>      = <span class="variable">$(Ctoo)</span></span><br><span class="line"><span class="constant">cctoo</span>       = <span class="variable">$(Ctoo)</span></span><br><span class="line"><span class="constant">cpptoo</span>      = <span class="variable">$(Ctoo)</span></span><br><span class="line"></span><br><span class="line"><span class="constant">LINK_LIBS</span>   = <span class="variable">$(c++DBUG)</span></span><br><span class="line"></span><br><span class="line"><span class="constant">LINKLIBSO</span>   = <span class="variable">$(CC)</span> <span class="variable">$(c++FLAGS)</span> -shared -Xlinker --add-needed -Xlinker --no-as-needed</span><br><span class="line"><span class="constant">LINKEXE</span>     = <span class="variable">$(CC)</span> <span class="variable">$(c++FLAGS)</span> -Xlinker --add-needed -Xlinker --no-as-needed</span><br></pre></td></tr></table></figure></p>
<p>可见这里的确是使用了 <code>-DNoRepository</code> 选项。</p>
<p>为什么要在头文件里 <code>#include &quot;kEpsilon.C&quot;</code> 呢？这就涉及到模板类的实例化的问题。<a href="http://www.codeproject.com/Articles/3515/How-To-Organize-Template-Source-Code" target="_blank" rel="external">这篇文章</a>详细地探讨了模板类实例化过程中会遇到的问题，以及解决的办法。简单地说，<strong>模板类不是一种类型，而是一种模板</strong>，模板类通过代入模板参数来实例化，以得到具体的类（这个具体的类就可以看作是一种“数据类型”了）。在示例化过程中，编译器不光需要模板类的声明部分，还需要知道模板类的成员函数的具体定义部分，所以，如果在进行模板类声明的地方只包含了模板类的声明部分（一般是头文件），那实例化就会失败，编译器会报类似“undefined reference to …” 的错误。<br><a href="http://www.cfd-online.com/Forums/openfoam-programming-development/90676-norepository.html" target="_blank" rel="external">cfd-online 上的这个帖子</a>也探讨了关于 <code>NoRepository</code> 的问题。</p>
<p>最后，<code>makeTurbulenceModels.C</code> 里的 <code>#include  &quot;kEpsilon.H&quot;</code>，其实相当于也 <code>#include &quot;kEpsilon.C&quot;</code>，而且，要注意<strong>这里 include 进来的是一个模板类，是用来建立实例化的模型的</strong>！实例化的过程，在 <code>makeRASModel(kEpsilon)</code> 里，详细的参考前一篇，看看这个宏函数的展开，就知道模型参数是怎么代入进去来得到实例化的湍流模型类的。 </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最后来看一个小问题：OpenFOAM-3.0 中的湍流模型是怎么编译的。在这之前，湍流模型的编译很直观，将需要编译的湍流模型的代码的 <code>.C</code> 文件写到 <code>Make/files</code> 里就好了。可是，在 OpenFOAM-3.0 里，很多湍流模型代码的 <code>.C</code> 文件并没有写到 <code>Make/files</code> 里，而是在 <code>makeTurbulenceModels.C</code>里类似这样写<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "mykEpsilon.H"</span></span><br><span class="line">makeRASModel(mykEpsilon);</span><br></pre></td></tr></table></figure></p>
<p>然后在 <code>Make/files</code> 里写的是这个 <code>makeTurbulenceModels.C</code> 文件。为什么呢？</p>
<p>这里来分析一下这个问题。</p>]]>
    
    </summary>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="turbulence model" scheme="http://xiaopingqiu.github.io/tags/turbulence-model/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenFOAM-3.0 的湍流模型（三）]]></title>
    <link href="http://xiaopingqiu.github.io/2016/04/24/TurbulenceModel-30-NewModels/"/>
    <id>http://xiaopingqiu.github.io/2016/04/24/TurbulenceModel-30-NewModels/</id>
    <published>2016-04-24T15:34:01.000Z</published>
    <updated>2016-04-25T02:07:48.763Z</updated>
    <content type="html"><![CDATA[<p>有了上一篇的基础，就很容易做到添加新的湍流模型了，这里分别给出对四类湍流模型增加新模型的方法。探索过程不详述了，仅给出结果。</p>
<a id="more"></a>
<h5 id="3-_添加新模型的方法。">3. 添加新模型的方法。</h5><p>添加湍流模型，关键的有两个，一是如果将新湍流模型添加到合适的 hashTable，以便能被求解器调用，另一个是 Make/files 和 Make/options 的写法以使湍流模型能被编译。</p>
<p>这里不给出具体湍流模型的代码，仅给出 Make 的写法，以及一个 <code>.C</code> 文件。编译湍流模型的时候，新建一个目录，将需要编译的湍流模型代码、这里给出的对应类型的 <code>.C</code> 文件和 Make 文件夹都拷贝到新建的目录，然后运行 <code>wmake libso</code> 即可。</p>
<h6 id="3-1_单相不可压缩湍流模型">3.1 单相不可压缩湍流模型</h6><ul>
<li>makeTuebulenceModels.C</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "IncompressibleTurbulenceModel.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "incompressible/transportModel/transportModel.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "addToRunTimeSelectionTable.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "makeTurbulenceModel.H"</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "RASModel.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "LESModel.H"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 宏函数定义</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> makeRASModel(Type)                                                     \</span><br><span class="line">    makeTemplatedTurbulenceModel                                               \</span><br><span class="line">    (transportModelIncompressibleTurbulenceModel, RAS, Type)</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> makeLESModel(Type)                                                     \</span><br><span class="line">    makeTemplatedTurbulenceModel                                               \</span><br><span class="line">    (transportModelIncompressibleTurbulenceModel, LES, Type)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------------------------------------------------- //</span></span><br><span class="line"><span class="comment">// RAS models</span></span><br><span class="line"><span class="comment">// -------------------------------------------------------------------------- //</span></span><br><span class="line"><span class="keyword">namespace</span> Foam</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> IncompressibleTurbulenceModel&lt;transportModel&gt; transportModelIncompressibleTurbulenceModel; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">typedef</span> RASModel&lt;transportModelIncompressibleTurbulenceModel&gt; RAStransportModelIncompressibleTurbulenceModel;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">typedef</span> LESModel&lt;transportModelIncompressibleTurbulenceModel&gt; LEStransportModelIncompressibleTurbulenceModel; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里说明一下，编译新的模型，最重要的是将作为模板类的通用湍流模型代入合适的模板参数以实例化，然后将实例化的模型添加到合适的　hashTable。</span></span><br><span class="line"><span class="comment">// 上面定义的几个别名，是为了下面将模型添加到 hashTable 而服务的，至于为什么要定义这几个别名，参考前一篇的 `makeBaseTurbulenceModel` 宏函数的展开部分。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "mykEpsilon.H"</span></span><br><span class="line">makeRASModel(mykEpsilon); <span class="comment">// 如前篇所属，这个宏函数，先对模板类进行了实例化，然后调用 `addToRunTimeSelectionTable` 宏函数，将实例化模型添加到 hashTable。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------------------------------------------------- //</span></span><br><span class="line"><span class="comment">// LES models</span></span><br><span class="line"><span class="comment">// -------------------------------------------------------------------------- //</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "mySmagorinsky.H"</span></span><br><span class="line">makeLESModel(mySmagorinsky);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Make/files</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">makeTuebulenceModels.C</span><br><span class="line"></span><br><span class="line"><span class="constant">LIB</span> = <span class="variable">$(FOAM_USER_LIBBIN)</span>/libTestincompressibleTurbulenceModels</span><br></pre></td></tr></table></figure>
</li>
<li><p>Make/options</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">EXE_INC = \</span><br><span class="line">    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/<span class="constant">TurbulenceModels</span>/turbulenceModels/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/<span class="constant">TurbulenceModels</span>/incompressible/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/transportModels \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/finiteVolume/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/meshTools/lnInclude \</span><br><span class="line"></span></span><br><span class="line">LIB_LIBS = \</span><br><span class="line">    -<span class="ruby">lincompressibleTransportModels \</span><br><span class="line"></span>    -<span class="ruby">lturbulenceModels \</span><br><span class="line"></span>    -<span class="ruby">lfiniteVolume \</span><br><span class="line"></span>    -<span class="ruby">lmeshTools</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h6 id="3-2_单相可压缩湍流模型">3.2 单相可压缩湍流模型</h6><ul>
<li><p>makeTurbulenceModels.C</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "CompressibleTurbulenceModel.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "compressibleTransportModel.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "fluidThermo.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "addToRunTimeSelectionTable.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "makeTurbulenceModel.H"</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "ThermalDiffusivity.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "EddyDiffusivity.H"</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "RASModel.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "LESModel.H"</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> makeRASModel(Type)                                                     \</span><br><span class="line">    makeTemplatedTurbulenceModel                                               \</span><br><span class="line">    (fluidThermoCompressibleTurbulenceModel, RAS, Type)</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> makeLESModel(Type)                                                     \</span><br><span class="line">    makeTemplatedTurbulenceModel                                               \</span><br><span class="line">    (fluidThermoCompressibleTurbulenceModel, LES, Type)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Foam</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> ThermalDiffusivity&lt;CompressibleTurbulenceModel&lt;fluidThermo&gt; &gt;  fluidThermoCompressibleTurbulenceModel;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> RASModel&lt;EddyDiffusivity&lt;fluidThermoCompressibleTurbulenceModel&gt; &gt;  RASfluidThermoCompressibleTurbulenceModel;       </span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> LESModel&lt;EddyDiffusivity&lt;fluidThermoCompressibleTurbulenceModel&gt; &gt;  LESfluidThermoCompressibleTurbulenceModel;       </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------------------------------------------------- //</span></span><br><span class="line"><span class="comment">// RAS models</span></span><br><span class="line"><span class="comment">// -------------------------------------------------------------------------- //</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "mykEpsilon.H"</span></span><br><span class="line">makeRASModel(mykEpsilon);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "mybuoyantKEpsilon.H"</span></span><br><span class="line">makeRASModel(mybuoyantKEpsilon);</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------------------------------------------------- //</span></span><br><span class="line"><span class="comment">// LES models</span></span><br><span class="line"><span class="comment">// -------------------------------------------------------------------------- //</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "mySmagorinsky.H"</span></span><br><span class="line">makeLESModel(mySmagorinsky);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Make/files</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">makeTurbulenceModels.C</span><br><span class="line"></span><br><span class="line"><span class="constant">LIB</span> = <span class="variable">$(FOAM_USER_LIBBIN)</span>/libTestcompressibleTurbulenceModels</span><br></pre></td></tr></table></figure>
</li>
<li><p>Make/options</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">EXE_INC = \</span><br><span class="line">    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/<span class="constant">TurbulenceModels</span>/compressible/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/<span class="constant">TurbulenceModels</span>/turbulenceModels/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/transportModels/compressible/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/thermophysicalModels/basic/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/thermophysicalModels/specie/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/thermophysicalModels/solidThermo/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/thermophysicalModels/solidSpecie/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/finiteVolume/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/meshTools/lnInclude \</span><br><span class="line"></span></span><br><span class="line">LIB_LIBS = \</span><br><span class="line">    -<span class="ruby">lcompressibleTransportModels \</span><br><span class="line"></span>    -<span class="ruby">lfluidThermophysicalModels \</span><br><span class="line"></span>    -<span class="ruby">lsolidThermo \</span><br><span class="line"></span>    -<span class="ruby">lsolidSpecie \</span><br><span class="line"></span>    -<span class="ruby">lturbulenceModels \</span><br><span class="line"></span>    -<span class="ruby">lspecie \</span><br><span class="line"></span>    -<span class="ruby">lfiniteVolume \</span><br><span class="line"></span>    -<span class="ruby">lmeshTools</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>注意，由于在 <code>TurbulenceModels/compressible/lnInclude</code> 和 <code>TurbulenceModels/turbulenceModels/lnInclude</code> 两个目录下，都存在 <code>makeTurbulenceModel.H</code> 头文件，内容是不一样的，这里需要 include 的是前者，所以在 <code>Make/options</code> 里， <code>TurbulenceModels/compressible/lnInclude</code> 一定要写在前面才能编译成功。</p>
<h6 id="3-3_多相不可压缩湍流模型">3.3 多相不可压缩湍流模型</h6><ul>
<li><p>DPMTurbulenceModels.C</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "PhaseIncompressibleTurbulenceModel.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "singlePhaseTransportModel.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "addToRunTimeSelectionTable.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "makeTurbulenceModel.H"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#include "laminar.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "turbulentTransportModel.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "LESModel.H"</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> makeRASModel(Type)                                                     \</span><br><span class="line">    makeTemplatedTurbulenceModel                                               \</span><br><span class="line">    (singlePhaseTransportModelPhaseIncompressibleTurbulenceModel, RAS, Type)</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> makeLESModel(Type)                                                     \</span><br><span class="line">    makeTemplatedTurbulenceModel                                               \</span><br><span class="line">    (singlePhaseTransportModelPhaseIncompressibleTurbulenceModel, LES, Type)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Foam</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> PhaseIncompressibleTurbulenceModel&lt;singlePhaseTransportModel&gt; singlePhaseTransportModelPhaseIncompressibleTurbulenceModel; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">typedef</span> RASModel&lt;singlePhaseTransportModelPhaseIncompressibleTurbulenceModel&gt; RASsinglePhaseTransportModelPhaseIncompressibleTurbulenceModel;      </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">typedef</span> LESModel&lt;singlePhaseTransportModelPhaseIncompressibleTurbulenceModel&gt; LESsinglePhaseTransportModelPhaseIncompressibleTurbulenceModel;      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "mykEpsilon.H"</span></span><br><span class="line">makeRASModel(mykEpsilon);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "mySmagorinsky.H"</span></span><br><span class="line">makeLESModel(mySmagorinsky);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Make/files</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DPMTurbulenceModels.C</span><br><span class="line"></span><br><span class="line"><span class="constant">LIB</span> = <span class="variable">$(FOAM_USER_LIBBIN)</span>/libTestDPMTurbulenceModels</span><br></pre></td></tr></table></figure>
</li>
<li><p>Make/options</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">EXE_INC = \</span><br><span class="line">    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/transportModels/compressible/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/thermophysicalModels/basic/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/transportModels \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/transportModels/incompressible/singlePhaseTransportModel \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/<span class="constant">TurbulenceModels</span>/turbulenceModels/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/<span class="constant">TurbulenceModels</span>/incompressible/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/<span class="constant">TurbulenceModels</span>/phaseIncompressible/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/finiteVolume/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/meshTools/lnInclude</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>注意，这里的湍流模型是给 <code>DPMFoam</code> 求解器用的，如果要给其他求解器写湍流模型，可能需要做些修改。</p>
<h6 id="3-4_多相可压缩湍流模型">3.4 多相可压缩湍流模型</h6><ul>
<li><p>phaseCompressibleTurbulenceModels.C</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "PhaseCompressibleTurbulenceModel.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "phaseModel.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "twoPhaseSystem.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "addToRunTimeSelectionTable.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "makeTurbulenceModel.H"</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "ThermalDiffusivity.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "EddyDiffusivity.H"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#include "laminar.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "RASModel.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "LESModel.H"</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> makeRASModel(Type)                                                     \</span><br><span class="line">    makeTemplatedTurbulenceModel                                               \</span><br><span class="line">    (phaseModelPhaseCompressibleTurbulenceModel, RAS, Type)</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> makeLESModel(Type)                                                     \</span><br><span class="line">    makeTemplatedTurbulenceModel                                               \</span><br><span class="line">    (phaseModelPhaseCompressibleTurbulenceModel, LES, Type)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Foam</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> ThermalDiffusivity&lt;PhaseCompressibleTurbulenceModel&lt;phaseModel&gt; &gt;  phaseModelPhaseCompressibleTurbulenceModel;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> RASModel&lt;EddyDiffusivity&lt;phaseModelPhaseCompressibleTurbulenceModel&gt; &gt;  RASphaseModelPhaseCompressibleTurbulenceModel;           </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">typedef</span> LESModel&lt;EddyDiffusivity&lt;phaseModelPhaseCompressibleTurbulenceModel&gt; &gt;   LESphaseModelPhaseCompressibleTurbulenceModel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "mykEpsilon.H"</span></span><br><span class="line">makeRASModel(mykEpsilon);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "mySmagorinsky.H"</span></span><br><span class="line">makeLESModel(mySmagorinsky);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "myphasePressureModel.H"</span></span><br><span class="line">makeTurbulenceModel</span><br><span class="line">(phaseModelPhaseCompressibleTurbulenceModel, RAS, myphasePressureModel);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Make/files</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">phaseCompressibleTurbulenceModels<span class="class">.C</span></span><br><span class="line">phasePressureModel/myphasePressureModel<span class="class">.C</span></span><br><span class="line"></span><br><span class="line">LIB = $(FOAM_USER_LIBBIN)/libTestphaseCompressibleTurbulenceModels</span><br></pre></td></tr></table></figure>
</li>
<li><p>Make/options</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">EXE_INC = \</span><br><span class="line">    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">WM_PROJECT_DIR</span>)/applications/solvers/multiphase/twoPhaseEulerFoam/twoPhaseSystem/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">WM_PROJECT_DIR</span>)/applications/solvers/multiphase/twoPhaseEulerFoam/interfacialModels/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/transportModels/compressible/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/thermophysicalModels/basic/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/transportModels/incompressible/transportModel \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/<span class="constant">TurbulenceModels</span>/compressible/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/<span class="constant">TurbulenceModels</span>/turbulenceModels/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/<span class="constant">TurbulenceModels</span>/phaseCompressible/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/finiteVolume/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/meshTools/lnInclude</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>注意，这里的湍流模型是给求解器 <code>twoPhaseEulerFoam</code> 用的，如果要给其他求解器开发湍流模型，可能需要做些修改。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>有了上一篇的基础，就很容易做到添加新的湍流模型了，这里分别给出对四类湍流模型增加新模型的方法。探索过程不详述了，仅给出结果。</p>]]>
    
    </summary>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="turbulence model" scheme="http://xiaopingqiu.github.io/tags/turbulence-model/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenFOAM-3.0 的湍流模型（二）]]></title>
    <link href="http://xiaopingqiu.github.io/2016/04/24/TurbulenceModel-30-RTS/"/>
    <id>http://xiaopingqiu.github.io/2016/04/24/TurbulenceModel-30-RTS/</id>
    <published>2016-04-24T14:21:52.000Z</published>
    <updated>2016-04-25T02:15:41.650Z</updated>
    <content type="html"><![CDATA[<p>本篇分析 OpenFOAM-3.0 中湍流模型的 RTS 机制。RTS 机制主要是通过调用几个相关的宏函数来实现的，所以，分析 RTS 机制需要将相关的宏函数展开。四类湍流模型，机制是类似的，这里以单相不可压缩湍流模型为例，后文会给出所有其他湍流模型相关的宏函数的展开结果，供读者参考。<br>RTS 机制的基础这里不再重复了，读者若对这里涉及到 RTS 机制的名称感兴趣，可以参考我以前对 RTS 机制的解读。</p>
<a id="more"></a>
<h5 id="2-_RTS_机制">2. RTS 机制</h5><p>单相不可压缩湍流模型类，在 <code>Make/files</code> 文件里包含的其中一个是 <code>src/TurbulenceModels/incompressible/turbulentTransportModels/turbulentTransportModels.C</code> turbulentTransportModels.C，这个文件里包含了一些通用的湍流模型模板类，并调用了一些宏函数来实现 RTS 相关的，这里将宏函数展开看看这个文件究竟实现了怎样的功能。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">makeBaseTurbulenceModel</span><br><span class="line">(</span><br><span class="line">    geometricOneField,</span><br><span class="line">    geometricOneField,</span><br><span class="line">    incompressibleTurbulenceModel,</span><br><span class="line">    IncompressibleTurbulenceModel,</span><br><span class="line">    transportModel</span><br><span class="line">);</span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> makeRASModel(Type)                                                     \</span><br><span class="line">    makeTemplatedTurbulenceModel                                               \</span><br><span class="line">    (transportModelIncompressibleTurbulenceModel, RAS, Type)</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> makeLESModel(Type)                                                     \</span><br><span class="line">    makeTemplatedTurbulenceModel                                               \</span><br><span class="line">    (transportModelIncompressibleTurbulenceModel, LES, Type)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------------------------------------------------- //</span></span><br><span class="line"><span class="comment">// RAS models</span></span><br><span class="line"><span class="comment">// -------------------------------------------------------------------------- //</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "SpalartAllmaras.H"</span></span><br><span class="line">makeRASModel(SpalartAllmaras);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "kEpsilon.H"</span></span><br><span class="line">makeRASModel(kEpsilon);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "RNGkEpsilon.H"</span></span><br><span class="line">makeRASModel(RNGkEpsilon);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "realizableKE.H"</span></span><br><span class="line">makeRASModel(realizableKE);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "LaunderSharmaKE.H"</span></span><br><span class="line">makeRASModel(LaunderSharmaKE);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "kOmega.H"</span></span><br><span class="line">makeRASModel(kOmega);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "kOmegaSST.H"</span></span><br><span class="line">makeRASModel(kOmegaSST);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "kOmegaSSTSAS.H"</span></span><br><span class="line">makeRASModel(kOmegaSSTSAS);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "v2f.H"</span></span><br><span class="line">makeRASModel(v2f);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "LRR.H"</span></span><br><span class="line">makeRASModel(LRR);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "SSG.H"</span></span><br><span class="line">makeRASModel(SSG);</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------------------------------------------------- //</span></span><br><span class="line"><span class="comment">// LES models</span></span><br><span class="line"><span class="comment">// -------------------------------------------------------------------------- //</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "Smagorinsky.H"</span></span><br><span class="line">makeLESModel(Smagorinsky);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "WALE.H"</span></span><br><span class="line">makeLESModel(WALE);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "dynamicLagrangian.H"</span></span><br><span class="line">makeLESModel(dynamicLagrangian);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "kEqn.H"</span></span><br><span class="line">makeLESModel(kEqn);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "dynamicKEqn.H"</span></span><br><span class="line">makeLESModel(dynamicKEqn);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "SpalartAllmarasDES.H"</span></span><br><span class="line">makeLESModel(SpalartAllmarasDES);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "SpalartAllmarasDDES.H"</span></span><br><span class="line">makeLESModel(SpalartAllmarasDDES);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "SpalartAllmarasIDDES.H"</span></span><br><span class="line">makeLESModel(SpalartAllmarasIDDES);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "DeardorffDiffStress.H"</span></span><br><span class="line">makeLESModel(DeardorffDiffStress);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "kOmegaSSTDES.H"</span></span><br><span class="line">makeLESModel(kOmegaSSTDES);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "kOmegaSSTDDES.H"</span></span><br><span class="line">makeLESModel(kOmegaSSTDDES);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "kOmegaSSTIDDES.H"</span></span><br><span class="line">makeLESModel(kOmegaSSTIDDES);</span><br></pre></td></tr></table></figure>
<p>这个宏函数调用<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">makeBaseTurbulenceModel</span><br><span class="line"><span class="list">(</span><br><span class="line">    <span class="keyword">geometricOneField</span>,</span><br><span class="line">    geometricOneField,</span><br><span class="line">    incompressibleTurbulenceModel,</span><br><span class="line">    IncompressibleTurbulenceModel,</span><br><span class="line">    transportModel</span><br><span class="line">)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>展开结果为<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Foam                                                             </span><br><span class="line">&#123;                                                                          </span><br><span class="line">    <span class="keyword">typedef</span> TurbulenceModel                                                </span><br><span class="line">    &lt;                                                                      </span><br><span class="line">        geometricOneField,                                                             </span><br><span class="line">        geometricOneField,                                                               </span><br><span class="line">        incompressibleTurbulenceModel,                                                         </span><br><span class="line">        transportModel                                                          </span><br><span class="line">    &gt; transportModelincompressibleTurbulenceModel;                                                </span><br><span class="line">                                                                           </span><br><span class="line">    defineTemplateRunTimeSelectionTable <span class="comment">// 对TurbulenceModel类中定义的 hashTable 进行了初始化                                    </span></span><br><span class="line">    (                                                                      </span><br><span class="line">        transportModelincompressibleTurbulenceModel,                                              </span><br><span class="line">        dictionary                                                         </span><br><span class="line">    );                                                                     </span><br><span class="line">                                                                           </span><br><span class="line">    <span class="keyword">typedef</span> IncompressibleTurbulenceModel&lt;transportModel&gt; transportModelIncompressibleTurbulenceModel;                     </span><br><span class="line">                                                                           </span><br><span class="line">    <span class="keyword">typedef</span> laminar&lt;transportModelIncompressibleTurbulenceModel&gt; LaminartransportModelIncompressibleTurbulenceModel;   </span><br><span class="line">                                                                           </span><br><span class="line">    defineNamedTemplateTypeNameAndDebug(LaminartransportModelIncompressibleTurbulenceModel, <span class="number">0</span>); </span><br><span class="line">                                                                           </span><br><span class="line">    addToRunTimeSelectionTable   <span class="comment">// 将laminar 模型加到定义在 TurbulenceModel 类中的hashTable                                      </span></span><br><span class="line">    (                                                                      </span><br><span class="line">        transportModelincompressibleTurbulenceModel,                                              </span><br><span class="line">        LaminartransportModelIncompressibleTurbulenceModel,                                     </span><br><span class="line">        dictionary                                                         </span><br><span class="line">    );                                                                     </span><br><span class="line">                                                                           </span><br><span class="line">    <span class="keyword">typedef</span> RASModel&lt;transportModelIncompressibleTurbulenceModel&gt; RAStransportModelIncompressibleTurbulenceModel;      </span><br><span class="line">    </span><br><span class="line">    defineNamedTemplateTypeNameAndDebug(RAStransportModelIncompressibleTurbulenceModel, <span class="number">0</span>);     </span><br><span class="line"></span><br><span class="line">     <span class="comment">// 对 RASModel类中定义的hashTable进行了初始化                          </span></span><br><span class="line">    defineTemplateRunTimeSelectionTable                                    </span><br><span class="line">    (RAStransportModelIncompressibleTurbulenceModel, dictionary);                               </span><br><span class="line">    <span class="comment">// 将 RASModel 添加到 TurbulenceModel 中定义的hashTable                         </span></span><br><span class="line">    addToRunTimeSelectionTable                                             </span><br><span class="line">    (                                                                      </span><br><span class="line">        transportModelincompressibleTurbulenceModel,                                              </span><br><span class="line">        RAStransportModelIncompressibleTurbulenceModel,                                         </span><br><span class="line">        dictionary                                                         </span><br><span class="line">    );                                                                     </span><br><span class="line">                                                                           </span><br><span class="line">    <span class="keyword">typedef</span> LESModel&lt;transportModelIncompressibleTurbulenceModel&gt; LEStransportModelIncompressibleTurbulenceModel;      </span><br><span class="line">                                                                           </span><br><span class="line">    defineNamedTemplateTypeNameAndDebug(LEStransportModelIncompressibleTurbulenceModel, <span class="number">0</span>);     </span><br><span class="line">    </span><br><span class="line">     <span class="comment">// 对LESModel类中定义的hashTable进行了初始化</span></span><br><span class="line">    defineTemplateRunTimeSelectionTable                                    </span><br><span class="line">    (LEStransportModelIncompressibleTurbulenceModel, dictionary);                               </span><br><span class="line">    <span class="comment">// 将 LESModel 添加到 TurbulenceModel 中定义的hashTable                   </span></span><br><span class="line">    addToRunTimeSelectionTable                                             </span><br><span class="line">    (                                                                      </span><br><span class="line">        transportModelincompressibleTurbulenceModel,                                              </span><br><span class="line">        LEStransportModelIncompressibleTurbulenceModel,                                         </span><br><span class="line">        dictionary                                                         </span><br><span class="line">    );                                                                     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>makeRASModel(SpalartAllmaras)</code> 展开结果为<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">makeTemplatedTurbulenceModel </span><br><span class="line"> <span class="list">(<span class="keyword">transportModelIncompressibleTurbulenceModel</span>, RAS, SpalartAllmaras)</span></span><br></pre></td></tr></table></figure></p>
<p>继续展开结果为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">defineNamedTemplateTypeNameAndDebug                      </span><br><span class="line">    (Foam::RASModels::SpalartAllmaras&lt;Foam::transportModelIncompressibleTurbulenceModel&gt;, <span class="number">0</span>);     </span><br><span class="line">                                                         </span><br><span class="line"><span class="keyword">namespace</span> Foam                                           </span><br><span class="line">&#123;                                                        </span><br><span class="line">    <span class="keyword">namespace</span> RASModels                              </span><br><span class="line">    &#123;                                                    </span><br><span class="line">        <span class="keyword">typedef</span> SpalartAllmaras&lt;transportModelIncompressibleTurbulenceModel&gt; SpalartAllmarasRAStransportModelIncompressibleTurbulenceModel;  </span><br><span class="line">                                                         </span><br><span class="line">	<span class="comment">// 将 SpalartAllmaras 模型添加到 RASModel 中定义的 hashTable</span></span><br><span class="line">        addToRunTimeSelectionTable                       </span><br><span class="line">        (                                                </span><br><span class="line">            RAStransportModelIncompressibleTurbulenceModel,                            </span><br><span class="line">            SpalartAllmarasRAStransportModelIncompressibleTurbulenceModel,                      </span><br><span class="line">            dictionary                                   </span><br><span class="line">        );                                               </span><br><span class="line">    &#125;                                                    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>makeLESModel(Smagorinsky)</code> 展开结果为<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">makeTemplatedTurbulenceModel </span><br><span class="line"> <span class="list">(<span class="keyword">transportModelIncompressibleTurbulenceModel</span>, LES, Smagorinsky)</span></span><br></pre></td></tr></table></figure></p>
<p>继续展开结果为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">defineNamedTemplateTypeNameAndDebug                      </span><br><span class="line">    (Foam::LESModels::Smagorinsky&lt;Foam::transportModelIncompressibleTurbulenceModel&gt;, <span class="number">0</span>);     </span><br><span class="line">                                                         </span><br><span class="line"><span class="keyword">namespace</span> Foam                                           </span><br><span class="line">&#123;                                                        </span><br><span class="line">    <span class="keyword">namespace</span> LESModels                              </span><br><span class="line">    &#123;                                                    </span><br><span class="line">        <span class="keyword">typedef</span> Smagorinsky&lt;transportModelIncompressibleTurbulenceModel&gt; SmagorinskyLEStransportModelIncompressibleTurbulenceModel;  </span><br><span class="line">                                                         </span><br><span class="line">	<span class="comment">// 将 Smagorinsky 模型添加到 LESModel 中定义的hashTable</span></span><br><span class="line">        addToRunTimeSelectionTable                       </span><br><span class="line">        (                                                </span><br><span class="line">            LEStransportModelIncompressibleTurbulenceModel,                            </span><br><span class="line">            SmagorinskyLEStransportModelIncompressibleTurbulenceModel,                      </span><br><span class="line">            dictionary                                   </span><br><span class="line">        );                                               </span><br><span class="line">    &#125;                                                    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，这里给 <code>kEpsilon</code> 和 <code>Smagorinsky</code> 模型代入的模板参数是 <code>transportModelIncompressibleTurbulenceModel</code>，即 <code>IncompressibleTurbulenceModel&lt;transportModel&gt;</code>。</p>
<p>上面给出了单相不可压缩湍流模型是如何添加到各自该所属的 hashTable 里的。接着，以单相不可压缩模型为例，看看湍流模型的调用过程。<br>在 <code>pisoFoam</code> 求解器中，湍流模型接口的定义如下<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">autoPtr&lt;<span class="symbol">incompressible:</span><span class="symbol">:turbulenceModel&gt;</span> turbulence</span><br><span class="line">(</span><br><span class="line">    <span class="symbol">incompressible:</span><span class="symbol">:turbulenceModel</span><span class="symbol">:</span><span class="symbol">:New</span>(<span class="constant">U,</span> phi, laminarTransport)</span><br><span class="line">);</span><br><span class="line"><span class="regexp">//</span> laminarTransport 是 singlePhaseTransportModel 的一个对象</span><br></pre></td></tr></table></figure></p>
<p><code>incompressible::turbulenceModel</code> 是 <code>IncompressibleTurbulenceModel&lt;transportModel&gt;</code> 的别名。<br>这里调用的是 <code>IncompressibleTurbulenceModel</code> 类的 <code>New</code> 函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> TransportModel&gt;</span><br><span class="line">Foam::autoPtr&lt;Foam::IncompressibleTurbulenceModel&lt;TransportModel&gt; &gt;</span><br><span class="line">Foam::IncompressibleTurbulenceModel&lt;TransportModel&gt;::New</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> volVectorField&amp; U,</span><br><span class="line">    <span class="keyword">const</span> surfaceScalarField&amp; phi,</span><br><span class="line">    <span class="keyword">const</span> TransportModel&amp; transport,</span><br><span class="line">    <span class="keyword">const</span> word&amp; propertiesName</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> autoPtr&lt;IncompressibleTurbulenceModel&gt;</span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;IncompressibleTurbulenceModel*&gt;(</span><br><span class="line">        TurbulenceModel</span><br><span class="line">        &lt;</span><br><span class="line">            geometricOneField,</span><br><span class="line">            geometricOneField,</span><br><span class="line">            incompressibleTurbulenceModel,</span><br><span class="line">            TransportModel</span><br><span class="line">        &gt;::New</span><br><span class="line">        (</span><br><span class="line">            geometricOneField(),</span><br><span class="line">            geometricOneField(),</span><br><span class="line">            U,</span><br><span class="line">            phi,</span><br><span class="line">            phi,</span><br><span class="line">            transport,</span><br><span class="line">            propertiesName</span><br><span class="line">        ).ptr())</span><br><span class="line">    );</span><br></pre></td></tr></table></figure></p>
<p>返回的是 <code>TurbulenceModel</code> 类的 <code>New</code> 函数。<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">template</span><br><span class="line">&lt;</span><br><span class="line">    <span class="keyword">class</span> <span class="keyword">Alpha</span>,</span><br><span class="line">    <span class="keyword">class</span> Rho,</span><br><span class="line">    <span class="keyword">class</span> BasicTurbulenceModel,</span><br><span class="line">    <span class="keyword">class</span> TransportModel</span><br><span class="line">&gt;</span><br><span class="line">Foam::autoPtr</span><br><span class="line">&lt;</span><br><span class="line">    Foam::TurbulenceModel&lt;<span class="keyword">Alpha</span>, Rho, BasicTurbulenceModel, TransportModel&gt;</span><br><span class="line">&gt;</span><br><span class="line">Foam::TurbulenceModel&lt;<span class="keyword">Alpha</span>, Rho, BasicTurbulenceModel, TransportModel&gt;::New</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> alphaField&amp; <span class="keyword">alpha</span>,</span><br><span class="line">    <span class="keyword">const</span> rhoField&amp; rho,</span><br><span class="line">    <span class="keyword">const</span> volVectorField&amp; <span class="keyword">U</span>,</span><br><span class="line">    <span class="keyword">const</span> surfaceScalarField&amp; alphaRhoPhi,</span><br><span class="line">    <span class="keyword">const</span> surfaceScalarField&amp; phi,</span><br><span class="line">    <span class="keyword">const</span> transportModel&amp; transport,</span><br><span class="line">    <span class="keyword">const</span> word&amp; propertiesName</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// get model name, but do not register the dictionary</span></span><br><span class="line">    <span class="comment">// otherwise it is registered in the database twice</span></span><br><span class="line">    <span class="keyword">const</span> word modelType</span><br><span class="line">    (</span><br><span class="line">        IOdictionary</span><br><span class="line">        (</span><br><span class="line">            IOobject</span><br><span class="line">            (</span><br><span class="line">                IOobject::groupName(propertiesName, <span class="keyword">U</span>.<span class="literal">group</span>()),</span><br><span class="line">                <span class="keyword">U</span>.time().constant(),</span><br><span class="line">                <span class="keyword">U</span>.<span class="keyword">db</span>(),</span><br><span class="line">                IOobject::MUST_READ_IF_MODIFIED,</span><br><span class="line">                IOobject::NO_WRITE,</span><br><span class="line">                false</span><br><span class="line">            )</span><br><span class="line">        ).<span class="keyword">lookup</span>(<span class="string">"simulationType"</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    Info&lt;&lt; <span class="string">"Selecting turbulence model type "</span> &lt;&lt; modelType &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    typename dictionaryConstructorTable::iterator cstrIter =</span><br><span class="line">        dictionaryConstructorTablePtr_-&gt;find(modelType);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cstrIter == dictionaryConstructorTablePtr_-&gt;end())</span><br><span class="line">    &#123;</span><br><span class="line">        FatalErrorInFunction</span><br><span class="line">            &lt;&lt; <span class="string">"Unknown TurbulenceModel type "</span></span><br><span class="line">            &lt;&lt; modelType &lt;&lt; <span class="keyword">nl</span> &lt;&lt; <span class="keyword">nl</span></span><br><span class="line">            &lt;&lt; <span class="string">"Valid TurbulenceModel types:"</span> &lt;&lt; endl</span><br><span class="line">            &lt;&lt; dictionaryConstructorTablePtr_-&gt;sortedToc()</span><br><span class="line">            &lt;&lt; <span class="keyword">exit</span>(FatalError);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> autoPtr&lt;TurbulenceModel&gt;</span><br><span class="line">    (</span><br><span class="line">        cstrIter()(<span class="keyword">alpha</span>, rho, <span class="keyword">U</span>, alphaRhoPhi, phi, transport, propertiesName)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里通过读取 <code>turbulenceProperties</code> 文件，查找关键字 <code>simulationType</code>（只能是 <code>RAS</code> 或  <code>LES</code> ），并据此从定义在 <code>TurbulenceModel</code> 类中 hashTable 中找对应的模型，然后返回的模型（可能是 <code>RAStransportModelIncompressibleTurbulenceModel</code>， <code>RASfluidThermoCompressibleTurbulenceModel</code>， <code>RASsinglePhaseTransportModelPhaseIncompressibleTurbulenceModel</code>， <code>RASphaseModelPhaseCompressibleTurbulenceModel</code>）的 <code>New</code> 函数<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">template&lt;<span class="keyword">class</span> BasicTurbulenceModel&gt;</span><br><span class="line">Foam::autoPtr&lt;Foam::RASModel&lt;BasicTurbulenceModel&gt; &gt;</span><br><span class="line">Foam::RASModel&lt;BasicTurbulenceModel&gt;::New</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> alphaField&amp; <span class="keyword">alpha</span>,</span><br><span class="line">    <span class="keyword">const</span> rhoField&amp; rho,</span><br><span class="line">    <span class="keyword">const</span> volVectorField&amp; <span class="keyword">U</span>,</span><br><span class="line">    <span class="keyword">const</span> surfaceScalarField&amp; alphaRhoPhi,</span><br><span class="line">    <span class="keyword">const</span> surfaceScalarField&amp; phi,</span><br><span class="line">    <span class="keyword">const</span> transportModel&amp; transport,</span><br><span class="line">    <span class="keyword">const</span> word&amp; propertiesName</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// get model name, but do not register the dictionary</span></span><br><span class="line">    <span class="comment">// otherwise it is registered in the database twice</span></span><br><span class="line">    <span class="keyword">const</span> word modelType</span><br><span class="line">    (</span><br><span class="line">        IOdictionary</span><br><span class="line">        (</span><br><span class="line">            IOobject</span><br><span class="line">            (</span><br><span class="line">                IOobject::groupName(propertiesName, <span class="keyword">U</span>.<span class="literal">group</span>()),</span><br><span class="line">                <span class="keyword">U</span>.time().constant(),</span><br><span class="line">                <span class="keyword">U</span>.<span class="keyword">db</span>(),</span><br><span class="line">                IOobject::MUST_READ_IF_MODIFIED,</span><br><span class="line">                IOobject::NO_WRITE,</span><br><span class="line">                false</span><br><span class="line">            )</span><br><span class="line">        ).subDict(<span class="string">"RAS"</span>).<span class="keyword">lookup</span>(<span class="string">"RASModel"</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    Info&lt;&lt; <span class="string">"Selecting RAS turbulence model "</span> &lt;&lt; modelType &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    typename dictionaryConstructorTable::iterator cstrIter =</span><br><span class="line">        dictionaryConstructorTablePtr_-&gt;find(modelType);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cstrIter == dictionaryConstructorTablePtr_-&gt;end())</span><br><span class="line">    &#123;</span><br><span class="line">        FatalErrorInFunction</span><br><span class="line">            &lt;&lt; <span class="string">"Unknown RASModel type "</span></span><br><span class="line">            &lt;&lt; modelType &lt;&lt; <span class="keyword">nl</span> &lt;&lt; <span class="keyword">nl</span></span><br><span class="line">            &lt;&lt; <span class="string">"Valid RASModel types:"</span> &lt;&lt; endl</span><br><span class="line">            &lt;&lt; dictionaryConstructorTablePtr_-&gt;sortedToc()</span><br><span class="line">            &lt;&lt; <span class="keyword">exit</span>(FatalError);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> autoPtr&lt;RASModel&gt;</span><br><span class="line">    (</span><br><span class="line">        cstrIter()(<span class="keyword">alpha</span>, rho, <span class="keyword">U</span>, alphaRhoPhi, phi, transport, propertiesName)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个 <code>New</code> 函数中需要读取 <code>RAS</code> 子字典，从中读取 <code>RASModel</code> 关键字，并据此从定义在 <code>RASModel</code> 类中的 hashTable 中查找到对应的湍流模型，并返回湍流模型的构造函数<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> return autoPtr&lt;RASModel&gt;</span><br><span class="line"><span class="list">(</span><br><span class="line">    <span class="keyword">cstrIter</span><span class="list">()</span><span class="list">(<span class="keyword">alpha</span>, rho, U, alphaRhoPhi, phi, transport, propertiesName)</span></span><br><span class="line">)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>其他三类湍流模型，机制是类似的，这里不再详述，仅给出三个链接，供大家参考：<a href="http://www.evernote.com/l/AYvnAYRFNFNM-bJC82rVLGiBybePgFNMF4o/" target="_blank" rel="external">单相可压缩湍流模型</a>，<a href="http://www.evernote.com/l/AYsCXim6tA9DuYjdWDxPSTmltaMig6GIl5A/" target="_blank" rel="external">多相不可压缩湍流模型</a>，<a href="http://www.evernote.com/l/AYuP9x_D59FCPbFXFTY97LbV__jBebUzW8A/" target="_blank" rel="external">多相可压缩湍流模型</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本篇分析 OpenFOAM-3.0 中湍流模型的 RTS 机制。RTS 机制主要是通过调用几个相关的宏函数来实现的，所以，分析 RTS 机制需要将相关的宏函数展开。四类湍流模型，机制是类似的，这里以单相不可压缩湍流模型为例，后文会给出所有其他湍流模型相关的宏函数的展开结果，供读者参考。<br>RTS 机制的基础这里不再重复了，读者若对这里涉及到 RTS 机制的名称感兴趣，可以参考我以前对 RTS 机制的解读。</p>]]>
    
    </summary>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="RTS" scheme="http://xiaopingqiu.github.io/tags/RTS/"/>
    
      <category term="turbulence model" scheme="http://xiaopingqiu.github.io/tags/turbulence-model/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenFOAM-3.0 的湍流模型（一）]]></title>
    <link href="http://xiaopingqiu.github.io/2016/04/24/TurbulenceModel-30-structure/"/>
    <id>http://xiaopingqiu.github.io/2016/04/24/TurbulenceModel-30-structure/</id>
    <published>2016-04-24T13:35:17.000Z</published>
    <updated>2016-04-24T14:38:56.963Z</updated>
    <content type="html"><![CDATA[<p>本系列分析 OpenFOAM-3.0 版本的湍流模型。从 3.0 版开始，OpenFOAM 中的湍流模型架构发生了较大的变化，其实这种变化在 2.3 版开始已经初露端倪，在 2.3 版里，多相流的湍流模型已经开始跟单相流湍流模型分开。从 3.0 开始，单相流湍流模型和多相流湍流模型统一到了一个架构下。本系列将对 3.0 版的湍流模型进行详细的分析，分为四部分：结构概览，RTS 机制分析，编译新模型的方法，以及一些补充说明。</p>
<a id="more"></a>
<h5 id="1-_结构概览">　1.  结构概览</h5><p>这部分主要是概括一下湍流模型的框架的结构，如下图（请点击右键查看大图）：</p>
<p><img src="/image/turbulenceModel/turbulenceModel-3.0.png" alt="湍流模型的架构"></p>
<p>图片中，蓝色字体的是类名，绿框中的类是调用 <code>declareRunTimeSeclectionTable</code> 的类（如果对这个的含义感兴趣，建议参考<a href="http://xiaopingqiu.github.io/2016/03/12/RTS1/" target="_blank" rel="external">这篇</a>或者<a href="http://www.sourceflux.de/blog/run-time-type-selection-openfoam-selecting-types-based-type-name/" target="_blank" rel="external">这篇</a>），四种不同颜色的箭头，代表的是四种不同的湍流模型：单相不可压缩湍流模型，单相可压缩湍流模型，多相不可压缩模型，多相可压缩模型。</p>
<p>在图片下面，我用了一个 <code>kEpsilon</code> 和一个 <code>Smagorinsky</code> 模型作为示例，这是因为，这两个湍流模型都是以通用形式来实现的，从 C++ 角度来说，就是模板类。通过代入不同的模板参数， <code>kEpsilon</code> 和 <code>Smagorinsky</code> 这两个模板类可以实例化为不同种类的湍流模型。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">template</span>&lt;<span class="keyword">class</span> <span class="type">BasicTurbulenceModel</span>&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> kEpsilon</span><br><span class="line">:</span><br><span class="line">    public eddyViscosity&lt;<span class="type">RASModel</span>&lt;<span class="type">BasicTurbulenceModel</span>&gt; &gt;</span><br><span class="line">&#123;</span><br><span class="line">    // <span class="type">Private</span> <span class="type">Member</span> <span class="type">Functions</span></span><br><span class="line"></span><br><span class="line">        // <span class="type">Disallow</span> default bitwise copy construct and assignment</span><br><span class="line">        kEpsilon<span class="container">(<span class="title">const</span> <span class="title">kEpsilon</span>&amp;)</span>;</span><br><span class="line">        kEpsilon&amp; operator=<span class="container">(<span class="title">const</span> <span class="title">kEpsilon</span>&amp;)</span>;</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line"> tmp&lt;fvScalarMatrix&gt; epsEqn</span><br><span class="line">    <span class="container">(</span><br><span class="line">        <span class="title">fvm</span>::<span class="title">ddt</span>(<span class="title">alpha</span>, <span class="title">rho</span>, <span class="title">epsilon_</span>)</span></span><br><span class="line">      + fvm::div<span class="container">(<span class="title">alphaRhoPhi</span>, <span class="title">epsilon_</span>)</span></span><br><span class="line">      - fvm::laplacian<span class="container">(<span class="title">alpha</span>*<span class="title">rho</span>*<span class="type">DepsilonEff</span>()</span>, epsilon_)</span><br><span class="line">     ==</span><br><span class="line">        <span class="type">C1_</span>*alpha*rho*<span class="type">G</span>*epsilon_/k_</span><br><span class="line">      - fvm::<span class="type">SuSp</span><span class="container">(((2.0/3.0)</span>*<span class="type">C1_</span> + <span class="type">C3_</span>)*alpha*rho*divU, epsilon_)</span><br><span class="line">      - fvm::<span class="type">Sp</span><span class="container">(<span class="type">C2_</span>*<span class="title">alpha</span>*<span class="title">rho</span>*<span class="title">epsilon_</span>/<span class="title">k_</span>, <span class="title">epsilon_</span>)</span></span><br><span class="line">      + epsilonSource<span class="container">()</span></span><br><span class="line">      + fvOptions<span class="container">(<span class="title">alpha</span>, <span class="title">rho</span>, <span class="title">epsilon_</span>)</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    epsEqn<span class="container">()</span>.relax<span class="container">()</span>;</span><br><span class="line">    fvOptions.constrain<span class="container">(<span class="title">epsEqn</span>()</span>);</span><br><span class="line">    epsEqn<span class="container">()</span>.boundaryManipulate<span class="container">(<span class="title">epsilon_</span>.<span class="title">boundaryField</span>()</span>);</span><br><span class="line">    solve<span class="container">(<span class="title">epsEqn</span>)</span>;</span><br><span class="line">    fvOptions.correct<span class="container">(<span class="title">epsilon_</span>)</span>;</span><br><span class="line">    bound<span class="container">(<span class="title">epsilon_</span>, <span class="title">this</span>-&gt;<span class="title">epsilonMin_</span>)</span>;</span><br><span class="line"></span><br><span class="line">    // <span class="type">Turbulent</span> kinetic energy equation</span><br><span class="line">    tmp&lt;fvScalarMatrix&gt; kEqn</span><br><span class="line">    <span class="container">(</span><br><span class="line">        <span class="title">fvm</span>::<span class="title">ddt</span>(<span class="title">alpha</span>, <span class="title">rho</span>, <span class="title">k_</span>)</span></span><br><span class="line">      + fvm::div<span class="container">(<span class="title">alphaRhoPhi</span>, <span class="title">k_</span>)</span></span><br><span class="line">      - fvm::laplacian<span class="container">(<span class="title">alpha</span>*<span class="title">rho</span>*<span class="type">DkEff</span>()</span>, k_)</span><br><span class="line">     ==</span><br><span class="line">        alpha*rho*<span class="type">G</span></span><br><span class="line">      - fvm::<span class="type">SuSp</span><span class="container">((2.0/3.0)</span>*alpha*rho*divU, k_)</span><br><span class="line">      - fvm::<span class="type">Sp</span><span class="container">(<span class="title">alpha</span>*<span class="title">rho</span>*<span class="title">epsilon_</span>/<span class="title">k_</span>, <span class="title">k_</span>)</span></span><br><span class="line">      + kSource<span class="container">()</span></span><br><span class="line">      + fvOptions<span class="container">(<span class="title">alpha</span>, <span class="title">rho</span>, <span class="title">k_</span>)</span></span><br><span class="line">    );</span></span><br></pre></td></tr></table></figure></p>
<p>从上述代码可以看出，输运方程中带入了密度 <code>rho</code> 和代表相体积分率的 <code>alpha</code> 。代入不同的模板参数， <code>rho</code> 和 <code>alpha</code> 的取值也会不同，从而实例化为不同的湍流模型，详细的后文还会分析。除此之外，输运方程中还加入了两种源项的实现，一种是以成员函数的形式（ <code>epsilonSource()</code> 和 <code>kEpsilon()</code> ）；另一种是以 <code>fvOptions</code> 的形式，允许用户自定义源项。</p>
<p>在这个架构下，湍流模型是怎么通过 RTS 机制来进行选择的呢？请看下一篇。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本系列分析 OpenFOAM-3.0 版本的湍流模型。从 3.0 版开始，OpenFOAM 中的湍流模型架构发生了较大的变化，其实这种变化在 2.3 版开始已经初露端倪，在 2.3 版里，多相流的湍流模型已经开始跟单相流湍流模型分开。从 3.0 开始，单相流湍流模型和多相流湍流模型统一到了一个架构下。本系列将对 3.0 版的湍流模型进行详细的分析，分为四部分：结构概览，RTS 机制分析，编译新模型的方法，以及一些补充说明。</p>]]>
    
    </summary>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="turbulence model" scheme="http://xiaopingqiu.github.io/tags/turbulence-model/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenFOAM 中的边界条件（四）]]></title>
    <link href="http://xiaopingqiu.github.io/2016/04/02/Boundary-conditions-in-OpenFOAM4/"/>
    <id>http://xiaopingqiu.github.io/2016/04/02/Boundary-conditions-in-OpenFOAM4/</id>
    <published>2016-04-02T10:16:39.000Z</published>
    <updated>2016-04-03T03:42:14.824Z</updated>
    <content type="html"><![CDATA[<h4 id="JohnsonJackson_边界条件">JohnsonJackson 边界条件</h4><p>本篇来看用于气固两相流模拟的 JohnsonJackson 边界条件。这组边界条件用于设定双流体模型中固相在壁面的速度和颗粒温度。根据 <a href="http://www.sciencedirect.com/science/article/pii/S0009250908003904" target="_blank" rel="external">N. Reuge 2008, CES</a>，壁面上的固相速度和颗粒温度可以表示为：<br><img src="/image/boundaryConditions/JJ.png" alt="JohnsonJackson boundary conditions"><br>其中，$u_m$ 指的是 m 相在壁面切向上的滑移速度。<br>下面来看 OpenFOAM 中对这两个边界条件的实现</p>
<a id="more"></a>
<p>在看 JohnsonJackson 边界条件之前，先要看一下 <code>partialSlip</code> 边界。</p>
<h5 id="partialSlip">partialSlip</h5><p><code>partialSlipFvPatchField</code> 继承自 <code>transformFvPatchField</code><br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line">class partialSlipFvPatchField</span><br><span class="line">:</span><br><span class="line">    public transformFvPatchField&lt;<span class="type">Type</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    // <span class="type">Private</span> data</span><br><span class="line"></span><br><span class="line">        //- <span class="type">Fraction</span> (<span class="number">0</span>-<span class="number">1</span>) <span class="keyword">of</span> value used <span class="keyword">for</span> boundary condition</span><br><span class="line">        scalarField valueFraction_;</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其定义了一个标量形式的 <code>valueFraction_</code> 。</p>
<ul>
<li>evaluate 函数<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">template<span class="subst">&lt;</span>class <span class="keyword">Type</span><span class="subst">&gt;</span></span><br><span class="line"><span class="literal">void</span> Foam<span class="tag">::partialSlipFvPatchField</span><span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::evaluate</span></span><br><span class="line">(</span><br><span class="line">    const Pstream<span class="tag">::commsTypes</span></span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="subst">!</span>this<span class="subst">-&gt;</span>updated())</span><br><span class="line">    &#123;</span><br><span class="line">        this<span class="subst">-&gt;</span>updateCoeffs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tmp<span class="subst">&lt;</span>vectorField<span class="subst">&gt;</span> nHat <span class="subst">=</span> this<span class="subst">-&gt;</span>patch()<span class="built_in">.</span>nf();</span><br><span class="line"></span><br><span class="line">    Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::operator</span><span class="subst">=</span></span><br><span class="line">    (</span><br><span class="line">        (<span class="number">1.0</span> <span class="subst">-</span> valueFraction_)</span><br><span class="line">       <span class="subst">*</span>transform(I <span class="subst">-</span> sqr(nHat), this<span class="subst">-&gt;</span>patchInternalField())</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    transformFvPatchField<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::evaluate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>与 <code>basicSymmetry</code> 相比，只是多了一项 <code>1.0 - valueFraction_</code> 。当 <code>valueFraction_ = 0</code> 时，其与 <code>basicSymmetry</code> 是一样的。</p>
<ul>
<li>snGradTransformDiag<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Type&gt;</span><br><span class="line">Foam::tmp&lt;Foam::Field&lt;Type&gt; &gt;</span><br><span class="line">Foam::partialSlipFvPatchField&lt;Type&gt;::snGradTransformDiag() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> vectorField <span class="title">nHat</span><span class="params">(<span class="keyword">this</span>-&gt;patch()</span>.<span class="title">nf</span><span class="params">()</span>)</span>;</span><br><span class="line">    <span class="function">vectorField <span class="title">diag</span><span class="params">(nHat.size()</span>)</span>;</span><br><span class="line"></span><br><span class="line">    diag.replace(<span class="built_in">vector</span>::X, mag(nHat.component(<span class="built_in">vector</span>::X)));</span><br><span class="line">    diag.replace(<span class="built_in">vector</span>::Y, mag(nHat.component(<span class="built_in">vector</span>::Y)));</span><br><span class="line">    diag.replace(<span class="built_in">vector</span>::Z, mag(nHat.component(<span class="built_in">vector</span>::Z)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        valueFraction_*pTraits&lt;Type&gt;::one</span><br><span class="line">      + (<span class="number">1.0</span> - valueFraction_)</span><br><span class="line">       *transformFieldMask&lt;Type&gt;(<span class="built_in">pow</span>&lt;<span class="built_in">vector</span>, pTraits&lt;Type&gt;::rank&gt;(diag));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>当 <code>valueFraction_ = 0</code> 时，这里的返回值与 <code>basicSymmetry</code> 也是一样的。</p>
<ul>
<li>snGrad<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class <span class="constant">Type&gt;</span></span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:tmp&lt;Foam</span><span class="symbol">:</span><span class="symbol">:Field&lt;Type&gt;</span> &gt;</span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:partialSlipFvPatchField&lt;Type&gt;</span><span class="symbol">:</span><span class="symbol">:snGrad</span>() const</span><br><span class="line">&#123;</span><br><span class="line">    tmp&lt;vectorField&gt; nHat = this-&gt;patch().nf();</span><br><span class="line">    const <span class="constant">Field&lt;Type&gt;</span> pif(this-&gt;patchInternalField());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    (</span><br><span class="line">        (<span class="number">1.0</span> - valueFraction<span class="constant">_</span>)*transform(<span class="constant">I </span>- sqr(nHat), pif) - pif</span><br><span class="line">    )*this-&gt;patch().deltaCoeffs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><a href="http://cfd.direct/openfoam/user-guide/boundaries/" target="_blank" rel="external">User guide</a> 里说这个边界是 <code>slip</code> 和 <code>zeroGradient</code> 的混合。 <code>valueFraction_ = 0</code> 时， <code>partialSlip</code> 与 <code>slip</code> 等价，这一点上面说明了。不过， 另一个极端，<code>valueFraction_ = 1</code> 时，却似乎不是跟 <code>zeroGradient</code> 等价。至少， <code>evaluate</code> 函数在<code>valueFraction_ = 1</code> 时与 <code>zeroGradient</code> 中的是不一样的。</p>
<p>这里提到了 <code>slip</code> 这个边界，顺便再说一下， <code>slip</code> 边界继承自 <code>basicSymmetry</code> ，而且没有增加任何新的定义，所以， <code>slip</code> 与  <code>basicSymmetry</code> 的效果是等价的。对于标量， <code>slip</code> 与 <code>zeroGradient</code> 一样；对于矢量，以速度为例， <code>slip</code> 定义的边界上的速度值等于边界所属网格的速度的平行边界的分量，即<br>$$<br>u_p = u_C - (\mathbf{I}-\overrightarrow{n} \otimes \overrightarrow{n})\cdot u_C<br>$$</p>
<h5 id="JohnsonJacksonParticleSlip">JohnsonJacksonParticleSlip</h5><p>这个边界条件继承自 <code>partialSlip</code>，在此基础上额外定义了镜面反弹系数 <code>specularityCoefficient_</code> 。代码的核心在 <code>updateCoeffs</code> 函数<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Foam::JohnsonJacksonParticleSlipFvPatchVectorField::updateCoeffs()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (updated())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lookup the fluid model and the phase</span></span><br><span class="line">    <span class="keyword">const</span> twoPhaseSystem&amp; fluid = db().lookupObject&lt;twoPhaseSystem&gt;</span><br><span class="line">    (</span><br><span class="line">        <span class="string">"phaseProperties"</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> phaseModel&amp; phased</span><br><span class="line">    (</span><br><span class="line">        fluid.phase1().name() == dimensionedInternalField().group()</span><br><span class="line">      ? fluid.phase1()</span><br><span class="line">      : fluid.phase2()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lookup all the fields on this patch</span></span><br><span class="line">    <span class="keyword">const</span> fvPatchScalarField&amp; alpha</span><br><span class="line">    (</span><br><span class="line">        patch().lookupPatchField&lt;volScalarField, scalar&gt;</span><br><span class="line">        (</span><br><span class="line">            phased.volScalarField::name()</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> fvPatchScalarField&amp; gs0</span><br><span class="line">    (</span><br><span class="line">        patch().lookupPatchField&lt;volScalarField, scalar&gt;</span><br><span class="line">        (</span><br><span class="line">            IOobject::groupName(<span class="string">"gs0"</span>, phased.name())</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> scalarField nu</span><br><span class="line">    (</span><br><span class="line">        patch().lookupPatchField&lt;volScalarField, scalar&gt;</span><br><span class="line">        (</span><br><span class="line">            IOobject::groupName(<span class="string">"nut"</span>, phased.name())</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    word ThetaName(IOobject::groupName(<span class="string">"Theta"</span>, phased.name()));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> fvPatchScalarField&amp; Theta</span><br><span class="line">    (</span><br><span class="line">        db().foundObject&lt;volScalarField&gt;(ThetaName)</span><br><span class="line">      ? patch().lookupPatchField&lt;volScalarField, scalar&gt;(ThetaName)</span><br><span class="line">      : alpha</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lookup the packed volume fraction</span></span><br><span class="line">    dimensionedScalar alphaMax</span><br><span class="line">    (</span><br><span class="line">        <span class="string">"alphaMax"</span>,</span><br><span class="line">        dimless,</span><br><span class="line">        db()</span><br><span class="line">       .lookupObject&lt;IOdictionary&gt;</span><br><span class="line">        (</span><br><span class="line">            IOobject::groupName(<span class="string">"turbulenceProperties"</span>, phased.name())</span><br><span class="line">        )</span><br><span class="line">       .subDict(<span class="string">"RAS"</span>)</span><br><span class="line">       .subDict(<span class="string">"kineticTheoryCoeffs"</span>)</span><br><span class="line">       .lookup(<span class="string">"alphaMax"</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// calculate the slip value fraction</span></span><br><span class="line">    scalarField c</span><br><span class="line">    (</span><br><span class="line">        constant::mathematical::pi</span><br><span class="line">       *alpha</span><br><span class="line">       *gs0</span><br><span class="line">       *specularityCoefficient_.value()</span><br><span class="line">       *sqrt(3.0*Theta)</span><br><span class="line">       /max(6.0*nu*alphaMax.value(), SMALL)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;valueFraction() = c/(c + patch().deltaCoeffs());</span><br><span class="line"></span><br><span class="line">    partialSlipFvPatchVectorField::updateCoeffs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数主要的功能是重定义了继承自 <code>partialSlip</code> 中的 <code>valueFraction_</code>。结合 <code>partialSlip</code> 中的定义，可以知道最终 <code>JohnsonJacksonParticleSlip</code> 定义的边界速度的值为<br>$$<br>u_m=(1-\frac{c}{c+\Delta}) \cdot (\mathbf{I}-\overrightarrow{n}\otimes\overrightarrow{n})\cdot u_c<br>$$<br>其中 $u_c$ 为邻近壁面网格的 m 相的速度。<code>c</code> 的定义为：<br>$$<br>c=\frac{\pi \varepsilon_m g_0 \phi\sqrt{3\Theta}}{6.0\nu_m\varepsilon_m^{max}}<br>$$<br>对照上述公式(34)，根据 $c$ 的定义，这里可以把公式(34)简写为<br>$$<br>\frac{\partial u_m}{\partial x}=-cu_m<br>$$<br>写成差分形式，即<br>$$<br>(u_m-u_{ct})\cdot \Delta=-cu_m<br>$$<br>于是得到<br>$$<br>u_m = \frac{\Delta}{c+\Delta}u_{ct}<br>$$<br>若 $u_{ct}$ 定义为邻近壁面网格的速度壁面切向分量，则公式(34)与代码是一致的。</p>
<h5 id="JohnsonJacksonParticleTheta">JohnsonJacksonParticleTheta</h5><p>这个边界条件继承自 <code>mixed</code> ，此外新增了两个数据成员： <code>specularityCoefficient_</code> 和 <code>restitutionCoefficient_</code> 。核心的函数也是 <code>updateCoeffs</code> 。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Foam::JohnsonJacksonParticleThetaFvPatchScalarField::updateCoeffs()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (updated())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lookup the fluid model and the phase</span></span><br><span class="line">    <span class="keyword">const</span> twoPhaseSystem&amp; fluid = db().lookupObject&lt;twoPhaseSystem&gt;</span><br><span class="line">    (</span><br><span class="line">        <span class="string">"phaseProperties"</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> phaseModel&amp; phased</span><br><span class="line">    (</span><br><span class="line">        fluid.phase1().name() == dimensionedInternalField().group()</span><br><span class="line">      ? fluid.phase1()</span><br><span class="line">      : fluid.phase2()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lookup all the fields on this patch</span></span><br><span class="line">    <span class="keyword">const</span> fvPatchScalarField&amp; alpha</span><br><span class="line">    (</span><br><span class="line">        patch().lookupPatchField&lt;volScalarField, scalar&gt;</span><br><span class="line">        (</span><br><span class="line">            phased.volScalarField::name()</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> fvPatchVectorField&amp; U</span><br><span class="line">    (</span><br><span class="line">        patch().lookupPatchField&lt;volVectorField, vector&gt;</span><br><span class="line">        (</span><br><span class="line">            IOobject::groupName(<span class="string">"U"</span>, phased.name())</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> fvPatchScalarField&amp; gs0</span><br><span class="line">    (</span><br><span class="line">        patch().lookupPatchField&lt;volScalarField, scalar&gt;</span><br><span class="line">        (</span><br><span class="line">            IOobject::groupName(<span class="string">"gs0"</span>, phased.name())</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> fvPatchScalarField&amp; kappa</span><br><span class="line">    (</span><br><span class="line">        patch().lookupPatchField&lt;volScalarField, scalar&gt;</span><br><span class="line">        (</span><br><span class="line">            IOobject::groupName(<span class="string">"kappa"</span>, phased.name())</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> scalarField Theta(patchInternalField());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lookup the packed volume fraction</span></span><br><span class="line">    dimensionedScalar alphaMax</span><br><span class="line">    (</span><br><span class="line">        <span class="string">"alphaMax"</span>,</span><br><span class="line">        dimless,</span><br><span class="line">        db()</span><br><span class="line">       .lookupObject&lt;IOdictionary&gt;</span><br><span class="line">        (</span><br><span class="line">            IOobject::groupName(<span class="string">"turbulenceProperties"</span>, phased.name())</span><br><span class="line">        )</span><br><span class="line">       .subDict(<span class="string">"RAS"</span>)</span><br><span class="line">       .subDict(<span class="string">"kineticTheoryCoeffs"</span>)</span><br><span class="line">       .lookup(<span class="string">"alphaMax"</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// calculate the reference value and the value fraction</span></span><br><span class="line">    <span class="keyword">if</span> (restitutionCoefficient_.value() != <span class="number">1.0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;refValue() =</span><br><span class="line">            (<span class="number">2.0</span>/<span class="number">3.0</span>)</span><br><span class="line">           *specularityCoefficient_.value()</span><br><span class="line">           *magSqr(U)</span><br><span class="line">           /(scalar(<span class="number">1</span>) - sqr(restitutionCoefficient_.value()));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>-&gt;refGrad() = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">        scalarField c</span><br><span class="line">        (</span><br><span class="line">             constant::mathematical::pi</span><br><span class="line">            *alpha</span><br><span class="line">            *gs0</span><br><span class="line">            *(scalar(1) - sqr(restitutionCoefficient_.value()))</span><br><span class="line">            *sqrt(3.0*Theta)</span><br><span class="line">            /max(4.0*kappa*alphaMax.value(), SMALL)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>-&gt;valueFraction() = c/(c + patch().deltaCoeffs());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for a restitution coefficient of 1, the boundary degenerates to a fixed</span></span><br><span class="line">    <span class="comment">// gradient condition</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;refValue() = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>-&gt;refGrad() =</span><br><span class="line">            pos(alpha - SMALL)</span><br><span class="line">           *constant::mathematical::pi</span><br><span class="line">           *specularityCoefficient_.value()</span><br><span class="line">           *alpha</span><br><span class="line">           *gs0</span><br><span class="line">           *sqrt(3.0*Theta)</span><br><span class="line">           *magSqr(U)</span><br><span class="line">           /max(6.0*kappa*alphaMax.value(), SMALL);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>-&gt;valueFraction() = <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mixedFvPatchScalarField::updateCoeffs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里分两种情况，即 <code>restitutionCoefficient_</code> 是否等于1。其实从公式(35)也能看出来，$e_w=1$ 与 $e_w \neq 1$ 是不一样的。</p>
<ul>
<li><p>$e_w\neq 1$<br>这时，重定义了 <code>refValue</code> 和 <code>valueFraction</code>。利用辅助变量 $c$ 的定义，可以将公式(35)简化如下：<br>$$<br>\frac{\partial \Theta_m}{\partial x}=c \cdot refValue - c \cdot \Theta_m<br>$$<br>写成差分形式<br>$$<br>(\Theta_m-\Theta_c) \cdot \Delta = c\cdot refValue - c \cdot \Theta_m<br>$$<br>得<br>$$<br>\Theta_m=\frac{c}{c+\Delta}\cdot refValue + \frac{\Delta}{c+\Delta} \cdot \Theta_c<br>$$<br>其中 $\Theta_c$ 为邻近壁面网格的颗粒温度。<br>根据 <code>mixed</code> 的定义，壁面的值应当是 <code>valureFraction * refValue + (1-valueFraction)*(patchInternalField() + refGrad/delta)</code>。 这里将 <code>refGrad</code> 赋值为0，就与公式一致了。</p>
</li>
<li><p>$e_w = 1$<br>这种情况下， <code>JohnsonJacksonParticleTheta</code> 就退化为简单的 <code>fixedGradient</code> 了。若 $ \varepsilon_m $ 特别小，则为零梯度，否则，固定梯度，梯度值等于公式(35)的右边第一项。</p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="JohnsonJackson_边界条件">JohnsonJackson 边界条件</h4><p>本篇来看用于气固两相流模拟的 JohnsonJackson 边界条件。这组边界条件用于设定双流体模型中固相在壁面的速度和颗粒温度。根据 <a href="http://www.sciencedirect.com/science/article/pii/S0009250908003904">N. Reuge 2008, CES</a>，壁面上的固相速度和颗粒温度可以表示为：<br><img src="/image/boundaryConditions/JJ.png" alt="JohnsonJackson boundary conditions"><br>其中，$u_m$ 指的是 m 相在壁面切向上的滑移速度。<br>下面来看 OpenFOAM 中对这两个边界条件的实现</p>]]>
    
    </summary>
    
      <category term="Boundary conditions" scheme="http://xiaopingqiu.github.io/tags/Boundary-conditions/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenFOAM 中的边界条件（三）]]></title>
    <link href="http://xiaopingqiu.github.io/2016/04/02/Boundary-conditions-in-OpenFOAM3/"/>
    <id>http://xiaopingqiu.github.io/2016/04/02/Boundary-conditions-in-OpenFOAM3/</id>
    <published>2016-04-02T09:29:16.000Z</published>
    <updated>2016-04-03T07:44:44.840Z</updated>
    <content type="html"><![CDATA[<p>OpenFOAM 中有很多复杂的边界都是继承自上篇中提到的三个基础边界条件，这些边界条件的代码在上一篇的基础上就很容易看懂了。只不过，还有一些边界条件，不是继承自这三个基础边界条件的，其中有一些都直接或间接继承自另一个重要的边界条件： <code>transformFvPatchField</code>。本篇来看看这个 <code>transformFvPatchField</code> 以及几个继承自它的边界条件。</p>
<a id="more"></a>
<h5 id="5-_transform">5. transform</h5><p>这是一个抽象基类，主要注意一下四个函数的定义：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line">tmp&lt;<span class="type">Field</span>&lt;<span class="type">Type</span>&gt; &gt; transformFvPatchField&lt;<span class="type">Type</span>&gt;::valueInternalCoeffs</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;scalarField&gt;&amp;</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> pTraits&lt;<span class="type">Type</span>&gt;::one - snGradTransformDiag();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line">tmp&lt;<span class="type">Field</span>&lt;<span class="type">Type</span>&gt; &gt; transformFvPatchField&lt;<span class="type">Type</span>&gt;::valueBoundaryCoeffs</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;scalarField&gt;&amp;</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        *this</span><br><span class="line">      - cmptMultiply</span><br><span class="line">        (</span><br><span class="line">            valueInternalCoeffs(this-&gt;patch().weights()),</span><br><span class="line">            this-&gt;patchInternalField()</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line">tmp&lt;<span class="type">Field</span>&lt;<span class="type">Type</span>&gt; &gt; transformFvPatchField&lt;<span class="type">Type</span>&gt;::gradientInternalCoeffs() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> -this-&gt;patch().deltaCoeffs()*snGradTransformDiag();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line">tmp&lt;<span class="type">Field</span>&lt;<span class="type">Type</span>&gt; &gt; transformFvPatchField&lt;<span class="type">Type</span>&gt;::gradientBoundaryCoeffs() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        snGrad()</span><br><span class="line">      - cmptMultiply(gradientInternalCoeffs(), this-&gt;patchInternalField());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于 <code>snGrad</code> 和 <code>snGradTransformDiag</code> 都是纯虚函数，所以这四个函数的具体返回值需要在派生类中实现了 <code>snGrad</code> 和 <code>snGradTransformDiag</code> 之后才能确定。<br>另外注意，当模板参数为 <code>scalar</code> 时， <code>gradientInternalCoeffs</code> 函数有特殊的定义：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line">tmp&lt;scalarField &gt; transformFvPatchField&lt;scalar&gt;::gradientInternalCoeffs() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> tmp&lt;scalarField &gt;(new scalarField(size(), <span class="number">0</span>.<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="6-_directionMixed">6. directionMixed</h5><p>这个类，跟前面的 <code>mixed</code> 有点类似，但是又继承自 <code>transform</code> ，所以，似乎是二者的结合。<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">template&lt;<span class="keyword">class</span> <span class="keyword">Type</span>&gt;</span><br><span class="line"><span class="keyword">class</span> directionMixedFvPatchField</span><br><span class="line">:</span><br><span class="line">    <span class="keyword">public</span> transformFvPatchField&lt;<span class="keyword">Type</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    // <span class="keyword">Private</span> <span class="type">data</span></span><br><span class="line"></span><br><span class="line">        //- <span class="keyword">Value</span> field</span><br><span class="line">        Field&lt;<span class="keyword">Type</span>&gt; refValue_;</span><br><span class="line"></span><br><span class="line">        //- Normal gradient field</span><br><span class="line">        Field&lt;<span class="keyword">Type</span>&gt; refGrad_;</span><br><span class="line"></span><br><span class="line">        //- <span class="built_in">Fraction</span> (<span class="number">0</span>-<span class="number">1</span>) of <span class="keyword">value</span> used for boundary condition</span><br><span class="line">        symmTensorField valueFraction_;</span><br></pre></td></tr></table></figure></p>
<p>与 <code>mixed</code> 相似之处是，这里也定义了 <code>refValue_</code> ， <code>refGrad_</code> 和 <code>valueFraction_</code> 三个参数，所不同的是，这里的 <code>valueFraction_</code> 是一个对称张量。</p>
<p>接下来， <code>directionMixed</code> 定义了 <code>snGrad</code> 和 <code>snGradTransformDiag</code> 这两个函数</p>
<ul>
<li><p><code>snGrad</code> 和 <code>snGradTransformDiag</code></p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class <span class="constant">Type&gt;</span></span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:tmp&lt;Foam</span><span class="symbol">:</span><span class="symbol">:Field&lt;Type&gt;</span> &gt;</span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:directionMixedFvPatchField&lt;Type&gt;</span><span class="symbol">:</span><span class="symbol">:snGrad</span>() const</span><br><span class="line">&#123;</span><br><span class="line">    const <span class="constant">Field&lt;Type&gt;</span> pif(this-&gt;patchInternalField());</span><br><span class="line"></span><br><span class="line">    tmp&lt;<span class="constant">Field&lt;Type&gt;</span> &gt; normalValue = transform(valueFraction<span class="constant">_</span>, refValue<span class="constant">_</span>);</span><br><span class="line"></span><br><span class="line">    tmp&lt;<span class="constant">Field&lt;Type&gt;</span> &gt; gradValue = pif + refGrad<span class="constant">_</span>/this-&gt;patch().deltaCoeffs();</span><br><span class="line"></span><br><span class="line">    tmp&lt;<span class="constant">Field&lt;Type&gt;</span> &gt; transformGradValue =</span><br><span class="line">        transform(<span class="constant">I </span>- valueFraction<span class="constant">_</span>, gradValue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        (normalValue + transformGradValue - pif)*</span><br><span class="line">        this-&gt;patch().deltaCoeffs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class <span class="constant">Type&gt;</span></span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:tmp&lt;Foam</span><span class="symbol">:</span><span class="symbol">:Field&lt;Type&gt;</span> &gt;</span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:directionMixedFvPatchField&lt;Type&gt;</span><span class="symbol">:</span><span class="symbol">:snGradTransformDiag</span>() const</span><br><span class="line">&#123;</span><br><span class="line">    vectorField diag(valueFraction<span class="constant">_</span>.size());</span><br><span class="line"></span><br><span class="line">    diag.replace</span><br><span class="line">    (</span><br><span class="line">        <span class="symbol">vector:</span><span class="symbol">:X</span>,</span><br><span class="line">        sqrt(mag(valueFraction<span class="constant">_</span>.component(<span class="symbol">symmTensor:</span><span class="symbol">:XX</span>)))</span><br><span class="line">    );</span><br><span class="line">    diag.replace</span><br><span class="line">    (</span><br><span class="line">        <span class="symbol">vector:</span><span class="symbol">:Y</span>,</span><br><span class="line">        sqrt(mag(valueFraction<span class="constant">_</span>.component(<span class="symbol">symmTensor:</span><span class="symbol">:YY</span>)))</span><br><span class="line">    );</span><br><span class="line">    diag.replace</span><br><span class="line">    (</span><br><span class="line">        <span class="symbol">vector:</span><span class="symbol">:Z</span>,</span><br><span class="line">        sqrt(mag(valueFraction<span class="constant">_</span>.component(<span class="symbol">symmTensor:</span><span class="symbol">:ZZ</span>)))</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> transformFieldMask&lt;<span class="constant">Type&gt;</span>(pow&lt;vector, pTraits&lt;<span class="constant">Type&gt;</span><span class="symbol">:</span><span class="symbol">:rank&gt;</span>(diag));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>evaluate</code> 函数</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">template<span class="subst">&lt;</span>class <span class="keyword">Type</span><span class="subst">&gt;</span></span><br><span class="line"><span class="literal">void</span> Foam<span class="tag">::directionMixedFvPatchField</span><span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::evaluate</span>(const Pstream<span class="tag">::commsTypes</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="subst">!</span>this<span class="subst">-&gt;</span>updated())</span><br><span class="line">    &#123;</span><br><span class="line">        this<span class="subst">-&gt;</span>updateCoeffs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tmp<span class="subst">&lt;</span>Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span> <span class="subst">&gt;</span> normalValue <span class="subst">=</span> transform(valueFraction_, refValue_);</span><br><span class="line"></span><br><span class="line">    tmp<span class="subst">&lt;</span>Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span> <span class="subst">&gt;</span> gradValue <span class="subst">=</span></span><br><span class="line">        this<span class="subst">-&gt;</span>patchInternalField() <span class="subst">+</span> refGrad_/this<span class="subst">-&gt;</span>patch()<span class="built_in">.</span>deltaCoeffs();</span><br><span class="line"></span><br><span class="line">    tmp<span class="subst">&lt;</span>Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span> <span class="subst">&gt;</span> transformGradValue <span class="subst">=</span></span><br><span class="line">        transform(I <span class="subst">-</span> valueFraction_, gradValue);</span><br><span class="line"></span><br><span class="line">    Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::operator</span><span class="subst">=</span>(normalValue <span class="subst">+</span> transformGradValue);</span><br><span class="line"></span><br><span class="line">    transformFvPatchField<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::evaluate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="7-_basicSymmetry">7. basicSymmetry</h5><p>这个类的结构与 <code>directionMixed</code> 类似，对 <code>snGrad</code> ， <code>snGradTransformDiag</code> 和 <code>evaluate</code> 等几个函数进行了重新定义。</p>
<ul>
<li><p><code>snGrad</code> 和 <code>snGradTransformDiag</code></p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class <span class="constant">Type&gt;</span></span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:tmp&lt;Foam</span><span class="symbol">:</span><span class="symbol">:Field&lt;Type&gt;</span> &gt;</span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:basicSymmetryFvPatchField&lt;Type&gt;</span><span class="symbol">:</span><span class="symbol">:snGrad</span>() const</span><br><span class="line">&#123;</span><br><span class="line">    tmp&lt;vectorField&gt; nHat = this-&gt;patch().nf();</span><br><span class="line"></span><br><span class="line">    const <span class="constant">Field&lt;Type&gt;</span> iF(this-&gt;patchInternalField());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        (transform(<span class="constant">I </span>- <span class="number">2.0</span>*sqr(nHat), iF) - iF)</span><br><span class="line">       *(this-&gt;patch().deltaCoeffs()/<span class="number">2.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class <span class="constant">Type&gt;</span></span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:tmp&lt;Foam</span><span class="symbol">:</span><span class="symbol">:Field&lt;Type&gt;</span> &gt;</span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:basicSymmetryFvPatchField&lt;Type&gt;</span><span class="symbol">:</span><span class="symbol">:snGradTransformDiag</span>() const</span><br><span class="line">&#123;</span><br><span class="line">    const vectorField nHat(this-&gt;patch().nf());</span><br><span class="line"></span><br><span class="line">    vectorField diag(nHat.size());</span><br><span class="line"></span><br><span class="line">    diag.replace(<span class="symbol">vector:</span><span class="symbol">:X</span>, mag(nHat.component(<span class="symbol">vector:</span><span class="symbol">:X</span>)));</span><br><span class="line">    diag.replace(<span class="symbol">vector:</span><span class="symbol">:Y</span>, mag(nHat.component(<span class="symbol">vector:</span><span class="symbol">:Y</span>)));</span><br><span class="line">    diag.replace(<span class="symbol">vector:</span><span class="symbol">:Z</span>, mag(nHat.component(<span class="symbol">vector:</span><span class="symbol">:Z</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> transformFieldMask&lt;<span class="constant">Type&gt;</span>(pow&lt;vector, pTraits&lt;<span class="constant">Type&gt;</span><span class="symbol">:</span><span class="symbol">:rank&gt;</span>(diag));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>evaluate</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">template<span class="subst">&lt;</span>class <span class="keyword">Type</span><span class="subst">&gt;</span></span><br><span class="line"><span class="literal">void</span> Foam<span class="tag">::basicSymmetryFvPatchField</span><span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::evaluate</span>(const Pstream<span class="tag">::commsTypes</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="subst">!</span>this<span class="subst">-&gt;</span>updated())</span><br><span class="line">    &#123;</span><br><span class="line">        this<span class="subst">-&gt;</span>updateCoeffs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tmp<span class="subst">&lt;</span>vectorField<span class="subst">&gt;</span> nHat <span class="subst">=</span> this<span class="subst">-&gt;</span>patch()<span class="built_in">.</span>nf();</span><br><span class="line"></span><br><span class="line">    const Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span> <span class="keyword">iF</span>(this<span class="subst">-&gt;</span>patchInternalField());</span><br><span class="line"></span><br><span class="line">    Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::operator</span><span class="subst">=</span></span><br><span class="line">    (</span><br><span class="line">        (<span class="keyword">iF</span> <span class="subst">+</span> transform(I <span class="subst">-</span> <span class="number">2.0</span><span class="subst">*</span>sqr(nHat), <span class="keyword">iF</span>))/<span class="number">2.0</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    transformFvPatchField<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::evaluate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>另外，值得注意的是，当模板参数 <code>Type</code> 是 <code>scalar</code> 时， <code>snGrad</code> 和 <code>evaluate</code> 函数有其他的定义：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">Foam</span>::tmp&lt;<span class="type">Foam</span>::scalarField&gt;</span><br><span class="line"><span class="type">Foam</span>::basicSymmetryFvPatchField&lt;<span class="type">Foam</span>::scalar&gt;::snGrad() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> tmp&lt;scalarField &gt;(new scalarField(size(), <span class="number">0</span>.<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="type">Foam</span>::basicSymmetryFvPatchField&lt;<span class="type">Foam</span>::scalar&gt;::evaluate</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> <span class="type">Pstream</span>::commsTypes</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!updated())</span><br><span class="line">    &#123;</span><br><span class="line">        updateCoeffs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    scalarField::operator=(patchInternalField());</span><br><span class="line">    transformFvPatchField&lt;scalar&gt;::evaluate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从这两个函数可推断，当 <code>Type = scalar</code> 时， <code>basicSymmetry</code> 其实就相当于 <code>zeroGradient</code>。 </p>
<p>关于 <code>transform</code> 和 <code>transformFieldMask</code> 这两个函数，摸索了很久。前者涉及的源文件有 <a href="http://foam.sourceforge.net/docs/cpp/a07932_source.html" target="_blank" rel="external"><code>symmTransformField.C</code></a> ，<a href="http://foam.sourceforge.net/docs/cpp/a07942_source.html" target="_blank" rel="external"> <code>transformFieldTemplates.C</code> </a>；后者的定义在 <a href="http://foam.sourceforge.net/docs/cpp/a07933_source.html" target="_blank" rel="external"><code>symmTransformField.H</code></a>，涉及到的 <code>pow</code> 函数的定义在<a href="http://foam.sourceforge.net/docs/cpp/a07889_source.html" target="_blank" rel="external"><code>FieldFunctions.C</code></a>。此外，这两个函数还需要用到类似 <code>TFOR_ALL_F_OP_FUNC_F_F</code> 的宏，定义在<a href="http://foam.sourceforge.net/docs/cpp/a07893_source.html#l00153" target="_blank" rel="external"><code>fieldM.H</code></a>，而这个宏里涉及到的类似 <code>List_ELEM</code> 这样的宏，则定义在 <a href="http://foam.sourceforge.net/docs/cpp/a07587_source.html" target="_blank" rel="external"><code>ListLoopM.H</code></a>。</p>
<p>看了这么多，仍然无法完全确定这两个函数的具体的行为。主要的障碍在于那个 <code>pow</code> 函数实在看不明白。最后只好来对这两个函数进行了一些测试，测试结果总结如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">transform</span><span class="params">(tensorField p1, vectorField p2)</span></span></span><br></pre></td></tr></table></figure></p>
<p>返回的是另一个 <code>vectorField</code> ，其值等于 <code>p1</code> 与 <code>p2</code> 的内积（即点乘）。注意，一般使用过程中总能保证 <code>p1.size() == p2.size()</code>，但是如果 <code>p1.size() &gt; p2.size()</code>， 则返回结果的 <code>size</code> 等于 <code>p2.size()</code> ，值则等于 <code>p1</code> 的前 <code>p2.size()</code> 部分与 <code>p2</code> 的内积。<br><a href="http://www.slideshare.net/fumiyanozaki96/boundary-conditions-in-openfoam" target="_blank" rel="external">Boundary Conditions in OpenFOAM</a> 这个 silde 也提到了29页也同样提到了 <code>transform</code> 函数的作用<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">inline scalar transform(constsymmTensor&amp;, <span class="keyword">const</span> scalar s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Cmpt</span>&gt;</span><br><span class="line">inline <span class="type">Vector</span>&lt;<span class="type">Cmpt</span>&gt; transform(<span class="keyword">const</span> symmTensor&amp; stt, <span class="keyword">const</span> <span class="type">Vector</span>&lt;<span class="type">Cmpt</span>&gt;&amp; v)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> stt &amp; v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而 <code>transformFieldMask</code><br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transformFieldMask&lt;Type&gt;<span class="list">(<span class="keyword">pow&lt;vector</span>, pTraits&lt;Type&gt;:<span class="keyword">:rank&gt;</span><span class="list">(<span class="keyword">diag</span>)</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>目前测试的结果是，其返回值等于 <code>diag</code> 。</p>
<p>有了上面对 <code>transform</code> 和 <code>transformFieldMask</code> 两个函数的测试结果，就可以来分析 <code>basicSymmetry</code> 和 <code>directionMixed</code> 两个边界条件的行为了。</p>
<h5 id="basicSymmetry">basicSymmetry</h5><p>对于标量，前面说过其等价于 <code>zeroGradient</code>，所以这里只分析矢量的情形。<br>从 <code>evaluate</code> 函数，可以得到如下公式<br>$$<br>\begin{align}<br>\overrightarrow{\phi}_b = &amp; \left [\overrightarrow{\phi}_c + (\mathrm{I} - 2\overrightarrow{n} \otimes \overrightarrow{n})\cdot \overrightarrow{\phi}_c  \right ] \cdot \frac{1}{2.0} \\<br>= &amp;  \overrightarrow{\phi}_c- \left ( \overrightarrow{\phi}_c \cdot  \overrightarrow{n} \right)\cdot \overrightarrow{n}<br>\end{align}<br>$$<br>这意味着，边界上的值等于其邻近网格中心的值的切向分量。<br>为了方便分析四个系数，将上式写成分量的形式:<br>$$<br>\begin{align}<br>\begin{bmatrix}<br>\phi_{px} \\<br>\phi_{py} \\<br>\phi_{pz}<br>\end{bmatrix} = &amp;<br>\begin{bmatrix}<br>\phi_{cx} \\<br>\phi_{cy} \\<br>\phi_{cz}<br>\end{bmatrix} -<br>\begin{bmatrix}<br>(\phi_{cx}n_x + \phi_{cy}n_y + \phi_{cz}n_z)n_x \\<br>(\phi_{cx}n_x + \phi_{cy}n_y + \phi_{cz}n_z)n_y \\<br>(\phi_{cx}n_x + \phi_{cy}n_y + \phi_{cz}n_z)n_z<br>\end{bmatrix} \\<br>= &amp; \begin{bmatrix}<br>(1-n_xn_x)\phi_{cx} \\<br>(1-n_yn_y)\phi_{cy} \\<br>(1-n_zn_z)\phi_{cz}<br>\end{bmatrix} -<br>\begin{bmatrix}<br>\phi_{cy}n_yn_x + \phi_{cz}n_zn_x \\<br>\phi_{cx}n_xn_y + \phi_{cz}n_zn_y \\<br>\phi_{cx}n_xn_z + \phi_{cy}n_yn_z<br>\end{bmatrix}<br>\end{align}<br>$$<br>照此公式，可以分析得到四个系数如下：<br>$$<br>valueInternalCoeffs =<br>\begin{bmatrix}<br>(1-n_xn_x) \\<br>(1-n_yn_y) \\<br>(1-n_zn_z)<br>\end{bmatrix}<br>$$<br>$$<br>valueBoundaryCoeffs =<br>\begin{bmatrix}<br>\phi_{px} \\<br>\phi_{py} \\<br>\phi_{pz}<br>\end{bmatrix} - valueInternalCoeffs<br>\begin{bmatrix}<br>\phi_{cx} \\<br>\phi_{cy} \\<br>\phi_{cz}<br>\end{bmatrix}<br>$$<br>$$<br>gradientInternalCoeffs= - \Delta<br>\begin{bmatrix}<br>(n_xn_x) \\<br>(n_yn_y) \\<br>(n_zn_z)<br>\end{bmatrix}<br>$$<br>$$<br>gradientBoundaryCoeffs = - \begin{bmatrix}<br>(\phi_{cx}n_x + \phi_{cy}n_y + \phi_{cz}n_z)n_x \\<br>(\phi_{cx}n_x + \phi_{cy}n_y + \phi_{cz}n_z)n_y \\<br>(\phi_{cx}n_x + \phi_{cy}n_y + \phi_{cz}n_z)n_z<br>\end{bmatrix}  \Delta - gradientInternalCoeffs<br>\begin{bmatrix}<br>\phi_{cx} \\<br>\phi_{cy} \\<br>\phi_{cz}<br>\end{bmatrix}<br>$$</p>
<p><strong> 但是，实际上 OpenFOAM 里不是这么实现的</strong>！关键就在于这个 <code>snGradTransformDiag</code> 函数的定义与预期不符。<br>根据我的测试， <code>snGradTransformDiag</code> 函数返回值应该是<br>$$<br>snGradTransformDiag =<br>\begin{bmatrix}<br>|n_x| \\<br>|n_y| \\<br>|n_z|<br>\end{bmatrix}<br>$$<br>即，张量 $\overrightarrow{n}\otimes\overrightarrow{n}$ 的主对角线元素组成的矢量。</p>
<p>而 <code>snGrad</code> 函数的返回值，根据代码可知<br>$$<br>snGrad = - \left ( \overrightarrow{\phi}_c \cdot  \overrightarrow{n} \right)\cdot \overrightarrow{n}\cdot \Delta<br>$$<br>所以，OpenFOAM 中定义的四个系数为：<br>$$<br>valueInternalCoeffs =<br>\begin{bmatrix}<br>(1-|n_x|) \\<br>(1-|n_y|) \\<br>(1-|n_z|)<br>\end{bmatrix}<br>$$<br>$$<br>valueBoundaryCoeffs =<br>\begin{bmatrix}<br>\phi_{px} \\<br>\phi_{py} \\<br>\phi_{pz}<br>\end{bmatrix} - valueInternalCoeffs<br>\begin{bmatrix}<br>\phi_{cx} \\<br>\phi_{cy} \\<br>\phi_{cz}<br>\end{bmatrix}<br>$$<br>$$<br>gradientInternalCoeffs= - \Delta<br>\begin{bmatrix}<br>|n_x| \\<br>|n_y| \\<br>|n_z|<br>\end{bmatrix}<br>$$<br>$$<br>gradientBoundaryCoeffs = - \begin{bmatrix}<br>(\phi_{cx}n_x + \phi_{cy}n_y + \phi_{cz}n_z)n_x \\<br>(\phi_{cx}n_x + \phi_{cy}n_y + \phi_{cz}n_z)n_y \\<br>(\phi_{cx}n_x + \phi_{cy}n_y + \phi_{cz}n_z)n_z<br>\end{bmatrix}  \Delta - gradientInternalCoeffs<br>\begin{bmatrix}<br>\phi_{cx} \\<br>\phi_{cy} \\<br>\phi_{cz}<br>\end{bmatrix}<br>$$</p>
<p>这里的 $\Delta$ 代表代码中的 <code>deltaCoeffs</code> 。</p>
<h5 id="directionMixed">directionMixed</h5><p><code>directionMixed</code> 与 <code>basicSymmetry</code> 是类似的，差别在于 <code>directionMixed</code> 所使用的对称张量是指定的，而不一定是 $\overrightarrow{n}\otimes\overrightarrow{n}$。<br>根据 <code>evaluate</code> 函数，可以得到如下公式：<br>$$<br>\begin{align}<br>\overrightarrow{\phi}_b = &amp; \overrightarrow{\phi}_{ref}\cdot \mathbf{vF} + (\mathrm{I} - \mathbf{vF}) \cdot \left (\overrightarrow{\phi}_c + \frac{\overrightarrow{G}}{\Delta} \right)\\<br>= &amp;  (\mathrm{I} - \mathbf{vF}) \cdot \overrightarrow{\phi}_c + \overrightarrow{\phi}_{ref}\cdot vF + (\mathrm{I} - \mathbf{vF}) \cdot \frac{\overrightarrow{G}}{\Delta}<br>\end{align}<br>$$<br>其中，$\overrightarrow{\phi}_{ref}=refValue$，$\overrightarrow{G}=refGrad$，$\mathbf{vF}=valueFraction$<br>同样，为了方便分析，将上述公式的部分写成分量形式：<br>$$<br>\begin{align}<br>\begin{bmatrix}<br>\phi_{px} \\<br>\phi_{py} \\<br>\phi_{pz}<br>\end{bmatrix} = &amp; \begin{bmatrix}<br>\phi_{cx} \\<br>\phi_{cy} \\<br>\phi_{cz}<br>\end{bmatrix} - \begin{bmatrix}<br>vF_{xx}\phi_{cx} + vF_{xy}\phi_{cy} + vF_{xz}\phi_{cz}\\<br>vF_{yx}\phi_{cx} + vF_{yy}\phi_{cy} + vF_{yz}\phi_{cz} \\<br>vF_{zx}\phi_{cx} + vF_{zy}\phi_{cy} + vF_{zz}\phi_{cz}<br>\end{bmatrix} + \overrightarrow{\phi}_{ref}\cdot \mathbf{vF} + (\mathrm{I} - \mathbf{vF}) \cdot \frac{\overrightarrow{G}}{\Delta} \\<br>= &amp; \begin{bmatrix}<br>(1-vF_{xx})\phi_{cx} \\<br>(1-vF_{yy})\phi_{cy} \\<br>(1-vF_{zz})\phi_{cz}<br>\end{bmatrix} - \begin{bmatrix}<br>vF_{xy}\phi_{cy} + vF_{xz}\phi_{cz}\\<br>vF_{yx}\phi_{cx} + vF_{yz}\phi_{cz} \\<br>vF_{zx}\phi_{cx} + vF_{zy}\phi_{cy}<br>\end{bmatrix} + \overrightarrow{\phi}_{ref}\cdot \mathbf{vF} + (\mathrm{I} - \mathbf{vF}) \cdot \frac{\overrightarrow{G}}{\Delta}<br>\end{align}<br>$$<br>同样的，OpenFOAM 中四个系数的实现也与预期的不一样。主要还是 <code>snGradTransformDiag</code> 的定义与预期的不符:<br>$$<br>snGradTransformDiag =<br>\begin{bmatrix}<br>\sqrt{|vF_{xx}|} \\<br>\sqrt{|vF_{yy}|} \\<br>\sqrt{|vF_{zz}|}<br>\end{bmatrix}<br>$$</p>
<p>结合代码，可以得到四个系数如下：<br>$$<br>valueInternalCoeffs =<br>\begin{bmatrix}<br>(1-\sqrt{|vF_{xx}|}) \\<br>(1-\sqrt{|vF_{yy}|}) \\<br>(1-\sqrt{|vF_{zz}|})<br>\end{bmatrix}<br>$$<br>$$<br>valueBoundaryCoeffs =<br>\begin{bmatrix}<br>\phi_{px} \\<br>\phi_{py} \\<br>\phi_{pz}<br>\end{bmatrix} - valueInternalCoeffs<br>\begin{bmatrix}<br>\phi_{cx} \\<br>\phi_{cy} \\<br>\phi_{cz}<br>\end{bmatrix}<br>$$<br>$$<br>gradientInternalCoeffs= - \Delta<br>\begin{bmatrix}<br>\sqrt{|vF_{xx}|} \\<br>\sqrt{|vF_{yy}|} \\<br>\sqrt{|vF_{zz}|}<br>\end{bmatrix}<br>$$<br>$$<br>gradientBoundaryCoeffs = - \mathbf{vF} \cdot \overrightarrow{\phi}_c \cdot \Delta+ \overrightarrow{\phi}_{ref}\cdot \mathbf{vF} \cdot \Delta + (\mathrm{I} - \mathbf{vF}) \cdot \overrightarrow{G} - gradientInternalCoeffs \cdot \overrightarrow{\phi}_c<br>$$</p>
<p>代码里的 <code>snGrad</code> 函数对应公式为：<br>$$<br>\left [ \overrightarrow{\phi}_{ref}\cdot \mathbf{vF} + (\mathrm{I} - \mathbf{vF}) \cdot (\overrightarrow{\phi}_c + \frac{\overrightarrow{G}}{\Delta}) - \overrightarrow{\phi}_c \right ]\cdot \Delta<br>$$</p>
<p>不知道为什么 <code>snGradTransformDiag</code> 要按照这种方式来定义，可能是为了数值稳定性。不过，由于 <code>valueBoundaryCoeffs</code> 和 <code>gradientBoundaryCoeffs</code> 分别是在 <code>valueInternalCoeffs</code> 和 <code>gradientInternalCoeffs</code> 的基础之上定义的，所以总是能保证 <code>evaluate</code> 的结果与预期一致。</p>
<p>可以将 <code>directionMixed</code> 的行为总结如下：<br><img src="/image/boundaryConditions/boundary-conditions-in-openfoam-90.jpg" alt="directionMixed 的行为"></p>
<p>不过，如果 <code>valueFraction</code> 的值是任意指定的，而不是由 $\overrightarrow{n}\otimes\overrightarrow{n}$ 构成的，那又另当别论了。</p>
<p><strong>参考资料</strong>：<br><a href="http://www.slideshare.net/fumiyanozaki96/boundary-conditions-in-openfoam" target="_blank" rel="external">Boundary Conditions in OpenFOAM</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>OpenFOAM 中有很多复杂的边界都是继承自上篇中提到的三个基础边界条件，这些边界条件的代码在上一篇的基础上就很容易看懂了。只不过，还有一些边界条件，不是继承自这三个基础边界条件的，其中有一些都直接或间接继承自另一个重要的边界条件： <code>transformFvPatchField</code>。本篇来看看这个 <code>transformFvPatchField</code> 以及几个继承自它的边界条件。</p>]]>
    
    </summary>
    
      <category term="Boundary conditions" scheme="http://xiaopingqiu.github.io/tags/Boundary-conditions/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenFOAM 中的边界条件（二）]]></title>
    <link href="http://xiaopingqiu.github.io/2016/04/02/Boundary-conditions-in-OpenFOAM2/"/>
    <id>http://xiaopingqiu.github.io/2016/04/02/Boundary-conditions-in-OpenFOAM2/</id>
    <published>2016-04-02T08:40:43.000Z</published>
    <updated>2016-05-30T16:01:39.866Z</updated>
    <content type="html"><![CDATA[<p>本篇在上一篇的基础上来解读 OpenFOAM 中的基础边界条件。基础边界条件一般包括三类，一是Dirichlet 边界，二是 Neumann 边界，三是混合 Dirichlet 和 Neumann 的边界。</p>
<a id="more"></a>
<h5 id="1-_fixedValue">1. fixedValue</h5><p>这个是 OpenFOAM 中的 Dirichlet 边界条件。</p>
<ul>
<li>构造函数<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line">fixedValueFvPatchField&lt;<span class="type">Type</span>&gt;::fixedValueFvPatchField</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> fvPatch&amp; p,</span><br><span class="line">    <span class="keyword">const</span> <span class="type">DimensionedField</span>&lt;<span class="type">Type</span>, volMesh&gt;&amp; iF,</span><br><span class="line">    <span class="keyword">const</span> dictionary&amp; dict</span><br><span class="line">)</span><br><span class="line">:</span><br><span class="line">    fvPatchField&lt;<span class="type">Type</span>&gt;(p, iF, dict, <span class="literal">true</span>)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>熟悉 OpenFOAM 的人都知道， <code>fixedValue</code> 这个边界条件需要用 <code>value</code> 关键字来指定边界的值。<code>value</code> 这个关键字是通过 <code>DimensionedField</code> 类来处理的。 <code>DimensionedField</code> 这个类将读取 <code>value</code> 关键字对应的场的值用来初始化边界上的值。</p>
<ul>
<li>coefficients<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line">tmp&lt;<span class="type">Field</span>&lt;<span class="type">Type</span>&gt; &gt; fixedValueFvPatchField&lt;<span class="type">Type</span>&gt;::valueInternalCoeffs</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;scalarField&gt;&amp;</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> tmp&lt;<span class="type">Field</span>&lt;<span class="type">Type</span>&gt; &gt;</span><br><span class="line">    (</span><br><span class="line">        new <span class="type">Field</span>&lt;<span class="type">Type</span>&gt;(this-&gt;size(), pTraits&lt;<span class="type">Type</span>&gt;::zero)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line">tmp&lt;<span class="type">Field</span>&lt;<span class="type">Type</span>&gt; &gt; fixedValueFvPatchField&lt;<span class="type">Type</span>&gt;::valueBoundaryCoeffs</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;scalarField&gt;&amp;</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> *this;</span><br><span class="line">&#125;</span><br><span class="line">这里 <span class="string">"*this"</span> 表示类本身，即当前边界上的值。这个值在上面的构造函数中进行了初始化，所以，可以理解为 valueBoundaryCoeffs 函数返回的正是关键字 <span class="string">"value"</span> 所对应的值。</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line">tmp&lt;<span class="type">Field</span>&lt;<span class="type">Type</span>&gt; &gt; fixedValueFvPatchField&lt;<span class="type">Type</span>&gt;::gradientInternalCoeffs() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> -pTraits&lt;<span class="type">Type</span>&gt;::one*this-&gt;patch().deltaCoeffs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line">tmp&lt;<span class="type">Field</span>&lt;<span class="type">Type</span>&gt; &gt; fixedValueFvPatchField&lt;<span class="type">Type</span>&gt;::gradientBoundaryCoeffs() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> this-&gt;patch().deltaCoeffs()*(*this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>$$<br>\begin{align}<br>valueInternalCoeffs &amp; = 0 \\<br>valueBoundaryCoeffs &amp; = value \\<br>gradientInternalCoeffs &amp; = -delta \\<br>gradientBoundaryCoeffs &amp; = delta* value<br>\end{align}<br>$$</p>
<p>其中 $delta$ 为面心与面所属网格中心的距离的倒数。<br>从上述系数，可以知道，fixedValue 边界条件对边界的值和梯度值的计算为如下：<br>$$<br>\begin{align}<br>x_p &amp; = value \\<br>\nabla x_p &amp; = - delta \cdot x_C + delta \cdot value = (value - x_C) \cdot delta<br>\end{align}<br>$$<br>这与预期是一致的。</p>
<h5 id="2-_zeroGradient">2. zeroGradient</h5><p>这个是 OpenFOAM 中的一种特殊的 Neumann 边界条件，即边界的梯度为零。</p>
<ul>
<li>evaluate 函数<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">template<span class="subst">&lt;</span>class <span class="keyword">Type</span><span class="subst">&gt;</span></span><br><span class="line"><span class="literal">void</span> zeroGradientFvPatchField<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::evaluate</span>(const Pstream<span class="tag">::commsTypes</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="subst">!</span>this<span class="subst">-&gt;</span>updated())</span><br><span class="line">    &#123;</span><br><span class="line">        this<span class="subst">-&gt;</span>updateCoeffs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fvPatchField<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::operator</span><span class="subst">==</span>(this<span class="subst">-&gt;</span>patchInternalField());</span><br><span class="line">    fvPatchField<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::evaluate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>注意，这里的 <code>operator==</code> 与 <code>operator=</code> 的作用是一样的，都是赋值运算，而不是比较。</p>
<ul>
<li>coefficients<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">template<span class="subst">&lt;</span>class <span class="keyword">Type</span><span class="subst">&gt;</span></span><br><span class="line">tmp<span class="subst">&lt;</span>Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span> <span class="subst">&gt;</span> zeroGradientFvPatchField<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::valueInternalCoeffs</span></span><br><span class="line">(</span><br><span class="line">    const tmp<span class="subst">&lt;</span>scalarField<span class="subst">&gt;&amp;</span></span><br><span class="line">) const</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> tmp<span class="subst">&lt;</span>Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span> <span class="subst">&gt;</span></span><br><span class="line">    (</span><br><span class="line">        <span class="literal">new</span> Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span>(this<span class="subst">-&gt;</span>size(), pTraits<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::one</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template<span class="subst">&lt;</span>class <span class="keyword">Type</span><span class="subst">&gt;</span></span><br><span class="line">tmp<span class="subst">&lt;</span>Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span> <span class="subst">&gt;</span> zeroGradientFvPatchField<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::valueBoundaryCoeffs</span></span><br><span class="line">(</span><br><span class="line">    const tmp<span class="subst">&lt;</span>scalarField<span class="subst">&gt;&amp;</span></span><br><span class="line">) const</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> tmp<span class="subst">&lt;</span>Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span> <span class="subst">&gt;</span></span><br><span class="line">    (</span><br><span class="line">        <span class="literal">new</span> Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span>(this<span class="subst">-&gt;</span>size(), pTraits<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::zero</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template<span class="subst">&lt;</span>class <span class="keyword">Type</span><span class="subst">&gt;</span></span><br><span class="line">tmp<span class="subst">&lt;</span>Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span> <span class="subst">&gt;</span> zeroGradientFvPatchField<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::gradientInternalCoeffs</span>() const</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> tmp<span class="subst">&lt;</span>Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span> <span class="subst">&gt;</span></span><br><span class="line">    (</span><br><span class="line">        <span class="literal">new</span> Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span>(this<span class="subst">-&gt;</span>size(), pTraits<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::zero</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template<span class="subst">&lt;</span>class <span class="keyword">Type</span><span class="subst">&gt;</span></span><br><span class="line">tmp<span class="subst">&lt;</span>Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span> <span class="subst">&gt;</span> zeroGradientFvPatchField<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::gradientBoundaryCoeffs</span>() const</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> tmp<span class="subst">&lt;</span>Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span> <span class="subst">&gt;</span></span><br><span class="line">    (</span><br><span class="line">        <span class="literal">new</span> Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span>(this<span class="subst">-&gt;</span>size(), pTraits<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::zero</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>$$<br>\begin{align}<br>valueInternalCoeffs &amp; = 1 \\<br>valueBoundaryCoeffs &amp; = 0 \\<br>gradientInternalCoeffs &amp; = 0 \\<br>gradientBoundaryCoeffs &amp; = 0<br>\end{align}<br>$$</p>
<p>从上述系数，可以知道，fixedValue 边界条件对边界的值和梯度值的计算为如下：</p>
<p>$$<br>\begin{align}<br>x_p &amp; = x_C \\<br>\nabla x_p &amp; = 0<br>\end{align}<br>$$<br>这与预期是一致的。</p>
<h5 id="3-_fixedGradient">3. fixedGradient</h5><p>这个是 OpenFOAM 中的 Neumann 边界条件，可以指定边界上的梯度值。</p>
<ul>
<li>构造函数<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line">fixedGradientFvPatchField&lt;<span class="type">Type</span>&gt;::fixedGradientFvPatchField</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> fvPatch&amp; p,</span><br><span class="line">    <span class="keyword">const</span> <span class="type">DimensionedField</span>&lt;<span class="type">Type</span>, volMesh&gt;&amp; iF,</span><br><span class="line">    <span class="keyword">const</span> dictionary&amp; dict</span><br><span class="line">)</span><br><span class="line">:</span><br><span class="line">    fvPatchField&lt;<span class="type">Type</span>&gt;(p, iF, dict),</span><br><span class="line">    gradient_(<span class="string">"gradient"</span>, dict, p.size())</span><br><span class="line">&#123;</span><br><span class="line">    evaluate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>需要读取关键字 “gradient” 对应的值来初始化变量 <code>gradient_</code>。</p>
<ul>
<li>evaluate 函数<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">template<span class="subst">&lt;</span>class <span class="keyword">Type</span><span class="subst">&gt;</span></span><br><span class="line"><span class="literal">void</span> fixedGradientFvPatchField<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::evaluate</span>(const Pstream<span class="tag">::commsTypes</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="subst">!</span>this<span class="subst">-&gt;</span>updated())</span><br><span class="line">    &#123;</span><br><span class="line">        this<span class="subst">-&gt;</span>updateCoeffs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::operator</span><span class="subst">=</span></span><br><span class="line">    (</span><br><span class="line">        this<span class="subst">-&gt;</span>patchInternalField() <span class="subst">+</span> gradient_/this<span class="subst">-&gt;</span>patch()<span class="built_in">.</span>deltaCoeffs()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    fvPatchField<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::evaluate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>$$<br>x_p = x_C + \frac{gradient} {delta}<br>$$<br>其中 $delta$ 为面心与面所属网格中心的距离的倒数。</p>
<ul>
<li>coefficients<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line">tmp&lt;<span class="type">Field</span>&lt;<span class="type">Type</span>&gt; &gt; fixedGradientFvPatchField&lt;<span class="type">Type</span>&gt;::valueInternalCoeffs</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;scalarField&gt;&amp;</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> tmp&lt;<span class="type">Field</span>&lt;<span class="type">Type</span>&gt; &gt;(new <span class="type">Field</span>&lt;<span class="type">Type</span>&gt;(this-&gt;size(), pTraits&lt;<span class="type">Type</span>&gt;::one));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line">tmp&lt;<span class="type">Field</span>&lt;<span class="type">Type</span>&gt; &gt; fixedGradientFvPatchField&lt;<span class="type">Type</span>&gt;::valueBoundaryCoeffs</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;scalarField&gt;&amp;</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> gradient()/this-&gt;patch().deltaCoeffs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line">tmp&lt;<span class="type">Field</span>&lt;<span class="type">Type</span>&gt; &gt; fixedGradientFvPatchField&lt;<span class="type">Type</span>&gt;::</span><br><span class="line">gradientInternalCoeffs() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> tmp&lt;<span class="type">Field</span>&lt;<span class="type">Type</span>&gt; &gt;</span><br><span class="line">    (</span><br><span class="line">        new <span class="type">Field</span>&lt;<span class="type">Type</span>&gt;(this-&gt;size(), pTraits&lt;<span class="type">Type</span>&gt;::zero)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line">tmp&lt;<span class="type">Field</span>&lt;<span class="type">Type</span>&gt; &gt; fixedGradientFvPatchField&lt;<span class="type">Type</span>&gt;::</span><br><span class="line">gradientBoundaryCoeffs() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> gradient();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>$$<br>\begin{align}<br>valueInternalCoeffs &amp; = 1 \\<br>valueBoundaryCoeffs &amp; = \tfrac{gradient}{delta} \\<br>gradientInternalCoeffs &amp; = 0 \\<br>gradientBoundaryCoeffs &amp; = gradient<br>\end{align}<br>$$</p>
<h5 id="4-_mixed">4. mixed</h5><p>这是 OpenFOAM 中的混合边界条件。</p>
<ul>
<li>构造函数<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line">mixedFvPatchField&lt;<span class="type">Type</span>&gt;::mixedFvPatchField</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> fvPatch&amp; p,</span><br><span class="line">    <span class="keyword">const</span> <span class="type">DimensionedField</span>&lt;<span class="type">Type</span>, volMesh&gt;&amp; iF,</span><br><span class="line">    <span class="keyword">const</span> dictionary&amp; dict</span><br><span class="line">)</span><br><span class="line">:</span><br><span class="line">    fvPatchField&lt;<span class="type">Type</span>&gt;(p, iF, dict),</span><br><span class="line">    refValue_(<span class="string">"refValue"</span>, dict, p.size()),</span><br><span class="line">    refGrad_(<span class="string">"refGradient"</span>, dict, p.size()),</span><br><span class="line">    valueFraction_(<span class="string">"valueFraction"</span>, dict, p.size())</span><br><span class="line">&#123;</span><br><span class="line">    evaluate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>需要读取三个参数。</p>
<ul>
<li>evaluate<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">template<span class="subst">&lt;</span>class <span class="keyword">Type</span><span class="subst">&gt;</span></span><br><span class="line"><span class="literal">void</span> mixedFvPatchField<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::evaluate</span>(const Pstream<span class="tag">::commsTypes</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="subst">!</span>this<span class="subst">-&gt;</span>updated())</span><br><span class="line">    &#123;</span><br><span class="line">        this<span class="subst">-&gt;</span>updateCoeffs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::operator</span><span class="subst">=</span></span><br><span class="line">    (</span><br><span class="line">        valueFraction_<span class="subst">*</span>refValue_</span><br><span class="line">      <span class="subst">+</span></span><br><span class="line">        (<span class="number">1.0</span> <span class="subst">-</span> valueFraction_)<span class="subst">*</span></span><br><span class="line">        (</span><br><span class="line">            this<span class="subst">-&gt;</span>patchInternalField()</span><br><span class="line">          <span class="subst">+</span> refGrad_/this<span class="subst">-&gt;</span>patch()<span class="built_in">.</span>deltaCoeffs()</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">    fvPatchField<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::evaluate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>$$<br>x_p = valueFraction \cdot refValue + (1-valueFraction) \cdot (x_C + \frac{refGrad}{delta})<br>$$</p>
<ul>
<li>coefficients<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line">tmp&lt;<span class="type">Field</span>&lt;<span class="type">Type</span>&gt; &gt; mixedFvPatchField&lt;<span class="type">Type</span>&gt;::valueInternalCoeffs</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;scalarField&gt;&amp;</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Type</span>(pTraits&lt;<span class="type">Type</span>&gt;::one)*(<span class="number">1</span>.<span class="number">0</span> - valueFraction_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line">tmp&lt;<span class="type">Field</span>&lt;<span class="type">Type</span>&gt; &gt; mixedFvPatchField&lt;<span class="type">Type</span>&gt;::valueBoundaryCoeffs</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;scalarField&gt;&amp;</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">         valueFraction_*refValue_</span><br><span class="line">       + (<span class="number">1</span>.<span class="number">0</span> - valueFraction_)*refGrad_/this-&gt;patch().deltaCoeffs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line">tmp&lt;<span class="type">Field</span>&lt;<span class="type">Type</span>&gt; &gt; mixedFvPatchField&lt;<span class="type">Type</span>&gt;::gradientInternalCoeffs() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="type">Type</span>(pTraits&lt;<span class="type">Type</span>&gt;::one)*valueFraction_*this-&gt;patch().deltaCoeffs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line">tmp&lt;<span class="type">Field</span>&lt;<span class="type">Type</span>&gt; &gt; mixedFvPatchField&lt;<span class="type">Type</span>&gt;::gradientBoundaryCoeffs() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        valueFraction_*this-&gt;patch().deltaCoeffs()*refValue_</span><br><span class="line">      + (<span class="number">1</span>.<span class="number">0</span> - valueFraction_)*refGrad_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>$$<br>\begin{align}<br>valueInternalCoeffs &amp; = 1-valueFraction \\<br>valueBoundaryCoeffs &amp; = valueFraction \cdot refValue + (1-valueFraction) \cdot \tfrac{refGrad}{delta} \\<br>gradientInternalCoeffs &amp; = -valueFraction \cdot delta \\<br>gradientBoundaryCoeffs &amp; = valueFraction \cdot refValue \cdot delta + (1-valueFraction) \cdot refGrad<br>\end{align}<br>$$</p>
<p>附注：本篇中所有的下标 $p$ 都表示当前边界（present boundary patch），下标 $C$ 表示当前边界所属的网格的中心。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本篇在上一篇的基础上来解读 OpenFOAM 中的基础边界条件。基础边界条件一般包括三类，一是Dirichlet 边界，二是 Neumann 边界，三是混合 Dirichlet 和 Neumann 的边界。</p>]]>
    
    </summary>
    
      <category term="Boundary conditions" scheme="http://xiaopingqiu.github.io/tags/Boundary-conditions/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenFOAM 中的边界条件（一）]]></title>
    <link href="http://xiaopingqiu.github.io/2016/04/02/Boundary-conditions-in-OpenFOAM1/"/>
    <id>http://xiaopingqiu.github.io/2016/04/02/Boundary-conditions-in-OpenFOAM1/</id>
    <published>2016-04-02T07:29:24.000Z</published>
    <updated>2016-04-03T07:27:24.175Z</updated>
    <content type="html"><![CDATA[<p>本系列解读 OpenFOAM 中边界条件的实现。主要关心一些几个问题：</p>
<ol>
<li>OpenFOAM 中边界条件是怎样与有限体积离散部分交互的？</li>
<li>怎么从代码看懂一个边界条件具体是怎么计算边界上的值的？</li>
<li>怎么定制一个边界条件？</li>
</ol>
<p>本篇先阐述第一个问题。</p>
<a id="more"></a>
<p>从有限体积离散的角度来看，离散过程中，可能要用到的边界信息包括两类：一是某个场在边界上的值，另一是某个场在边界上的梯度。前者在对流项的离散中需要用到，举例说<br>$$<br>\int_v \nabla \cdot (\rho \mathbf{U} \phi) dV = \sum_f m_f \phi_f<br>$$<br>当组成体积元的面中有边界面时，需要用到这些边界面上的值 $\phi_f$。<br>而在扩散项的离散过程中<br>$$<br>\int_v \nabla \cdot (\Gamma \nabla \phi) dV = \sum_f (\Gamma \nabla \phi)_f \cdot \mathbf{S}_f<br>$$<br>这时，如果组成体积元的某个面是边界面，就需要该边界面上 $\phi$ 的梯度值 $\nabla \phi_f$ 了。</p>
<p>边界上的某个场值，或者梯度值，其计算方法可以用如下通式表示<br>$$<br>\begin{align}<br>\phi_f &amp; = A_1 \phi_C + B_1 \\<br>\nabla \phi_f &amp; = A_2 \phi_C + B_2<br>\end{align}<br>$$<br>这里，$ \phi_C$ 表示 $\phi$ 在邻近边界的网格中心的值，$A_1$ ，$B_1$，$A_2$，$B_2$ 是系数。</p>
<p>OpenFOAM 中的边界条件类中，有四个函数分别对应上面四个系数：<code>valueInternalCoeffs</code> 对应 $A_1$，<code>valueBoundaryCoeffs</code> 对应 $B_1$，<code>gradientInternalCoeffs</code> 对应 $A_2$，<code>gradientBoundaryCoeffs</code> 对应 $B_2$。<br>所以，看懂 OpenFOAM 中的边界条件，很关键的一步就是看懂这四个函数的定义。</p>
<p>此外，还有一个函数，<code>updateCoeffs</code>， 也很重要。这个函数负责对边界条件进行显式地更新。浏览一下 OpenFOAM 边界条件的代码，会发现很多边界条件都是在 <code>updateCoeffs</code> 这个函数中进行边界值的计算的。</p>
<p>另外，还有些边界条件，似乎是在 <code>evaluate</code> 函数中进行边界值的指定的。</p>
<p>至于边界条件是在什么地方调用的，cfd-online 上有<a href="http://www.cfd-online.com/Forums/openfoam-programming-development/129271-how-boundary-conditions-called-openfoam-solvers.html" target="_blank" rel="external">一个帖子</a>，Hrvoje Jasak 对这个问题的回答是：<br>“<br>Easy:<br>- on correctBoundaryConditions() for a field<br>- on updateCoeffs() at matrix creation<br>correctBoundaryConditions is also called after the linear solver call automatically.<br>”<br>其他网友还提供了一些有价值的信息，比如，在 <code>correctBoundaryConditions</code> 函数中，<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>, <span class="keyword">template</span>&lt;class&gt; class <span class="type">PatchField</span>, class <span class="type">GeoMesh</span>&gt;</span><br><span class="line"><span class="type">void</span> <span class="type">Foam</span>::<span class="type">GeometricField</span>&lt;<span class="type">Type</span>, <span class="type">PatchField</span>, <span class="type">GeoMesh</span>&gt;::</span><br><span class="line">correctBoundaryConditions()</span><br><span class="line">&#123;</span><br><span class="line">    this-&gt;setUpToDate();</span><br><span class="line">    storeOldTimes();</span><br><span class="line">    boundaryField_.evaluate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用了 <code>evaluate</code> 函数。<br>为什么有些边界条件用 <code>updateCoeffs()</code>，而有些则用 <code>evaluate()</code> 呢？目前的理解是这样的： <code>updateCoeffs()</code> 主要用来显式地计算并更新变量在边界上的值，当边界上的值是通过某个依赖于外部参数的公式来计算，并且值会随着迭代的进行而不断改变时，则需要用 <code>updateCoeffs()</code>。有些边界条件，比如最基本的 <code>zeroGradient()</code>，不需要外部的参数，只需要每一次将临近网格的值赋给边界就可以了，这时就可以用 <code>evaluate()</code>。</p>
<p>关于边界条件调用的具体过程，需要在看了 <code>fvMatrix</code> 类以后才能更深入地理解，博主目前只能给出一个粗浅的理解。</p>
<p><strong>参考资料</strong>：<br>The Finite Volume Method in Computational Fluid Dynamics: An Advanced Introduction with OpenFOAM® and Matlab®</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本系列解读 OpenFOAM 中边界条件的实现。主要关心一些几个问题：</p>
<ol>
<li>OpenFOAM 中边界条件是怎样与有限体积离散部分交互的？</li>
<li>怎么从代码看懂一个边界条件具体是怎么计算边界上的值的？</li>
<li>怎么定制一个边界条件？</li>
</ol>
<p>本篇先阐述第一个问题。</p>]]>
    
    </summary>
    
      <category term="Boundary conditions" scheme="http://xiaopingqiu.github.io/tags/Boundary-conditions/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[fvOptions 之 semiImplicitSource]]></title>
    <link href="http://xiaopingqiu.github.io/2016/03/20/fvOptions2/"/>
    <id>http://xiaopingqiu.github.io/2016/03/20/fvOptions2/</id>
    <published>2016-03-20T07:24:41.000Z</published>
    <updated>2016-04-26T13:03:19.617Z</updated>
    <content type="html"><![CDATA[<p>上篇浅析了 fvOptions 框架的结构，这篇来看一个具体的源项类： <code>semiImplicitSource</code> 。</p>
<a id="more"></a>
<p>先来看看这个源项代码中的关键部分。</p>
<ul>
<li>SemiImplicitSource.C<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "SemiImplicitSource.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "fvMesh.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "fvMatrices.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "DimensionedField.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "fvmSup.H"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Type&gt;</span><br><span class="line"><span class="keyword">const</span> Foam::wordList Foam::fv::SemiImplicitSource&lt;Type&gt;::volumeModeTypeNames_</span><br><span class="line">(</span><br><span class="line">    IStringStream(<span class="string">"(absolute specific)"</span>)()  <span class="comment">// 初始化 volumeModeTypeNames_，这里有两种模式， `absolute` 和 `specific` ，具体含义下面会解释。 </span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Type&gt;</span><br><span class="line"><span class="keyword">typename</span> Foam::fv::SemiImplicitSource&lt;Type&gt;::volumeModeType</span><br><span class="line">Foam::fv::SemiImplicitSource&lt;Type&gt;::wordToVolumeModeType <span class="comment">// 将字符串转换成 volumeModeType</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> word&amp; vmtName</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    forAll(volumeModeTypeNames_, i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (vmtName == volumeModeTypeNames_[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> volumeModeType(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FatalErrorIn</span><br><span class="line">    (</span><br><span class="line">        <span class="string">"SemiImplicitSource&lt;Type&gt;::volumeModeType"</span></span><br><span class="line">        <span class="string">"SemiImplicitSource&lt;Type&gt;::wordToVolumeModeType(const word&amp;)"</span></span><br><span class="line">    )   &lt;&lt; <span class="string">"Unknown volumeMode type "</span> &lt;&lt; vmtName</span><br><span class="line">        &lt;&lt; <span class="string">". Valid volumeMode types are:"</span> &lt;&lt; nl &lt;&lt; volumeModeTypeNames_</span><br><span class="line">        &lt;&lt; <span class="built_in">exit</span>(FatalError);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> volumeModeType(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Type&gt;</span><br><span class="line">Foam::word Foam::fv::SemiImplicitSource&lt;Type&gt;::volumeModeTypeToWord</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> volumeModeType&amp; vmtType</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (vmtType &gt; volumeModeTypeNames_.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"UNKNOWN"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> volumeModeTypeNames_[vmtType];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Type&gt;</span><br><span class="line"><span class="keyword">void</span> Foam::fv::SemiImplicitSource&lt;Type&gt;::setFieldData(<span class="keyword">const</span> dictionary&amp; dict)</span><br><span class="line">&#123;</span><br><span class="line">    fieldNames_.setSize(dict.toc().size());</span><br><span class="line">    injectionRate_.setSize(fieldNames_.size());</span><br><span class="line"></span><br><span class="line">    applied_.setSize(fieldNames_.size(), <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    label i = <span class="number">0</span>;</span><br><span class="line">    forAllConstIter(dictionary, dict, iter)</span><br><span class="line">    &#123;</span><br><span class="line">        fieldNames_[i] = iter().keyword();</span><br><span class="line">        dict.lookup(iter().keyword()) &gt;&gt; injectionRate_[i];</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set volume normalisation</span></span><br><span class="line">    <span class="keyword">if</span> (volumeMode_ == vmAbsolute)</span><br><span class="line">    &#123;</span><br><span class="line">        VDash_ = V_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Type&gt;</span><br><span class="line">Foam::fv::SemiImplicitSource&lt;Type&gt;::SemiImplicitSource</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> word&amp; name,</span><br><span class="line">    <span class="keyword">const</span> word&amp; modelType,</span><br><span class="line">    <span class="keyword">const</span> dictionary&amp; dict,</span><br><span class="line">    <span class="keyword">const</span> fvMesh&amp; mesh</span><br><span class="line">)</span><br><span class="line">:</span><br><span class="line">    option(name, modelType, dict, mesh),</span><br><span class="line">    volumeMode_(vmAbsolute), volumeMode 初始值为 vmAbsolute，也就是字典里的 <span class="function">absolute</span><br><span class="line">    <span class="title">VDash_</span><span class="params">(1.0)</span>, <span class="comment">// VDash 初始值为 1.0</span></span><br><span class="line">    <span class="title">injectionRate_</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    read(dict);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Type&gt;</span><br><span class="line"><span class="keyword">void</span> Foam::fv::SemiImplicitSource&lt;Type&gt;::addSup <span class="comment">// 这个是最关键的函数，求解器里的 fvOptions(T)，最终就是转换为调用这个函数。</span></span><br><span class="line">(</span><br><span class="line">    fvMatrix&lt;Type&gt;&amp; eqn,</span><br><span class="line">    <span class="keyword">const</span> label fieldI</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (debug)</span><br><span class="line">    &#123;</span><br><span class="line">        Info&lt;&lt; <span class="string">"SemiImplicitSource&lt;"</span> &lt;&lt; pTraits&lt;Type&gt;::typeName</span><br><span class="line">            &lt;&lt; <span class="string">"&gt;::addSup for source "</span> &lt;&lt; name_ &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// psi 表示方程中的未知量，比如，eqn(fvm::ddt(T))，则psi其实就相当于T，其量纲也与T的量纲一致。</span></span><br><span class="line">    <span class="keyword">const</span> GeometricField&lt;Type, fvPatchField, volMesh&gt;&amp; psi = eqn.psi();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个场 Su，其量纲为方程eqn的量纲除以体积的量纲。注意，经测试，假设eqn为（fvm::ddt(T)），则eqn的量纲为k.m^3/s。</span></span><br><span class="line">    DimensionedField&lt;Type, volMesh&gt; Su</span><br><span class="line">    (</span><br><span class="line">        IOobject</span><br><span class="line">        (</span><br><span class="line">            name_ + fieldNames_[fieldI] + <span class="string">"Su"</span>,</span><br><span class="line">            mesh_.time().timeName(),</span><br><span class="line">            mesh_,</span><br><span class="line">            IOobject::NO_READ,</span><br><span class="line">            IOobject::NO_WRITE</span><br><span class="line">        ),</span><br><span class="line">        mesh_,</span><br><span class="line">        dimensioned&lt;Type&gt;</span><br><span class="line">        (</span><br><span class="line">            <span class="string">"zero"</span>,</span><br><span class="line">            eqn.dimensions()/dimVolume,</span><br><span class="line">            pTraits&lt;Type&gt;::zero</span><br><span class="line">        ),</span><br><span class="line">        <span class="keyword">false</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这一句的意思是，将属于cells_这个集合的网格的Su赋值为fvoptions里所设置的第一个参数的值除以体积VDash。这里的VDash,如果模式为absolute，则值为cells_这个集合的网格体积之和，如果模式为specific，则其值为1. </span></span><br><span class="line">    <span class="comment">// UUIndirectList&lt;Type&gt;(Su, cells_)这一句是利用Su和cells为参数，构建一个UUIndirectList类的临时对象，并调用这个类的重载的“=”操作符对Su进行重新赋值。</span></span><br><span class="line">    </span><br><span class="line">    UIndirectList&lt;Type&gt;(Su, cells_) = injectionRate_[fieldI].first()/VDash_;</span><br><span class="line"></span><br><span class="line">    DimensionedField&lt;scalar, volMesh&gt; Sp</span><br><span class="line">    (</span><br><span class="line">        IOobject</span><br><span class="line">        (</span><br><span class="line">            name_ + fieldNames_[fieldI] + <span class="string">"Sp"</span>,</span><br><span class="line">            mesh_.time().timeName(),</span><br><span class="line">            mesh_,</span><br><span class="line">            IOobject::NO_READ,</span><br><span class="line">            IOobject::NO_WRITE</span><br><span class="line">        ),</span><br><span class="line">        mesh_,</span><br><span class="line">        dimensioned&lt;scalar&gt;</span><br><span class="line">        (</span><br><span class="line">            <span class="string">"zero"</span>,</span><br><span class="line">            Su.dimensions()/psi.dimensions(),</span><br><span class="line">            <span class="number">0.0</span></span><br><span class="line">        ),</span><br><span class="line">        <span class="keyword">false</span></span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    UIndirectList&lt;scalar&gt;(Sp, cells_) = injectionRate_[fieldI].second()/VDash_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fvMatrix&lt;Type&gt; 类中对“+=”操作符进行了重载，所以，eqn与Su的相加，相当于eqn+Su*mesh.V()，要不然eqn与Su的量纲不一致。</span></span><br><span class="line">    eqn += Su + fvm::SuSp(Sp, psi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>下面用一个例子来说明 <code>semiImplicitSource</code> 的作用。前提到 <code>scalarTransportFoam</code> 是使用 fvOptions 的一个最简单的求解器，这里对该求解器进一步简化，只保留瞬变项，对流和扩散项都删去，来验证 <code>semiImplicitSource</code> 的作用。<br>修改之后的 <code>TEqn</code> 为<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tmp TEqn</span><br><span class="line"><span class="list">(</span><br><span class="line">    <span class="keyword">fvm</span>:<span class="keyword">:ddt</span><span class="list">(<span class="keyword">T</span>)</span>  == fvOptions<span class="list">(<span class="keyword">T</span>)</span></span><br><span class="line">)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>然后，<code>fvOptions</code> 词典文件的设置如下：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">firstHeatSource</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title">type</span> scalarSemiImplicitSource;</span><br><span class="line">    <span class="title">active</span>          <span class="built_in">true</span>;</span><br><span class="line">    <span class="title">selectionMode</span>   cellZone;</span><br><span class="line">    <span class="title">cellZone</span>        boxSourceZone;</span><br><span class="line">    <span class="title">scalarSemiImplicitSourceCoeffs</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title">volumeMode</span> absolute;</span><br><span class="line">        <span class="title">injectionRateSuSp</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title">T</span> (<span class="number">0</span>.<span class="number">05</span> <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述设置，相当于求解如下方程<br>$$<br>\frac{\partial T}{\partial t}=S_u + S_p\cdot T<br>$$<br>其中 $S_u=0.05, S_p = 0$ 。<br>反观上面对代码的分析，可知对于当前的设置，$S_u$ 的量纲为 <code>TEqn</code> 的量纲除以体积量纲，$S_p$ 的量为 $S_u$ 量纲除以 <code>T</code> 的量纲，这与上面给出的方程是一致的。<br>但是，要注意， <code>SemiImplicitSource</code> 有两个模式：absolute 和 specific，区别在于代码里的 <code>VDash</code> 的取值不一样。对于 absolute 模式，<code>VDash = V</code>，即所选的 cellZone 的体积；对于 specific 模式，<code>VDash = 1.0</code>。而代码里的 <code>Su</code> 和 <code>Sp</code> 的值都是用在<code>fvOptions</code> 词典文件设置的值除以 <code>VDash</code> 。<br>所以，确切地说，求解的应该是如下积分方程：<br>$$<br>\int_V \frac{\partial T}{\partial t} dV - \int_V \nabla \cdot (D_T \nabla T) dV = \int_V (\frac{S_u}{V_{Dash}}+\frac{S_p}{V_{Dash}}T )dV<br>$$<br>其中 $V_{Dash}$ 是选定的 cellZone 的体积。<br>为了验证以上的推演，作了如下两个测试：</p>
<ul>
<li>源项参数设置为<code>T (0.01 0)</code>，源项作用的区域为一个体积为$V_{Dash}=0.001$ 的 cellZone，为了消除热量传递，设置 $D_T = 0$，初始整个区域的 T 均为0， 模拟时间为1 s。<br>按照上述的推演，如果是 <code>absolute</code> 模式，最终 1 s 时选定的 cellZone 的温度将是 $T=t\cdot \frac{S_u}{V_{Dash}}=1s\cdot\frac{0.01 k/s}{0.001}=10k$；如果是 <code>specific</code> 模式，那么最终1 s 时选定的 cellZone 的温度将是 $T=1s\cdot\frac{0.01 k/s}{1.0}=0.01k$。以上结果在测试算例中得到了证实。</li>
<li>源项参数设置为<code>T (1.0 2.0)</code>，同样设置 $D_T = 0$。这种情况下，可以先求微分方程<br>$$\frac{\partial T}{\partial t}=x+yT$$<br>的解，经简单计算得到<br>$$T=\frac{e^{yt}\cdot e^{yc}-x}{y}$$<br>$c$ 为任意常数。<br>若 $T|\,_{t=0}=0k$，则可以得到定解为<br>$$T=\frac{e^{yt}\cdot x-x}{y}$$<br>若使用<code>specific</code> 模式，则根据当前的设置得到1 s时的解为<br>$$T=\frac{e^{2\cdot 1}\cdot 1 -1}{2}=3.194528 k$$<br>算例测试结果为：</li>
<li>时间离散格式:Euler，$\Delta T=0.001s$，$T=3.20193k$；</li>
<li>时间离散格式：Euler，$\Delta T=0.0001s$，$T=3.19527k$，可见减小时间步后结果与解析解吻合度提高了很多。</li>
<li>时间离散格式：CrankNicolson，$\Delta T=0.001s$，$T=3.19454k$。可见用高阶的时间离散格式，在同样时间步下能得到误差更小的结果。</li>
</ul>
<p>同样，如果用<code>absolute</code> 模式，且源项设置为 <code>T (0.001 0.002)</code> ，应该能得到一样的结果，实际上算例测试正是如此。由此可以认为推演得到了证实。</p>
<p>至此，<code>SemiImplicitSource</code> 这个源项的核心部分就算是明了了。可是，现在测试的是非常简单的情形，如果在求解多个方程，且有多个方程里都加入了源项的情况下，该怎么给不同的方程设置不一样的源项呢？要解决这个问题，需要先理解清楚 <code>fvOptions</code> 的调用过程。</p>
<h5 id="fvOptions_源项的调用过程">fvOptions 源项的调用过程</h5><p>下面至下而上地来看看 fvOptions 的调用过程。</p>
<p><code>TEqn</code>里，有一个调用 <code>fvOptions</code> 的语句： <code>fvOptions(T)</code>，上一篇讲过， <code>fvOptions</code> 的定义为<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="rule"><span class="attribute">fv</span>:<span class="value">:IOoptionList <span class="function">fvOptions</span>(mesh)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>这就很明显了：建立一个 <code>IOoptionList</code> 类的对象 <code>fvOptions</code>。由此可知，求解器里的 <code>fvOptions</code> 是一个对象的名字，因此 <code>fvOptions(T)</code> 这种用法也只可能是对象调用类中重载的 <code>()</code> 运算符了。从前面的分析，可知 <code>IOoptionList</code> 本身很简单，仅是作为一个接口来用的，所以 <code>()</code> 与算符的重载要去其父类中去找。 <code>IOoptionList</code> 的作用是，从 “constant”（优先）或者 “system” 目录读取 <code>fvOptions</code> 文件，并作为 <code>IOobject</code> 类的对象传递给父类 <code>optionList</code> （从构造函数的成员初始化列表 <code>optionList(mesh, *this)</code> ）</p>
<hr>
<p>接下来，就该进入 <code>optionList</code> 类了。这个类里，所有可能出现在求解器代码里函数都有了，包括 <code>correct</code> ， <code>constrain</code> ， <code>makeRelative</code> ， <code>makeAbsolute</code> ， <code>relative</code> 以及 <code>()</code> 运算符的重载。但是，注意这里并没有具体的代码实现，而是通过类似<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">forAll(*<span class="keyword">this</span>, i)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">this</span>-&gt;<span class="keyword">operator</span>[](i).makeAbsolute(phi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用其他地方的函数。 <code>optionList</code> 的一个重要使命是，统计 <code>fvOptions</code> 文件里定义了多少个源项，并将每一个源项都作为一个储存起来，然后再根据词典的内容创建特定的源项。核心在于 <code>reset</code> 函数。为了说明这一点，先从构造函数看起<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reset<span class="list">(<span class="keyword">optionsDict</span><span class="list">(<span class="keyword">dict</span>)</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>可见构造函数里调用了 <code>reset</code> 函数，并且用 <code>optionsDict</code> 函数的返回值作为 <code>reset</code> 函数的参数。前文讲到， <code>IOoptionList</code> 类将 <code>fvOptions</code> 文件的内容以 <code>IOobject</code> 的形式传递给父类 <code>optionList</code>，所以，这里的参数 <code>dict</code> 可以理解为就是<code>fvOptions</code> 文件的内容。<code>optionsDict</code> 函数的代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Foam::dictionary&amp; Foam::fv::optionList::optionsDict</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> dictionary&amp; dict</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (dict.found(<span class="string">"options"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> dict.subDict(<span class="string">"options"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> dict;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可见，这个函数去 <code>fvOptions</code> 文件里查找关键字 <code>options</code>，如果找到，就将 <code>options</code> 关键字对应的 subDict 内容返回，否则直接返回 <code>fvOptions</code> 文件的内容。举例说，形如<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">firstHeatSource</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title">type</span> scalarSemiImplicitSource;</span><br><span class="line">    <span class="title">active</span>          <span class="built_in">true</span>;</span><br><span class="line">    <span class="title">selectionMode</span>   cellZone;</span><br><span class="line">    <span class="title">cellZone</span>        boxSourceZone;</span><br><span class="line">    <span class="title">scalarSemiImplicitSourceCoeffs</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title">volumeMode</span> absolute;</span><br><span class="line">        <span class="title">injectionRateSuSp</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title">T</span> (<span class="number">0</span>.<span class="number">001</span> <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>的，直接返回，因为这就构成了一个 dictionary；而形如<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">options</span><br><span class="line">&#123;</span><br><span class="line">    massSource1</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">type</span>            scalarSemiImplicitSource;</span><br><span class="line">        <span class="label">$injector1</span>;</span><br><span class="line"></span><br><span class="line">        scalarSemiImplicitSourceCoeffs</span><br><span class="line">        &#123;</span><br><span class="line">            volumeMode      absolute;</span><br><span class="line">            injectionRateSuSp</span><br><span class="line">            &#123;</span><br><span class="line">                thermo:rho.air     (1e-3 0); <span class="comment">// kg/s</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    momentumSource1</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">type</span>            vectorSemiImplicitSource;</span><br><span class="line">        <span class="label">$injector1</span>;</span><br><span class="line"></span><br><span class="line">        vectorSemiImplicitSourceCoeffs</span><br><span class="line">        &#123;</span><br><span class="line">            volumeMode      absolute;</span><br><span class="line">            injectionRateSuSp</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">U</span>.air           ((0 -1e-2 0) 0); <span class="comment">// kg*m/s^2</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    energySource1</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">type</span>            scalarSemiImplicitSource;</span><br><span class="line">        <span class="label">$injector1</span>;</span><br><span class="line"></span><br><span class="line">        scalarSemiImplicitSourceCoeffs</span><br><span class="line">        &#123;</span><br><span class="line">            volumeMode      absolute;</span><br><span class="line">            injectionRateSuSp</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">e</span>.air      (500 0); <span class="comment">// kg*m^2/s^3</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>的，则将options下的每一个 subDict 作为 dictionary 返回。注意，这里的 <code>dictionary</code> 类可以理解为一个容器，每一个<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xxxxx</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">...</span><span class="attribute">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>都可以作为容器里的一个成员，容器的容量（size）等于总的成员数，每一个成员，其实就对应一个源项。<br>于是，我们知道 <code>optionsDict</code> 返回了一个有一定数目成员的容器。再来看 <code>reset</code> 函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Foam::fv::optionList::reset(<span class="keyword">const</span> dictionary&amp; dict)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Count number of active fvOptions</span></span><br><span class="line">    label count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历 dict 容器，确定其成员的数目，即确定定义了几个源项。</span></span><br><span class="line">    forAllConstIter(dictionary, dict, iter) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (iter().isDict())</span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>-&gt;setSize(count); <span class="comment">// setSize 是 PtrList 类的成员，顾名思义，PtrList 是一个 List。PtrList&lt;option&gt; 类的成员是 options 类的对象。</span></span><br><span class="line">    </span><br><span class="line">    label i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 遍历 dict 容器，根据每一个 dict 容器的成员来建立对应的 option 类的对象，这通过调用 option 类的 New 函数来实现。这是使用 RuntimeSelection 机制的类的很常规的做法。</span></span><br><span class="line">    forAllConstIter(dictionary, dict, iter)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (iter().isDict())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">const</span> word&amp; name = iter().keyword(); <span class="comment">// keyword 返回的是类似 energySource1 这样的，是这个源项的一个名字</span></span><br><span class="line">            <span class="keyword">const</span> dictionary&amp; sourceDict = iter().dict();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">set</span> <span class="comment">// set 函数，肯定毫无疑问也是从 PtrList 类中继承而来的</span></span><br><span class="line">            (</span><br><span class="line">                i++,</span><br><span class="line">                option::New(name, sourceDict, mesh_) <span class="comment">// 调用 option 类的 New 函数</span></span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，最重要的是， <code>reset</code> 里实现了对父类 <code>PtrList&lt;option&gt;</code> 的初始化。<br>理解了这些，再来看 <code>correct</code> 以及 <code>()</code> 操作符重载中的代码，就好理解了：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本来 *this 应该是 optionList 类的指针，这里先作个隐式转换，转成 PtrList&lt;option&gt; 类的指针。前面reset函数已经对 PtrList&lt;option&gt; 进行了初始化，使其读入了每一个源项。所以，这里的循环就是对每一个源项进行循环，然后调用对应的函数。operator[]肯定也是在PtrList类中定义的，i 指的是 PtrList 类的第 i 个成员，这里 PtrList 的每一个成员都是一个 option 类的对象，所以，makeAbsolute 函数是定义在 option 类中的函数。</span></span><br><span class="line">forAll(*<span class="keyword">this</span>, i)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">this</span>-&gt;<span class="keyword">operator</span>[](i).makeAbsolute(phi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据上面的理解，一个很自然的推论是，定义在 <code>fvOptions</code> 文件中的源项，其作用是叠加的。也就是说，上述的 <code>fvOptions(T)</code>，对定义在 <code>fvOptions</code> 文件中的每一个源项，都会调用一次。经测试，<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="title">firstHeatSource</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title">type</span> scalarSemiImplicitSource;</span><br><span class="line">    <span class="title">active</span>          <span class="built_in">true</span>;</span><br><span class="line">    <span class="title">selectionMode</span>   cellZone;</span><br><span class="line">    <span class="title">cellZone</span>        boxSourceZone;</span><br><span class="line">    <span class="title">scalarSemiImplicitSourceCoeffs</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title">volumeMode</span> absolute;</span><br><span class="line">        <span class="title">injectionRateSuSp</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title">T</span> (<span class="number">0</span>.<span class="number">001</span> <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="title">secondHeatSource</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title">type</span> scalarSemiImplicitSource;</span><br><span class="line">    <span class="title">active</span>          <span class="built_in">true</span>;</span><br><span class="line">    <span class="title">selectionMode</span>   cellZone;</span><br><span class="line">    <span class="title">cellZone</span>        boxSourceZone;</span><br><span class="line">    <span class="title">scalarSemiImplicitSourceCoeffs</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title">volumeMode</span> absolute;</span><br><span class="line">        <span class="title">injectionRateSuSp</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title">T</span> (<span class="number">0</span>.<span class="number">0</span> <span class="number">0</span>.<span class="number">002</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>与<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">secondHeatSource</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title">type</span> scalarSemiImplicitSource;</span><br><span class="line">    <span class="title">active</span>          <span class="built_in">true</span>;</span><br><span class="line">    <span class="title">selectionMode</span>   cellZone;</span><br><span class="line">    <span class="title">cellZone</span>        boxSourceZone;</span><br><span class="line">    <span class="title">scalarSemiImplicitSourceCoeffs</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title">volumeMode</span> absolute;</span><br><span class="line">        <span class="title">injectionRateSuSp</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title">T</span> (<span class="number">0</span>.<span class="number">0001</span> <span class="number">0</span>.<span class="number">002</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>的作用是一样的，这证实了源项的作用确实是叠加的。<br>此外，还要注意一点，那就是 <code>optionList</code> 类中重载的 <code>()</code> 运算符，其实是在调用 option 类中的 <code>addSup</code> 函数，并且其返回值是 fvMatrix 类的对象。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Type&gt;</span><br><span class="line">Foam::tmp&lt;Foam::fvMatrix&lt;Type&gt; &gt; Foam::fv::optionList::<span class="keyword">operator</span>()</span><br><span class="line">(</span><br><span class="line">    GeometricField&lt;Type, fvPatchField, volMesh&gt;&amp; fld,</span><br><span class="line">    <span class="keyword">const</span> word&amp; fieldName</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    checkApplied();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> dimensionSet ds = fld.dimensions()/dimTime*dimVolume;</span><br><span class="line"></span><br><span class="line">    tmp&lt;fvMatrix&lt;Type&gt; &gt; tmtx(<span class="keyword">new</span> fvMatrix&lt;Type&gt;(fld, ds));</span><br><span class="line">    fvMatrix&lt;Type&gt;&amp; mtx = tmtx();</span><br><span class="line"></span><br><span class="line">    forAll(*<span class="keyword">this</span>, i)</span><br><span class="line">    &#123;</span><br><span class="line">        option&amp; source = <span class="keyword">this</span>-&gt;<span class="keyword">operator</span>[](i);</span><br><span class="line"></span><br><span class="line">        label fieldI = source.applyToField(fieldName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fieldI != -<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            source.setApplied(fieldI);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (source.isActive())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (debug)</span><br><span class="line">                &#123;</span><br><span class="line">                    Info&lt;&lt; <span class="string">"Applying source "</span> &lt;&lt; source.name() &lt;&lt; <span class="string">" to field "</span></span><br><span class="line">                        &lt;&lt; fieldName &lt;&lt; endl;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                source.addSup(mtx, fieldI);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmtx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>理解了以上这些，就可以进入 <code>option</code> 类了。<br>option 类是所有具体的源项类的基类，这个类里处理了所有源项都需要处理的部分，比如确定起始时间，选择源项作用的区域，这些都是在构造函数里完成的，主要是通过调用 <code>setSelection</code> 和 <code>setCellSet</code> 两个函数。这里需要注意的是数据成员 <code>cells_</code>， <code>V_</code>  以及 <code>fieldNames_</code>，分别定义源项作用区域的网格id （这里源项的作用区域是以 cell 为基础来指定的，即便是 points 模式，实际上源项作用的区域仍然是 points 所在的 cell。）， 选定区域的体积以及需要开启源项作用的场名（有时候，求解器的多个 Eqn 里有fvOptions，但是实际算例中只想针对特定的场开启源项，这可以通过指定 fieldNames_ 来实现）。</p>
<p>注意 fieldNames 在 <code>option</code> 类中并没有初始化，需要在具体的源项类中指定。此外，<code>makeRelative</code> 等在求解器中实际调用的函数，在 <code>option</code> 类中也并没有进行具体的实现（但不是声明为纯虚函数，仅仅是函数体为空的而已，这里的结果不适合用纯虚函数）</p>
<p>以 <code>SemiImplicitSource</code> 为例，主要去看 <code>addSup</code> 函数，这个函数，关键的一个参数是<code>fieldI</code>，这个参数，指的是 <code>fieldName_</code> 这个List的 <code>applyToField</code> 函数的返回值，用来判断一个 field 是否要启用源项。<code>fieldName_</code> 这个List，是在  <code>SemiImplicitSource</code> 类的 <code>setFieldData</code> 函数中赋值的，通过读取 <code>SemiImplicitSourceCoeffs</code> 中的参数来决定。但是这个 <code>fieldName_</code> 的确定方法根据不同的类有不同的做法，要具体分析。<br>到此，<code>fvOpptions</code> 源项的调用途径就打通了，接下来可以继续具体分析特定的源项了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>上篇浅析了 fvOptions 框架的结构，这篇来看一个具体的源项类： <code>semiImplicitSource</code> 。</p>]]>
    
    </summary>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="fvOptions" scheme="http://xiaopingqiu.github.io/tags/fvOptions/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
</feed>