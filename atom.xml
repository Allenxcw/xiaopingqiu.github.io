<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Giskard's CFD Learning Tricks]]></title>
  <subtitle><![CDATA[CFD and Scientific Computing]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://xiaopingqiu.github.io/"/>
  <updated>2016-05-03T05:33:04.459Z</updated>
  <id>http://xiaopingqiu.github.io/</id>
  
  <author>
    <name><![CDATA[Giskard Q.]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[LIGGGHTS tips]]></title>
    <link href="http://xiaopingqiu.github.io/2016/05/03/liggghts-howto/"/>
    <id>http://xiaopingqiu.github.io/2016/05/03/liggghts-howto/</id>
    <published>2016-05-03T04:38:31.000Z</published>
    <updated>2016-05-03T05:33:04.459Z</updated>
    <content type="html"><![CDATA[<p>本篇介绍几个 LIGGGHTS 技巧，read_data，freeze，move，modify_timing，neigh_modify。</p>
<a id="more"></a>
<p>LIGGGHTS 中可以用 STL 格式的几何面来模拟复杂边界的问题。如果想用冻结粒子当作壁面，可以采用如下方法。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">read_data test.dat</span><br><span class="line"></span><br><span class="line">group    Par_wall id &lt;&gt; <span class="number">1</span> <span class="number">1000</span>  </span><br><span class="line">fix       fr Par_wall freeze</span><br></pre></td></tr></table></figure></p>
<p>上述代码中，第一行是从外部文件中读取颗粒的信息；第二行是将ID在 1 到 1000 的粒子放到一个 group 里；第三行是将 Par_wall 这个 group 里的粒子冻结起来，具体的操作其实是将这些粒子的力归零，这样粒子将保持最初始的速度。如果将壁面粒子预先生成好，并将其初始速度设置为 0，便可以实现冻结粒子壁面了。</p>
<p>test.data 文件的数据格式如下，每一列数据的含义见注释：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">LAMMPS data file via write_data, version Version LIGGGHTS-PUBLIC <span class="number">3.2</span>.0, git commit <span class="number">6</span>de550fbf3b8451f51246aa3c76374012e935340 based on LAMMPS <span class="number">23</span> Nov <span class="number">2013</span>, timestep = <span class="number">0</span>  <span class="preprocessor">## 第一行随便是什么</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span> atoms  <span class="preprocessor">## 颗粒数</span></span><br><span class="line"><span class="number">1</span> atom types <span class="preprocessor">## 颗粒的 type 数</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">## 模拟区域的大小</span></span><br><span class="line">-<span class="number">5.0009999999999999e-01</span> <span class="number">5.0009999999999999e-01</span> xlo xhi</span><br><span class="line">-<span class="number">2.0004000000000002e-01</span> <span class="number">2.0004000000000002e-01</span> ylo yhi</span><br><span class="line">-<span class="number">2.0005500000000001e-01</span> <span class="number">3.4999999999999998e-01</span> zlo zhi</span><br><span class="line"></span><br><span class="line">Atoms</span><br><span class="line"><span class="preprocessor">#id type radius density x y z i j k</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2.9999999999999999e-02</span> <span class="number">2.5000000000000005e+03</span> -<span class="number">2.9626205235821884e-01</span> -<span class="number">1.7191257603378007e-01</span> -<span class="number">5.2585560979625336e-02</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">2.9999999999999999e-02</span> <span class="number">2.5000000000000005e+03</span> -<span class="number">3.1357080694177836e-01</span> -<span class="number">8.1292507237863978e-02</span> -<span class="number">3.0941241635135643e-02</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">2.9999999999999999e-02</span> <span class="number">2.5000000000000005e+03</span> -<span class="number">3.4986005571676082e-01</span> -<span class="number">4.6564797686740017e-02</span> -<span class="number">5.0161637377833301e-02</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">4</span> <span class="number">1</span> <span class="number">2.9999999999999999e-02</span> <span class="number">2.5000000000000005e+03</span> -<span class="number">3.2901105748658366e-01</span> <span class="number">1.1629149478965480e-01</span> -<span class="number">2.8537062345934828e-02</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">5</span> <span class="number">1</span> <span class="number">5.0000000000000003e-02</span> <span class="number">2.5000000000000000e+03</span> -<span class="number">3.9692279707164302e-01</span> <span class="number">1.5000972515153915e-01</span> -<span class="number">3.5647118241865984e-02</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Velocities <span class="preprocessor">## 如果粒子的初始速度为零，这一段可以删去。</span></span><br><span class="line"><span class="preprocessor">#id vx vy vz omegax omegay omegaz</span></span><br><span class="line"><span class="number">1</span> -<span class="number">1.5290519507823870e+00</span> <span class="number">1.0245516532619933e-01</span> -<span class="number">1.1594445288149451e+00</span> <span class="number">6.3791250045904881e+00</span> <span class="number">2.0674456758001139e+02</span> <span class="number">1.0276923966595568e+02</span></span><br><span class="line"><span class="number">2</span> -<span class="number">2.1385398568904033e+00</span> -<span class="number">1.8858415304542153e-01</span> -<span class="number">9.4897293591801291e-01</span> <span class="number">1.2732686070189061e+01</span> <span class="number">1.9114652955524940e+02</span> -<span class="number">4.8862922016708987e+00</span></span><br><span class="line"><span class="number">3</span> -<span class="number">2.1931823490540205e+00</span> <span class="number">1.2314081721772643e-01</span> -<span class="number">1.1305039942880526e+00</span> -<span class="number">7.7211996358126047e+00</span> <span class="number">1.8655504536271400e+02</span> -<span class="number">3.5674698533544941e+01</span></span><br><span class="line"><span class="number">4</span> -<span class="number">2.3661710510727509e+00</span> <span class="number">6.5301832663338024e-03</span> -<span class="number">9.2367025774174294e-01</span> -<span class="number">5.7926985652143115e-01</span> <span class="number">1.7594397127744105e+02</span> <span class="number">6.1151183183219171e+00</span></span><br><span class="line"><span class="number">5</span> -<span class="number">2.6032940321288258e+00</span> <span class="number">1.7791968545582579e-01</span> -<span class="number">1.0893683893889663e+00</span> -<span class="number">1.6450273309025711e+01</span> <span class="number">6.8599979334439681e+01</span> <span class="number">3.4617478295022179e+00</span></span><br></pre></td></tr></table></figure></p>
<p>上述能实现静止的壁面，如果希望用粒子来实现运动壁面（比如旋转），则可以用 move 命令：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">group rotateWall id &lt;&gt; <span class="number">1001</span> <span class="number">2000</span> <span class="preprocessor"># 将 1001 &lt;= id &lt;= 2000 的粒子放到 group rotateWall 里</span></span><br><span class="line">fix mov rotateWall move rotate -<span class="number">19.8</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">8</span></span><br></pre></td></tr></table></figure></p>
<p>move 命令有不同的模式，这里用的是 rotate，用这个命令以后，rotateWall 这个 group 里的粒子，将按照指定的参数来进行旋转运动，而不再是根据其受力来更新速度和位置。参数的含义分别为：起始点坐标(x,y,z)；旋转轴的指向(x,y,z)；周期(转一圈的时间)。</p>
<p>最后再介绍几个小 tips：</p>
<ol>
<li>有时候想知道程序中哪一部分耗时最多，并据此来优化程序，这时可以在输入脚本的最开头，添加一句 modify_timing on ，之后在程序运行结束后会统计出每一条 fix 命令的耗时信息。</li>
<li>上述提到的冻结粒子壁面，在使用中会有一个问题：壁面粒子之间的距离通常是很小的，在建立粒子碰撞对的时候，壁面粒子之间通常会形成碰撞对，但壁面粒子之间没必要建立碰撞对，如果壁面粒子很多，这个建立过程是很耗时的。这种情况下，可以通过修改 neigh_modify 命令的参数来防止壁面粒子之间建立碰撞对：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">neigh_modify delay 0 exclude group  Par_wall Par_wall</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这条命令将防止在 Par_wall 这个 group 里的粒子彼此之间建立碰撞对。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本篇介绍几个 LIGGGHTS 技巧，read_data，freeze，move，modify_timing，neigh_modify。</p>]]>
    
    </summary>
    
      <category term="LIGGGHTS" scheme="http://xiaopingqiu.github.io/tags/LIGGGHTS/"/>
    
      <category term="DEM" scheme="http://xiaopingqiu.github.io/categories/DEM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenFOAM 中的壁面函数（四）]]></title>
    <link href="http://xiaopingqiu.github.io/2016/04/25/wallFunctions4/"/>
    <id>http://xiaopingqiu.github.io/2016/04/25/wallFunctions4/</id>
    <published>2016-04-24T16:43:40.000Z</published>
    <updated>2016-04-25T03:14:35.521Z</updated>
    <content type="html"><![CDATA[<p>这篇来看看可能是最关键的 $\nu_t$ 的壁面函数。</p>
<a id="more"></a>
<h5 id="5-_湍流粘度_$\nu_t$_的壁面函数">5. 湍流粘度 $\nu_t$ 的壁面函数</h5><p>这个类型的壁面函数，结构比较简单，计算的是每一个壁面边界面上的湍流粘度 $\nu_t$。<br><code>nutWallFunction</code> 是虚基类，其中定义了一个纯虚函数 <code>calcNut</code><br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> tmp&lt;scalarField&gt; <span class="title">calcNut</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<p>并且在 <code>updateCoeffs</code> 函数中，将 <code>calcNut</code> 的返回值赋值给边界面<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> nutWallFunctionFvPatchScalarField::updateCoeffs()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (updated())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span>==(calcNut());</span><br><span class="line"></span><br><span class="line">    fixedValueFvPatchScalarField::updateCoeffs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样，在具体的那些计算 $\nu_t$ 的壁面函数中，只需要看 <code>calcNut</code> 的返回值就可以了。</p>
<ul>
<li>(1). nutkWallFunction<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">tmp&lt;scalarField&gt; nutkWallFunctionFvPatchScalarField::calcNut() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">label</span> patchi = patch().<span class="literal">index</span>();</span><br><span class="line">    <span class="keyword">const</span> turbulenceModel&amp; turbModel =</span><br><span class="line">        <span class="keyword">db</span>().lookupObject&lt;turbulenceModel&gt;(<span class="string">"turbulenceModel"</span>);</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; y = turbModel.<span class="literal">y</span>()[patchi];</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tk = turbModel.k();</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; k = tk();</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tnu = turbModel.nu();</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; nu = tnu();</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; nuw = nu.boundaryField()[patchi];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">scalar</span> Cmu25 = pow025(Cmu_);</span><br><span class="line">    tmp&lt;scalarField&gt; tnutw(new scalarField(patch().size(), 0.0));</span><br><span class="line">    scalarField&amp; nutw = tnutw();</span><br><span class="line">    forAll(nutw, faceI)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">label</span> faceCellI = patch().faceCells()[faceI];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">scalar</span> yPlus = Cmu25*y[faceI]*<span class="literal">sqrt</span>(k[faceCellI])/nuw[faceI];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (yPlus &gt; yPlusLam_)</span><br><span class="line">        &#123;</span><br><span class="line">            nutw[faceI] = nuw[faceI]*(yPlus*kappa_/<span class="literal">log</span>(E_*yPlus) - 1.0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tnutw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这里，仍然是分情况处理<br><code>yPlus &lt; yPlusLam_</code> 时，壁面上的 <code>nut</code> 设为0；<br><code>yPlus &gt; yPlusLam_</code> 时<br>$$<br>\nu_t = \nu \cdot \left( \frac{\kappa y^+}{\ln(Ey^+)}-1 \right)<br>$$<br>这里实现的其实就是标准壁面函数。理论上讲，这里的计算只在粘性底层和对数区是有效的，所以，使用这个壁面条件的时候，要尽量壁面网格落在过渡区，否则可能会引入较大误差。</p>
<p>顺带提一下，这里还定义了一个 <code>yPlus</code> 函数，用来计算 $y^+$，这个函数在这里没有调用，不过在其他代码中需要 $y^+$ 的时候会调用这个函数。比如，计算 $y^+$ 的应用 <code>yPlusRAS</code> 就是调用这里的 <code>yPlus</code> 函数来计算 $y^+$。<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">tmp&lt;scalarField&gt; nutkWallFunctionFvPatchScalarField::yPlus() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">label</span> patchi = patch().<span class="literal">index</span>();</span><br><span class="line">    <span class="keyword">const</span> turbulenceModel&amp; turbModel =</span><br><span class="line">        <span class="keyword">db</span>().lookupObject&lt;turbulenceModel&gt;(<span class="string">"turbulenceModel"</span>);</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; y = turbModel.<span class="literal">y</span>()[patchi];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tk = turbModel.k();</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; k = tk();</span><br><span class="line">    tmp&lt;scalarField&gt; kwc = k.boundaryField()[patchi].patchInternalField();</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tnu = turbModel.nu();</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; nu = tnu();</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; nuw = nu.boundaryField()[patchi];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pow025(Cmu_)*y*<span class="literal">sqrt</span>(kwc)/nuw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>(2). nutUWallFunction<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">tmp&lt;scalarField&gt; nutUWallFunctionFvPatchScalarField::calcNut() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">label</span> patchi = patch().<span class="literal">index</span>();</span><br><span class="line">    <span class="keyword">const</span> turbulenceModel&amp; turbModel =</span><br><span class="line">        <span class="keyword">db</span>().lookupObject&lt;turbulenceModel&gt;(<span class="string">"turbulenceModel"</span>);</span><br><span class="line">    <span class="keyword">const</span> fvPatchVectorField&amp; Uw = turbModel.<span class="keyword">U</span>().boundaryField()[patchi];</span><br><span class="line">    <span class="keyword">const</span> scalarField magUp(mag(Uw.patchInternalField() - Uw));</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tnu = turbModel.nu();</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; nu = tnu();</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; nuw = nu.boundaryField()[patchi];</span><br><span class="line">    tmp&lt;scalarField&gt; tyPlus = calcYPlus(magUp);</span><br><span class="line">    scalarField&amp; yPlus = tyPlus();</span><br><span class="line">    tmp&lt;scalarField&gt; tnutw(new scalarField(patch().size(), 0.0));</span><br><span class="line">    scalarField&amp; nutw = tnutw();</span><br><span class="line"></span><br><span class="line">    forAll(yPlus, facei)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (yPlus[facei] &gt; yPlusLam_)</span><br><span class="line">        &#123;</span><br><span class="line">            nutw[facei] =</span><br><span class="line">                nuw[facei]*(yPlus[facei]*kappa_/<span class="literal">log</span>(E_*yPlus[facei]) - 1.0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tnutw;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tmp&lt;scalarField&gt; nutUWallFunctionFvPatchScalarField::calcYPlus</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; magUp</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">label</span> patchi = patch().<span class="literal">index</span>();</span><br><span class="line">    <span class="keyword">const</span> turbulenceModel&amp; turbModel =</span><br><span class="line">        <span class="keyword">db</span>().lookupObject&lt;turbulenceModel&gt;(<span class="string">"turbulenceModel"</span>);</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; y = turbModel.<span class="literal">y</span>()[patchi];</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tnu = turbModel.nu();</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; nu = tnu();</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; nuw = nu.boundaryField()[patchi];</span><br><span class="line">    tmp&lt;scalarField&gt; tyPlus(new scalarField(patch().size(), 0.0));</span><br><span class="line">    scalarField&amp; yPlus = tyPlus();</span><br><span class="line">    forAll(yPlus, facei)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">scalar</span> kappaRe = kappa_*magUp[facei]*y[facei]/nuw[facei];</span><br><span class="line">        <span class="keyword">scalar</span> yp = yPlusLam_;</span><br><span class="line">        <span class="keyword">scalar</span> ryPlusLam = 1.0/yp;</span><br><span class="line">        int iter = 0;</span><br><span class="line">        <span class="keyword">scalar</span> yPlusLast = 0.0;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            yPlusLast = yp;</span><br><span class="line">            yp = (kappaRe + yp)/(1.0 + <span class="literal">log</span>(E_*yp));</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">while</span> (mag(ryPlusLam*(yp - yPlusLast)) &gt; 0.01 &amp;&amp; ++iter &lt; 10 );</span><br><span class="line"></span><br><span class="line">        yPlus[facei] = <span class="literal">max</span>(0.0, yp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tyPlus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这个壁函数的 $y^+$ 的计算方式跟 <code>nutkWallFunction</code> 有点区别。经过摸索，这里 <code>calcYPlus</code> 函数中的那段 <code>do ... while</code> 循环的原理如下：<br>对数律可以表达如下：<br>$$<br>U^+ = \frac{U_p}{u_\tau}=\frac{1}{\kappa}\ln(Ey^+)<br>$$<br>其中 $U_p$ 等于壁面上的速度减去壁面所属网格中心的速度。<br>经过简单变形<br>$$<br>\frac{U_p}{ y u_\tau/\nu }\cdot (y/\nu)=\frac{U_p}{ y^+}\cdot (y/\nu)=\frac{1}{\kappa}\ln(Ey^+)<br>$$<br>整理得<br>$$<br>y^+ \ln(Ey^+) - \frac{\kappa y U_p}{\nu}=0<br>$$<br>这是一个 $y^+$ 的一元方程，可以通过牛顿迭代来求解<br>$$<br>y^+_{n+1} = y^+_{n} - \frac{f(y^+)}{f^{\prime}(y+)} = y^+_{n}-\frac{y_n^+ \ln(Ey_n^+) - \frac{\kappa y U_p}{\nu}}{1+\ln(Ey_n^+)} = \frac{y_n^+ + \frac{\kappa y U_p}{\nu}}{1+\ln(Ey_n^+)}<br>$$<br>上面代码里的 <code>do ... while</code> 循环，正是在做这个迭代求解，初始值选择的是 <code>yPlusLam</code>，这个值在前面提过了。<br>求出 $y^+$ 以后，$\nu_t$ 计算如下<br>$$<br>\nu_t = \nu \cdot \left( \frac{\kappa y^+}{\ln(Ey^+)}-1 \right)<br>$$<br>与 <code>nutkWallFunction</code> 形式是一样的。</p>
<p>这个壁面函数，求壁面上的 $\nu_t$ 时使用的对数律方程，所以，理论上这个壁面函数应该只适用于第一层网格落在对数层的情形。</p>
<ul>
<li>(3). nutLowReWallFunction<br>这个壁面函数直接将壁面上的 $\nu_t$ 的值设为0。<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">tmp</span>&lt;<span class="tag">scalarField</span>&gt; <span class="rule"><span class="attribute">nutLowReWallFunctionFvPatchScalarField</span>:<span class="value">:<span class="function">calcNut</span>() const</span><br><span class="line">&#123;</span><br><span class="line">    return tmp&lt;scalarField&gt;(new <span class="function">scalarField</span>(<span class="function">patch</span>().<span class="function">size</span>(), <span class="number">0.0</span>))</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>$y^+$ 的计算也值得注意：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">tmp&lt;scalarField&gt; nutLowReWallFunctionFvPatchScalarField::yPlus() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">label</span> patchi = patch().<span class="literal">index</span>();</span><br><span class="line">    <span class="keyword">const</span> turbulenceModel&amp; turbModel =</span><br><span class="line">        <span class="keyword">db</span>().lookupObject&lt;turbulenceModel&gt;(<span class="string">"turbulenceModel"</span>);</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; y = turbModel.<span class="literal">y</span>()[patchi];</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tnu = turbModel.nu();</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; nu = tnu();</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; nuw = nu.boundaryField()[patchi];</span><br><span class="line">    <span class="keyword">const</span> fvPatchVectorField&amp; Uw = turbModel.<span class="keyword">U</span>().boundaryField()[patchi];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y*<span class="literal">sqrt</span>(nuw*mag(Uw.snGrad()))/nuw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>$$<br>y^+ = \frac{y\sqrt{\nu \cdot |\frac{U_w-U_c}{d}|}}{\nu}<br>$$<br>注意由于 $\nu_t = 0$ ，所以 $\frac{\tau_w}{\rho} = \nu \cdot |\frac{U_w-U_c}{d}|$，所以，$\sqrt{\nu \cdot |\frac{U_w-U_c}{d}|}=\sqrt{\frac{\tau_w}{\rho}}=u_\tau$ 。</p>
<ul>
<li>(4). nutUSpaldingWallFunction<br>这个壁函数基于 Spalding 提出的一个拟合的 $y^+$ 与 $u^+$ 的关系式，见文献 <em>A Single Formula for the “Law of the Wall” </em> 。<br>$$<br>y^+ = u^+ + \frac{1}{E}\left[ e^{\kappa u^+} -1-\kappa u^+ -\frac{1}{2}(\kappa u^+)^2 - \frac{1}{6}(\kappa u^+)^3 \right]<br>$$<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">tmp&lt;scalarField&gt; nutUSpaldingWallFunctionFvPatchScalarField::calcNut() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">label</span> patchI = patch().<span class="literal">index</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> turbulenceModel&amp; turbModel =</span><br><span class="line">        <span class="keyword">db</span>().lookupObject&lt;turbulenceModel&gt;(<span class="string">"turbulenceModel"</span>);</span><br><span class="line">    <span class="keyword">const</span> fvPatchVectorField&amp; Uw = turbModel.<span class="keyword">U</span>().boundaryField()[patchI];</span><br><span class="line">    <span class="keyword">const</span> scalarField magGradU(mag(Uw.snGrad()));</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tnu = turbModel.nu();</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; nu = tnu();</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; nuw = nu.boundaryField()[patchI];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">max</span></span><br><span class="line">    (</span><br><span class="line">        <span class="literal">scalar</span>(0),</span><br><span class="line">        sqr(calcUTau(magGradU))/(magGradU + ROOTVSMALL) - nuw</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tmp&lt;scalarField&gt; nutUSpaldingWallFunctionFvPatchScalarField::calcUTau</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; magGradU</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">label</span> patchI = patch().<span class="literal">index</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> turbulenceModel&amp; turbModel =</span><br><span class="line">        <span class="keyword">db</span>().lookupObject&lt;turbulenceModel&gt;(<span class="string">"turbulenceModel"</span>);</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; y = turbModel.<span class="literal">y</span>()[patchI];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> fvPatchVectorField&amp; Uw = turbModel.<span class="keyword">U</span>().boundaryField()[patchI];</span><br><span class="line">    <span class="keyword">const</span> scalarField magUp(mag(Uw.patchInternalField() - Uw));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tnu = turbModel.nu();</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; nu = tnu();</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; nuw = nu.boundaryField()[patchI];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; nutw = *this;</span><br><span class="line"></span><br><span class="line">    tmp&lt;scalarField&gt; tuTau(new scalarField(patch().size(), 0.0));</span><br><span class="line">    scalarField&amp; uTau = tuTau();</span><br><span class="line"></span><br><span class="line">    forAll(uTau, faceI)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">scalar</span> ut = <span class="literal">sqrt</span>((nutw[faceI] + nuw[faceI])*magGradU[faceI]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ut &gt; ROOTVSMALL)</span><br><span class="line">        &#123;</span><br><span class="line">            int iter = 0;</span><br><span class="line">            <span class="keyword">scalar</span> <span class="keyword">err</span> = GREAT;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">scalar</span> kUu = <span class="literal">min</span>(kappa_*magUp[faceI]/ut, 50);</span><br><span class="line">                <span class="keyword">scalar</span> fkUu = <span class="literal">exp</span>(kUu) - 1 - kUu*(1 + 0.5*kUu);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">scalar</span> f =</span><br><span class="line">                    - ut*y[faceI]/nuw[faceI]</span><br><span class="line">                    + magUp[faceI]/ut</span><br><span class="line">                    + 1/E_*(fkUu - 1.0/6.0*kUu*sqr(kUu));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">scalar</span> df =</span><br><span class="line">                    y[faceI]/nuw[faceI]</span><br><span class="line">                  + magUp[faceI]/sqr(ut)</span><br><span class="line">                  + 1/E_*kUu*fkUu/ut;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">scalar</span> uTauNew = ut + f/df;</span><br><span class="line">                <span class="keyword">err</span> = mag((ut - uTauNew)/ut);</span><br><span class="line">                ut = uTauNew;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">while</span> (ut &gt; ROOTVSMALL &amp;&amp; <span class="keyword">err</span> &gt; 0.01 &amp;&amp; ++iter &lt; 10);</span><br><span class="line"></span><br><span class="line">            uTau[faceI] = <span class="literal">max</span>(0.0, ut);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tuTau;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><code>calcUtau</code> 函数，其实是在用牛顿法迭代求解 $y^+$，进而得到 $u_\tau$ 的值。<code>calcNut</code> 函数中<br>$$<br>\frac{u_\tau ^2}{|\frac{U_w-U_c}{d}|} - \nu = \frac{\tau_w}{|\frac{U_w-U_c}{d}|} -\nu = \nu_{eff} - \nu = \nu_t<br>$$</p>
<p>这个壁面函数使用的是从粘性底层连续变化到对数层的 $y^+ \text{-} u^+$ 关系式，所以，这个可以认为是网格无关的，即不管第一层网格落在哪个区，都是有效的。如果网格无法做到全部位于粘性层或者对数区，建议用这个壁面条件。</p>
<ul>
<li>(5). nutUTabulatedWallFunction</li>
</ul>
<p>这个壁面函数，需要从外部读取一个 $U^+ \text{-}\,Re_y$ 数据表，通过从这个数据表插值来得到 $U^+$ 的值。其中 $Re_y=yU/\nu$ 。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">nutUTabulatedWallFunctionFvPatchScalarField::</span><br><span class="line">nutUTabulatedWallFunctionFvPatchScalarField</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> fvPatch&amp; p,</span><br><span class="line">    <span class="keyword">const</span> DimensionedField&lt;scalar, volMesh&gt;&amp; iF,</span><br><span class="line">    <span class="keyword">const</span> dictionary&amp; dict</span><br><span class="line">)</span><br><span class="line">:</span><br><span class="line">    nutWallFunctionFvPatchScalarField(p, iF, dict),</span><br><span class="line">    uPlusTableName_(dict.lookup(<span class="string">"uPlusTable"</span>)),</span><br><span class="line">    uPlusTable_</span><br><span class="line">    (</span><br><span class="line">        IOobject</span><br><span class="line">        (</span><br><span class="line">            uPlusTableName_,</span><br><span class="line">            patch().boundaryMesh().mesh().time().constant(),</span><br><span class="line">            patch().boundaryMesh().mesh(),</span><br><span class="line">            IOobject::MUST_READ_IF_MODIFIED,</span><br><span class="line">            IOobject::NO_WRITE,</span><br><span class="line">            <span class="keyword">false</span></span><br><span class="line">        ),</span><br><span class="line">        <span class="keyword">true</span></span><br><span class="line">    )</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>$U^+$ 和 $\nu_t$ 分别由函数 <code>calcUPlus</code> 和 <code>calcNut</code> 来计算。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">tmp&lt;scalarField&gt; nutUTabulatedWallFunctionFvPatchScalarField::calcNut() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">label</span> patchi = patch().<span class="literal">index</span>();</span><br><span class="line">    <span class="keyword">const</span> turbulenceModel&amp; turbModel =</span><br><span class="line">        <span class="keyword">db</span>().lookupObject&lt;turbulenceModel&gt;(<span class="string">"turbulenceModel"</span>);</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; y = turbModel.<span class="literal">y</span>()[patchi];</span><br><span class="line">    <span class="keyword">const</span> fvPatchVectorField&amp; Uw = turbModel.<span class="keyword">U</span>().boundaryField()[patchi];</span><br><span class="line">    <span class="keyword">const</span> scalarField magUp(mag(Uw.patchInternalField() - Uw));</span><br><span class="line">    <span class="keyword">const</span> scalarField magGradU(mag(Uw.snGrad()));</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tnu = turbModel.nu();</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; nu = tnu();</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; nuw = nu.boundaryField()[patchi];</span><br><span class="line">    <span class="literal">return</span></span><br><span class="line">        <span class="literal">max</span></span><br><span class="line">        (</span><br><span class="line">            <span class="literal">scalar</span>(0),</span><br><span class="line">            sqr(magUp/(calcUPlus(magUp*y/nuw) + ROOTVSMALL))</span><br><span class="line">           /(magGradU + ROOTVSMALL)</span><br><span class="line">          - nuw</span><br><span class="line">        );</span><br><span class="line">    <span class="comment">// magUp/UPlus = utau, sqr(utau) = tauw, tauw/magGradU = nuEff = nut + nu</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tmp&lt;scalarField&gt; nutUTabulatedWallFunctionFvPatchScalarField::calcUPlus</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; Rey</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    tmp&lt;scalarField&gt; tuPlus(new scalarField(patch().size(), 0.0));</span><br><span class="line">    scalarField&amp; uPlus = tuPlus();</span><br><span class="line">    forAll(uPlus, faceI)</span><br><span class="line">    &#123;</span><br><span class="line">        uPlus[faceI] = uPlusTable_.interpolateLog10(Rey[faceI]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tuPlus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这里 <code>calcUPlus</code> 用的是 <code>interpolateLog10</code> 函数来插值，这个函数的定义为<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">template&lt;<span class="keyword">class</span> <span class="keyword">Type</span>&gt;</span><br><span class="line"><span class="keyword">Type</span> Foam::uniformInterpolationTable&lt;<span class="keyword">Type</span>&gt;::interpolateLog10</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">scalar</span> x</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (log10_)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            x = ::<span class="literal">log10</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (bound_ &amp;&amp; (x &lt;= 0))</span><br><span class="line">        &#123;</span><br><span class="line">            x = x0_;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            FatalErrorIn</span><br><span class="line">            (</span><br><span class="line">                <span class="string">"uniformInterpolationTable&lt;Type&gt;::interpolateLog10(scalar x)"</span></span><br><span class="line">            )   &lt;&lt; <span class="string">"Table "</span> &lt;&lt; name() &lt;&lt; <span class="keyword">nl</span></span><br><span class="line">                &lt;&lt; <span class="string">"Supplied value must be greater than 0 when in log10 mode"</span></span><br><span class="line">                &lt;&lt; <span class="keyword">nl</span> &lt;&lt; <span class="string">"x="</span> &lt;&lt; x &lt;&lt; <span class="keyword">nl</span> &lt;&lt; <span class="keyword">exit</span>(FatalError);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> interpolate(x); <span class="comment">// 这个是普通的线性插值函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>即计算 <code>x</code> 的对数（log10），在将计算结果用来进行线性插值。所以，用这个壁面函数的时候，要注意你所提供的数据表是普通线性坐标的还是对数坐标的。</p>
<p>基本上常见的处理壁面上的湍流粘度的方法就是以上几种了。OpenFOAM 中还提供了几个能处理粗糙壁面的壁面函数( <code>nutURoughWallFunction</code> ， <code>nutkRoughWallFunction</code> )，以及处理大气层边界的(<code>nutkAtmRoughWallFunction</code>，需要跟 <code>atmBoundaryLayerInletVelocity</code> 这个入口边界配合使用 )，细节这里不再详述了，有需要时可以去看相关代码，代码结构是类似的，只是具体计算公式不一样。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这篇来看看可能是最关键的 $\nu_t$ 的壁面函数。</p>]]>
    
    </summary>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="wall functions" scheme="http://xiaopingqiu.github.io/tags/wall-functions/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenFOAM 中的壁面函数（三）]]></title>
    <link href="http://xiaopingqiu.github.io/2016/04/25/wallFunctions3/"/>
    <id>http://xiaopingqiu.github.io/2016/04/25/wallFunctions3/</id>
    <published>2016-04-24T16:43:34.000Z</published>
    <updated>2016-04-25T03:05:53.080Z</updated>
    <content type="html"><![CDATA[<p>这篇来看看计算湍动能 $\varepsilon$  和 $\omega$ 的壁面函数。</p>
<a id="more"></a>
<h5 id="3-_湍动能耗散_$\varepsilon$_的壁面函数">3. 湍动能耗散 $\varepsilon$ 的壁面函数</h5><p>本篇来看看 OpenFOAM 中的 <code>epsilonWallFunction</code>，共有两个： <code>epsilonWallFunction</code> 和 <code>epsilonLowReWallFunction</code>。</p>
<ul>
<li>(1). epsilonWallFunction</li>
</ul>
<p><code>epsilonWallFunction</code> 代码比前面的 <code>kqRWallFunction</code> 复杂多了，主要原因在于这里需要得到的是 <code>epsilon</code> 在临近网格的值，而且，需要考虑包含两个边界面的网格。这里先来梳理代码的脉络，然后再看具体的计算细节。<br>外部调用的主要是 <code>updateCoeffs()</code> 函数，所以，从这个函数看起。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> epsilonWallFunctionFvPatchScalarField::updateCoeffs()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (updated())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> turbulenceModel&amp; turbulence =</span><br><span class="line">        db().lookupObject&lt;turbulenceModel&gt;(turbulenceModel::typeName);</span><br><span class="line"></span><br><span class="line">    setMaster();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (patch().index() == master_)</span><br><span class="line">    &#123;</span><br><span class="line">        createAveragingWeights();</span><br><span class="line">        calculateTurbulenceFields(turbulence, G(<span class="keyword">true</span>), epsilon(<span class="keyword">true</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; G0 = <span class="keyword">this</span>-&gt;G();</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; epsilon0 = <span class="keyword">this</span>-&gt;epsilon();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> DimensionedField&lt;scalar, volMesh&gt; FieldType;</span><br><span class="line"></span><br><span class="line">    FieldType&amp; G =</span><br><span class="line">        <span class="keyword">const_cast</span>&lt;FieldType&amp;&gt;</span><br><span class="line">        (</span><br><span class="line">            db().lookupObject&lt;FieldType&gt;(turbulence.GName())</span><br><span class="line">        );</span><br><span class="line">    <span class="comment">//这里是获取内部场，所以，修改这里的引用 "epsilon",相当于修改 epsilon 的内部场值。</span></span><br><span class="line">    FieldType&amp; epsilon = <span class="keyword">const_cast</span>&lt;FieldType&amp;&gt;(dimensionedInternalField());</span><br><span class="line"></span><br><span class="line">    forAll(*<span class="keyword">this</span>, faceI)</span><br><span class="line">    &#123;</span><br><span class="line">        label cellI = patch().faceCells()[faceI];</span><br><span class="line"></span><br><span class="line">        G[cellI] = G0[cellI];</span><br><span class="line">        epsilon[cellI] = epsilon0[cellI];</span><br><span class="line">    &#125;</span><br><span class="line">    fvPatchField&lt;scalar&gt;::updateCoeffs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 一步一步来看。首先是调用了 <code>setMaster()</code> 函数，来看看这个函数以及相关的一个函数 <code>epsilonPatch</code> 的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> epsilonWallFunctionFvPatchScalarField::setMaster()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (master_ != -<span class="number">1</span>) <span class="comment">// 如果当前处理的边界的 master_ != -1，说明它已被处理过，直接返回</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; epsilon =</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> volScalarField&amp;&gt;(<span class="keyword">this</span>-&gt;dimensionedInternalField());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> volScalarField::GeometricBoundaryField&amp; bf = epsilon.boundaryField();</span><br><span class="line"></span><br><span class="line">    label master = -<span class="number">1</span>;</span><br><span class="line">    forAll(bf, patchI)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isA&lt;epsilonWallFunctionFvPatchScalarField&gt;(bf[patchI]))</span><br><span class="line">        &#123;</span><br><span class="line">            epsilonWallFunctionFvPatchScalarField&amp; epf = epsilonPatch(patchI);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (master == -<span class="number">1</span>) <span class="comment">// 只有头一个被处理的边界满足这个条件</span></span><br><span class="line">            &#123;</span><br><span class="line">                master = patchI;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            epf.master() = master; <span class="comment">// 这意味着所有边界的 master_ 数据成员都将赋值为头一个被处理的边界的编号，即第一个被处理的边界是master</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">epsilonWallFunctionFvPatchScalarField&amp;</span><br><span class="line">epsilonWallFunctionFvPatchScalarField::epsilonPatch(<span class="keyword">const</span> label patchI)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; epsilon =</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> volScalarField&amp;&gt;(<span class="keyword">this</span>-&gt;dimensionedInternalField());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> volScalarField::GeometricBoundaryField&amp; bf = epsilon.boundaryField();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> epsilonWallFunctionFvPatchScalarField&amp; epf =</span><br><span class="line">        refCast&lt;<span class="keyword">const</span> epsilonWallFunctionFvPatchScalarField&gt;(bf[patchI]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;epsilonWallFunctionFvPatchScalarField&amp;&gt;(epf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 从上述代码可以看出， <code>epsilonPatch</code> 函数需要一个参数，这个参数的含义是某一个边界的序号，返回的是指向这个边界的一个 <code>epsilonWallFunctionFvPatchScalarField</code> 类型的引用。<br>在此基础上，再来看 <code>setMaster</code>。先判断当前边界的数据成员 <code>master_</code> 是否不等于-1，如果成立则不做任何操作，直接返回；否则，先获取到 <code>epsilon</code> 的所有边界，存在变量 <code>bf</code> 中，然后，遍历 <code>bf</code> ，如果边界的类型是 <code>epsilonWallFunctionFvPatchScalarField</code>，则判断临时变量 <code>master</code> 是否等于 <code>-1</code>，等于则将边界的序号 <code>patchI</code>  赋值给 <code>master</code>，并临时变量 <code>master</code> 的值赋给 <code>patchI</code> 对应边界的数据成员 <code>master_</code>。 举个例子，假设有一个算例，有两个边界上使用了 <code>epsilonWallFunctionFvPatchScalarField</code> 类型的边界条件，两个边界的编号分别是 <code>patchI = 0</code> 和 <code>patchI = 1</code>。则在上述循环过程中，当 <code>patchI = 0</code>时， <code>master == -1</code> 肯定成立。于是，<code>patchI = 0</code> 对应边界的数据成员 <code>master_</code> 被赋值为0；而当遍历到 <code>patchI = 1</code> 时， 此时<code>master = 0</code>，所以，结果是 <code>patchI = 1</code> 的边界的数据成员 <code>master_</code> 也被赋值为0。 </p>
<p> 继续向下看，如果 <code>patch.index() == master_</code> ，则调用两个函数。这个怎么理解呢？还以上面的那个简单例子来说明。注意，在外部调用边界条件的时候，也是会依次调用一个场的所有边界的边界条件的。在这里的简单例子中，有两个边界的类型是 <code>epsilonWallFunctionFvPatchScalarField</code> ，所以，我们假设调用 <code>patchI = 0</code> 对应的边界时，由于初始化时数据成员 <code>master_</code> 赋值为 <code>-1</code> ，所以，调用 <code>patchI = 0</code> 的边界时， <code>setMaster</code> 函数中的操作会进行。而根据上面的分析，调用 <code>patchI = 0</code> 的边界时， <code>setMaster</code> 函数同时也将 <code>patchI = 1</code> 边界的数据成员 <code>master_</code> 赋值为 <code>0</code>了，所以，在外部调用 <code>patchI = 1</code> 的边界时， <code>setMaster</code> 函数将不作任何操作，直接返回。同样的，在外部调用 <code>patchI = 0</code> 的边界时，<code>patch.index() == master_</code> 条件是成立的，所以 <code>createAveragingWeights()</code> 和 <code>calculateTurbulenceFields(turbulence, G(true), epsilon(true));</code> 两个语句将会执行；而在外部调用 <code>patchI = 1</code> 边界时，由于 <code>patch.index() == master_</code> 不成立，这两个语句将不执行。</p>
<p> 再继续往前看， <code>const scalarField&amp; G0 = this-&gt;G();    const scalarField&amp; epsilon0 = this-&gt;epsilon();</code> ，这里是将成员函数 <code>G</code> 和 <code>epsilon</code> 的返回值分别赋给变量 <code>G0</code> 和 <code>epsilon0</code>。开看一下成员函数的定义<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">scalarField&amp; epsilonWallFunctionFvPatchScalarField::<span class="type">G</span>(bool <span class="keyword">init</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (patch().index() == master_) <span class="comment">// 只有头一个被处理的边界满足这个条件</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">init</span>) <span class="comment">// init 缺省值是 false </span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">G_</span> = <span class="number">0.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">G_</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> epsilonPatch(master_).<span class="type">G</span>(); <span class="comment">// 对于不是 master 的边界，返回master边界的数据成员 G_</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">scalarField&amp; epsilonWallFunctionFvPatchScalarField::epsilon(bool <span class="keyword">init</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (patch().index() == master_)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">init</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            epsilon_ = <span class="number">0.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> epsilon_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> epsilonPatch(master_).epsilon(<span class="keyword">init</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>类似的，对于 <code>patchI = 0</code>， <code>patch().index() == master_</code> ，所以返回值为 <code>patchI = 0</code> 边界的数据成员 <code>G_</code> 或  <code>epsilon_</code> (<code>init</code> 的缺省值是 <code>false</code>)；而对于 <code>patchI = 1</code>边界，返回的是 <code>patchI = master_</code> 对应边界的数据成员 <code>G_</code> 或  <code>epsilon_</code>，而根据上面的分析， <code>patchI= 1</code> 的边界的数据成员 <code>master_ = 0</code>，因此， <code>patchI = 1</code> 的边界的成员函数返回的是 <code>patchI = 0</code>边界的相应的数据成员。</p>
<p>再往下的内容就很简单了，只是将得到的 <code>G0</code> 和 <code>epsilon0</code> 的值分别赋给当前边界的临近边界网格而已。</p>
<p>到此，代码的框架就基本清晰了，小结一下就是，如果对于某个算例，有多个边界上需要用到 <code>epsilonWallFunctionFvPatchScalarField</code> 类型的边界条件，则，编号更小的那个边界将会被设置成 <code>master</code>。所有的相关计算都在调用 <code>master</code> 边界的时候进行，非 <code>master</code> 的边界，则只需要从 <code>master</code> 那里读取结果即可！ </p>
<p>接下来看看外部调用 <code>master</code> 边界的时候，具体做了哪些计算，主要就是看 <code>createAveragingWeights()</code> 和 <code>calculateTurbulenceFields(turbulence, G(true), epsilon(true));</code> 这两条语句了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> epsilonWallFunctionFvPatchScalarField::createAveragingWeights()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; epsilon =</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> volScalarField&amp;&gt;(<span class="keyword">this</span>-&gt;dimensionedInternalField());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> volScalarField::GeometricBoundaryField&amp; bf = epsilon.boundaryField();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> fvMesh&amp; mesh = epsilon.mesh();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (initialised_ &amp;&amp; !mesh.changing())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">volScalarField <span class="title">weights</span></span><br><span class="line">    <span class="params">(</span><br><span class="line">        IOobject</span><br><span class="line">        (</span><br><span class="line">            "weights",</span><br><span class="line">            mesh.time()</span>.<span class="title">timeName</span><span class="params">()</span>,</span><br><span class="line">            mesh,</span><br><span class="line">            IOobject::NO_READ,</span><br><span class="line">            IOobject::NO_WRITE,</span><br><span class="line">            <span class="keyword">false</span> <span class="comment">// do not register</span></span><br><span class="line">        ),</span><br><span class="line">        mesh,</span><br><span class="line">        <span class="title">dimensionedScalar</span><span class="params">("zero", dimless, 0.0)</span></span><br><span class="line">    )</span>;</span><br><span class="line"></span><br><span class="line">    DynamicList&lt;label&gt; epsilonPatches(bf.size());</span><br><span class="line">    <span class="comment">//遍历所有边界，如果边界类型是 epsilonWallFunctionFvPatchScalarField 则将该边界放到 epsilonPatches 这个动态 list 中。</span></span><br><span class="line">    forAll(bf, patchI)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isA&lt;epsilonWallFunctionFvPatchScalarField&gt;(bf[patchI]))</span><br><span class="line">        &#123;</span><br><span class="line">            epsilonPatches.append(patchI);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> labelUList&amp; faceCells = bf[patchI].patch().faceCells();</span><br><span class="line">            forAll(faceCells, i)</span><br><span class="line">            &#123;</span><br><span class="line">                label cellI = faceCells[i];</span><br><span class="line">            <span class="comment">// weight 衡量的是网格cellI有多少个边界面使用了 epsilonWallFunctionFvPatchScalarField 类型的边界条件</span></span><br><span class="line">                 weights[cellI]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cornerWeights_.setSize(bf.size());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历所有 epsilonWallFunctionFvPatchScalarField 类型的边界</span></span><br><span class="line">    forAll(epsilonPatches, i)</span><br><span class="line">    &#123;</span><br><span class="line">        label patchI = epsilonPatches[i];</span><br><span class="line">        <span class="keyword">const</span> fvPatchScalarField&amp; wf = weights.boundaryField()[patchI];</span><br><span class="line">    <span class="comment">//cornerWeights_存储的所有边界面的weight的倒数，边界面的weight等于其所属网格的weight。所以，如果有一个网格包含两个使用epsilonWallFunction的边界面，那么根据上面的计算，这个网格的weight将是 2，而这两个边界面的 cornerWeights_ 则都是 1/2。 </span></span><br><span class="line">        cornerWeights_[patchI] = <span class="number">1.0</span>/wf.patchInternalField();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将数据成员 G_ 和 epsilon_ 初始化为0</span></span><br><span class="line">    G_.setSize(dimensionedInternalField().size(), <span class="number">0.0</span>);</span><br><span class="line">    epsilon_.setSize(dimensionedInternalField().size(), <span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">    initialised_ = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> epsilonWallFunctionFvPatchScalarField::calculateTurbulenceFields</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> turbulenceModel&amp; turbulence,</span><br><span class="line">    scalarField&amp; G0,</span><br><span class="line">    scalarField&amp; epsilon0</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// accumulate all of the G and epsilon contributions</span></span><br><span class="line">    <span class="comment">//cornerWeights_ 是一个二维 list，这里是遍历这个list 的第一层</span></span><br><span class="line">    forAll(cornerWeights_, patchI)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!cornerWeights_[patchI].empty()) <span class="comment">// 如果是empty，意味着这个对应的边界不是epsilonWallFunction类型，所以就不需要考虑</span></span><br><span class="line">        &#123;</span><br><span class="line">            epsilonWallFunctionFvPatchScalarField&amp; epf = epsilonPatch(patchI);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> List&lt;scalar&gt;&amp; w = cornerWeights_[patchI];</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 非 empty 则调用 calculate 函数更新 G0 和 epsilon 的值</span></span><br><span class="line">            epf.calculate(turbulence, w, epf.patch(), G0, epsilon0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// apply zero-gradient condition for epsilon</span></span><br><span class="line">    forAll(cornerWeights_, patchI)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!cornerWeights_[patchI].empty())</span><br><span class="line">        &#123;</span><br><span class="line">            epsilonWallFunctionFvPatchScalarField&amp; epf = epsilonPatch(patchI);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对 epsilon 使用 零梯度边界条件，即将上面计算得到的临近壁面网格的epsilon的值存储在壁面。</span></span><br><span class="line">            epf == scalarField(epsilon0, epf.patch().faceCells());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> epsilonWallFunctionFvPatchScalarField::calculate</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> turbulenceModel&amp; turbulence,</span><br><span class="line">    <span class="keyword">const</span> List&lt;scalar&gt;&amp; cornerWeights,</span><br><span class="line">    <span class="keyword">const</span> fvPatch&amp; patch,</span><br><span class="line">    scalarField&amp; G,</span><br><span class="line">    scalarField&amp; epsilon</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> label patchI = patch.index();</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; y = turbulence.y()[patchI];</span><br><span class="line">    <span class="keyword">const</span> scalar Cmu25 = pow025(Cmu_);</span><br><span class="line">    <span class="keyword">const</span> scalar Cmu75 = <span class="built_in">pow</span>(Cmu_, <span class="number">0.75</span>);</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tk = turbulence.k();</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; k = tk();</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tnu = turbulence.nu();</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; nuw = tnu().boundaryField()[patchI];</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tnut = turbulence.nut();</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; nut = tnut();</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; nutw = nut.boundaryField()[patchI];</span><br><span class="line">    <span class="keyword">const</span> fvPatchVectorField&amp; Uw = turbulence.U().boundaryField()[patchI];</span><br><span class="line">    <span class="function"><span class="keyword">const</span> scalarField <span class="title">magGradUw</span><span class="params">(mag(Uw.snGrad()</span>))</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set epsilon and G</span></span><br><span class="line">    遍历参数 patch 对应的边界的每一个面</span><br><span class="line">    forAll(nutw, faceI)</span><br><span class="line">    &#123;</span><br><span class="line">        label cellI = patch.faceCells()[faceI];</span><br><span class="line">        scalar w = cornerWeights[faceI];</span><br><span class="line">        </span><br><span class="line">        epsilon[cellI] += w*Cmu75*<span class="built_in">pow</span>(k[cellI], <span class="number">1.5</span>)/(kappa_*y[faceI]);</span><br><span class="line">        G[cellI] +=</span><br><span class="line">            w</span><br><span class="line">           *(nutw[faceI] + nuw[faceI])</span><br><span class="line">           *magGradUw[faceI]</span><br><span class="line">           *Cmu25*<span class="built_in">sqrt</span>(k[cellI])</span><br><span class="line">           /(kappa_*y[faceI]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>calculate</code> 函数中进行的是实际的计算过程，主要是更新了临近壁面网格的 <code>epsilon</code> 和 <code>G</code> 的值，计算公式如下：<br>$$<br>\varepsilon_c = \frac{1}{N} \sum_{f=i}^{N}\left( \frac{c_\mu^{3/4} k_C^{3/2}}{\kappa y_i}\right) \\<br>\text{相当于} \quad \quad \quad<br>\varepsilon ^+ = \frac{1}{\kappa y^+} \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad<br>$$</p>
<p>$$<br>G_c = \frac{1}{N} \sum_{f=i}^{N}\left( \frac{(\nu + \nu_t)\cdot |\tfrac{U_i-U_c}{d}|\cdot c_\mu^{1/4} k_C^{1/2}}{\kappa y_i}\right)<br>$$<br>这里的 <code>Uw.snGrad()</code> 是 <code>fvPatchFields&lt;Type&gt;</code> 类的成员函数：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class <span class="constant">Type&gt;</span></span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:tmp&lt;Foam</span><span class="symbol">:</span><span class="symbol">:Field&lt;Type&gt;</span> &gt; <span class="constant">Foam:</span><span class="symbol">:fvPatchField&lt;Type&gt;</span><span class="symbol">:</span><span class="symbol">:snGrad</span>() const</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">return</span> patch<span class="constant">_</span>.deltaCoeffs()*(*this - patchInternalField());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>公式中下标 <code>c</code> 表示临近边界的网格， <code>i</code> 表示网格 <code>c</code> 包含的某个边界面元。<code>y</code> 和 <code>d</code> 都表示边界面元所属网格中心到该面元的垂直距离。 </p>
<p>还有一个重要的函数， <code>manipulateMatrix</code><br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void epsilonWallFunctionFvPatchScalarField::manipulateMatrix</span><br><span class="line">(</span><br><span class="line">    fvMatrix&lt;<span class="keyword">scalar</span>&gt;&amp; <span class="literal">matrix</span></span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (manipulatedMatrix())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">matrix</span>.setValues(patch().faceCells(), patchInternalField());</span><br><span class="line"></span><br><span class="line">    fvPatchField&lt;<span class="keyword">scalar</span>&gt;::manipulateMatrix(<span class="keyword">matrix</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数的功能是修改 matrix 中的值，将当前 patch 每一个面所属网格的值更新到 matrix 中，参考<a href="http://www.cfd-online.com/Forums/openfoam-solving/132703-boundarymanipulate.html" target="_blank" rel="external">这个帖子</a>。</p>
<p>如果不是使用的低雷诺数湍流模型，则 $\varepsilon$ 应该使用这个边界条件。理论上，边界第一层网格应该设置在对数区。什么是低雷诺数湍流模型呢？<a href="http://www.cfd-online.com/Forums/openfoam/125473-low-reynolds-turbulence-models.html" target="_blank" rel="external">这篇帖子</a>的三楼有精彩的解释。</p>
<ul>
<li>(2). epsilonLowReWallFunction</li>
</ul>
<p><code>epsilonLowReWallFunction</code> 继承自 <code>epsilonWallFunction</code> ，在此基础上，增加了一个成员函数 <code>yPlusLam</code>，并重新定义了 <code>calculate</code> 函数<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">scalar</span> epsilonLowReWallFunctionFvPatchScalarField::yPlusLam</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">scalar</span> <span class="keyword">kappa</span>,</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">scalar</span> <span class="literal">E</span></span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">scalar</span> ypl = 11.0;</span><br><span class="line">    <span class="keyword">for</span> (int i=0; i&lt;10; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ypl = <span class="literal">log</span>(<span class="literal">max</span>(<span class="keyword">E</span>*ypl, 1))/<span class="keyword">kappa</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ypl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个跟 <code>kLowReWallFunction</code> 里是一样的，不再赘述。<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">void epsilonLowReWallFunctionFvPatchScalarField::calculate</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> turbulenceModel&amp; turbulence,</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">List</span>&lt;<span class="keyword">scalar</span>&gt;&amp; cornerWeights,</span><br><span class="line">    <span class="keyword">const</span> fvPatch&amp; patch,</span><br><span class="line">    scalarField&amp; <span class="keyword">G</span>,</span><br><span class="line">    scalarField&amp; epsilon</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">label</span> patchI = patch.<span class="literal">index</span>();</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; y = turbulence.<span class="literal">y</span>()[patchI];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">scalar</span> Cmu25 = pow025(Cmu_);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">scalar</span> Cmu75 = pow(Cmu_, 0.75);</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tk = turbulence.k();</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; k = tk();</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tnu = turbulence.nu();</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; nuw = tnu().boundaryField()[patchI];</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tnut = turbulence.nut();</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; nut = tnut();</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; nutw = nut.boundaryField()[patchI];</span><br><span class="line">    <span class="keyword">const</span> fvPatchVectorField&amp; Uw = turbulence.<span class="keyword">U</span>().boundaryField()[patchI];</span><br><span class="line">    <span class="keyword">const</span> scalarField magGradUw(mag(Uw.snGrad()));</span><br><span class="line">    </span><br><span class="line"><span class="comment">// Set epsilon and G</span></span><br><span class="line">    forAll(nutw, faceI)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">label</span> cellI = patch.faceCells()[faceI];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">scalar</span> yPlus = Cmu25*<span class="literal">sqrt</span>(k[cellI])*y[faceI]/nuw[faceI];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">scalar</span> w = cornerWeights[faceI];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (yPlus &gt; yPlusLam_)</span><br><span class="line">        &#123;</span><br><span class="line">            epsilon[cellI] = w*Cmu75*pow(k[cellI], 1.5)/(kappa_*y[faceI]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            epsilon[cellI] = w*2.0*k[cellI]*nuw[faceI]/sqr(y[faceI]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">G</span>[cellI] =</span><br><span class="line">            <span class="literal">w</span></span><br><span class="line"><span class="comment">           *(nutw[faceI] + nuw[faceI])</span></span><br><span class="line"><span class="comment">           *magGradUw[faceI]</span></span><br><span class="line"><span class="comment">           *Cmu25*sqrt(k[cellI])</span></span><br><span class="line">           /(kappa_*y[faceI]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里需要根据 <code>yPlus</code> 和 <code>yPlusLam_</code> 的相对大小来选择不同的计算方式。只是，上面这段来自 OpenFOAM-2.3.1 的代码是有问题的！在OpenFOAM-3.0.1 中已经修复成如下<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="atom">forAll</span>(<span class="atom">nutw</span>, <span class="atom">facei</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="atom">label</span> <span class="atom">celli</span> = <span class="atom">patch</span>.<span class="atom">faceCells</span>()[<span class="atom">facei</span>];</span><br><span class="line"></span><br><span class="line">        <span class="atom">scalar</span> <span class="atom">yPlus</span> = <span class="name">Cmu25</span>*<span class="atom">sqrt</span>(<span class="atom">k</span>[<span class="atom">celli</span>])*<span class="atom">y</span>[<span class="atom">facei</span>]/<span class="atom">nuw</span>[<span class="atom">facei</span>];</span><br><span class="line"></span><br><span class="line">        <span class="atom">scalar</span> <span class="atom">w</span> = <span class="atom">cornerWeights</span>[<span class="atom">facei</span>];</span><br><span class="line"></span><br><span class="line">        <span class="atom">if</span> (<span class="atom">yPlus</span> &gt; <span class="atom">yPlusLam_</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="atom">epsilon0</span>[<span class="atom">celli</span>] += <span class="atom">w</span>*<span class="name">Cmu75</span>*<span class="atom">pow</span>(<span class="atom">k</span>[<span class="atom">celli</span>], <span class="number">1.5</span>)/(<span class="atom">kappa_</span>*<span class="atom">y</span>[<span class="atom">facei</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="name">G0</span>[<span class="atom">celli</span>] +=</span><br><span class="line">                <span class="atom">w</span></span><br><span class="line">               *(<span class="atom">nutw</span>[<span class="atom">facei</span>] + <span class="atom">nuw</span>[<span class="atom">facei</span>])</span><br><span class="line">               *<span class="atom">magGradUw</span>[<span class="atom">facei</span>]</span><br><span class="line">               *<span class="name">Cmu25</span>*<span class="atom">sqrt</span>(<span class="atom">k</span>[<span class="atom">celli</span>])</span><br><span class="line">               /(<span class="atom">kappa_</span>*<span class="atom">y</span>[<span class="atom">facei</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="atom">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="atom">epsilon0</span>[<span class="atom">celli</span>] += <span class="atom">w</span>*<span class="number">2.0</span>*<span class="atom">k</span>[<span class="atom">celli</span>]*<span class="atom">nuw</span>[<span class="atom">facei</span>]/<span class="atom">sqr</span>(<span class="atom">y</span>[<span class="atom">facei</span>]);</span><br><span class="line">            <span class="name">G0</span>[<span class="atom">celli</span>] += <span class="name">G</span>[<span class="atom">celli</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>yPlus &gt; yPlusLam_</code> 时，与 <code>epsilonWallFunction</code> 是一样的；<br><code>yPlus &lt; yPlusLam_</code> 时<br>$$<br>\varepsilon_c = \frac{1}{N} \sum_{f=i}^{N}\left( \frac{2\cdot k_C \nu_i}{y^2_i}\right)<br>$$<br>这个公式等价于<br>$$<br>\varepsilon ^+ = 2\frac{k^+}{(y^+)^2}<br>$$</p>
<p><code>G</code> 则取在湍流模型中定义的值，不作修改。 不过，这里 <code>G0[celli] += G[celli]</code> 意味着假设有一个网格有两个边界面，则这个网格的中计算得到的 <code>G0</code> ，将是在湍流模型中定义的该网格中的 G 值的 2 倍，即认为每一个边界面对都该网格内的湍动能生成有贡献。</p>
<p>这个边界是给低雷诺数的 $k-\varepsilon$ 模型以及 $v^2\text{-}f$ 模型使用的。用 OpenFOAM-3.0 以下版本的注意了，这些版本的 <code>epsilonLowReWallFunction</code> 有问题，<strong>一定不要忘了修正一下上面提到的那个bug </strong>！</p>
<h5 id="4-_$\omega$_的壁面函数">4. $\omega$ 的壁面函数</h5><p>OpenFOAM 中只提供了一个 <code>omegaWallFunction</code>，这个壁面函数，属于一种自动壁面函数，能自动地根据 $y^+$ 的值来在粘性层和对数层切换，过渡层则采用粘性层和对数层混合的结果。<br><code>omegaWallFunction</code> 与 <code>epsilonWallFunction</code> 类似，也是需要计算 $\omega$ 和 $P_k$ 在临近边界网格里的值，因此也需要考虑一个网格包含两个以上边界面的情况。具体处理方法跟 <code>epsilonWallFunction</code> 是一样的 ，所以这里就不重复了，只看具体的计算 $\omega$ 和 $P_k$ 的公式<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">void omegaWallFunctionFvPatchScalarField::calculate</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> turbulenceModel&amp; turbulence,</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">List</span>&lt;<span class="keyword">scalar</span>&gt;&amp; cornerWeights,</span><br><span class="line">    <span class="keyword">const</span> fvPatch&amp; patch,</span><br><span class="line">    scalarField&amp; <span class="keyword">G</span>,</span><br><span class="line">    scalarField&amp; omega</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">label</span> patchI = patch.<span class="literal">index</span>();</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; y = turbulence.<span class="literal">y</span>()[patchI];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">scalar</span> Cmu25 = pow025(Cmu_);</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tk = turbulence.k();</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; k = tk();</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tnu = turbulence.nu();</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; nuw = tnu().boundaryField()[patchI];</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tnut = turbulence.nut();</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; nut = tnut();</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; nutw = nut.boundaryField()[patchI];</span><br><span class="line">    <span class="keyword">const</span> fvPatchVectorField&amp; Uw = turbulence.<span class="keyword">U</span>().boundaryField()[patchI];</span><br><span class="line">    <span class="keyword">const</span> scalarField magGradUw(mag(Uw.snGrad()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set omega and G</span></span><br><span class="line">    forAll(nutw, faceI)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">label</span> cellI = patch.faceCells()[faceI];</span><br><span class="line">        <span class="keyword">scalar</span> w = cornerWeights[faceI];</span><br><span class="line">        <span class="keyword">scalar</span> omegaVis = 6.0*nuw[faceI]/(beta1_*sqr(y[faceI]));</span><br><span class="line">        <span class="keyword">scalar</span> omegaLog = <span class="literal">sqrt</span>(k[cellI])/(Cmu25*kappa_*y[faceI]);</span><br><span class="line">        omega[cellI] += w*<span class="literal">sqrt</span>(sqr(omegaVis) + sqr(omegaLog));</span><br><span class="line">        <span class="keyword">G</span>[cellI] +=</span><br><span class="line">            <span class="literal">w</span></span><br><span class="line"><span class="comment">           *(nutw[faceI] + nuw[faceI])</span></span><br><span class="line"><span class="comment">           *magGradUw[faceI]</span></span><br><span class="line"><span class="comment">           *Cmu25*sqrt(k[cellI])</span></span><br><span class="line">           /(kappa_*y[faceI]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里， <code>omegaVis</code> 和 <code>omegaLog</code> 分别指的是在假定第一层网格位于粘性底层和对数层时得到的 <code>omega</code> 的解析解<br>$$<br>\omega_{Vis} = \frac{6.0\nu}{\beta_1y^2} \<br>\omega_{Log} = \frac{k_C^{1/2}}{C_\mu^{1/4}\kappa y}<br>$$<br>然后，将 $\omega_{Vis}$ 和 $\omega_{Log}$ 用一个函数混合起来，就得到了<br>$$<br>\omega = \sqrt{\omega_{Vis}^2 + \omega_{Log}^2}<br>$$<br>只是，这里的湍动能生成项，却似乎并没有使用混合的方法，而是用的基于对数律的公式：<br>$$<br>G = \frac{(\nu + \nu_t)\cdot |\frac{U_c-U_w}{d}|\cdot C_\mu^{1/4}k_C^{1/2}}{\kappa y}<br>$$</p>
<p>$omega$ 方程是能直接积分到壁面，所以，如果使用基于 $\omega$ 的湍流模型，$\omega$ 变量直接使用这个边界条件就可以了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这篇来看看计算湍动能 $\varepsilon$  和 $\omega$ 的壁面函数。</p>]]>
    
    </summary>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="wall functions" scheme="http://xiaopingqiu.github.io/tags/wall-functions/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenFOAM 中的壁面函数（二）]]></title>
    <link href="http://xiaopingqiu.github.io/2016/04/25/wallFunctions2/"/>
    <id>http://xiaopingqiu.github.io/2016/04/25/wallFunctions2/</id>
    <published>2016-04-24T16:43:29.000Z</published>
    <updated>2016-04-25T02:49:07.183Z</updated>
    <content type="html"><![CDATA[<p>这篇来看看计算湍动能 $k$ 的壁面函数。</p>
<a id="more"></a>
<h5 id="2-_湍流动能_$k$_的壁面函数">2. 湍流动能 $k$ 的壁面函数</h5><p>OpenFOAM 中提供了两种 $k$ 的壁面函数， <code>kqRWallFunction</code> 和 <code>kLowReWallFunction</code> 。</p>
<ul>
<li><p><code>kqRWallFunction</code><br>其实就是 <code>zeroGradient</code> ，无需多言。除非使用 $v^2\text{-}f$ 模型，一般情况下 $k$ 应该使用这个边界条件。</p>
</li>
<li><p><code>kLowReWallFunction</code><br>这个壁面函数应该是可以用于低雷诺数模型的。该壁面函数继承自 <code>fixedValue</code> ：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> kLowReWallFunctionFvPatchScalarField</span><br><span class="line">:</span><br><span class="line">    public fixedValueFvPatchField&lt;<span class="keyword">scalar</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">protected:</span><br><span class="line">       <span class="comment">//- Cmu coefficient</span></span><br><span class="line">        <span class="keyword">scalar</span> Cmu_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Von Karman constant</span></span><br><span class="line">        <span class="keyword">scalar</span> kappa_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- E coefficient</span></span><br><span class="line">        <span class="keyword">scalar</span> E_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Ceps2 coefficient</span></span><br><span class="line">        <span class="keyword">scalar</span> Ceps2_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Y+ at the edge of the laminar sublayer</span></span><br><span class="line">        <span class="keyword">scalar</span> yPlusLam_;</span><br><span class="line">        ......</span><br><span class="line">        </span><br><span class="line">kLowReWallFunctionFvPatchScalarField::kLowReWallFunctionFvPatchScalarField</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> fvPatch&amp; p,</span><br><span class="line">    <span class="keyword">const</span> DimensionedField&lt;<span class="keyword">scalar</span>, volMesh&gt;&amp; <span class="keyword">iF</span>,</span><br><span class="line">    <span class="keyword">const</span> dictionary&amp; dict</span><br><span class="line">)</span><br><span class="line">:</span><br><span class="line">    fixedValueFvPatchField&lt;<span class="keyword">scalar</span>&gt;(p, <span class="keyword">iF</span>, dict),</span><br><span class="line">    Cmu_(dict.lookupOrDefault&lt;<span class="keyword">scalar</span>&gt;(<span class="string">"Cmu"</span>, 0.09)),</span><br><span class="line">    kappa_(dict.lookupOrDefault&lt;<span class="keyword">scalar</span>&gt;(<span class="string">"kappa"</span>, 0.41)),</span><br><span class="line">    E_(dict.lookupOrDefault&lt;<span class="keyword">scalar</span>&gt;(<span class="string">"E"</span>, 9.8)),</span><br><span class="line">    Ceps2_(dict.lookupOrDefault&lt;<span class="keyword">scalar</span>&gt;(<span class="string">"Ceps2"</span>, 1.9)),</span><br><span class="line">    yPlusLam_(yPlusLam(kappa_, E_))</span><br><span class="line">    &#123;</span><br><span class="line">        checkType();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>核心的函数是以下两个：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">scalar kLowReWallFunctionFvPatchScalarField::yPlusLam</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> scalar kappa,</span><br><span class="line">    <span class="keyword">const</span> scalar E</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    scalar ypl = <span class="number">11.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ypl = <span class="built_in">log</span>(max(E*ypl, <span class="number">1</span>))/kappa;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ypl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> kLowReWallFunctionFvPatchScalarField::updateCoeffs()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (updated())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> label patchI = patch().index();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> turbulenceModel&amp; turbulence =</span><br><span class="line">        db().lookupObject&lt;turbulenceModel&gt;(<span class="string">"turbulenceModel"</span>);</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; y = turbulence.y()[patchI];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tk = turbulence.k();</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; k = tk();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> tmp&lt;volScalarField&gt; tnu = turbulence.nu();</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; nuw = tnu().boundaryField()[patchI];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> scalar Cmu25 = pow025(Cmu_);</span><br><span class="line"></span><br><span class="line">    scalarField&amp; kw = *<span class="keyword">this</span>; <span class="comment">// 更新 kw 相当于更新壁面上的 k 值。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set k wall values</span></span><br><span class="line">    forAll(kw, faceI)</span><br><span class="line">    &#123;</span><br><span class="line">        label faceCellI = patch().faceCells()[faceI];</span><br><span class="line"></span><br><span class="line">        scalar uTau = Cmu25*<span class="built_in">sqrt</span>(k[faceCellI]);</span><br><span class="line"></span><br><span class="line">        scalar yPlus = uTau*y[faceI]/nuw[faceI];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (yPlus &gt; yPlusLam_)</span><br><span class="line">        &#123;</span><br><span class="line">            scalar Ck = -<span class="number">0.416</span>;</span><br><span class="line">            scalar Bk = <span class="number">8.366</span>;</span><br><span class="line">            kw[faceI] = Ck/kappa_*<span class="built_in">log</span>(yPlus) + Bk;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            scalar C = <span class="number">11.0</span>;</span><br><span class="line">            scalar Cf = (<span class="number">1.0</span>/sqr(yPlus + C) + <span class="number">2.0</span>*yPlus/pow3(C) - <span class="number">1.0</span>/sqr(C));</span><br><span class="line">            kw[faceI] = <span class="number">2400.0</span>/sqr(Ceps2_)*Cf;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        kw[faceI] *= sqr(uTau);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fixedValueFvPatchField&lt;scalar&gt;::updateCoeffs();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO: perform averaging for cells sharing more than one boundary face</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>先在函数里计算 <code>ypl</code> 的值， <code>updateCoeffs</code> 函数里根据 <code>yPlus</code> 与这个 <code>ypl</code> 的值来相对大小而采取不同的方法来计算壁面上的 $k_w$。 <code>ypl</code> 的计算是一个迭代过程<br>$$<br>ypl = \frac{\log(\max(E*ypl,1.0))}{\kappa}<br>$$<br>初始值为 <code>ypl = 11.0</code>，迭代10次，最终结果应该是 <code>ypl = 11.5301073043272</code>。<br>$y^+$ 定义为：<br>$$<br>u_\tau = C_\mu^{1/4 }\sqrt{k_c} \<br>y^+ = \frac{u_\tau \cdot y}{\nu_w}<br>$$<br>壁面上的k计算方法如下：如果 $y^+ &gt; ypl$，则<br>$$<br>k^+ _w = \frac{C_k}{\kappa}\ln(y^+) + B_k<br>$$<br>否则<br>$$<br>k^+ _w = \frac{2400}{C_{eps2}^2}\cdot \left[ \frac{1}{(y^+ + C)^2} + \frac{2y^+}{C^3} - \frac{1}{C^2}\right ]<br>$$<br>最终，壁面上的值为 $k_w=k^+ _w u_\tau ^2 =k^+ _w C_\mu^{1/2}k_c$ 。<br>以上公式中，下标 $c$ 表示壁面单元所述网格的值，下标 $w$ 表示当前壁面上的值。<br>这个壁面函数参考文献 “Kalitzin, G., Medic, G., Iaccarino, G., Durbin, P., 2005. Near-wall behavior of RANS turbulence models and implications for wall functions. J. Comput. Phys. 204, 265–291. doi:10.1016/j.jcp.2004.10.018”，是为 $v^2\text{-}f$ 模型设计的。 </p>
<h5 id="$v^2$_和_$f$_的壁面函数">$v^2$ 和 $f$ 的壁面函数</h5><p>上面提到了 $v^2\text{-}f$ 模型，所以这里顺便来看看$v^2$ 和 $f$ 的壁面函数。这里参考的也是上面提到的那篇参考文献。</p>
<ul>
<li>$v^2$ 的壁函数<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">forAll(v2, faceI)</span><br><span class="line">    &#123;</span><br><span class="line">        label faceCellI = patch().faceCells()[faceI];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">scalar</span> uTau = Cmu25*<span class="keyword">sqrt</span>(k[faceCellI]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">scalar</span> yPlus = uTau*<span class="keyword">y</span>[faceI]/nuw[faceI];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (yPlus &gt; yPlusLam<span class="number">_</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">scalar</span> Cv2 = <span class="number">0</span>.<span class="number">193</span>;</span><br><span class="line">            <span class="keyword">scalar</span> Bv2 = -<span class="number">0</span>.<span class="number">94</span>;</span><br><span class="line">            v2[faceI] = Cv2/kappa<span class="number">_</span>*<span class="keyword">log</span>(yPlus) + Bv2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">scalar</span> Cv2 = <span class="number">0</span>.<span class="number">193</span>;</span><br><span class="line">            v2[faceI] = Cv2*pow4(yPlus);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        v2[faceI] *= <span class="keyword">s</span><span class="string">qr(uTau)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fixedValueFvPatchField&lt;<span class="keyword">scalar</span>&gt;::updateCoeffs();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><code>yPlus &gt; yPlusLam_</code> 时，<br>$$<br>v^2 = u_\tau^2 \cdot \left[ \frac{C_{v2}}{\kappa}\ln(y^+) + B_{v2} \right]<br>$$<br>与文献中的无量纲形式 $(\overline{v^2})^{^+} = \frac{C_{v2}}{\kappa}\ln(y^+) + B_{v2} $ 一致。</p>
<p><code>yPlus &lt; yPlusLam\_</code> 时，<br>$$<br>v^2 = u_\tau^2 \cdot C_{v2}(y^+)^2<br>$$<br>与无量纲形式 $(\overline{v^2})^{^+} = C_{v2}(y^+)^2$ 一致。</p>
<ul>
<li>$f$ 的壁函数<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">forAll(f, faceI)</span><br><span class="line">    &#123;</span><br><span class="line">        label faceCellI = patch().faceCells()[faceI];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">scalar</span> uTau = Cmu25*<span class="keyword">sqrt</span>(k[faceCellI]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">scalar</span> yPlus = uTau*<span class="keyword">y</span>[faceI]/nuw[faceI];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (yPlus &gt; yPlusLam<span class="number">_</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">scalar</span> N = <span class="number">6.0</span>;</span><br><span class="line">            <span class="keyword">scalar</span> v2c = v2[faceCellI];</span><br><span class="line">            <span class="keyword">scalar</span> epsc = epsilon[faceCellI];</span><br><span class="line">            <span class="keyword">scalar</span> kc = k[faceCellI];</span><br><span class="line"></span><br><span class="line">            f[faceI] = N*v2c*epsc/(<span class="keyword">s</span><span class="string">qr(kc)</span> + ROOTVSMALL);</span><br><span class="line">            f[faceI] /= <span class="keyword">s</span><span class="string">qr(uTau)</span> + ROOTVSMALL;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            f[faceI] = <span class="number">0</span>.<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><code>yPlus &gt; yPlusLam_</code> 时，<br>$$<br>f = \frac{N \cdot v^2\cdot \varepsilon}{k^2 u_\tau^2}<br>$$<br>这似乎与文献中的无量纲形式<br>$$<br>f^+ = N \frac{(\overline{v^2})^{^+}}{(k^+)^2}\varepsilon^+<br>$$<br>不一致！是 bug 还是我推导出错了？存疑…</p>
<p><code>yPlus &lt; yPlusLam_</code> 时，文献给出的公式是<br>$$<br>f^+ = \frac{-4(6-N)(\overline{v^2})^{^+}}{\varepsilon^+ (y^+)^4}<br>$$<br>当 <code>N=6</code> 时，可以得到 $f^+ = 0$ 。</p>
<p>按理说，$v^2$ 和 $f$ 应该跟 $\varepsilon$ 和 $\omega$ 那样（见后文），计算第一层网格内的值，并且考虑一个网格有多个边界面的情形。OpenFOAM 目前计算的是每一个边界面元上的值，不知道这两种方式对结果有多大影响。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这篇来看看计算湍动能 $k$ 的壁面函数。</p>]]>
    
    </summary>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="wall functions" scheme="http://xiaopingqiu.github.io/tags/wall-functions/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenFOAM 中的壁面函数（一）]]></title>
    <link href="http://xiaopingqiu.github.io/2016/04/25/wallFunctions1/"/>
    <id>http://xiaopingqiu.github.io/2016/04/25/wallFunctions1/</id>
    <published>2016-04-24T16:36:27.000Z</published>
    <updated>2016-04-26T15:12:44.864Z</updated>
    <content type="html"><![CDATA[<p>本系列来看看 OpenFOAM 中的壁面函数。壁面函数的本质，是边界条件。这里主要来看看壁面函数的基本原理，OpenFOAM 中实现了的壁面函数，以及选择壁面函数的一些参考依据。</p>
<a id="more"></a>
<h5 id="1-_壁面函数的基本原理">1. 壁面函数的基本原理</h5><p>湍流模拟中，需要对近壁区域进行处理。一般来讲，壁面处理方法包含两类，一类是使用很细的网格，使靠近壁面的第一层网格在粘性层内（$y^+ <1$），然后里可以直接解析到粘性层的低雷诺湍流模型；另一类，不直接解析粘性层，而是将第一层网格设置在对数区（$y^+> 30$），然后用经验公式来将粘性层和对数区关联起来。下图是一个典型的壁面附近的 $U^+ \text{-} y^+$ 关系图。<br><img src="/image/wallFunctions/Law_of_the_wall.png" alt="壁面律"><br>图片来自 <a href="https://en.wikipedia.org/wiki/Law_of_the_wall" target="_blank" rel="external">Wikipedia:Law of the wall </a>。<br>在粘性层，满足如下关系<br>$$<br>u^+ = y^+<br>$$<br>而在对数区，则满足<br>$$<br>U^+ = \frac{1}{\kappa}\ln(Ey^+)<br>$$<br>其中 $U^+ = U/u_\tau$， $y^+ = yu_\tau/\nu$， $u_\tau = \sqrt{\tau_w/\rho}$，$\kappa\approx 0.41$，$E \approx 9.8$，$y$ 表示与壁面的距离。</1$），然后里可以直接解析到粘性层的低雷诺湍流模型；另一类，不直接解析粘性层，而是将第一层网格设置在对数区（$y^+></p>
<p>本篇以标准壁面函数法来讨论一下壁面函数方法的基本原理，以及壁面函数在 OpenFOAM 中的实现。下面的讨论，先局限在 $k-\varepsilon$ 模型，且第一层网格在对数区的情形。<br>先来看一下壁面函数方法需要解决什么问题。<br>有限体积方法中，扩散项的离散可以表示如下：<br>$$<br>\nabla \cdot (\nu \nabla U) = \sum_f \left [\nu_f \cdot (\nabla U)_f \right]<br>$$<br>当 $f$ 表示的是壁面边界单元时，这时就需要知道在壁面上的速度梯度 $(\nabla U)_f$。壁面上一般对速度 $U$ 采用无滑移条件，如何得到正确的壁面速度梯度，这就是一个问题。这个问题有两个解决思路，一是通过实验或者 DNS 模拟等，得到一条连续的 $U-y$ 曲线，然后从这个曲线求壁面上的导数 $dU/dy$ 来得到壁面上的速度梯度；还有一种思路是，由于最终需要得到的是正确的 $\nu_f \cdot (\nabla U)_f$ ，即壁面上的剪应力，虽然<br>$$<br>\tau_w = \nu \cdot \frac{\partial U}{\partial n}\left. \right|_w \neq \nu \frac{U_p-U_w}{y}<br>$$<br>其中 $U_p$ 表示第一层网格中心的速度，$U_w$ 表示壁面上的速度。<br>但是，可以构造一个壁面上的有效粘度 $\nu_{eff}$，以使下式成立<br>$$<br>\tau_w = \nu \cdot  \frac{\partial U}{\partial n} \left. \right |_w = \nu_{eff} \frac{U_p-U_w}{y} = (\nu + \nu_t ) \cdot \frac{U_p-U_w}{y}<br>$$</p>
<p>后一种解决方法的好处是，不需要修改动量方程，直接使用 $\frac{U_p-U_w}{y}$ 来代替 $\frac{\partial U}{\partial n} \left. \right |_w  $，然后通过设置合适的湍流粘度 $\nu_t$ 的边界条件来修正壁面应力 $\tau_w$。</p>
<p>另一方面，在对数区，$k^+$ 是常数<br>$$<br>k^+ = \frac{1}{\sqrt{C_\mu}} \\<br>$$<br>其中 $k^+ = k/u_\tau^2$。<br>由<br>$$<br>k^+ = \frac{1}{\sqrt{C_\mu}} = k/u_\tau^2<br>$$<br>得<br>$$<br>u_\tau = C_\mu^{1/4}k^{1/2}<br>$$<br>于是<br>$$<br>\tau_w = \rho u_\tau^2 = \rho u_\tau \cdot \frac{U}{U^+} = \frac{\rho u_\tau (U_p-U_w)}{\frac{1}{\kappa}\ln(Ey^+)}<br>$$<br>若令<br>$$<br>\nu_{eff} = \frac{u_\tau y}{\frac{1}{\kappa}\ln(Ey^+)}<br>$$<br>则<br>$$<br>\tau_w = \rho \nu_{eff}\cdot \frac{U_p-U_w}{y}<br>$$<br>这正是上文提到的第二种解决壁面速度问题的形式。<br>而<br>$$<br>\nu_{eff} = \frac{ u_\tau y}{\frac{1}{\kappa}\ln(Ey^+)} = \frac{ y^+ \nu}{\frac{1}{\kappa}\ln(Ey^+)} = \nu + \nu_{tw}<br>$$<br>于是得到壁面上的湍流粘度为<br>$$<br>\nu_{tw} = \nu \cdot \left(\frac{\kappa y^+}{\ln(Ey^+)} -1 \right)<br>$$</p>
<p>$y^+$ 可以通过不同的方式来得到，具体的计算方法，见后文的 <code>nutWallFunctions</code> 部分。</p>
<p>除了得到壁面上的等效湍流粘度，还需要计算靠近壁面第一层网格的湍动能生成和湍动能耗散项。</p>
<p>湍动能生成项计算如下：<br>$$<br>G \approx \tau_w\cdot \frac{\partial (U_p -U_w)}{\partial y}<br>$$<br>由速度的壁面律<br>$$<br>U^+ = \frac{U_p - U_w}{u_\tau} = \frac{1}{\kappa}\ln(Ey^+) = \frac{1}{\kappa} \ln(E\frac{yu_\tau}{\nu})<br>$$<br>注意，$G$ 求的是第一层网格内的值，所以，由<br>$$<br>U_p -U_w = \frac{u_\tau}{\kappa} \ln(E\frac{yu_\tau}{\nu})<br>$$<br>可以求得第一层网格内的梯度<br>$$<br>\frac{\partial (U_p -U_w)}{\partial y} \left. \right|_p = \frac{u_\tau}{\kappa y_p}<br>$$<br>于是<br>$$<br>G = \tau_w \cdot \frac{u_\tau}{\kappa y_p}<br>$$<br>注意，这里的 $\frac{U_p-U_w}{d}$，其实是速度在壁面法向方向的梯度的近似值，这一点见上文 $\nu_t$ 的边界条件部分。</p>
<p>再来看 $\varepsilon$，$\varepsilon$ 的计算基于第一层网格内的湍动生成与湍动能耗散项守恒的假设，即<br>$$<br> \rho \varepsilon_p = G = \tau_w \cdot \frac{u_\tau}{\kappa y_p} =\rho\cdot \frac{u_\tau^3}{\kappa y_p}<br>$$<br>于是得<br>$$<br>\varepsilon_p = \frac{u_\tau^3}{\kappa y_p} = \frac{C_\mu^{3/4}k_p^{3/2}}{\kappa y_p}<br>$$</p>
<p>至于 $k$，一般认为当第一层网格位于对数区时，不需要在壁面上对 $k$ 加任何限制，用零梯度边界条件即可。</p>
<h5 id="2-_在_OpenFOAM_中的实现">2. 在 OpenFOAM 中的实现</h5><p>在 OpenFOAM 中，$k$，$\varepsilon$ 和 $\nu_t$ 分别有对应的边界条件可以选择，壁面函数的实现是在这些边界条件里进行的。具体地说， <code>k***WallFunction</code> 用于指定 $k$ 的边界条件， <code>epsilon***WallFunction</code> 用于计算 $\varepsilon$ 和 $G$ 在第一层网格内的值， <code>nut***WallFunction</code> 用来计算 $\nu_t$ 在壁面上的值。 还有就是一个要关心的问题是这些边界条件的调用顺序，这需要通过湍流模型的一段代码来说明，以 <code>kEpsilon</code> 为例：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> kEpsilon::correct()</span><br><span class="line">&#123;</span><br><span class="line">    RASModel::correct();</span><br><span class="line">    <span class="keyword">if</span> (!turbulence_)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    volScalarField G(GName(), nut_*<span class="number">2</span>*magSqr(symm(fvc::grad(U_))));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update epsilon and G at the wall</span></span><br><span class="line">    epsilon_.boundaryField().updateCoeffs();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dissipation equation</span></span><br><span class="line">    tmp&lt;fvScalarMatrix&gt; epsEqn</span><br><span class="line">    (</span><br><span class="line">        fvm::ddt(epsilon_)</span><br><span class="line">      + fvm::div(phi_, epsilon_)</span><br><span class="line">      - fvm::laplacian(DepsilonEff(), epsilon_)</span><br><span class="line">     ==</span><br><span class="line">        C1_*G*epsilon_/k_</span><br><span class="line">      - fvm::Sp(C2_*epsilon_/k_, epsilon_)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    epsEqn().relax();</span><br><span class="line">    epsEqn().boundaryManipulate(epsilon_.boundaryField());</span><br><span class="line"></span><br><span class="line">    solve(epsEqn);</span><br><span class="line">    bound(epsilon_, epsilonMin_);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Turbulent kinetic energy equation</span></span><br><span class="line">    tmp&lt;fvScalarMatrix&gt; kEqn</span><br><span class="line">    (</span><br><span class="line">        fvm::ddt(k_)</span><br><span class="line">      + fvm::div(phi_, k_)</span><br><span class="line">      - fvm::laplacian(DkEff(), k_)</span><br><span class="line">     ==</span><br><span class="line">        G</span><br><span class="line">      - fvm::Sp(epsilon_/k_, k_)</span><br><span class="line">    );</span><br><span class="line">    kEqn().relax();</span><br><span class="line">    solve(kEqn);</span><br><span class="line">    bound(k_, kMin_);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-calculate viscosity</span></span><br><span class="line">    nut_ = Cmu_*sqr(k_)/epsilon_;</span><br><span class="line">    nut_.correctBoundaryConditions();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上述代码，可以将湍流模型的具体计算过程归纳如下：</p>
<ol>
<li>计算湍动能生成项 $G$，并修正 $G$ 在第一层网格的值。修正是通过 <code>epsilon_.boundaryField().updateCoeffs();</code> 来实现的，这里调用 <code>epsilon</code> 的边界条件的 <code>updateCoeffs</code> 函数，实现的操作是修正 $G$ 和 $\varepsilon$ 在第一层网格的值。</li>
<li>利用更新的 $G$ 构建 <code>epsEqn</code>，然后修改 <code>epsEqn</code>（ <code>epsEqn().boundaryManipulate(epsilon_.boundaryField());</code> ），这样做的目的是保证在下一步 <code>solve(epsEqn)</code>的时候，<code>epsilonWallFunction</code> 类型的边界所属的网格的值不会变化，而是保持在 <code>epsilon_.boundaryField().updateCoeffs();</code> 这一步里设置的值（参考 <a href="http://www.cfd-online.com/Forums/openfoam-solving/132703-boundarymanipulate.html" target="_blank" rel="external">cfd-online 的这个帖子</a>）。</li>
<li>求解 <code>epsEqn</code>，得到更新的 $\varepsilon$ 场。</li>
<li>利用更新的 $\varepsilon$ 场构建并求解 <code>kEqn</code>，得到更新的 $k$ 场。</li>
<li>计算 $\nu_t$，并更新 $\nu_t$ 在边界上的值（<code>nut_.correctBoundaryConditions()</code>） </li>
</ol>
<p>至于具体的 $k$，$\varepsilon$，以及 $\nu_t$ 的边界条件的实现，见后文。 </p>
<p><strong>参考</strong></p>
<ol>
<li>The Finite Volume Method in Computational Fluid Dynamics An Advanced Introduction with OpenFOAM® and Matlab®</li>
<li><a href="http://www.slideshare.net/fumiyanozaki96/openfoam-36426892" target="_blank" rel="external">http://www.slideshare.net/fumiyanozaki96/openfoam-36426892</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>本系列来看看 OpenFOAM 中的壁面函数。壁面函数的本质，是边界条件。这里主要来看看壁面函数的基本原理，OpenFOAM 中实现了的壁面函数，以及选择壁面函数的一些参考依据。</p>]]>
    
    </summary>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="wall functions" scheme="http://xiaopingqiu.github.io/tags/wall-functions/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenFOAM-3.0 的湍流模型（四）]]></title>
    <link href="http://xiaopingqiu.github.io/2016/04/25/TurbulenceModel-30-macro/"/>
    <id>http://xiaopingqiu.github.io/2016/04/25/TurbulenceModel-30-macro/</id>
    <published>2016-04-24T16:11:08.000Z</published>
    <updated>2016-04-25T01:44:22.363Z</updated>
    <content type="html"><![CDATA[<p>最后来看一个小问题：OpenFOAM-3.0 中的湍流模型是怎么编译的。在这之前，湍流模型的编译很直观，将需要编译的湍流模型的代码的 <code>.C</code> 文件写到 <code>Make/files</code> 里就好了。可是，在 OpenFOAM-3.0 里，很多湍流模型代码的 <code>.C</code> 文件并没有写到 <code>Make/files</code> 里，而是在 <code>makeTurbulenceModels.C</code>里类似这样写<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "mykEpsilon.H"</span></span><br><span class="line">makeRASModel(mykEpsilon);</span><br></pre></td></tr></table></figure></p>
<p>然后在 <code>Make/files</code> 里写的是这个 <code>makeTurbulenceModels.C</code> 文件。为什么呢？</p>
<p>这里来分析一下这个问题。</p>
<a id="more"></a>
<p>这个问题，说起来也简单，不过我经过很多摸索从想明白。其实，这个问题用一个概念就可以解释清楚：条件编译。</p>
<p>条件编译常用于头文件，格式如下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//filename: kEpsilon.H</span></span><br><span class="line"><span class="preprocessor">#ifndef  kEpsilon_H</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span>  kEpsilon_H</span></span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>这样能避免头文件重复引用的导致变量或者类重复定义的问题，原因在于，第一次 <code>#include &quot;kEpsilon.H&quot;</code> 时，会触发 <code>#define  kEpsilon_H</code> 的操作，之后如果代码中再出现 <code>#include &quot;kEpsilon.H&quot;</code> 则  <code>#ifndef  kEpsilon_H</code> 将不再成立，所以， <code>#ifndef ... #endif</code> 之间的内容将不会再度被引入。</p>
<p>OpenFOAM 的模板类中，还常见的一种用法是<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#ifdef NoRepository</span></span><br><span class="line"><span class="preprocessor">#   <span class="keyword">include</span> "kEpsilon.C"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>这个怎么理解呢？ 本来也不难理解，无非就是如果定义了宏 <code>NoRepository</code> 则在头文件里将类的具体定义部分也引入到头文件里。问题是，翻遍 OpenFOAM 的 <code>src</code> 目录下的源码，也找不到 <code>NoRepository</code> 的定义。经过搜索，原来这个 <code>NoRepository</code> 是通过 g++ 的 <code>-D</code> 选项来定义的！在编译过程中，使用<br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -c -DNoRepository ...</span><br></pre></td></tr></table></figure></p>
<p>相当于进行了 <code>#define NoRepository 1</code> 的操作，所以， <code>#ifdef NoRepository</code> 这个条件是满足的。<br>OpenFOAM 中，编译选项的定义在 <code>wmake/rules</code> 下，具体的定义取决于你用的编译器，以 <code>linux64Gcc/c++</code> 为例<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">c++WARN     = -Wall -Wextra -Wno-unused-parameter -Wold-style-cast -Wnon-virtual-dtor</span><br><span class="line"></span><br><span class="line"><span class="constant">CC</span>          = g++ -m64</span><br><span class="line"></span><br><span class="line">include $(RULES)/c++$(WM_COMPILE_OPTION)</span><br><span class="line"></span><br><span class="line"><span class="constant">ptFLAGS</span>     = -DNoRepository -ftemplate-depth-100</span><br><span class="line"></span><br><span class="line">c++FLAGS    = $(GFLAGS) $(c++WARN) $(c++OPT) $(c++DBUG) $(ptFLAGS) $(LIB_HEADER_DIRS) -fPIC</span><br><span class="line"></span><br><span class="line"><span class="constant">Ctoo</span>        = <span class="variable">$(WM_SCHEDULER)</span> <span class="variable">$(CC)</span> <span class="variable">$(c++FLAGS)</span> -c $$SOURCE -o $@</span><br><span class="line"><span class="constant">cxxtoo</span>      = <span class="variable">$(Ctoo)</span></span><br><span class="line"><span class="constant">cctoo</span>       = <span class="variable">$(Ctoo)</span></span><br><span class="line"><span class="constant">cpptoo</span>      = <span class="variable">$(Ctoo)</span></span><br><span class="line"></span><br><span class="line"><span class="constant">LINK_LIBS</span>   = <span class="variable">$(c++DBUG)</span></span><br><span class="line"></span><br><span class="line"><span class="constant">LINKLIBSO</span>   = <span class="variable">$(CC)</span> <span class="variable">$(c++FLAGS)</span> -shared -Xlinker --add-needed -Xlinker --no-as-needed</span><br><span class="line"><span class="constant">LINKEXE</span>     = <span class="variable">$(CC)</span> <span class="variable">$(c++FLAGS)</span> -Xlinker --add-needed -Xlinker --no-as-needed</span><br></pre></td></tr></table></figure></p>
<p>可见这里的确是使用了 <code>-DNoRepository</code> 选项。</p>
<p>为什么要在头文件里 <code>#include &quot;kEpsilon.C&quot;</code> 呢？这就涉及到模板类的实例化的问题。<a href="http://www.codeproject.com/Articles/3515/How-To-Organize-Template-Source-Code" target="_blank" rel="external">这篇文章</a>详细地探讨了模板类实例化过程中会遇到的问题，以及解决的办法。简单地说，<strong>模板类不是一种类型，而是一种模板</strong>，模板类通过代入模板参数来实例化，以得到具体的类（这个具体的类就可以看作是一种“数据类型”了）。在示例化过程中，编译器不光需要模板类的声明部分，还需要知道模板类的成员函数的具体定义部分，所以，如果在进行模板类声明的地方只包含了模板类的声明部分（一般是头文件），那实例化就会失败，编译器会报类似“undefined reference to …” 的错误。<br><a href="http://www.cfd-online.com/Forums/openfoam-programming-development/90676-norepository.html" target="_blank" rel="external">cfd-online 上的这个帖子</a>也探讨了关于 <code>NoRepository</code> 的问题。</p>
<p>最后，<code>makeTurbulenceModels.C</code> 里的 <code>#include  &quot;kEpsilon.H&quot;</code>，其实相当于也 <code>#include &quot;kEpsilon.C&quot;</code>，而且，要注意<strong>这里 include 进来的是一个模板类，是用来建立实例化的模型的</strong>！实例化的过程，在 <code>makeRASModel(kEpsilon)</code> 里，详细的参考前一篇，看看这个宏函数的展开，就知道模型参数是怎么代入进去来得到实例化的湍流模型类的。 </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最后来看一个小问题：OpenFOAM-3.0 中的湍流模型是怎么编译的。在这之前，湍流模型的编译很直观，将需要编译的湍流模型的代码的 <code>.C</code> 文件写到 <code>Make/files</code> 里就好了。可是，在 OpenFOAM-3.0 里，很多湍流模型代码的 <code>.C</code> 文件并没有写到 <code>Make/files</code> 里，而是在 <code>makeTurbulenceModels.C</code>里类似这样写<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "mykEpsilon.H"</span></span><br><span class="line">makeRASModel(mykEpsilon);</span><br></pre></td></tr></table></figure></p>
<p>然后在 <code>Make/files</code> 里写的是这个 <code>makeTurbulenceModels.C</code> 文件。为什么呢？</p>
<p>这里来分析一下这个问题。</p>]]>
    
    </summary>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="turbulence model" scheme="http://xiaopingqiu.github.io/tags/turbulence-model/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenFOAM-3.0 的湍流模型（三）]]></title>
    <link href="http://xiaopingqiu.github.io/2016/04/24/TurbulenceModel-30-NewModels/"/>
    <id>http://xiaopingqiu.github.io/2016/04/24/TurbulenceModel-30-NewModels/</id>
    <published>2016-04-24T15:34:01.000Z</published>
    <updated>2016-04-25T02:07:48.763Z</updated>
    <content type="html"><![CDATA[<p>有了上一篇的基础，就很容易做到添加新的湍流模型了，这里分别给出对四类湍流模型增加新模型的方法。探索过程不详述了，仅给出结果。</p>
<a id="more"></a>
<h5 id="3-_添加新模型的方法。">3. 添加新模型的方法。</h5><p>添加湍流模型，关键的有两个，一是如果将新湍流模型添加到合适的 hashTable，以便能被求解器调用，另一个是 Make/files 和 Make/options 的写法以使湍流模型能被编译。</p>
<p>这里不给出具体湍流模型的代码，仅给出 Make 的写法，以及一个 <code>.C</code> 文件。编译湍流模型的时候，新建一个目录，将需要编译的湍流模型代码、这里给出的对应类型的 <code>.C</code> 文件和 Make 文件夹都拷贝到新建的目录，然后运行 <code>wmake libso</code> 即可。</p>
<h6 id="3-1_单相不可压缩湍流模型">3.1 单相不可压缩湍流模型</h6><ul>
<li>makeTuebulenceModels.C</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "IncompressibleTurbulenceModel.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "incompressible/transportModel/transportModel.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "addToRunTimeSelectionTable.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "makeTurbulenceModel.H"</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "RASModel.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "LESModel.H"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 宏函数定义</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> makeRASModel(Type)                                                     \</span><br><span class="line">    makeTemplatedTurbulenceModel                                               \</span><br><span class="line">    (transportModelIncompressibleTurbulenceModel, RAS, Type)</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> makeLESModel(Type)                                                     \</span><br><span class="line">    makeTemplatedTurbulenceModel                                               \</span><br><span class="line">    (transportModelIncompressibleTurbulenceModel, LES, Type)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------------------------------------------------- //</span></span><br><span class="line"><span class="comment">// RAS models</span></span><br><span class="line"><span class="comment">// -------------------------------------------------------------------------- //</span></span><br><span class="line"><span class="keyword">namespace</span> Foam</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> IncompressibleTurbulenceModel&lt;transportModel&gt; transportModelIncompressibleTurbulenceModel; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">typedef</span> RASModel&lt;transportModelIncompressibleTurbulenceModel&gt; RAStransportModelIncompressibleTurbulenceModel;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">typedef</span> LESModel&lt;transportModelIncompressibleTurbulenceModel&gt; LEStransportModelIncompressibleTurbulenceModel; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里说明一下，编译新的模型，最重要的是将作为模板类的通用湍流模型代入合适的模板参数以实例化，然后将实例化的模型添加到合适的　hashTable。</span></span><br><span class="line"><span class="comment">// 上面定义的几个别名，是为了下面将模型添加到 hashTable 而服务的，至于为什么要定义这几个别名，参考前一篇的 `makeBaseTurbulenceModel` 宏函数的展开部分。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "mykEpsilon.H"</span></span><br><span class="line">makeRASModel(mykEpsilon); <span class="comment">// 如前篇所属，这个宏函数，先对模板类进行了实例化，然后调用 `addToRunTimeSelectionTable` 宏函数，将实例化模型添加到 hashTable。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------------------------------------------------- //</span></span><br><span class="line"><span class="comment">// LES models</span></span><br><span class="line"><span class="comment">// -------------------------------------------------------------------------- //</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "mySmagorinsky.H"</span></span><br><span class="line">makeLESModel(mySmagorinsky);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Make/files</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">makeTuebulenceModels.C</span><br><span class="line"></span><br><span class="line"><span class="constant">LIB</span> = <span class="variable">$(FOAM_USER_LIBBIN)</span>/libTestincompressibleTurbulenceModels</span><br></pre></td></tr></table></figure>
</li>
<li><p>Make/options</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">EXE_INC = \</span><br><span class="line">    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/<span class="constant">TurbulenceModels</span>/turbulenceModels/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/<span class="constant">TurbulenceModels</span>/incompressible/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/transportModels \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/finiteVolume/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/meshTools/lnInclude \</span><br><span class="line"></span></span><br><span class="line">LIB_LIBS = \</span><br><span class="line">    -<span class="ruby">lincompressibleTransportModels \</span><br><span class="line"></span>    -<span class="ruby">lturbulenceModels \</span><br><span class="line"></span>    -<span class="ruby">lfiniteVolume \</span><br><span class="line"></span>    -<span class="ruby">lmeshTools</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h6 id="3-2_单相可压缩湍流模型">3.2 单相可压缩湍流模型</h6><ul>
<li><p>makeTurbulenceModels.C</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "CompressibleTurbulenceModel.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "compressibleTransportModel.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "fluidThermo.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "addToRunTimeSelectionTable.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "makeTurbulenceModel.H"</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "ThermalDiffusivity.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "EddyDiffusivity.H"</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "RASModel.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "LESModel.H"</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> makeRASModel(Type)                                                     \</span><br><span class="line">    makeTemplatedTurbulenceModel                                               \</span><br><span class="line">    (fluidThermoCompressibleTurbulenceModel, RAS, Type)</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> makeLESModel(Type)                                                     \</span><br><span class="line">    makeTemplatedTurbulenceModel                                               \</span><br><span class="line">    (fluidThermoCompressibleTurbulenceModel, LES, Type)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Foam</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> ThermalDiffusivity&lt;CompressibleTurbulenceModel&lt;fluidThermo&gt; &gt;  fluidThermoCompressibleTurbulenceModel;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> RASModel&lt;EddyDiffusivity&lt;fluidThermoCompressibleTurbulenceModel&gt; &gt;  RASfluidThermoCompressibleTurbulenceModel;       </span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> LESModel&lt;EddyDiffusivity&lt;fluidThermoCompressibleTurbulenceModel&gt; &gt;  LESfluidThermoCompressibleTurbulenceModel;       </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------------------------------------------------- //</span></span><br><span class="line"><span class="comment">// RAS models</span></span><br><span class="line"><span class="comment">// -------------------------------------------------------------------------- //</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "mykEpsilon.H"</span></span><br><span class="line">makeRASModel(mykEpsilon);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "mybuoyantKEpsilon.H"</span></span><br><span class="line">makeRASModel(mybuoyantKEpsilon);</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------------------------------------------------- //</span></span><br><span class="line"><span class="comment">// LES models</span></span><br><span class="line"><span class="comment">// -------------------------------------------------------------------------- //</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "mySmagorinsky.H"</span></span><br><span class="line">makeLESModel(mySmagorinsky);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Make/files</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">makeTurbulenceModels.C</span><br><span class="line"></span><br><span class="line"><span class="constant">LIB</span> = <span class="variable">$(FOAM_USER_LIBBIN)</span>/libTestcompressibleTurbulenceModels</span><br></pre></td></tr></table></figure>
</li>
<li><p>Make/options</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">EXE_INC = \</span><br><span class="line">    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/<span class="constant">TurbulenceModels</span>/compressible/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/<span class="constant">TurbulenceModels</span>/turbulenceModels/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/transportModels/compressible/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/thermophysicalModels/basic/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/thermophysicalModels/specie/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/thermophysicalModels/solidThermo/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/thermophysicalModels/solidSpecie/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/finiteVolume/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/meshTools/lnInclude \</span><br><span class="line"></span></span><br><span class="line">LIB_LIBS = \</span><br><span class="line">    -<span class="ruby">lcompressibleTransportModels \</span><br><span class="line"></span>    -<span class="ruby">lfluidThermophysicalModels \</span><br><span class="line"></span>    -<span class="ruby">lsolidThermo \</span><br><span class="line"></span>    -<span class="ruby">lsolidSpecie \</span><br><span class="line"></span>    -<span class="ruby">lturbulenceModels \</span><br><span class="line"></span>    -<span class="ruby">lspecie \</span><br><span class="line"></span>    -<span class="ruby">lfiniteVolume \</span><br><span class="line"></span>    -<span class="ruby">lmeshTools</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>注意，由于在 <code>TurbulenceModels/compressible/lnInclude</code> 和 <code>TurbulenceModels/turbulenceModels/lnInclude</code> 两个目录下，都存在 <code>makeTurbulenceModel.H</code> 头文件，内容是不一样的，这里需要 include 的是前者，所以在 <code>Make/options</code> 里， <code>TurbulenceModels/compressible/lnInclude</code> 一定要写在前面才能编译成功。</p>
<h6 id="3-3_多相不可压缩湍流模型">3.3 多相不可压缩湍流模型</h6><ul>
<li><p>DPMTurbulenceModels.C</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "PhaseIncompressibleTurbulenceModel.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "singlePhaseTransportModel.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "addToRunTimeSelectionTable.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "makeTurbulenceModel.H"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#include "laminar.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "turbulentTransportModel.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "LESModel.H"</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> makeRASModel(Type)                                                     \</span><br><span class="line">    makeTemplatedTurbulenceModel                                               \</span><br><span class="line">    (singlePhaseTransportModelPhaseIncompressibleTurbulenceModel, RAS, Type)</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> makeLESModel(Type)                                                     \</span><br><span class="line">    makeTemplatedTurbulenceModel                                               \</span><br><span class="line">    (singlePhaseTransportModelPhaseIncompressibleTurbulenceModel, LES, Type)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Foam</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> PhaseIncompressibleTurbulenceModel&lt;singlePhaseTransportModel&gt; singlePhaseTransportModelPhaseIncompressibleTurbulenceModel; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">typedef</span> RASModel&lt;singlePhaseTransportModelPhaseIncompressibleTurbulenceModel&gt; RASsinglePhaseTransportModelPhaseIncompressibleTurbulenceModel;      </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">typedef</span> LESModel&lt;singlePhaseTransportModelPhaseIncompressibleTurbulenceModel&gt; LESsinglePhaseTransportModelPhaseIncompressibleTurbulenceModel;      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "mykEpsilon.H"</span></span><br><span class="line">makeRASModel(mykEpsilon);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "mySmagorinsky.H"</span></span><br><span class="line">makeLESModel(mySmagorinsky);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Make/files</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DPMTurbulenceModels.C</span><br><span class="line"></span><br><span class="line"><span class="constant">LIB</span> = <span class="variable">$(FOAM_USER_LIBBIN)</span>/libTestDPMTurbulenceModels</span><br></pre></td></tr></table></figure>
</li>
<li><p>Make/options</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">EXE_INC = \</span><br><span class="line">    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/transportModels/compressible/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/thermophysicalModels/basic/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/transportModels \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/transportModels/incompressible/singlePhaseTransportModel \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/<span class="constant">TurbulenceModels</span>/turbulenceModels/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/<span class="constant">TurbulenceModels</span>/incompressible/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/<span class="constant">TurbulenceModels</span>/phaseIncompressible/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/finiteVolume/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/meshTools/lnInclude</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>注意，这里的湍流模型是给 <code>DPMFoam</code> 求解器用的，如果要给其他求解器写湍流模型，可能需要做些修改。</p>
<h6 id="3-4_多相可压缩湍流模型">3.4 多相可压缩湍流模型</h6><ul>
<li><p>phaseCompressibleTurbulenceModels.C</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "PhaseCompressibleTurbulenceModel.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "phaseModel.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "twoPhaseSystem.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "addToRunTimeSelectionTable.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "makeTurbulenceModel.H"</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "ThermalDiffusivity.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "EddyDiffusivity.H"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#include "laminar.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "RASModel.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "LESModel.H"</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> makeRASModel(Type)                                                     \</span><br><span class="line">    makeTemplatedTurbulenceModel                                               \</span><br><span class="line">    (phaseModelPhaseCompressibleTurbulenceModel, RAS, Type)</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> makeLESModel(Type)                                                     \</span><br><span class="line">    makeTemplatedTurbulenceModel                                               \</span><br><span class="line">    (phaseModelPhaseCompressibleTurbulenceModel, LES, Type)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Foam</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> ThermalDiffusivity&lt;PhaseCompressibleTurbulenceModel&lt;phaseModel&gt; &gt;  phaseModelPhaseCompressibleTurbulenceModel;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> RASModel&lt;EddyDiffusivity&lt;phaseModelPhaseCompressibleTurbulenceModel&gt; &gt;  RASphaseModelPhaseCompressibleTurbulenceModel;           </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">typedef</span> LESModel&lt;EddyDiffusivity&lt;phaseModelPhaseCompressibleTurbulenceModel&gt; &gt;   LESphaseModelPhaseCompressibleTurbulenceModel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "mykEpsilon.H"</span></span><br><span class="line">makeRASModel(mykEpsilon);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "mySmagorinsky.H"</span></span><br><span class="line">makeLESModel(mySmagorinsky);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "myphasePressureModel.H"</span></span><br><span class="line">makeTurbulenceModel</span><br><span class="line">(phaseModelPhaseCompressibleTurbulenceModel, RAS, myphasePressureModel);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Make/files</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">phaseCompressibleTurbulenceModels<span class="class">.C</span></span><br><span class="line">phasePressureModel/myphasePressureModel<span class="class">.C</span></span><br><span class="line"></span><br><span class="line">LIB = $(FOAM_USER_LIBBIN)/libTestphaseCompressibleTurbulenceModels</span><br></pre></td></tr></table></figure>
</li>
<li><p>Make/options</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">EXE_INC = \</span><br><span class="line">    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">WM_PROJECT_DIR</span>)/applications/solvers/multiphase/twoPhaseEulerFoam/twoPhaseSystem/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">WM_PROJECT_DIR</span>)/applications/solvers/multiphase/twoPhaseEulerFoam/interfacialModels/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/transportModels/compressible/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/thermophysicalModels/basic/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/transportModels/incompressible/transportModel \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/<span class="constant">TurbulenceModels</span>/compressible/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/<span class="constant">TurbulenceModels</span>/turbulenceModels/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/<span class="constant">TurbulenceModels</span>/phaseCompressible/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/finiteVolume/lnInclude \</span><br><span class="line"></span>    -<span class="ruby"><span class="constant">I</span><span class="variable">$(</span><span class="constant">LIB_SRC</span>)/meshTools/lnInclude</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>注意，这里的湍流模型是给求解器 <code>twoPhaseEulerFoam</code> 用的，如果要给其他求解器开发湍流模型，可能需要做些修改。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>有了上一篇的基础，就很容易做到添加新的湍流模型了，这里分别给出对四类湍流模型增加新模型的方法。探索过程不详述了，仅给出结果。</p>]]>
    
    </summary>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="turbulence model" scheme="http://xiaopingqiu.github.io/tags/turbulence-model/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenFOAM-3.0 的湍流模型（二）]]></title>
    <link href="http://xiaopingqiu.github.io/2016/04/24/TurbulenceModel-30-RTS/"/>
    <id>http://xiaopingqiu.github.io/2016/04/24/TurbulenceModel-30-RTS/</id>
    <published>2016-04-24T14:21:52.000Z</published>
    <updated>2016-04-25T02:15:41.650Z</updated>
    <content type="html"><![CDATA[<p>本篇分析 OpenFOAM-3.0 中湍流模型的 RTS 机制。RTS 机制主要是通过调用几个相关的宏函数来实现的，所以，分析 RTS 机制需要将相关的宏函数展开。四类湍流模型，机制是类似的，这里以单相不可压缩湍流模型为例，后文会给出所有其他湍流模型相关的宏函数的展开结果，供读者参考。<br>RTS 机制的基础这里不再重复了，读者若对这里涉及到 RTS 机制的名称感兴趣，可以参考我以前对 RTS 机制的解读。</p>
<a id="more"></a>
<h5 id="2-_RTS_机制">2. RTS 机制</h5><p>单相不可压缩湍流模型类，在 <code>Make/files</code> 文件里包含的其中一个是 <code>src/TurbulenceModels/incompressible/turbulentTransportModels/turbulentTransportModels.C</code> turbulentTransportModels.C，这个文件里包含了一些通用的湍流模型模板类，并调用了一些宏函数来实现 RTS 相关的，这里将宏函数展开看看这个文件究竟实现了怎样的功能。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">makeBaseTurbulenceModel</span><br><span class="line">(</span><br><span class="line">    geometricOneField,</span><br><span class="line">    geometricOneField,</span><br><span class="line">    incompressibleTurbulenceModel,</span><br><span class="line">    IncompressibleTurbulenceModel,</span><br><span class="line">    transportModel</span><br><span class="line">);</span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> makeRASModel(Type)                                                     \</span><br><span class="line">    makeTemplatedTurbulenceModel                                               \</span><br><span class="line">    (transportModelIncompressibleTurbulenceModel, RAS, Type)</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> makeLESModel(Type)                                                     \</span><br><span class="line">    makeTemplatedTurbulenceModel                                               \</span><br><span class="line">    (transportModelIncompressibleTurbulenceModel, LES, Type)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------------------------------------------------- //</span></span><br><span class="line"><span class="comment">// RAS models</span></span><br><span class="line"><span class="comment">// -------------------------------------------------------------------------- //</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "SpalartAllmaras.H"</span></span><br><span class="line">makeRASModel(SpalartAllmaras);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "kEpsilon.H"</span></span><br><span class="line">makeRASModel(kEpsilon);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "RNGkEpsilon.H"</span></span><br><span class="line">makeRASModel(RNGkEpsilon);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "realizableKE.H"</span></span><br><span class="line">makeRASModel(realizableKE);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "LaunderSharmaKE.H"</span></span><br><span class="line">makeRASModel(LaunderSharmaKE);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "kOmega.H"</span></span><br><span class="line">makeRASModel(kOmega);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "kOmegaSST.H"</span></span><br><span class="line">makeRASModel(kOmegaSST);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "kOmegaSSTSAS.H"</span></span><br><span class="line">makeRASModel(kOmegaSSTSAS);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "v2f.H"</span></span><br><span class="line">makeRASModel(v2f);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "LRR.H"</span></span><br><span class="line">makeRASModel(LRR);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "SSG.H"</span></span><br><span class="line">makeRASModel(SSG);</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------------------------------------------------- //</span></span><br><span class="line"><span class="comment">// LES models</span></span><br><span class="line"><span class="comment">// -------------------------------------------------------------------------- //</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "Smagorinsky.H"</span></span><br><span class="line">makeLESModel(Smagorinsky);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "WALE.H"</span></span><br><span class="line">makeLESModel(WALE);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "dynamicLagrangian.H"</span></span><br><span class="line">makeLESModel(dynamicLagrangian);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "kEqn.H"</span></span><br><span class="line">makeLESModel(kEqn);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "dynamicKEqn.H"</span></span><br><span class="line">makeLESModel(dynamicKEqn);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "SpalartAllmarasDES.H"</span></span><br><span class="line">makeLESModel(SpalartAllmarasDES);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "SpalartAllmarasDDES.H"</span></span><br><span class="line">makeLESModel(SpalartAllmarasDDES);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "SpalartAllmarasIDDES.H"</span></span><br><span class="line">makeLESModel(SpalartAllmarasIDDES);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "DeardorffDiffStress.H"</span></span><br><span class="line">makeLESModel(DeardorffDiffStress);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "kOmegaSSTDES.H"</span></span><br><span class="line">makeLESModel(kOmegaSSTDES);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "kOmegaSSTDDES.H"</span></span><br><span class="line">makeLESModel(kOmegaSSTDDES);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "kOmegaSSTIDDES.H"</span></span><br><span class="line">makeLESModel(kOmegaSSTIDDES);</span><br></pre></td></tr></table></figure>
<p>这个宏函数调用<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">makeBaseTurbulenceModel</span><br><span class="line"><span class="list">(</span><br><span class="line">    <span class="keyword">geometricOneField</span>,</span><br><span class="line">    geometricOneField,</span><br><span class="line">    incompressibleTurbulenceModel,</span><br><span class="line">    IncompressibleTurbulenceModel,</span><br><span class="line">    transportModel</span><br><span class="line">)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>展开结果为<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Foam                                                             </span><br><span class="line">&#123;                                                                          </span><br><span class="line">    <span class="keyword">typedef</span> TurbulenceModel                                                </span><br><span class="line">    &lt;                                                                      </span><br><span class="line">        geometricOneField,                                                             </span><br><span class="line">        geometricOneField,                                                               </span><br><span class="line">        incompressibleTurbulenceModel,                                                         </span><br><span class="line">        transportModel                                                          </span><br><span class="line">    &gt; transportModelincompressibleTurbulenceModel;                                                </span><br><span class="line">                                                                           </span><br><span class="line">    defineTemplateRunTimeSelectionTable <span class="comment">// 对TurbulenceModel类中定义的 hashTable 进行了初始化                                    </span></span><br><span class="line">    (                                                                      </span><br><span class="line">        transportModelincompressibleTurbulenceModel,                                              </span><br><span class="line">        dictionary                                                         </span><br><span class="line">    );                                                                     </span><br><span class="line">                                                                           </span><br><span class="line">    <span class="keyword">typedef</span> IncompressibleTurbulenceModel&lt;transportModel&gt; transportModelIncompressibleTurbulenceModel;                     </span><br><span class="line">                                                                           </span><br><span class="line">    <span class="keyword">typedef</span> laminar&lt;transportModelIncompressibleTurbulenceModel&gt; LaminartransportModelIncompressibleTurbulenceModel;   </span><br><span class="line">                                                                           </span><br><span class="line">    defineNamedTemplateTypeNameAndDebug(LaminartransportModelIncompressibleTurbulenceModel, <span class="number">0</span>); </span><br><span class="line">                                                                           </span><br><span class="line">    addToRunTimeSelectionTable   <span class="comment">// 将laminar 模型加到定义在 TurbulenceModel 类中的hashTable                                      </span></span><br><span class="line">    (                                                                      </span><br><span class="line">        transportModelincompressibleTurbulenceModel,                                              </span><br><span class="line">        LaminartransportModelIncompressibleTurbulenceModel,                                     </span><br><span class="line">        dictionary                                                         </span><br><span class="line">    );                                                                     </span><br><span class="line">                                                                           </span><br><span class="line">    <span class="keyword">typedef</span> RASModel&lt;transportModelIncompressibleTurbulenceModel&gt; RAStransportModelIncompressibleTurbulenceModel;      </span><br><span class="line">    </span><br><span class="line">    defineNamedTemplateTypeNameAndDebug(RAStransportModelIncompressibleTurbulenceModel, <span class="number">0</span>);     </span><br><span class="line"></span><br><span class="line">     <span class="comment">// 对 RASModel类中定义的hashTable进行了初始化                          </span></span><br><span class="line">    defineTemplateRunTimeSelectionTable                                    </span><br><span class="line">    (RAStransportModelIncompressibleTurbulenceModel, dictionary);                               </span><br><span class="line">    <span class="comment">// 将 RASModel 添加到 TurbulenceModel 中定义的hashTable                         </span></span><br><span class="line">    addToRunTimeSelectionTable                                             </span><br><span class="line">    (                                                                      </span><br><span class="line">        transportModelincompressibleTurbulenceModel,                                              </span><br><span class="line">        RAStransportModelIncompressibleTurbulenceModel,                                         </span><br><span class="line">        dictionary                                                         </span><br><span class="line">    );                                                                     </span><br><span class="line">                                                                           </span><br><span class="line">    <span class="keyword">typedef</span> LESModel&lt;transportModelIncompressibleTurbulenceModel&gt; LEStransportModelIncompressibleTurbulenceModel;      </span><br><span class="line">                                                                           </span><br><span class="line">    defineNamedTemplateTypeNameAndDebug(LEStransportModelIncompressibleTurbulenceModel, <span class="number">0</span>);     </span><br><span class="line">    </span><br><span class="line">     <span class="comment">// 对LESModel类中定义的hashTable进行了初始化</span></span><br><span class="line">    defineTemplateRunTimeSelectionTable                                    </span><br><span class="line">    (LEStransportModelIncompressibleTurbulenceModel, dictionary);                               </span><br><span class="line">    <span class="comment">// 将 LESModel 添加到 TurbulenceModel 中定义的hashTable                   </span></span><br><span class="line">    addToRunTimeSelectionTable                                             </span><br><span class="line">    (                                                                      </span><br><span class="line">        transportModelincompressibleTurbulenceModel,                                              </span><br><span class="line">        LEStransportModelIncompressibleTurbulenceModel,                                         </span><br><span class="line">        dictionary                                                         </span><br><span class="line">    );                                                                     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>makeRASModel(SpalartAllmaras)</code> 展开结果为<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">makeTemplatedTurbulenceModel </span><br><span class="line"> <span class="list">(<span class="keyword">transportModelIncompressibleTurbulenceModel</span>, RAS, SpalartAllmaras)</span></span><br></pre></td></tr></table></figure></p>
<p>继续展开结果为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">defineNamedTemplateTypeNameAndDebug                      </span><br><span class="line">    (Foam::RASModels::SpalartAllmaras&lt;Foam::transportModelIncompressibleTurbulenceModel&gt;, <span class="number">0</span>);     </span><br><span class="line">                                                         </span><br><span class="line"><span class="keyword">namespace</span> Foam                                           </span><br><span class="line">&#123;                                                        </span><br><span class="line">    <span class="keyword">namespace</span> RASModels                              </span><br><span class="line">    &#123;                                                    </span><br><span class="line">        <span class="keyword">typedef</span> SpalartAllmaras&lt;transportModelIncompressibleTurbulenceModel&gt; SpalartAllmarasRAStransportModelIncompressibleTurbulenceModel;  </span><br><span class="line">                                                         </span><br><span class="line">	<span class="comment">// 将 SpalartAllmaras 模型添加到 RASModel 中定义的 hashTable</span></span><br><span class="line">        addToRunTimeSelectionTable                       </span><br><span class="line">        (                                                </span><br><span class="line">            RAStransportModelIncompressibleTurbulenceModel,                            </span><br><span class="line">            SpalartAllmarasRAStransportModelIncompressibleTurbulenceModel,                      </span><br><span class="line">            dictionary                                   </span><br><span class="line">        );                                               </span><br><span class="line">    &#125;                                                    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>makeLESModel(Smagorinsky)</code> 展开结果为<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">makeTemplatedTurbulenceModel </span><br><span class="line"> <span class="list">(<span class="keyword">transportModelIncompressibleTurbulenceModel</span>, LES, Smagorinsky)</span></span><br></pre></td></tr></table></figure></p>
<p>继续展开结果为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">defineNamedTemplateTypeNameAndDebug                      </span><br><span class="line">    (Foam::LESModels::Smagorinsky&lt;Foam::transportModelIncompressibleTurbulenceModel&gt;, <span class="number">0</span>);     </span><br><span class="line">                                                         </span><br><span class="line"><span class="keyword">namespace</span> Foam                                           </span><br><span class="line">&#123;                                                        </span><br><span class="line">    <span class="keyword">namespace</span> LESModels                              </span><br><span class="line">    &#123;                                                    </span><br><span class="line">        <span class="keyword">typedef</span> Smagorinsky&lt;transportModelIncompressibleTurbulenceModel&gt; SmagorinskyLEStransportModelIncompressibleTurbulenceModel;  </span><br><span class="line">                                                         </span><br><span class="line">	<span class="comment">// 将 Smagorinsky 模型添加到 LESModel 中定义的hashTable</span></span><br><span class="line">        addToRunTimeSelectionTable                       </span><br><span class="line">        (                                                </span><br><span class="line">            LEStransportModelIncompressibleTurbulenceModel,                            </span><br><span class="line">            SmagorinskyLEStransportModelIncompressibleTurbulenceModel,                      </span><br><span class="line">            dictionary                                   </span><br><span class="line">        );                                               </span><br><span class="line">    &#125;                                                    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，这里给 <code>kEpsilon</code> 和 <code>Smagorinsky</code> 模型代入的模板参数是 <code>transportModelIncompressibleTurbulenceModel</code>，即 <code>IncompressibleTurbulenceModel&lt;transportModel&gt;</code>。</p>
<p>上面给出了单相不可压缩湍流模型是如何添加到各自该所属的 hashTable 里的。接着，以单相不可压缩模型为例，看看湍流模型的调用过程。<br>在 <code>pisoFoam</code> 求解器中，湍流模型接口的定义如下<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">autoPtr&lt;<span class="symbol">incompressible:</span><span class="symbol">:turbulenceModel&gt;</span> turbulence</span><br><span class="line">(</span><br><span class="line">    <span class="symbol">incompressible:</span><span class="symbol">:turbulenceModel</span><span class="symbol">:</span><span class="symbol">:New</span>(<span class="constant">U,</span> phi, laminarTransport)</span><br><span class="line">);</span><br><span class="line"><span class="regexp">//</span> laminarTransport 是 singlePhaseTransportModel 的一个对象</span><br></pre></td></tr></table></figure></p>
<p><code>incompressible::turbulenceModel</code> 是 <code>IncompressibleTurbulenceModel&lt;transportModel&gt;</code> 的别名。<br>这里调用的是 <code>IncompressibleTurbulenceModel</code> 类的 <code>New</code> 函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> TransportModel&gt;</span><br><span class="line">Foam::autoPtr&lt;Foam::IncompressibleTurbulenceModel&lt;TransportModel&gt; &gt;</span><br><span class="line">Foam::IncompressibleTurbulenceModel&lt;TransportModel&gt;::New</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> volVectorField&amp; U,</span><br><span class="line">    <span class="keyword">const</span> surfaceScalarField&amp; phi,</span><br><span class="line">    <span class="keyword">const</span> TransportModel&amp; transport,</span><br><span class="line">    <span class="keyword">const</span> word&amp; propertiesName</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> autoPtr&lt;IncompressibleTurbulenceModel&gt;</span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;IncompressibleTurbulenceModel*&gt;(</span><br><span class="line">        TurbulenceModel</span><br><span class="line">        &lt;</span><br><span class="line">            geometricOneField,</span><br><span class="line">            geometricOneField,</span><br><span class="line">            incompressibleTurbulenceModel,</span><br><span class="line">            TransportModel</span><br><span class="line">        &gt;::New</span><br><span class="line">        (</span><br><span class="line">            geometricOneField(),</span><br><span class="line">            geometricOneField(),</span><br><span class="line">            U,</span><br><span class="line">            phi,</span><br><span class="line">            phi,</span><br><span class="line">            transport,</span><br><span class="line">            propertiesName</span><br><span class="line">        ).ptr())</span><br><span class="line">    );</span><br></pre></td></tr></table></figure></p>
<p>返回的是 <code>TurbulenceModel</code> 类的 <code>New</code> 函数。<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">template</span><br><span class="line">&lt;</span><br><span class="line">    <span class="keyword">class</span> <span class="keyword">Alpha</span>,</span><br><span class="line">    <span class="keyword">class</span> Rho,</span><br><span class="line">    <span class="keyword">class</span> BasicTurbulenceModel,</span><br><span class="line">    <span class="keyword">class</span> TransportModel</span><br><span class="line">&gt;</span><br><span class="line">Foam::autoPtr</span><br><span class="line">&lt;</span><br><span class="line">    Foam::TurbulenceModel&lt;<span class="keyword">Alpha</span>, Rho, BasicTurbulenceModel, TransportModel&gt;</span><br><span class="line">&gt;</span><br><span class="line">Foam::TurbulenceModel&lt;<span class="keyword">Alpha</span>, Rho, BasicTurbulenceModel, TransportModel&gt;::New</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> alphaField&amp; <span class="keyword">alpha</span>,</span><br><span class="line">    <span class="keyword">const</span> rhoField&amp; rho,</span><br><span class="line">    <span class="keyword">const</span> volVectorField&amp; <span class="keyword">U</span>,</span><br><span class="line">    <span class="keyword">const</span> surfaceScalarField&amp; alphaRhoPhi,</span><br><span class="line">    <span class="keyword">const</span> surfaceScalarField&amp; phi,</span><br><span class="line">    <span class="keyword">const</span> transportModel&amp; transport,</span><br><span class="line">    <span class="keyword">const</span> word&amp; propertiesName</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// get model name, but do not register the dictionary</span></span><br><span class="line">    <span class="comment">// otherwise it is registered in the database twice</span></span><br><span class="line">    <span class="keyword">const</span> word modelType</span><br><span class="line">    (</span><br><span class="line">        IOdictionary</span><br><span class="line">        (</span><br><span class="line">            IOobject</span><br><span class="line">            (</span><br><span class="line">                IOobject::groupName(propertiesName, <span class="keyword">U</span>.<span class="literal">group</span>()),</span><br><span class="line">                <span class="keyword">U</span>.time().constant(),</span><br><span class="line">                <span class="keyword">U</span>.<span class="keyword">db</span>(),</span><br><span class="line">                IOobject::MUST_READ_IF_MODIFIED,</span><br><span class="line">                IOobject::NO_WRITE,</span><br><span class="line">                false</span><br><span class="line">            )</span><br><span class="line">        ).<span class="keyword">lookup</span>(<span class="string">"simulationType"</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    Info&lt;&lt; <span class="string">"Selecting turbulence model type "</span> &lt;&lt; modelType &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    typename dictionaryConstructorTable::iterator cstrIter =</span><br><span class="line">        dictionaryConstructorTablePtr_-&gt;find(modelType);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cstrIter == dictionaryConstructorTablePtr_-&gt;end())</span><br><span class="line">    &#123;</span><br><span class="line">        FatalErrorInFunction</span><br><span class="line">            &lt;&lt; <span class="string">"Unknown TurbulenceModel type "</span></span><br><span class="line">            &lt;&lt; modelType &lt;&lt; <span class="keyword">nl</span> &lt;&lt; <span class="keyword">nl</span></span><br><span class="line">            &lt;&lt; <span class="string">"Valid TurbulenceModel types:"</span> &lt;&lt; endl</span><br><span class="line">            &lt;&lt; dictionaryConstructorTablePtr_-&gt;sortedToc()</span><br><span class="line">            &lt;&lt; <span class="keyword">exit</span>(FatalError);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> autoPtr&lt;TurbulenceModel&gt;</span><br><span class="line">    (</span><br><span class="line">        cstrIter()(<span class="keyword">alpha</span>, rho, <span class="keyword">U</span>, alphaRhoPhi, phi, transport, propertiesName)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里通过读取 <code>turbulenceProperties</code> 文件，查找关键字 <code>simulationType</code>（只能是 <code>RAS</code> 或  <code>LES</code> ），并据此从定义在 <code>TurbulenceModel</code> 类中 hashTable 中找对应的模型，然后返回的模型（可能是 <code>RAStransportModelIncompressibleTurbulenceModel</code>， <code>RASfluidThermoCompressibleTurbulenceModel</code>， <code>RASsinglePhaseTransportModelPhaseIncompressibleTurbulenceModel</code>， <code>RASphaseModelPhaseCompressibleTurbulenceModel</code>）的 <code>New</code> 函数<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">template&lt;<span class="keyword">class</span> BasicTurbulenceModel&gt;</span><br><span class="line">Foam::autoPtr&lt;Foam::RASModel&lt;BasicTurbulenceModel&gt; &gt;</span><br><span class="line">Foam::RASModel&lt;BasicTurbulenceModel&gt;::New</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> alphaField&amp; <span class="keyword">alpha</span>,</span><br><span class="line">    <span class="keyword">const</span> rhoField&amp; rho,</span><br><span class="line">    <span class="keyword">const</span> volVectorField&amp; <span class="keyword">U</span>,</span><br><span class="line">    <span class="keyword">const</span> surfaceScalarField&amp; alphaRhoPhi,</span><br><span class="line">    <span class="keyword">const</span> surfaceScalarField&amp; phi,</span><br><span class="line">    <span class="keyword">const</span> transportModel&amp; transport,</span><br><span class="line">    <span class="keyword">const</span> word&amp; propertiesName</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// get model name, but do not register the dictionary</span></span><br><span class="line">    <span class="comment">// otherwise it is registered in the database twice</span></span><br><span class="line">    <span class="keyword">const</span> word modelType</span><br><span class="line">    (</span><br><span class="line">        IOdictionary</span><br><span class="line">        (</span><br><span class="line">            IOobject</span><br><span class="line">            (</span><br><span class="line">                IOobject::groupName(propertiesName, <span class="keyword">U</span>.<span class="literal">group</span>()),</span><br><span class="line">                <span class="keyword">U</span>.time().constant(),</span><br><span class="line">                <span class="keyword">U</span>.<span class="keyword">db</span>(),</span><br><span class="line">                IOobject::MUST_READ_IF_MODIFIED,</span><br><span class="line">                IOobject::NO_WRITE,</span><br><span class="line">                false</span><br><span class="line">            )</span><br><span class="line">        ).subDict(<span class="string">"RAS"</span>).<span class="keyword">lookup</span>(<span class="string">"RASModel"</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    Info&lt;&lt; <span class="string">"Selecting RAS turbulence model "</span> &lt;&lt; modelType &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    typename dictionaryConstructorTable::iterator cstrIter =</span><br><span class="line">        dictionaryConstructorTablePtr_-&gt;find(modelType);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cstrIter == dictionaryConstructorTablePtr_-&gt;end())</span><br><span class="line">    &#123;</span><br><span class="line">        FatalErrorInFunction</span><br><span class="line">            &lt;&lt; <span class="string">"Unknown RASModel type "</span></span><br><span class="line">            &lt;&lt; modelType &lt;&lt; <span class="keyword">nl</span> &lt;&lt; <span class="keyword">nl</span></span><br><span class="line">            &lt;&lt; <span class="string">"Valid RASModel types:"</span> &lt;&lt; endl</span><br><span class="line">            &lt;&lt; dictionaryConstructorTablePtr_-&gt;sortedToc()</span><br><span class="line">            &lt;&lt; <span class="keyword">exit</span>(FatalError);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> autoPtr&lt;RASModel&gt;</span><br><span class="line">    (</span><br><span class="line">        cstrIter()(<span class="keyword">alpha</span>, rho, <span class="keyword">U</span>, alphaRhoPhi, phi, transport, propertiesName)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个 <code>New</code> 函数中需要读取 <code>RAS</code> 子字典，从中读取 <code>RASModel</code> 关键字，并据此从定义在 <code>RASModel</code> 类中的 hashTable 中查找到对应的湍流模型，并返回湍流模型的构造函数<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> return autoPtr&lt;RASModel&gt;</span><br><span class="line"><span class="list">(</span><br><span class="line">    <span class="keyword">cstrIter</span><span class="list">()</span><span class="list">(<span class="keyword">alpha</span>, rho, U, alphaRhoPhi, phi, transport, propertiesName)</span></span><br><span class="line">)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>其他三类湍流模型，机制是类似的，这里不再详述，仅给出三个链接，供大家参考：<a href="http://www.evernote.com/l/AYvnAYRFNFNM-bJC82rVLGiBybePgFNMF4o/" target="_blank" rel="external">单相可压缩湍流模型</a>，<a href="http://www.evernote.com/l/AYsCXim6tA9DuYjdWDxPSTmltaMig6GIl5A/" target="_blank" rel="external">多相不可压缩湍流模型</a>，<a href="http://www.evernote.com/l/AYuP9x_D59FCPbFXFTY97LbV__jBebUzW8A/" target="_blank" rel="external">多相可压缩湍流模型</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本篇分析 OpenFOAM-3.0 中湍流模型的 RTS 机制。RTS 机制主要是通过调用几个相关的宏函数来实现的，所以，分析 RTS 机制需要将相关的宏函数展开。四类湍流模型，机制是类似的，这里以单相不可压缩湍流模型为例，后文会给出所有其他湍流模型相关的宏函数的展开结果，供读者参考。<br>RTS 机制的基础这里不再重复了，读者若对这里涉及到 RTS 机制的名称感兴趣，可以参考我以前对 RTS 机制的解读。</p>]]>
    
    </summary>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="RTS" scheme="http://xiaopingqiu.github.io/tags/RTS/"/>
    
      <category term="turbulence model" scheme="http://xiaopingqiu.github.io/tags/turbulence-model/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenFOAM-3.0 的湍流模型（一）]]></title>
    <link href="http://xiaopingqiu.github.io/2016/04/24/TurbulenceModel-30-structure/"/>
    <id>http://xiaopingqiu.github.io/2016/04/24/TurbulenceModel-30-structure/</id>
    <published>2016-04-24T13:35:17.000Z</published>
    <updated>2016-04-24T14:38:56.963Z</updated>
    <content type="html"><![CDATA[<p>本系列分析 OpenFOAM-3.0 版本的湍流模型。从 3.0 版开始，OpenFOAM 中的湍流模型架构发生了较大的变化，其实这种变化在 2.3 版开始已经初露端倪，在 2.3 版里，多相流的湍流模型已经开始跟单相流湍流模型分开。从 3.0 开始，单相流湍流模型和多相流湍流模型统一到了一个架构下。本系列将对 3.0 版的湍流模型进行详细的分析，分为四部分：结构概览，RTS 机制分析，编译新模型的方法，以及一些补充说明。</p>
<a id="more"></a>
<h5 id="1-_结构概览">　1.  结构概览</h5><p>这部分主要是概括一下湍流模型的框架的结构，如下图（请点击右键查看大图）：</p>
<p><img src="/image/turbulenceModel/turbulenceModel-3.0.png" alt="湍流模型的架构"></p>
<p>图片中，蓝色字体的是类名，绿框中的类是调用 <code>declareRunTimeSeclectionTable</code> 的类（如果对这个的含义感兴趣，建议参考<a href="http://xiaopingqiu.github.io/2016/03/12/RTS1/" target="_blank" rel="external">这篇</a>或者<a href="http://www.sourceflux.de/blog/run-time-type-selection-openfoam-selecting-types-based-type-name/" target="_blank" rel="external">这篇</a>），四种不同颜色的箭头，代表的是四种不同的湍流模型：单相不可压缩湍流模型，单相可压缩湍流模型，多相不可压缩模型，多相可压缩模型。</p>
<p>在图片下面，我用了一个 <code>kEpsilon</code> 和一个 <code>Smagorinsky</code> 模型作为示例，这是因为，这两个湍流模型都是以通用形式来实现的，从 C++ 角度来说，就是模板类。通过代入不同的模板参数， <code>kEpsilon</code> 和 <code>Smagorinsky</code> 这两个模板类可以实例化为不同种类的湍流模型。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">template</span>&lt;<span class="keyword">class</span> <span class="type">BasicTurbulenceModel</span>&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> kEpsilon</span><br><span class="line">:</span><br><span class="line">    public eddyViscosity&lt;<span class="type">RASModel</span>&lt;<span class="type">BasicTurbulenceModel</span>&gt; &gt;</span><br><span class="line">&#123;</span><br><span class="line">    // <span class="type">Private</span> <span class="type">Member</span> <span class="type">Functions</span></span><br><span class="line"></span><br><span class="line">        // <span class="type">Disallow</span> default bitwise copy construct and assignment</span><br><span class="line">        kEpsilon<span class="container">(<span class="title">const</span> <span class="title">kEpsilon</span>&amp;)</span>;</span><br><span class="line">        kEpsilon&amp; operator=<span class="container">(<span class="title">const</span> <span class="title">kEpsilon</span>&amp;)</span>;</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line"> tmp&lt;fvScalarMatrix&gt; epsEqn</span><br><span class="line">    <span class="container">(</span><br><span class="line">        <span class="title">fvm</span>::<span class="title">ddt</span>(<span class="title">alpha</span>, <span class="title">rho</span>, <span class="title">epsilon_</span>)</span></span><br><span class="line">      + fvm::div<span class="container">(<span class="title">alphaRhoPhi</span>, <span class="title">epsilon_</span>)</span></span><br><span class="line">      - fvm::laplacian<span class="container">(<span class="title">alpha</span>*<span class="title">rho</span>*<span class="type">DepsilonEff</span>()</span>, epsilon_)</span><br><span class="line">     ==</span><br><span class="line">        <span class="type">C1_</span>*alpha*rho*<span class="type">G</span>*epsilon_/k_</span><br><span class="line">      - fvm::<span class="type">SuSp</span><span class="container">(((2.0/3.0)</span>*<span class="type">C1_</span> + <span class="type">C3_</span>)*alpha*rho*divU, epsilon_)</span><br><span class="line">      - fvm::<span class="type">Sp</span><span class="container">(<span class="type">C2_</span>*<span class="title">alpha</span>*<span class="title">rho</span>*<span class="title">epsilon_</span>/<span class="title">k_</span>, <span class="title">epsilon_</span>)</span></span><br><span class="line">      + epsilonSource<span class="container">()</span></span><br><span class="line">      + fvOptions<span class="container">(<span class="title">alpha</span>, <span class="title">rho</span>, <span class="title">epsilon_</span>)</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    epsEqn<span class="container">()</span>.relax<span class="container">()</span>;</span><br><span class="line">    fvOptions.constrain<span class="container">(<span class="title">epsEqn</span>()</span>);</span><br><span class="line">    epsEqn<span class="container">()</span>.boundaryManipulate<span class="container">(<span class="title">epsilon_</span>.<span class="title">boundaryField</span>()</span>);</span><br><span class="line">    solve<span class="container">(<span class="title">epsEqn</span>)</span>;</span><br><span class="line">    fvOptions.correct<span class="container">(<span class="title">epsilon_</span>)</span>;</span><br><span class="line">    bound<span class="container">(<span class="title">epsilon_</span>, <span class="title">this</span>-&gt;<span class="title">epsilonMin_</span>)</span>;</span><br><span class="line"></span><br><span class="line">    // <span class="type">Turbulent</span> kinetic energy equation</span><br><span class="line">    tmp&lt;fvScalarMatrix&gt; kEqn</span><br><span class="line">    <span class="container">(</span><br><span class="line">        <span class="title">fvm</span>::<span class="title">ddt</span>(<span class="title">alpha</span>, <span class="title">rho</span>, <span class="title">k_</span>)</span></span><br><span class="line">      + fvm::div<span class="container">(<span class="title">alphaRhoPhi</span>, <span class="title">k_</span>)</span></span><br><span class="line">      - fvm::laplacian<span class="container">(<span class="title">alpha</span>*<span class="title">rho</span>*<span class="type">DkEff</span>()</span>, k_)</span><br><span class="line">     ==</span><br><span class="line">        alpha*rho*<span class="type">G</span></span><br><span class="line">      - fvm::<span class="type">SuSp</span><span class="container">((2.0/3.0)</span>*alpha*rho*divU, k_)</span><br><span class="line">      - fvm::<span class="type">Sp</span><span class="container">(<span class="title">alpha</span>*<span class="title">rho</span>*<span class="title">epsilon_</span>/<span class="title">k_</span>, <span class="title">k_</span>)</span></span><br><span class="line">      + kSource<span class="container">()</span></span><br><span class="line">      + fvOptions<span class="container">(<span class="title">alpha</span>, <span class="title">rho</span>, <span class="title">k_</span>)</span></span><br><span class="line">    );</span></span><br></pre></td></tr></table></figure></p>
<p>从上述代码可以看出，输运方程中带入了密度 <code>rho</code> 和代表相体积分率的 <code>alpha</code> 。代入不同的模板参数， <code>rho</code> 和 <code>alpha</code> 的取值也会不同，从而实例化为不同的湍流模型，详细的后文还会分析。除此之外，输运方程中还加入了两种源项的实现，一种是以成员函数的形式（ <code>epsilonSource()</code> 和 <code>kEpsilon()</code> ）；另一种是以 <code>fvOptions</code> 的形式，允许用户自定义源项。</p>
<p>在这个架构下，湍流模型是怎么通过 RTS 机制来进行选择的呢？请看下一篇。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本系列分析 OpenFOAM-3.0 版本的湍流模型。从 3.0 版开始，OpenFOAM 中的湍流模型架构发生了较大的变化，其实这种变化在 2.3 版开始已经初露端倪，在 2.3 版里，多相流的湍流模型已经开始跟单相流湍流模型分开。从 3.0 开始，单相流湍流模型和多相流湍流模型统一到了一个架构下。本系列将对 3.0 版的湍流模型进行详细的分析，分为四部分：结构概览，RTS 机制分析，编译新模型的方法，以及一些补充说明。</p>]]>
    
    </summary>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="turbulence model" scheme="http://xiaopingqiu.github.io/tags/turbulence-model/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenFOAM 中的边界条件（四）]]></title>
    <link href="http://xiaopingqiu.github.io/2016/04/02/Boundary-conditions-in-OpenFOAM4/"/>
    <id>http://xiaopingqiu.github.io/2016/04/02/Boundary-conditions-in-OpenFOAM4/</id>
    <published>2016-04-02T10:16:39.000Z</published>
    <updated>2016-04-03T03:42:14.824Z</updated>
    <content type="html"><![CDATA[<h4 id="JohnsonJackson_边界条件">JohnsonJackson 边界条件</h4><p>本篇来看用于气固两相流模拟的 JohnsonJackson 边界条件。这组边界条件用于设定双流体模型中固相在壁面的速度和颗粒温度。根据 <a href="http://www.sciencedirect.com/science/article/pii/S0009250908003904" target="_blank" rel="external">N. Reuge 2008, CES</a>，壁面上的固相速度和颗粒温度可以表示为：<br><img src="/image/boundaryConditions/JJ.png" alt="JohnsonJackson boundary conditions"><br>其中，$u_m$ 指的是 m 相在壁面切向上的滑移速度。<br>下面来看 OpenFOAM 中对这两个边界条件的实现</p>
<a id="more"></a>
<p>在看 JohnsonJackson 边界条件之前，先要看一下 <code>partialSlip</code> 边界。</p>
<h5 id="partialSlip">partialSlip</h5><p><code>partialSlipFvPatchField</code> 继承自 <code>transformFvPatchField</code><br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line">class partialSlipFvPatchField</span><br><span class="line">:</span><br><span class="line">    public transformFvPatchField&lt;<span class="type">Type</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    // <span class="type">Private</span> data</span><br><span class="line"></span><br><span class="line">        //- <span class="type">Fraction</span> (<span class="number">0</span>-<span class="number">1</span>) <span class="keyword">of</span> value used <span class="keyword">for</span> boundary condition</span><br><span class="line">        scalarField valueFraction_;</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其定义了一个标量形式的 <code>valueFraction_</code> 。</p>
<ul>
<li>evaluate 函数<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">template<span class="subst">&lt;</span>class <span class="keyword">Type</span><span class="subst">&gt;</span></span><br><span class="line"><span class="literal">void</span> Foam<span class="tag">::partialSlipFvPatchField</span><span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::evaluate</span></span><br><span class="line">(</span><br><span class="line">    const Pstream<span class="tag">::commsTypes</span></span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="subst">!</span>this<span class="subst">-&gt;</span>updated())</span><br><span class="line">    &#123;</span><br><span class="line">        this<span class="subst">-&gt;</span>updateCoeffs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tmp<span class="subst">&lt;</span>vectorField<span class="subst">&gt;</span> nHat <span class="subst">=</span> this<span class="subst">-&gt;</span>patch()<span class="built_in">.</span>nf();</span><br><span class="line"></span><br><span class="line">    Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::operator</span><span class="subst">=</span></span><br><span class="line">    (</span><br><span class="line">        (<span class="number">1.0</span> <span class="subst">-</span> valueFraction_)</span><br><span class="line">       <span class="subst">*</span>transform(I <span class="subst">-</span> sqr(nHat), this<span class="subst">-&gt;</span>patchInternalField())</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    transformFvPatchField<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::evaluate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>与 <code>basicSymmetry</code> 相比，只是多了一项 <code>1.0 - valueFraction_</code> 。当 <code>valueFraction_ = 0</code> 时，其与 <code>basicSymmetry</code> 是一样的。</p>
<ul>
<li>snGradTransformDiag<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Type&gt;</span><br><span class="line">Foam::tmp&lt;Foam::Field&lt;Type&gt; &gt;</span><br><span class="line">Foam::partialSlipFvPatchField&lt;Type&gt;::snGradTransformDiag() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> vectorField <span class="title">nHat</span><span class="params">(<span class="keyword">this</span>-&gt;patch()</span>.<span class="title">nf</span><span class="params">()</span>)</span>;</span><br><span class="line">    <span class="function">vectorField <span class="title">diag</span><span class="params">(nHat.size()</span>)</span>;</span><br><span class="line"></span><br><span class="line">    diag.replace(<span class="built_in">vector</span>::X, mag(nHat.component(<span class="built_in">vector</span>::X)));</span><br><span class="line">    diag.replace(<span class="built_in">vector</span>::Y, mag(nHat.component(<span class="built_in">vector</span>::Y)));</span><br><span class="line">    diag.replace(<span class="built_in">vector</span>::Z, mag(nHat.component(<span class="built_in">vector</span>::Z)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        valueFraction_*pTraits&lt;Type&gt;::one</span><br><span class="line">      + (<span class="number">1.0</span> - valueFraction_)</span><br><span class="line">       *transformFieldMask&lt;Type&gt;(<span class="built_in">pow</span>&lt;<span class="built_in">vector</span>, pTraits&lt;Type&gt;::rank&gt;(diag));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>当 <code>valueFraction_ = 0</code> 时，这里的返回值与 <code>basicSymmetry</code> 也是一样的。</p>
<ul>
<li>snGrad<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class <span class="constant">Type&gt;</span></span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:tmp&lt;Foam</span><span class="symbol">:</span><span class="symbol">:Field&lt;Type&gt;</span> &gt;</span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:partialSlipFvPatchField&lt;Type&gt;</span><span class="symbol">:</span><span class="symbol">:snGrad</span>() const</span><br><span class="line">&#123;</span><br><span class="line">    tmp&lt;vectorField&gt; nHat = this-&gt;patch().nf();</span><br><span class="line">    const <span class="constant">Field&lt;Type&gt;</span> pif(this-&gt;patchInternalField());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    (</span><br><span class="line">        (<span class="number">1.0</span> - valueFraction<span class="constant">_</span>)*transform(<span class="constant">I </span>- sqr(nHat), pif) - pif</span><br><span class="line">    )*this-&gt;patch().deltaCoeffs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><a href="http://cfd.direct/openfoam/user-guide/boundaries/" target="_blank" rel="external">User guide</a> 里说这个边界是 <code>slip</code> 和 <code>zeroGradient</code> 的混合。 <code>valueFraction_ = 0</code> 时， <code>partialSlip</code> 与 <code>slip</code> 等价，这一点上面说明了。不过， 另一个极端，<code>valueFraction_ = 1</code> 时，却似乎不是跟 <code>zeroGradient</code> 等价。至少， <code>evaluate</code> 函数在<code>valueFraction_ = 1</code> 时与 <code>zeroGradient</code> 中的是不一样的。</p>
<p>这里提到了 <code>slip</code> 这个边界，顺便再说一下， <code>slip</code> 边界继承自 <code>basicSymmetry</code> ，而且没有增加任何新的定义，所以， <code>slip</code> 与  <code>basicSymmetry</code> 的效果是等价的。对于标量， <code>slip</code> 与 <code>zeroGradient</code> 一样；对于矢量，以速度为例， <code>slip</code> 定义的边界上的速度值等于边界所属网格的速度的平行边界的分量，即<br>$$<br>u_p = u_C - (\mathbf{I}-\overrightarrow{n} \otimes \overrightarrow{n})\cdot u_C<br>$$</p>
<h5 id="JohnsonJacksonParticleSlip">JohnsonJacksonParticleSlip</h5><p>这个边界条件继承自 <code>partialSlip</code>，在此基础上额外定义了镜面反弹系数 <code>specularityCoefficient_</code> 。代码的核心在 <code>updateCoeffs</code> 函数<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Foam::JohnsonJacksonParticleSlipFvPatchVectorField::updateCoeffs()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (updated())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lookup the fluid model and the phase</span></span><br><span class="line">    <span class="keyword">const</span> twoPhaseSystem&amp; fluid = db().lookupObject&lt;twoPhaseSystem&gt;</span><br><span class="line">    (</span><br><span class="line">        <span class="string">"phaseProperties"</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> phaseModel&amp; phased</span><br><span class="line">    (</span><br><span class="line">        fluid.phase1().name() == dimensionedInternalField().group()</span><br><span class="line">      ? fluid.phase1()</span><br><span class="line">      : fluid.phase2()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lookup all the fields on this patch</span></span><br><span class="line">    <span class="keyword">const</span> fvPatchScalarField&amp; alpha</span><br><span class="line">    (</span><br><span class="line">        patch().lookupPatchField&lt;volScalarField, scalar&gt;</span><br><span class="line">        (</span><br><span class="line">            phased.volScalarField::name()</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> fvPatchScalarField&amp; gs0</span><br><span class="line">    (</span><br><span class="line">        patch().lookupPatchField&lt;volScalarField, scalar&gt;</span><br><span class="line">        (</span><br><span class="line">            IOobject::groupName(<span class="string">"gs0"</span>, phased.name())</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> scalarField nu</span><br><span class="line">    (</span><br><span class="line">        patch().lookupPatchField&lt;volScalarField, scalar&gt;</span><br><span class="line">        (</span><br><span class="line">            IOobject::groupName(<span class="string">"nut"</span>, phased.name())</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    word ThetaName(IOobject::groupName(<span class="string">"Theta"</span>, phased.name()));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> fvPatchScalarField&amp; Theta</span><br><span class="line">    (</span><br><span class="line">        db().foundObject&lt;volScalarField&gt;(ThetaName)</span><br><span class="line">      ? patch().lookupPatchField&lt;volScalarField, scalar&gt;(ThetaName)</span><br><span class="line">      : alpha</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lookup the packed volume fraction</span></span><br><span class="line">    dimensionedScalar alphaMax</span><br><span class="line">    (</span><br><span class="line">        <span class="string">"alphaMax"</span>,</span><br><span class="line">        dimless,</span><br><span class="line">        db()</span><br><span class="line">       .lookupObject&lt;IOdictionary&gt;</span><br><span class="line">        (</span><br><span class="line">            IOobject::groupName(<span class="string">"turbulenceProperties"</span>, phased.name())</span><br><span class="line">        )</span><br><span class="line">       .subDict(<span class="string">"RAS"</span>)</span><br><span class="line">       .subDict(<span class="string">"kineticTheoryCoeffs"</span>)</span><br><span class="line">       .lookup(<span class="string">"alphaMax"</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// calculate the slip value fraction</span></span><br><span class="line">    scalarField c</span><br><span class="line">    (</span><br><span class="line">        constant::mathematical::pi</span><br><span class="line">       *alpha</span><br><span class="line">       *gs0</span><br><span class="line">       *specularityCoefficient_.value()</span><br><span class="line">       *sqrt(3.0*Theta)</span><br><span class="line">       /max(6.0*nu*alphaMax.value(), SMALL)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;valueFraction() = c/(c + patch().deltaCoeffs());</span><br><span class="line"></span><br><span class="line">    partialSlipFvPatchVectorField::updateCoeffs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数主要的功能是重定义了继承自 <code>partialSlip</code> 中的 <code>valueFraction_</code>。结合 <code>partialSlip</code> 中的定义，可以知道最终 <code>JohnsonJacksonParticleSlip</code> 定义的边界速度的值为<br>$$<br>u_m=(1-\frac{c}{c+\Delta}) \cdot (\mathbf{I}-\overrightarrow{n}\otimes\overrightarrow{n})\cdot u_c<br>$$<br>其中 $u_c$ 为邻近壁面网格的 m 相的速度。<code>c</code> 的定义为：<br>$$<br>c=\frac{\pi \varepsilon_m g_0 \phi\sqrt{3\Theta}}{6.0\nu_m\varepsilon_m^{max}}<br>$$<br>对照上述公式(34)，根据 $c$ 的定义，这里可以把公式(34)简写为<br>$$<br>\frac{\partial u_m}{\partial x}=-cu_m<br>$$<br>写成差分形式，即<br>$$<br>(u_m-u_{ct})\cdot \Delta=-cu_m<br>$$<br>于是得到<br>$$<br>u_m = \frac{\Delta}{c+\Delta}u_{ct}<br>$$<br>若 $u_{ct}$ 定义为邻近壁面网格的速度壁面切向分量，则公式(34)与代码是一致的。</p>
<h5 id="JohnsonJacksonParticleTheta">JohnsonJacksonParticleTheta</h5><p>这个边界条件继承自 <code>mixed</code> ，此外新增了两个数据成员： <code>specularityCoefficient_</code> 和 <code>restitutionCoefficient_</code> 。核心的函数也是 <code>updateCoeffs</code> 。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Foam::JohnsonJacksonParticleThetaFvPatchScalarField::updateCoeffs()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (updated())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lookup the fluid model and the phase</span></span><br><span class="line">    <span class="keyword">const</span> twoPhaseSystem&amp; fluid = db().lookupObject&lt;twoPhaseSystem&gt;</span><br><span class="line">    (</span><br><span class="line">        <span class="string">"phaseProperties"</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> phaseModel&amp; phased</span><br><span class="line">    (</span><br><span class="line">        fluid.phase1().name() == dimensionedInternalField().group()</span><br><span class="line">      ? fluid.phase1()</span><br><span class="line">      : fluid.phase2()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lookup all the fields on this patch</span></span><br><span class="line">    <span class="keyword">const</span> fvPatchScalarField&amp; alpha</span><br><span class="line">    (</span><br><span class="line">        patch().lookupPatchField&lt;volScalarField, scalar&gt;</span><br><span class="line">        (</span><br><span class="line">            phased.volScalarField::name()</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> fvPatchVectorField&amp; U</span><br><span class="line">    (</span><br><span class="line">        patch().lookupPatchField&lt;volVectorField, vector&gt;</span><br><span class="line">        (</span><br><span class="line">            IOobject::groupName(<span class="string">"U"</span>, phased.name())</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> fvPatchScalarField&amp; gs0</span><br><span class="line">    (</span><br><span class="line">        patch().lookupPatchField&lt;volScalarField, scalar&gt;</span><br><span class="line">        (</span><br><span class="line">            IOobject::groupName(<span class="string">"gs0"</span>, phased.name())</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> fvPatchScalarField&amp; kappa</span><br><span class="line">    (</span><br><span class="line">        patch().lookupPatchField&lt;volScalarField, scalar&gt;</span><br><span class="line">        (</span><br><span class="line">            IOobject::groupName(<span class="string">"kappa"</span>, phased.name())</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> scalarField Theta(patchInternalField());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lookup the packed volume fraction</span></span><br><span class="line">    dimensionedScalar alphaMax</span><br><span class="line">    (</span><br><span class="line">        <span class="string">"alphaMax"</span>,</span><br><span class="line">        dimless,</span><br><span class="line">        db()</span><br><span class="line">       .lookupObject&lt;IOdictionary&gt;</span><br><span class="line">        (</span><br><span class="line">            IOobject::groupName(<span class="string">"turbulenceProperties"</span>, phased.name())</span><br><span class="line">        )</span><br><span class="line">       .subDict(<span class="string">"RAS"</span>)</span><br><span class="line">       .subDict(<span class="string">"kineticTheoryCoeffs"</span>)</span><br><span class="line">       .lookup(<span class="string">"alphaMax"</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// calculate the reference value and the value fraction</span></span><br><span class="line">    <span class="keyword">if</span> (restitutionCoefficient_.value() != <span class="number">1.0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;refValue() =</span><br><span class="line">            (<span class="number">2.0</span>/<span class="number">3.0</span>)</span><br><span class="line">           *specularityCoefficient_.value()</span><br><span class="line">           *magSqr(U)</span><br><span class="line">           /(scalar(<span class="number">1</span>) - sqr(restitutionCoefficient_.value()));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>-&gt;refGrad() = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">        scalarField c</span><br><span class="line">        (</span><br><span class="line">             constant::mathematical::pi</span><br><span class="line">            *alpha</span><br><span class="line">            *gs0</span><br><span class="line">            *(scalar(1) - sqr(restitutionCoefficient_.value()))</span><br><span class="line">            *sqrt(3.0*Theta)</span><br><span class="line">            /max(4.0*kappa*alphaMax.value(), SMALL)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>-&gt;valueFraction() = c/(c + patch().deltaCoeffs());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for a restitution coefficient of 1, the boundary degenerates to a fixed</span></span><br><span class="line">    <span class="comment">// gradient condition</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;refValue() = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>-&gt;refGrad() =</span><br><span class="line">            pos(alpha - SMALL)</span><br><span class="line">           *constant::mathematical::pi</span><br><span class="line">           *specularityCoefficient_.value()</span><br><span class="line">           *alpha</span><br><span class="line">           *gs0</span><br><span class="line">           *sqrt(3.0*Theta)</span><br><span class="line">           *magSqr(U)</span><br><span class="line">           /max(6.0*kappa*alphaMax.value(), SMALL);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>-&gt;valueFraction() = <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mixedFvPatchScalarField::updateCoeffs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里分两种情况，即 <code>restitutionCoefficient_</code> 是否等于1。其实从公式(35)也能看出来，$e_w=1$ 与 $e_w \neq 1$ 是不一样的。</p>
<ul>
<li><p>$e_w\neq 1$<br>这时，重定义了 <code>refValue</code> 和 <code>valueFraction</code>。利用辅助变量 $c$ 的定义，可以将公式(35)简化如下：<br>$$<br>\frac{\partial \Theta_m}{\partial x}=c \cdot refValue - c \cdot \Theta_m<br>$$<br>写成差分形式<br>$$<br>(\Theta_m-\Theta_c) \cdot \Delta = c\cdot refValue - c \cdot \Theta_m<br>$$<br>得<br>$$<br>\Theta_m=\frac{c}{c+\Delta}\cdot refValue + \frac{\Delta}{c+\Delta} \cdot \Theta_c<br>$$<br>其中 $\Theta_c$ 为邻近壁面网格的颗粒温度。<br>根据 <code>mixed</code> 的定义，壁面的值应当是 <code>valureFraction * refValue + (1-valueFraction)*(patchInternalField() + refGrad/delta)</code>。 这里将 <code>refGrad</code> 赋值为0，就与公式一致了。</p>
</li>
<li><p>$e_w = 1$<br>这种情况下， <code>JohnsonJacksonParticleTheta</code> 就退化为简单的 <code>fixedGradient</code> 了。若 $ \varepsilon_m $ 特别小，则为零梯度，否则，固定梯度，梯度值等于公式(35)的右边第一项。</p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="JohnsonJackson_边界条件">JohnsonJackson 边界条件</h4><p>本篇来看用于气固两相流模拟的 JohnsonJackson 边界条件。这组边界条件用于设定双流体模型中固相在壁面的速度和颗粒温度。根据 <a href="http://www.sciencedirect.com/science/article/pii/S0009250908003904">N. Reuge 2008, CES</a>，壁面上的固相速度和颗粒温度可以表示为：<br><img src="/image/boundaryConditions/JJ.png" alt="JohnsonJackson boundary conditions"><br>其中，$u_m$ 指的是 m 相在壁面切向上的滑移速度。<br>下面来看 OpenFOAM 中对这两个边界条件的实现</p>]]>
    
    </summary>
    
      <category term="Boundary conditions" scheme="http://xiaopingqiu.github.io/tags/Boundary-conditions/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenFOAM 中的边界条件（三）]]></title>
    <link href="http://xiaopingqiu.github.io/2016/04/02/Boundary-conditions-in-OpenFOAM3/"/>
    <id>http://xiaopingqiu.github.io/2016/04/02/Boundary-conditions-in-OpenFOAM3/</id>
    <published>2016-04-02T09:29:16.000Z</published>
    <updated>2016-04-03T07:44:44.840Z</updated>
    <content type="html"><![CDATA[<p>OpenFOAM 中有很多复杂的边界都是继承自上篇中提到的三个基础边界条件，这些边界条件的代码在上一篇的基础上就很容易看懂了。只不过，还有一些边界条件，不是继承自这三个基础边界条件的，其中有一些都直接或间接继承自另一个重要的边界条件： <code>transformFvPatchField</code>。本篇来看看这个 <code>transformFvPatchField</code> 以及几个继承自它的边界条件。</p>
<a id="more"></a>
<h5 id="5-_transform">5. transform</h5><p>这是一个抽象基类，主要注意一下四个函数的定义：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line">tmp&lt;<span class="type">Field</span>&lt;<span class="type">Type</span>&gt; &gt; transformFvPatchField&lt;<span class="type">Type</span>&gt;::valueInternalCoeffs</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;scalarField&gt;&amp;</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> pTraits&lt;<span class="type">Type</span>&gt;::one - snGradTransformDiag();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line">tmp&lt;<span class="type">Field</span>&lt;<span class="type">Type</span>&gt; &gt; transformFvPatchField&lt;<span class="type">Type</span>&gt;::valueBoundaryCoeffs</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;scalarField&gt;&amp;</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        *this</span><br><span class="line">      - cmptMultiply</span><br><span class="line">        (</span><br><span class="line">            valueInternalCoeffs(this-&gt;patch().weights()),</span><br><span class="line">            this-&gt;patchInternalField()</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line">tmp&lt;<span class="type">Field</span>&lt;<span class="type">Type</span>&gt; &gt; transformFvPatchField&lt;<span class="type">Type</span>&gt;::gradientInternalCoeffs() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> -this-&gt;patch().deltaCoeffs()*snGradTransformDiag();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line">tmp&lt;<span class="type">Field</span>&lt;<span class="type">Type</span>&gt; &gt; transformFvPatchField&lt;<span class="type">Type</span>&gt;::gradientBoundaryCoeffs() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        snGrad()</span><br><span class="line">      - cmptMultiply(gradientInternalCoeffs(), this-&gt;patchInternalField());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于 <code>snGrad</code> 和 <code>snGradTransformDiag</code> 都是纯虚函数，所以这四个函数的具体返回值需要在派生类中实现了 <code>snGrad</code> 和 <code>snGradTransformDiag</code> 之后才能确定。<br>另外注意，当模板参数为 <code>scalar</code> 时， <code>gradientInternalCoeffs</code> 函数有特殊的定义：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line">tmp&lt;scalarField &gt; transformFvPatchField&lt;scalar&gt;::gradientInternalCoeffs() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> tmp&lt;scalarField &gt;(new scalarField(size(), <span class="number">0</span>.<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="6-_directionMixed">6. directionMixed</h5><p>这个类，跟前面的 <code>mixed</code> 有点类似，但是又继承自 <code>transform</code> ，所以，似乎是二者的结合。<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">template&lt;<span class="keyword">class</span> <span class="keyword">Type</span>&gt;</span><br><span class="line"><span class="keyword">class</span> directionMixedFvPatchField</span><br><span class="line">:</span><br><span class="line">    <span class="keyword">public</span> transformFvPatchField&lt;<span class="keyword">Type</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    // <span class="keyword">Private</span> <span class="type">data</span></span><br><span class="line"></span><br><span class="line">        //- <span class="keyword">Value</span> field</span><br><span class="line">        Field&lt;<span class="keyword">Type</span>&gt; refValue_;</span><br><span class="line"></span><br><span class="line">        //- Normal gradient field</span><br><span class="line">        Field&lt;<span class="keyword">Type</span>&gt; refGrad_;</span><br><span class="line"></span><br><span class="line">        //- <span class="built_in">Fraction</span> (<span class="number">0</span>-<span class="number">1</span>) of <span class="keyword">value</span> used for boundary condition</span><br><span class="line">        symmTensorField valueFraction_;</span><br></pre></td></tr></table></figure></p>
<p>与 <code>mixed</code> 相似之处是，这里也定义了 <code>refValue_</code> ， <code>refGrad_</code> 和 <code>valueFraction_</code> 三个参数，所不同的是，这里的 <code>valueFraction_</code> 是一个对称张量。</p>
<p>接下来， <code>directionMixed</code> 定义了 <code>snGrad</code> 和 <code>snGradTransformDiag</code> 这两个函数</p>
<ul>
<li><p><code>snGrad</code> 和 <code>snGradTransformDiag</code></p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class <span class="constant">Type&gt;</span></span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:tmp&lt;Foam</span><span class="symbol">:</span><span class="symbol">:Field&lt;Type&gt;</span> &gt;</span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:directionMixedFvPatchField&lt;Type&gt;</span><span class="symbol">:</span><span class="symbol">:snGrad</span>() const</span><br><span class="line">&#123;</span><br><span class="line">    const <span class="constant">Field&lt;Type&gt;</span> pif(this-&gt;patchInternalField());</span><br><span class="line"></span><br><span class="line">    tmp&lt;<span class="constant">Field&lt;Type&gt;</span> &gt; normalValue = transform(valueFraction<span class="constant">_</span>, refValue<span class="constant">_</span>);</span><br><span class="line"></span><br><span class="line">    tmp&lt;<span class="constant">Field&lt;Type&gt;</span> &gt; gradValue = pif + refGrad<span class="constant">_</span>/this-&gt;patch().deltaCoeffs();</span><br><span class="line"></span><br><span class="line">    tmp&lt;<span class="constant">Field&lt;Type&gt;</span> &gt; transformGradValue =</span><br><span class="line">        transform(<span class="constant">I </span>- valueFraction<span class="constant">_</span>, gradValue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        (normalValue + transformGradValue - pif)*</span><br><span class="line">        this-&gt;patch().deltaCoeffs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class <span class="constant">Type&gt;</span></span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:tmp&lt;Foam</span><span class="symbol">:</span><span class="symbol">:Field&lt;Type&gt;</span> &gt;</span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:directionMixedFvPatchField&lt;Type&gt;</span><span class="symbol">:</span><span class="symbol">:snGradTransformDiag</span>() const</span><br><span class="line">&#123;</span><br><span class="line">    vectorField diag(valueFraction<span class="constant">_</span>.size());</span><br><span class="line"></span><br><span class="line">    diag.replace</span><br><span class="line">    (</span><br><span class="line">        <span class="symbol">vector:</span><span class="symbol">:X</span>,</span><br><span class="line">        sqrt(mag(valueFraction<span class="constant">_</span>.component(<span class="symbol">symmTensor:</span><span class="symbol">:XX</span>)))</span><br><span class="line">    );</span><br><span class="line">    diag.replace</span><br><span class="line">    (</span><br><span class="line">        <span class="symbol">vector:</span><span class="symbol">:Y</span>,</span><br><span class="line">        sqrt(mag(valueFraction<span class="constant">_</span>.component(<span class="symbol">symmTensor:</span><span class="symbol">:YY</span>)))</span><br><span class="line">    );</span><br><span class="line">    diag.replace</span><br><span class="line">    (</span><br><span class="line">        <span class="symbol">vector:</span><span class="symbol">:Z</span>,</span><br><span class="line">        sqrt(mag(valueFraction<span class="constant">_</span>.component(<span class="symbol">symmTensor:</span><span class="symbol">:ZZ</span>)))</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> transformFieldMask&lt;<span class="constant">Type&gt;</span>(pow&lt;vector, pTraits&lt;<span class="constant">Type&gt;</span><span class="symbol">:</span><span class="symbol">:rank&gt;</span>(diag));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>evaluate</code> 函数</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">template<span class="subst">&lt;</span>class <span class="keyword">Type</span><span class="subst">&gt;</span></span><br><span class="line"><span class="literal">void</span> Foam<span class="tag">::directionMixedFvPatchField</span><span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::evaluate</span>(const Pstream<span class="tag">::commsTypes</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="subst">!</span>this<span class="subst">-&gt;</span>updated())</span><br><span class="line">    &#123;</span><br><span class="line">        this<span class="subst">-&gt;</span>updateCoeffs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tmp<span class="subst">&lt;</span>Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span> <span class="subst">&gt;</span> normalValue <span class="subst">=</span> transform(valueFraction_, refValue_);</span><br><span class="line"></span><br><span class="line">    tmp<span class="subst">&lt;</span>Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span> <span class="subst">&gt;</span> gradValue <span class="subst">=</span></span><br><span class="line">        this<span class="subst">-&gt;</span>patchInternalField() <span class="subst">+</span> refGrad_/this<span class="subst">-&gt;</span>patch()<span class="built_in">.</span>deltaCoeffs();</span><br><span class="line"></span><br><span class="line">    tmp<span class="subst">&lt;</span>Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span> <span class="subst">&gt;</span> transformGradValue <span class="subst">=</span></span><br><span class="line">        transform(I <span class="subst">-</span> valueFraction_, gradValue);</span><br><span class="line"></span><br><span class="line">    Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::operator</span><span class="subst">=</span>(normalValue <span class="subst">+</span> transformGradValue);</span><br><span class="line"></span><br><span class="line">    transformFvPatchField<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::evaluate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="7-_basicSymmetry">7. basicSymmetry</h5><p>这个类的结构与 <code>directionMixed</code> 类似，对 <code>snGrad</code> ， <code>snGradTransformDiag</code> 和 <code>evaluate</code> 等几个函数进行了重新定义。</p>
<ul>
<li><p><code>snGrad</code> 和 <code>snGradTransformDiag</code></p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class <span class="constant">Type&gt;</span></span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:tmp&lt;Foam</span><span class="symbol">:</span><span class="symbol">:Field&lt;Type&gt;</span> &gt;</span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:basicSymmetryFvPatchField&lt;Type&gt;</span><span class="symbol">:</span><span class="symbol">:snGrad</span>() const</span><br><span class="line">&#123;</span><br><span class="line">    tmp&lt;vectorField&gt; nHat = this-&gt;patch().nf();</span><br><span class="line"></span><br><span class="line">    const <span class="constant">Field&lt;Type&gt;</span> iF(this-&gt;patchInternalField());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        (transform(<span class="constant">I </span>- <span class="number">2.0</span>*sqr(nHat), iF) - iF)</span><br><span class="line">       *(this-&gt;patch().deltaCoeffs()/<span class="number">2.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class <span class="constant">Type&gt;</span></span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:tmp&lt;Foam</span><span class="symbol">:</span><span class="symbol">:Field&lt;Type&gt;</span> &gt;</span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:basicSymmetryFvPatchField&lt;Type&gt;</span><span class="symbol">:</span><span class="symbol">:snGradTransformDiag</span>() const</span><br><span class="line">&#123;</span><br><span class="line">    const vectorField nHat(this-&gt;patch().nf());</span><br><span class="line"></span><br><span class="line">    vectorField diag(nHat.size());</span><br><span class="line"></span><br><span class="line">    diag.replace(<span class="symbol">vector:</span><span class="symbol">:X</span>, mag(nHat.component(<span class="symbol">vector:</span><span class="symbol">:X</span>)));</span><br><span class="line">    diag.replace(<span class="symbol">vector:</span><span class="symbol">:Y</span>, mag(nHat.component(<span class="symbol">vector:</span><span class="symbol">:Y</span>)));</span><br><span class="line">    diag.replace(<span class="symbol">vector:</span><span class="symbol">:Z</span>, mag(nHat.component(<span class="symbol">vector:</span><span class="symbol">:Z</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> transformFieldMask&lt;<span class="constant">Type&gt;</span>(pow&lt;vector, pTraits&lt;<span class="constant">Type&gt;</span><span class="symbol">:</span><span class="symbol">:rank&gt;</span>(diag));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>evaluate</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">template<span class="subst">&lt;</span>class <span class="keyword">Type</span><span class="subst">&gt;</span></span><br><span class="line"><span class="literal">void</span> Foam<span class="tag">::basicSymmetryFvPatchField</span><span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::evaluate</span>(const Pstream<span class="tag">::commsTypes</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="subst">!</span>this<span class="subst">-&gt;</span>updated())</span><br><span class="line">    &#123;</span><br><span class="line">        this<span class="subst">-&gt;</span>updateCoeffs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tmp<span class="subst">&lt;</span>vectorField<span class="subst">&gt;</span> nHat <span class="subst">=</span> this<span class="subst">-&gt;</span>patch()<span class="built_in">.</span>nf();</span><br><span class="line"></span><br><span class="line">    const Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span> <span class="keyword">iF</span>(this<span class="subst">-&gt;</span>patchInternalField());</span><br><span class="line"></span><br><span class="line">    Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::operator</span><span class="subst">=</span></span><br><span class="line">    (</span><br><span class="line">        (<span class="keyword">iF</span> <span class="subst">+</span> transform(I <span class="subst">-</span> <span class="number">2.0</span><span class="subst">*</span>sqr(nHat), <span class="keyword">iF</span>))/<span class="number">2.0</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    transformFvPatchField<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::evaluate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>另外，值得注意的是，当模板参数 <code>Type</code> 是 <code>scalar</code> 时， <code>snGrad</code> 和 <code>evaluate</code> 函数有其他的定义：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">Foam</span>::tmp&lt;<span class="type">Foam</span>::scalarField&gt;</span><br><span class="line"><span class="type">Foam</span>::basicSymmetryFvPatchField&lt;<span class="type">Foam</span>::scalar&gt;::snGrad() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> tmp&lt;scalarField &gt;(new scalarField(size(), <span class="number">0</span>.<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="type">Foam</span>::basicSymmetryFvPatchField&lt;<span class="type">Foam</span>::scalar&gt;::evaluate</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> <span class="type">Pstream</span>::commsTypes</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!updated())</span><br><span class="line">    &#123;</span><br><span class="line">        updateCoeffs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    scalarField::operator=(patchInternalField());</span><br><span class="line">    transformFvPatchField&lt;scalar&gt;::evaluate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从这两个函数可推断，当 <code>Type = scalar</code> 时， <code>basicSymmetry</code> 其实就相当于 <code>zeroGradient</code>。 </p>
<p>关于 <code>transform</code> 和 <code>transformFieldMask</code> 这两个函数，摸索了很久。前者涉及的源文件有 <a href="http://foam.sourceforge.net/docs/cpp/a07932_source.html" target="_blank" rel="external"><code>symmTransformField.C</code></a> ，<a href="http://foam.sourceforge.net/docs/cpp/a07942_source.html" target="_blank" rel="external"> <code>transformFieldTemplates.C</code> </a>；后者的定义在 <a href="http://foam.sourceforge.net/docs/cpp/a07933_source.html" target="_blank" rel="external"><code>symmTransformField.H</code></a>，涉及到的 <code>pow</code> 函数的定义在<a href="http://foam.sourceforge.net/docs/cpp/a07889_source.html" target="_blank" rel="external"><code>FieldFunctions.C</code></a>。此外，这两个函数还需要用到类似 <code>TFOR_ALL_F_OP_FUNC_F_F</code> 的宏，定义在<a href="http://foam.sourceforge.net/docs/cpp/a07893_source.html#l00153" target="_blank" rel="external"><code>fieldM.H</code></a>，而这个宏里涉及到的类似 <code>List_ELEM</code> 这样的宏，则定义在 <a href="http://foam.sourceforge.net/docs/cpp/a07587_source.html" target="_blank" rel="external"><code>ListLoopM.H</code></a>。</p>
<p>看了这么多，仍然无法完全确定这两个函数的具体的行为。主要的障碍在于那个 <code>pow</code> 函数实在看不明白。最后只好来对这两个函数进行了一些测试，测试结果总结如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">transform</span><span class="params">(tensorField p1, vectorField p2)</span></span></span><br></pre></td></tr></table></figure></p>
<p>返回的是另一个 <code>vectorField</code> ，其值等于 <code>p1</code> 与 <code>p2</code> 的内积（即点乘）。注意，一般使用过程中总能保证 <code>p1.size() == p2.size()</code>，但是如果 <code>p1.size() &gt; p2.size()</code>， 则返回结果的 <code>size</code> 等于 <code>p2.size()</code> ，值则等于 <code>p1</code> 的前 <code>p2.size()</code> 部分与 <code>p2</code> 的内积。<br><a href="http://www.slideshare.net/fumiyanozaki96/boundary-conditions-in-openfoam" target="_blank" rel="external">Boundary Conditions in OpenFOAM</a> 这个 silde 也提到了29页也同样提到了 <code>transform</code> 函数的作用<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">inline scalar transform(constsymmTensor&amp;, <span class="keyword">const</span> scalar s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Cmpt</span>&gt;</span><br><span class="line">inline <span class="type">Vector</span>&lt;<span class="type">Cmpt</span>&gt; transform(<span class="keyword">const</span> symmTensor&amp; stt, <span class="keyword">const</span> <span class="type">Vector</span>&lt;<span class="type">Cmpt</span>&gt;&amp; v)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> stt &amp; v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而 <code>transformFieldMask</code><br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transformFieldMask&lt;Type&gt;<span class="list">(<span class="keyword">pow&lt;vector</span>, pTraits&lt;Type&gt;:<span class="keyword">:rank&gt;</span><span class="list">(<span class="keyword">diag</span>)</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>目前测试的结果是，其返回值等于 <code>diag</code> 。</p>
<p>有了上面对 <code>transform</code> 和 <code>transformFieldMask</code> 两个函数的测试结果，就可以来分析 <code>basicSymmetry</code> 和 <code>directionMixed</code> 两个边界条件的行为了。</p>
<h5 id="basicSymmetry">basicSymmetry</h5><p>对于标量，前面说过其等价于 <code>zeroGradient</code>，所以这里只分析矢量的情形。<br>从 <code>evaluate</code> 函数，可以得到如下公式<br>$$<br>\begin{align}<br>\overrightarrow{\phi}_b = &amp; \left [\overrightarrow{\phi}_c + (\mathrm{I} - 2\overrightarrow{n} \otimes \overrightarrow{n})\cdot \overrightarrow{\phi}_c  \right ] \cdot \frac{1}{2.0} \\<br>= &amp;  \overrightarrow{\phi}_c- \left ( \overrightarrow{\phi}_c \cdot  \overrightarrow{n} \right)\cdot \overrightarrow{n}<br>\end{align}<br>$$<br>这意味着，边界上的值等于其邻近网格中心的值的切向分量。<br>为了方便分析四个系数，将上式写成分量的形式:<br>$$<br>\begin{align}<br>\begin{bmatrix}<br>\phi_{px} \\<br>\phi_{py} \\<br>\phi_{pz}<br>\end{bmatrix} = &amp;<br>\begin{bmatrix}<br>\phi_{cx} \\<br>\phi_{cy} \\<br>\phi_{cz}<br>\end{bmatrix} -<br>\begin{bmatrix}<br>(\phi_{cx}n_x + \phi_{cy}n_y + \phi_{cz}n_z)n_x \\<br>(\phi_{cx}n_x + \phi_{cy}n_y + \phi_{cz}n_z)n_y \\<br>(\phi_{cx}n_x + \phi_{cy}n_y + \phi_{cz}n_z)n_z<br>\end{bmatrix} \\<br>= &amp; \begin{bmatrix}<br>(1-n_xn_x)\phi_{cx} \\<br>(1-n_yn_y)\phi_{cy} \\<br>(1-n_zn_z)\phi_{cz}<br>\end{bmatrix} -<br>\begin{bmatrix}<br>\phi_{cy}n_yn_x + \phi_{cz}n_zn_x \\<br>\phi_{cx}n_xn_y + \phi_{cz}n_zn_y \\<br>\phi_{cx}n_xn_z + \phi_{cy}n_yn_z<br>\end{bmatrix}<br>\end{align}<br>$$<br>照此公式，可以分析得到四个系数如下：<br>$$<br>valueInternalCoeffs =<br>\begin{bmatrix}<br>(1-n_xn_x) \\<br>(1-n_yn_y) \\<br>(1-n_zn_z)<br>\end{bmatrix}<br>$$<br>$$<br>valueBoundaryCoeffs =<br>\begin{bmatrix}<br>\phi_{px} \\<br>\phi_{py} \\<br>\phi_{pz}<br>\end{bmatrix} - valueInternalCoeffs<br>\begin{bmatrix}<br>\phi_{cx} \\<br>\phi_{cy} \\<br>\phi_{cz}<br>\end{bmatrix}<br>$$<br>$$<br>gradientInternalCoeffs= - \Delta<br>\begin{bmatrix}<br>(n_xn_x) \\<br>(n_yn_y) \\<br>(n_zn_z)<br>\end{bmatrix}<br>$$<br>$$<br>gradientBoundaryCoeffs = - \begin{bmatrix}<br>(\phi_{cx}n_x + \phi_{cy}n_y + \phi_{cz}n_z)n_x \\<br>(\phi_{cx}n_x + \phi_{cy}n_y + \phi_{cz}n_z)n_y \\<br>(\phi_{cx}n_x + \phi_{cy}n_y + \phi_{cz}n_z)n_z<br>\end{bmatrix}  \Delta - gradientInternalCoeffs<br>\begin{bmatrix}<br>\phi_{cx} \\<br>\phi_{cy} \\<br>\phi_{cz}<br>\end{bmatrix}<br>$$</p>
<p><strong> 但是，实际上 OpenFOAM 里不是这么实现的</strong>！关键就在于这个 <code>snGradTransformDiag</code> 函数的定义与预期不符。<br>根据我的测试， <code>snGradTransformDiag</code> 函数返回值应该是<br>$$<br>snGradTransformDiag =<br>\begin{bmatrix}<br>|n_x| \\<br>|n_y| \\<br>|n_z|<br>\end{bmatrix}<br>$$<br>即，张量 $\overrightarrow{n}\otimes\overrightarrow{n}$ 的主对角线元素组成的矢量。</p>
<p>而 <code>snGrad</code> 函数的返回值，根据代码可知<br>$$<br>snGrad = - \left ( \overrightarrow{\phi}_c \cdot  \overrightarrow{n} \right)\cdot \overrightarrow{n}\cdot \Delta<br>$$<br>所以，OpenFOAM 中定义的四个系数为：<br>$$<br>valueInternalCoeffs =<br>\begin{bmatrix}<br>(1-|n_x|) \\<br>(1-|n_y|) \\<br>(1-|n_z|)<br>\end{bmatrix}<br>$$<br>$$<br>valueBoundaryCoeffs =<br>\begin{bmatrix}<br>\phi_{px} \\<br>\phi_{py} \\<br>\phi_{pz}<br>\end{bmatrix} - valueInternalCoeffs<br>\begin{bmatrix}<br>\phi_{cx} \\<br>\phi_{cy} \\<br>\phi_{cz}<br>\end{bmatrix}<br>$$<br>$$<br>gradientInternalCoeffs= - \Delta<br>\begin{bmatrix}<br>|n_x| \\<br>|n_y| \\<br>|n_z|<br>\end{bmatrix}<br>$$<br>$$<br>gradientBoundaryCoeffs = - \begin{bmatrix}<br>(\phi_{cx}n_x + \phi_{cy}n_y + \phi_{cz}n_z)n_x \\<br>(\phi_{cx}n_x + \phi_{cy}n_y + \phi_{cz}n_z)n_y \\<br>(\phi_{cx}n_x + \phi_{cy}n_y + \phi_{cz}n_z)n_z<br>\end{bmatrix}  \Delta - gradientInternalCoeffs<br>\begin{bmatrix}<br>\phi_{cx} \\<br>\phi_{cy} \\<br>\phi_{cz}<br>\end{bmatrix}<br>$$</p>
<p>这里的 $\Delta$ 代表代码中的 <code>deltaCoeffs</code> 。</p>
<h5 id="directionMixed">directionMixed</h5><p><code>directionMixed</code> 与 <code>basicSymmetry</code> 是类似的，差别在于 <code>directionMixed</code> 所使用的对称张量是指定的，而不一定是 $\overrightarrow{n}\otimes\overrightarrow{n}$。<br>根据 <code>evaluate</code> 函数，可以得到如下公式：<br>$$<br>\begin{align}<br>\overrightarrow{\phi}_b = &amp; \overrightarrow{\phi}_{ref}\cdot \mathbf{vF} + (\mathrm{I} - \mathbf{vF}) \cdot \left (\overrightarrow{\phi}_c + \frac{\overrightarrow{G}}{\Delta} \right)\\<br>= &amp;  (\mathrm{I} - \mathbf{vF}) \cdot \overrightarrow{\phi}_c + \overrightarrow{\phi}_{ref}\cdot vF + (\mathrm{I} - \mathbf{vF}) \cdot \frac{\overrightarrow{G}}{\Delta}<br>\end{align}<br>$$<br>其中，$\overrightarrow{\phi}_{ref}=refValue$，$\overrightarrow{G}=refGrad$，$\mathbf{vF}=valueFraction$<br>同样，为了方便分析，将上述公式的部分写成分量形式：<br>$$<br>\begin{align}<br>\begin{bmatrix}<br>\phi_{px} \\<br>\phi_{py} \\<br>\phi_{pz}<br>\end{bmatrix} = &amp; \begin{bmatrix}<br>\phi_{cx} \\<br>\phi_{cy} \\<br>\phi_{cz}<br>\end{bmatrix} - \begin{bmatrix}<br>vF_{xx}\phi_{cx} + vF_{xy}\phi_{cy} + vF_{xz}\phi_{cz}\\<br>vF_{yx}\phi_{cx} + vF_{yy}\phi_{cy} + vF_{yz}\phi_{cz} \\<br>vF_{zx}\phi_{cx} + vF_{zy}\phi_{cy} + vF_{zz}\phi_{cz}<br>\end{bmatrix} + \overrightarrow{\phi}_{ref}\cdot \mathbf{vF} + (\mathrm{I} - \mathbf{vF}) \cdot \frac{\overrightarrow{G}}{\Delta} \\<br>= &amp; \begin{bmatrix}<br>(1-vF_{xx})\phi_{cx} \\<br>(1-vF_{yy})\phi_{cy} \\<br>(1-vF_{zz})\phi_{cz}<br>\end{bmatrix} - \begin{bmatrix}<br>vF_{xy}\phi_{cy} + vF_{xz}\phi_{cz}\\<br>vF_{yx}\phi_{cx} + vF_{yz}\phi_{cz} \\<br>vF_{zx}\phi_{cx} + vF_{zy}\phi_{cy}<br>\end{bmatrix} + \overrightarrow{\phi}_{ref}\cdot \mathbf{vF} + (\mathrm{I} - \mathbf{vF}) \cdot \frac{\overrightarrow{G}}{\Delta}<br>\end{align}<br>$$<br>同样的，OpenFOAM 中四个系数的实现也与预期的不一样。主要还是 <code>snGradTransformDiag</code> 的定义与预期的不符:<br>$$<br>snGradTransformDiag =<br>\begin{bmatrix}<br>\sqrt{|vF_{xx}|} \\<br>\sqrt{|vF_{yy}|} \\<br>\sqrt{|vF_{zz}|}<br>\end{bmatrix}<br>$$</p>
<p>结合代码，可以得到四个系数如下：<br>$$<br>valueInternalCoeffs =<br>\begin{bmatrix}<br>(1-\sqrt{|vF_{xx}|}) \\<br>(1-\sqrt{|vF_{yy}|}) \\<br>(1-\sqrt{|vF_{zz}|})<br>\end{bmatrix}<br>$$<br>$$<br>valueBoundaryCoeffs =<br>\begin{bmatrix}<br>\phi_{px} \\<br>\phi_{py} \\<br>\phi_{pz}<br>\end{bmatrix} - valueInternalCoeffs<br>\begin{bmatrix}<br>\phi_{cx} \\<br>\phi_{cy} \\<br>\phi_{cz}<br>\end{bmatrix}<br>$$<br>$$<br>gradientInternalCoeffs= - \Delta<br>\begin{bmatrix}<br>\sqrt{|vF_{xx}|} \\<br>\sqrt{|vF_{yy}|} \\<br>\sqrt{|vF_{zz}|}<br>\end{bmatrix}<br>$$<br>$$<br>gradientBoundaryCoeffs = - \mathbf{vF} \cdot \overrightarrow{\phi}_c \cdot \Delta+ \overrightarrow{\phi}_{ref}\cdot \mathbf{vF} \cdot \Delta + (\mathrm{I} - \mathbf{vF}) \cdot \overrightarrow{G} - gradientInternalCoeffs \cdot \overrightarrow{\phi}_c<br>$$</p>
<p>代码里的 <code>snGrad</code> 函数对应公式为：<br>$$<br>\left [ \overrightarrow{\phi}_{ref}\cdot \mathbf{vF} + (\mathrm{I} - \mathbf{vF}) \cdot (\overrightarrow{\phi}_c + \frac{\overrightarrow{G}}{\Delta}) - \overrightarrow{\phi}_c \right ]\cdot \Delta<br>$$</p>
<p>不知道为什么 <code>snGradTransformDiag</code> 要按照这种方式来定义，可能是为了数值稳定性。不过，由于 <code>valueBoundaryCoeffs</code> 和 <code>gradientBoundaryCoeffs</code> 分别是在 <code>valueInternalCoeffs</code> 和 <code>gradientInternalCoeffs</code> 的基础之上定义的，所以总是能保证 <code>evaluate</code> 的结果与预期一致。</p>
<p>可以将 <code>directionMixed</code> 的行为总结如下：<br><img src="/image/boundaryConditions/boundary-conditions-in-openfoam-90.jpg" alt="directionMixed 的行为"></p>
<p>不过，如果 <code>valueFraction</code> 的值是任意指定的，而不是由 $\overrightarrow{n}\otimes\overrightarrow{n}$ 构成的，那又另当别论了。</p>
<p><strong>参考资料</strong>：<br><a href="http://www.slideshare.net/fumiyanozaki96/boundary-conditions-in-openfoam" target="_blank" rel="external">Boundary Conditions in OpenFOAM</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>OpenFOAM 中有很多复杂的边界都是继承自上篇中提到的三个基础边界条件，这些边界条件的代码在上一篇的基础上就很容易看懂了。只不过，还有一些边界条件，不是继承自这三个基础边界条件的，其中有一些都直接或间接继承自另一个重要的边界条件： <code>transformFvPatchField</code>。本篇来看看这个 <code>transformFvPatchField</code> 以及几个继承自它的边界条件。</p>]]>
    
    </summary>
    
      <category term="Boundary conditions" scheme="http://xiaopingqiu.github.io/tags/Boundary-conditions/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenFOAM 中的边界条件（二）]]></title>
    <link href="http://xiaopingqiu.github.io/2016/04/02/Boundary-conditions-in-OpenFOAM2/"/>
    <id>http://xiaopingqiu.github.io/2016/04/02/Boundary-conditions-in-OpenFOAM2/</id>
    <published>2016-04-02T08:40:43.000Z</published>
    <updated>2016-04-02T09:27:58.296Z</updated>
    <content type="html"><![CDATA[<p>本篇在上一篇的基础上来解读 OpenFOAM 中的基础边界条件。基础边界条件一般包括三类，一是Dirichlet 边界，二是 Neumann 边界，三是混合 Dirichlet 和 Neumann 的边界。</p>
<a id="more"></a>
<h5 id="1-_fixedalue">1. fixedalue</h5><p>这个是 OpenFOAM 中的 Dirichlet 边界条件。</p>
<ul>
<li>构造函数<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line">fixedValueFvPatchField&lt;<span class="type">Type</span>&gt;::fixedValueFvPatchField</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> fvPatch&amp; p,</span><br><span class="line">    <span class="keyword">const</span> <span class="type">DimensionedField</span>&lt;<span class="type">Type</span>, volMesh&gt;&amp; iF,</span><br><span class="line">    <span class="keyword">const</span> dictionary&amp; dict</span><br><span class="line">)</span><br><span class="line">:</span><br><span class="line">    fvPatchField&lt;<span class="type">Type</span>&gt;(p, iF, dict, <span class="literal">true</span>)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>熟悉 OpenFOAM 的人都知道， <code>fixedValue</code> 这个边界条件需要用 <code>value</code> 关键字来指定边界的值。<code>value</code> 这个关键字是通过 <code>DimensionedField</code> 类来处理的。 <code>DimensionedField</code> 这个类将读取 <code>value</code> 关键字对应的场的值用来初始化边界上的值。</p>
<ul>
<li>coefficients<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line">tmp&lt;<span class="type">Field</span>&lt;<span class="type">Type</span>&gt; &gt; fixedValueFvPatchField&lt;<span class="type">Type</span>&gt;::valueInternalCoeffs</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;scalarField&gt;&amp;</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> tmp&lt;<span class="type">Field</span>&lt;<span class="type">Type</span>&gt; &gt;</span><br><span class="line">    (</span><br><span class="line">        new <span class="type">Field</span>&lt;<span class="type">Type</span>&gt;(this-&gt;size(), pTraits&lt;<span class="type">Type</span>&gt;::zero)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line">tmp&lt;<span class="type">Field</span>&lt;<span class="type">Type</span>&gt; &gt; fixedValueFvPatchField&lt;<span class="type">Type</span>&gt;::valueBoundaryCoeffs</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;scalarField&gt;&amp;</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> *this;</span><br><span class="line">&#125;</span><br><span class="line">这里 <span class="string">"*this"</span> 表示类本身，即当前边界上的值。这个值在上面的构造函数中进行了初始化，所以，可以理解为 valueBoundaryCoeffs 函数返回的正是关键字 <span class="string">"value"</span> 所对应的值。</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line">tmp&lt;<span class="type">Field</span>&lt;<span class="type">Type</span>&gt; &gt; fixedValueFvPatchField&lt;<span class="type">Type</span>&gt;::gradientInternalCoeffs() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> -pTraits&lt;<span class="type">Type</span>&gt;::one*this-&gt;patch().deltaCoeffs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line">tmp&lt;<span class="type">Field</span>&lt;<span class="type">Type</span>&gt; &gt; fixedValueFvPatchField&lt;<span class="type">Type</span>&gt;::gradientBoundaryCoeffs() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> this-&gt;patch().deltaCoeffs()*(*this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>$$<br>\begin{align}<br>valueInternalCoeffs &amp; = 0 \\<br>valueBoundaryCoeffs &amp; = value \\<br>gradientInternalCoeffs &amp; = -delta \\<br>gradientBoundaryCoeffs &amp; = delta* value<br>\end{align}<br>$$</p>
<p>其中 $delta$ 为面心与面所属网格中心的距离的倒数。<br>从上述系数，可以知道，fixedValue 边界条件对边界的值和梯度值的计算为如下：<br>$$<br>\begin{align}<br>x_p &amp; = value \\<br>\nabla x_p &amp; = - delta \cdot x_C + delta \cdot value = (value - x_C) \cdot delta<br>\end{align}<br>$$<br>这与预期是一致的。</p>
<h5 id="2-_zeroGradient">2. zeroGradient</h5><p>这个是 OpenFOAM 中的一种特殊的 Neumann 边界条件，即边界的梯度为零。</p>
<ul>
<li>evaluate 函数<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">template<span class="subst">&lt;</span>class <span class="keyword">Type</span><span class="subst">&gt;</span></span><br><span class="line"><span class="literal">void</span> zeroGradientFvPatchField<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::evaluate</span>(const Pstream<span class="tag">::commsTypes</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="subst">!</span>this<span class="subst">-&gt;</span>updated())</span><br><span class="line">    &#123;</span><br><span class="line">        this<span class="subst">-&gt;</span>updateCoeffs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fvPatchField<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::operator</span><span class="subst">==</span>(this<span class="subst">-&gt;</span>patchInternalField());</span><br><span class="line">    fvPatchField<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::evaluate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>注意，这里的 <code>operator==</code> 与 <code>operator=</code> 的作用是一样的，都是赋值运算，而不是比较。</p>
<ul>
<li>coefficients<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">template<span class="subst">&lt;</span>class <span class="keyword">Type</span><span class="subst">&gt;</span></span><br><span class="line">tmp<span class="subst">&lt;</span>Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span> <span class="subst">&gt;</span> zeroGradientFvPatchField<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::valueInternalCoeffs</span></span><br><span class="line">(</span><br><span class="line">    const tmp<span class="subst">&lt;</span>scalarField<span class="subst">&gt;&amp;</span></span><br><span class="line">) const</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> tmp<span class="subst">&lt;</span>Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span> <span class="subst">&gt;</span></span><br><span class="line">    (</span><br><span class="line">        <span class="literal">new</span> Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span>(this<span class="subst">-&gt;</span>size(), pTraits<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::one</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template<span class="subst">&lt;</span>class <span class="keyword">Type</span><span class="subst">&gt;</span></span><br><span class="line">tmp<span class="subst">&lt;</span>Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span> <span class="subst">&gt;</span> zeroGradientFvPatchField<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::valueBoundaryCoeffs</span></span><br><span class="line">(</span><br><span class="line">    const tmp<span class="subst">&lt;</span>scalarField<span class="subst">&gt;&amp;</span></span><br><span class="line">) const</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> tmp<span class="subst">&lt;</span>Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span> <span class="subst">&gt;</span></span><br><span class="line">    (</span><br><span class="line">        <span class="literal">new</span> Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span>(this<span class="subst">-&gt;</span>size(), pTraits<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::zero</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template<span class="subst">&lt;</span>class <span class="keyword">Type</span><span class="subst">&gt;</span></span><br><span class="line">tmp<span class="subst">&lt;</span>Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span> <span class="subst">&gt;</span> zeroGradientFvPatchField<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::gradientInternalCoeffs</span>() const</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> tmp<span class="subst">&lt;</span>Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span> <span class="subst">&gt;</span></span><br><span class="line">    (</span><br><span class="line">        <span class="literal">new</span> Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span>(this<span class="subst">-&gt;</span>size(), pTraits<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::zero</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template<span class="subst">&lt;</span>class <span class="keyword">Type</span><span class="subst">&gt;</span></span><br><span class="line">tmp<span class="subst">&lt;</span>Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span> <span class="subst">&gt;</span> zeroGradientFvPatchField<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::gradientBoundaryCoeffs</span>() const</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> tmp<span class="subst">&lt;</span>Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span> <span class="subst">&gt;</span></span><br><span class="line">    (</span><br><span class="line">        <span class="literal">new</span> Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span>(this<span class="subst">-&gt;</span>size(), pTraits<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::zero</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>$$<br>\begin{align}<br>valueInternalCoeffs &amp; = 1 \\<br>valueBoundaryCoeffs &amp; = 0 \\<br>gradientInternalCoeffs &amp; = 0 \\<br>gradientBoundaryCoeffs &amp; = 0<br>\end{align}<br>$$</p>
<p>从上述系数，可以知道，fixedValue 边界条件对边界的值和梯度值的计算为如下：</p>
<p>$$<br>\begin{align}<br>x_p &amp; = x_C \\<br>\nabla x_p &amp; = 0<br>\end{align}<br>$$<br>这与预期是一致的。</p>
<h5 id="3-_fixedGradient">3. fixedGradient</h5><p>这个是 OpenFOAM 中的 Neumann 边界条件，可以指定边界上的梯度值。</p>
<ul>
<li>构造函数<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line">fixedGradientFvPatchField&lt;<span class="type">Type</span>&gt;::fixedGradientFvPatchField</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> fvPatch&amp; p,</span><br><span class="line">    <span class="keyword">const</span> <span class="type">DimensionedField</span>&lt;<span class="type">Type</span>, volMesh&gt;&amp; iF,</span><br><span class="line">    <span class="keyword">const</span> dictionary&amp; dict</span><br><span class="line">)</span><br><span class="line">:</span><br><span class="line">    fvPatchField&lt;<span class="type">Type</span>&gt;(p, iF, dict),</span><br><span class="line">    gradient_(<span class="string">"gradient"</span>, dict, p.size())</span><br><span class="line">&#123;</span><br><span class="line">    evaluate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>需要读取关键字 “gradient” 对应的值来初始化变量 <code>gradient_</code>。</p>
<ul>
<li>evaluate 函数<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">template<span class="subst">&lt;</span>class <span class="keyword">Type</span><span class="subst">&gt;</span></span><br><span class="line"><span class="literal">void</span> fixedGradientFvPatchField<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::evaluate</span>(const Pstream<span class="tag">::commsTypes</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="subst">!</span>this<span class="subst">-&gt;</span>updated())</span><br><span class="line">    &#123;</span><br><span class="line">        this<span class="subst">-&gt;</span>updateCoeffs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::operator</span><span class="subst">=</span></span><br><span class="line">    (</span><br><span class="line">        this<span class="subst">-&gt;</span>patchInternalField() <span class="subst">+</span> gradient_/this<span class="subst">-&gt;</span>patch()<span class="built_in">.</span>deltaCoeffs()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    fvPatchField<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::evaluate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>$$<br>x_p = x_C + \frac{gradient} {delta}<br>$$<br>其中 $delta$ 为面心与面所属网格中心的距离的倒数。</p>
<ul>
<li>coefficients<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line">tmp&lt;<span class="type">Field</span>&lt;<span class="type">Type</span>&gt; &gt; fixedGradientFvPatchField&lt;<span class="type">Type</span>&gt;::valueInternalCoeffs</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;scalarField&gt;&amp;</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> tmp&lt;<span class="type">Field</span>&lt;<span class="type">Type</span>&gt; &gt;(new <span class="type">Field</span>&lt;<span class="type">Type</span>&gt;(this-&gt;size(), pTraits&lt;<span class="type">Type</span>&gt;::one));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line">tmp&lt;<span class="type">Field</span>&lt;<span class="type">Type</span>&gt; &gt; fixedGradientFvPatchField&lt;<span class="type">Type</span>&gt;::valueBoundaryCoeffs</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;scalarField&gt;&amp;</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> gradient()/this-&gt;patch().deltaCoeffs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line">tmp&lt;<span class="type">Field</span>&lt;<span class="type">Type</span>&gt; &gt; fixedGradientFvPatchField&lt;<span class="type">Type</span>&gt;::</span><br><span class="line">gradientInternalCoeffs() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> tmp&lt;<span class="type">Field</span>&lt;<span class="type">Type</span>&gt; &gt;</span><br><span class="line">    (</span><br><span class="line">        new <span class="type">Field</span>&lt;<span class="type">Type</span>&gt;(this-&gt;size(), pTraits&lt;<span class="type">Type</span>&gt;::zero)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line">tmp&lt;<span class="type">Field</span>&lt;<span class="type">Type</span>&gt; &gt; fixedGradientFvPatchField&lt;<span class="type">Type</span>&gt;::</span><br><span class="line">gradientBoundaryCoeffs() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> gradient();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>$$<br>\begin{align}<br>valueInternalCoeffs &amp; = 1 \\<br>valueBoundaryCoeffs &amp; = \tfrac{gradient}{delta} \\<br>gradientInternalCoeffs &amp; = 0 \\<br>gradientBoundaryCoeffs &amp; = gradient<br>\end{align}<br>$$</p>
<h5 id="4-_mixed">4. mixed</h5><p>这是 OpenFOAM 中的混合边界条件。</p>
<ul>
<li>构造函数<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line">mixedFvPatchField&lt;<span class="type">Type</span>&gt;::mixedFvPatchField</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> fvPatch&amp; p,</span><br><span class="line">    <span class="keyword">const</span> <span class="type">DimensionedField</span>&lt;<span class="type">Type</span>, volMesh&gt;&amp; iF,</span><br><span class="line">    <span class="keyword">const</span> dictionary&amp; dict</span><br><span class="line">)</span><br><span class="line">:</span><br><span class="line">    fvPatchField&lt;<span class="type">Type</span>&gt;(p, iF, dict),</span><br><span class="line">    refValue_(<span class="string">"refValue"</span>, dict, p.size()),</span><br><span class="line">    refGrad_(<span class="string">"refGradient"</span>, dict, p.size()),</span><br><span class="line">    valueFraction_(<span class="string">"valueFraction"</span>, dict, p.size())</span><br><span class="line">&#123;</span><br><span class="line">    evaluate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>需要读取三个参数。</p>
<ul>
<li>evaluate<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">template<span class="subst">&lt;</span>class <span class="keyword">Type</span><span class="subst">&gt;</span></span><br><span class="line"><span class="literal">void</span> mixedFvPatchField<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::evaluate</span>(const Pstream<span class="tag">::commsTypes</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="subst">!</span>this<span class="subst">-&gt;</span>updated())</span><br><span class="line">    &#123;</span><br><span class="line">        this<span class="subst">-&gt;</span>updateCoeffs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::operator</span><span class="subst">=</span></span><br><span class="line">    (</span><br><span class="line">        valueFraction_<span class="subst">*</span>refValue_</span><br><span class="line">      <span class="subst">+</span></span><br><span class="line">        (<span class="number">1.0</span> <span class="subst">-</span> valueFraction_)<span class="subst">*</span></span><br><span class="line">        (</span><br><span class="line">            this<span class="subst">-&gt;</span>patchInternalField()</span><br><span class="line">          <span class="subst">+</span> refGrad_/this<span class="subst">-&gt;</span>patch()<span class="built_in">.</span>deltaCoeffs()</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">    fvPatchField<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::evaluate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>$$<br>x_p = valueFraction \cdot refValue + (1-valueFraction) \cdot (x_C + \frac{refGrad}{delta})<br>$$</p>
<ul>
<li>coefficients<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line">tmp&lt;<span class="type">Field</span>&lt;<span class="type">Type</span>&gt; &gt; mixedFvPatchField&lt;<span class="type">Type</span>&gt;::valueInternalCoeffs</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;scalarField&gt;&amp;</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Type</span>(pTraits&lt;<span class="type">Type</span>&gt;::one)*(<span class="number">1</span>.<span class="number">0</span> - valueFraction_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line">tmp&lt;<span class="type">Field</span>&lt;<span class="type">Type</span>&gt; &gt; mixedFvPatchField&lt;<span class="type">Type</span>&gt;::valueBoundaryCoeffs</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;scalarField&gt;&amp;</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">         valueFraction_*refValue_</span><br><span class="line">       + (<span class="number">1</span>.<span class="number">0</span> - valueFraction_)*refGrad_/this-&gt;patch().deltaCoeffs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line">tmp&lt;<span class="type">Field</span>&lt;<span class="type">Type</span>&gt; &gt; mixedFvPatchField&lt;<span class="type">Type</span>&gt;::gradientInternalCoeffs() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="type">Type</span>(pTraits&lt;<span class="type">Type</span>&gt;::one)*valueFraction_*this-&gt;patch().deltaCoeffs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line">tmp&lt;<span class="type">Field</span>&lt;<span class="type">Type</span>&gt; &gt; mixedFvPatchField&lt;<span class="type">Type</span>&gt;::gradientBoundaryCoeffs() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        valueFraction_*this-&gt;patch().deltaCoeffs()*refValue_</span><br><span class="line">      + (<span class="number">1</span>.<span class="number">0</span> - valueFraction_)*refGrad_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>$$<br>\begin{align}<br>valueInternalCoeffs &amp; = 1-valueFraction \\<br>valueBoundaryCoeffs &amp; = valueFraction \cdot refValue + (1-valueFraction) \cdot \tfrac{refGrad}{delta} \\<br>gradientInternalCoeffs &amp; = -valueFraction \cdot delta \\<br>gradientBoundaryCoeffs &amp; = valueFraction \cdot refValue \cdot delta + (1-valueFraction) \cdot refGrad<br>\end{align}<br>$$</p>
<p>附注：本篇中所有的下标 $p$ 都表示当前边界（present boundary patch），下标 $C$ 表示当前边界所属的网格的中心。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本篇在上一篇的基础上来解读 OpenFOAM 中的基础边界条件。基础边界条件一般包括三类，一是Dirichlet 边界，二是 Neumann 边界，三是混合 Dirichlet 和 Neumann 的边界。</p>]]>
    
    </summary>
    
      <category term="Boundary conditions" scheme="http://xiaopingqiu.github.io/tags/Boundary-conditions/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenFOAM 中的边界条件（一）]]></title>
    <link href="http://xiaopingqiu.github.io/2016/04/02/Boundary-conditions-in-OpenFOAM1/"/>
    <id>http://xiaopingqiu.github.io/2016/04/02/Boundary-conditions-in-OpenFOAM1/</id>
    <published>2016-04-02T07:29:24.000Z</published>
    <updated>2016-04-03T07:27:24.175Z</updated>
    <content type="html"><![CDATA[<p>本系列解读 OpenFOAM 中边界条件的实现。主要关心一些几个问题：</p>
<ol>
<li>OpenFOAM 中边界条件是怎样与有限体积离散部分交互的？</li>
<li>怎么从代码看懂一个边界条件具体是怎么计算边界上的值的？</li>
<li>怎么定制一个边界条件？</li>
</ol>
<p>本篇先阐述第一个问题。</p>
<a id="more"></a>
<p>从有限体积离散的角度来看，离散过程中，可能要用到的边界信息包括两类：一是某个场在边界上的值，另一是某个场在边界上的梯度。前者在对流项的离散中需要用到，举例说<br>$$<br>\int_v \nabla \cdot (\rho \mathbf{U} \phi) dV = \sum_f m_f \phi_f<br>$$<br>当组成体积元的面中有边界面时，需要用到这些边界面上的值 $\phi_f$。<br>而在扩散项的离散过程中<br>$$<br>\int_v \nabla \cdot (\Gamma \nabla \phi) dV = \sum_f (\Gamma \nabla \phi)_f \cdot \mathbf{S}_f<br>$$<br>这时，如果组成体积元的某个面是边界面，就需要该边界面上 $\phi$ 的梯度值 $\nabla \phi_f$ 了。</p>
<p>边界上的某个场值，或者梯度值，其计算方法可以用如下通式表示<br>$$<br>\begin{align}<br>\phi_f &amp; = A_1 \phi_C + B_1 \\<br>\nabla \phi_f &amp; = A_2 \phi_C + B_2<br>\end{align}<br>$$<br>这里，$ \phi_C$ 表示 $\phi$ 在邻近边界的网格中心的值，$A_1$ ，$B_1$，$A_2$，$B_2$ 是系数。</p>
<p>OpenFOAM 中的边界条件类中，有四个函数分别对应上面四个系数：<code>valueInternalCoeffs</code> 对应 $A_1$，<code>valueBoundaryCoeffs</code> 对应 $B_1$，<code>gradientInternalCoeffs</code> 对应 $A_2$，<code>gradientBoundaryCoeffs</code> 对应 $B_2$。<br>所以，看懂 OpenFOAM 中的边界条件，很关键的一步就是看懂这四个函数的定义。</p>
<p>此外，还有一个函数，<code>updateCoeffs</code>， 也很重要。这个函数负责对边界条件进行显式地更新。浏览一下 OpenFOAM 边界条件的代码，会发现很多边界条件都是在 <code>updateCoeffs</code> 这个函数中进行边界值的计算的。</p>
<p>另外，还有些边界条件，似乎是在 <code>evaluate</code> 函数中进行边界值的指定的。</p>
<p>至于边界条件是在什么地方调用的，cfd-online 上有<a href="http://www.cfd-online.com/Forums/openfoam-programming-development/129271-how-boundary-conditions-called-openfoam-solvers.html" target="_blank" rel="external">一个帖子</a>，Hrvoje Jasak 对这个问题的回答是：<br>“<br>Easy:<br>- on correctBoundaryConditions() for a field<br>- on updateCoeffs() at matrix creation<br>correctBoundaryConditions is also called after the linear solver call automatically.<br>”<br>其他网友还提供了一些有价值的信息，比如，在 <code>correctBoundaryConditions</code> 函数中，<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>, <span class="keyword">template</span>&lt;class&gt; class <span class="type">PatchField</span>, class <span class="type">GeoMesh</span>&gt;</span><br><span class="line"><span class="type">void</span> <span class="type">Foam</span>::<span class="type">GeometricField</span>&lt;<span class="type">Type</span>, <span class="type">PatchField</span>, <span class="type">GeoMesh</span>&gt;::</span><br><span class="line">correctBoundaryConditions()</span><br><span class="line">&#123;</span><br><span class="line">    this-&gt;setUpToDate();</span><br><span class="line">    storeOldTimes();</span><br><span class="line">    boundaryField_.evaluate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用了 <code>evaluate</code> 函数。<br>为什么有些边界条件用 <code>updateCoeffs()</code>，而有些则用 <code>evaluate()</code> 呢？目前的理解是这样的： <code>updateCoeffs()</code> 主要用来显式地计算并更新变量在边界上的值，当边界上的值是通过某个依赖于外部参数的公式来计算，并且值会随着迭代的进行而不断改变时，则需要用 <code>updateCoeffs()</code>。有些边界条件，比如最基本的 <code>zeroGradient()</code>，不需要外部的参数，只需要每一次将临近网格的值赋给边界就可以了，这时就可以用 <code>evaluate()</code>。</p>
<p>关于边界条件调用的具体过程，需要在看了 <code>fvMatrix</code> 类以后才能更深入地理解，博主目前只能给出一个粗浅的理解。</p>
<p><strong>参考资料</strong>：<br>The Finite Volume Method in Computational Fluid Dynamics: An Advanced Introduction with OpenFOAM® and Matlab®</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本系列解读 OpenFOAM 中边界条件的实现。主要关心一些几个问题：</p>
<ol>
<li>OpenFOAM 中边界条件是怎样与有限体积离散部分交互的？</li>
<li>怎么从代码看懂一个边界条件具体是怎么计算边界上的值的？</li>
<li>怎么定制一个边界条件？</li>
</ol>
<p>本篇先阐述第一个问题。</p>]]>
    
    </summary>
    
      <category term="Boundary conditions" scheme="http://xiaopingqiu.github.io/tags/Boundary-conditions/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[fvOptions 之 semiImplicitSource]]></title>
    <link href="http://xiaopingqiu.github.io/2016/03/20/fvOptions2/"/>
    <id>http://xiaopingqiu.github.io/2016/03/20/fvOptions2/</id>
    <published>2016-03-20T07:24:41.000Z</published>
    <updated>2016-04-26T13:03:19.617Z</updated>
    <content type="html"><![CDATA[<p>上篇浅析了 fvOptions 框架的结构，这篇来看一个具体的源项类： <code>semiImplicitSource</code> 。</p>
<a id="more"></a>
<p>先来看看这个源项代码中的关键部分。</p>
<ul>
<li>SemiImplicitSource.C<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "SemiImplicitSource.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "fvMesh.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "fvMatrices.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "DimensionedField.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "fvmSup.H"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Type&gt;</span><br><span class="line"><span class="keyword">const</span> Foam::wordList Foam::fv::SemiImplicitSource&lt;Type&gt;::volumeModeTypeNames_</span><br><span class="line">(</span><br><span class="line">    IStringStream(<span class="string">"(absolute specific)"</span>)()  <span class="comment">// 初始化 volumeModeTypeNames_，这里有两种模式， `absolute` 和 `specific` ，具体含义下面会解释。 </span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Type&gt;</span><br><span class="line"><span class="keyword">typename</span> Foam::fv::SemiImplicitSource&lt;Type&gt;::volumeModeType</span><br><span class="line">Foam::fv::SemiImplicitSource&lt;Type&gt;::wordToVolumeModeType <span class="comment">// 将字符串转换成 volumeModeType</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> word&amp; vmtName</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    forAll(volumeModeTypeNames_, i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (vmtName == volumeModeTypeNames_[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> volumeModeType(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FatalErrorIn</span><br><span class="line">    (</span><br><span class="line">        <span class="string">"SemiImplicitSource&lt;Type&gt;::volumeModeType"</span></span><br><span class="line">        <span class="string">"SemiImplicitSource&lt;Type&gt;::wordToVolumeModeType(const word&amp;)"</span></span><br><span class="line">    )   &lt;&lt; <span class="string">"Unknown volumeMode type "</span> &lt;&lt; vmtName</span><br><span class="line">        &lt;&lt; <span class="string">". Valid volumeMode types are:"</span> &lt;&lt; nl &lt;&lt; volumeModeTypeNames_</span><br><span class="line">        &lt;&lt; <span class="built_in">exit</span>(FatalError);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> volumeModeType(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Type&gt;</span><br><span class="line">Foam::word Foam::fv::SemiImplicitSource&lt;Type&gt;::volumeModeTypeToWord</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> volumeModeType&amp; vmtType</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (vmtType &gt; volumeModeTypeNames_.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"UNKNOWN"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> volumeModeTypeNames_[vmtType];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Type&gt;</span><br><span class="line"><span class="keyword">void</span> Foam::fv::SemiImplicitSource&lt;Type&gt;::setFieldData(<span class="keyword">const</span> dictionary&amp; dict)</span><br><span class="line">&#123;</span><br><span class="line">    fieldNames_.setSize(dict.toc().size());</span><br><span class="line">    injectionRate_.setSize(fieldNames_.size());</span><br><span class="line"></span><br><span class="line">    applied_.setSize(fieldNames_.size(), <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    label i = <span class="number">0</span>;</span><br><span class="line">    forAllConstIter(dictionary, dict, iter)</span><br><span class="line">    &#123;</span><br><span class="line">        fieldNames_[i] = iter().keyword();</span><br><span class="line">        dict.lookup(iter().keyword()) &gt;&gt; injectionRate_[i];</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set volume normalisation</span></span><br><span class="line">    <span class="keyword">if</span> (volumeMode_ == vmAbsolute)</span><br><span class="line">    &#123;</span><br><span class="line">        VDash_ = V_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Type&gt;</span><br><span class="line">Foam::fv::SemiImplicitSource&lt;Type&gt;::SemiImplicitSource</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> word&amp; name,</span><br><span class="line">    <span class="keyword">const</span> word&amp; modelType,</span><br><span class="line">    <span class="keyword">const</span> dictionary&amp; dict,</span><br><span class="line">    <span class="keyword">const</span> fvMesh&amp; mesh</span><br><span class="line">)</span><br><span class="line">:</span><br><span class="line">    option(name, modelType, dict, mesh),</span><br><span class="line">    volumeMode_(vmAbsolute), volumeMode 初始值为 vmAbsolute，也就是字典里的 <span class="function">absolute</span><br><span class="line">    <span class="title">VDash_</span><span class="params">(1.0)</span>, <span class="comment">// VDash 初始值为 1.0</span></span><br><span class="line">    <span class="title">injectionRate_</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    read(dict);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Type&gt;</span><br><span class="line"><span class="keyword">void</span> Foam::fv::SemiImplicitSource&lt;Type&gt;::addSup <span class="comment">// 这个是最关键的函数，求解器里的 fvOptions(T)，最终就是转换为调用这个函数。</span></span><br><span class="line">(</span><br><span class="line">    fvMatrix&lt;Type&gt;&amp; eqn,</span><br><span class="line">    <span class="keyword">const</span> label fieldI</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (debug)</span><br><span class="line">    &#123;</span><br><span class="line">        Info&lt;&lt; <span class="string">"SemiImplicitSource&lt;"</span> &lt;&lt; pTraits&lt;Type&gt;::typeName</span><br><span class="line">            &lt;&lt; <span class="string">"&gt;::addSup for source "</span> &lt;&lt; name_ &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// psi 表示方程中的未知量，比如，eqn(fvm::ddt(T))，则psi其实就相当于T，其量纲也与T的量纲一致。</span></span><br><span class="line">    <span class="keyword">const</span> GeometricField&lt;Type, fvPatchField, volMesh&gt;&amp; psi = eqn.psi();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个场 Su，其量纲为方程eqn的量纲除以体积的量纲。注意，经测试，假设eqn为（fvm::ddt(T)），则eqn的量纲为k.m^3/s。</span></span><br><span class="line">    DimensionedField&lt;Type, volMesh&gt; Su</span><br><span class="line">    (</span><br><span class="line">        IOobject</span><br><span class="line">        (</span><br><span class="line">            name_ + fieldNames_[fieldI] + <span class="string">"Su"</span>,</span><br><span class="line">            mesh_.time().timeName(),</span><br><span class="line">            mesh_,</span><br><span class="line">            IOobject::NO_READ,</span><br><span class="line">            IOobject::NO_WRITE</span><br><span class="line">        ),</span><br><span class="line">        mesh_,</span><br><span class="line">        dimensioned&lt;Type&gt;</span><br><span class="line">        (</span><br><span class="line">            <span class="string">"zero"</span>,</span><br><span class="line">            eqn.dimensions()/dimVolume,</span><br><span class="line">            pTraits&lt;Type&gt;::zero</span><br><span class="line">        ),</span><br><span class="line">        <span class="keyword">false</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这一句的意思是，将属于cells_这个集合的网格的Su赋值为fvoptions里所设置的第一个参数的值除以体积VDash。这里的VDash,如果模式为absolute，则值为cells_这个集合的网格体积之和，如果模式为specific，则其值为1. </span></span><br><span class="line">    <span class="comment">// UUIndirectList&lt;Type&gt;(Su, cells_)这一句是利用Su和cells为参数，构建一个UUIndirectList类的临时对象，并调用这个类的重载的“=”操作符对Su进行重新赋值。</span></span><br><span class="line">    </span><br><span class="line">    UIndirectList&lt;Type&gt;(Su, cells_) = injectionRate_[fieldI].first()/VDash_;</span><br><span class="line"></span><br><span class="line">    DimensionedField&lt;scalar, volMesh&gt; Sp</span><br><span class="line">    (</span><br><span class="line">        IOobject</span><br><span class="line">        (</span><br><span class="line">            name_ + fieldNames_[fieldI] + <span class="string">"Sp"</span>,</span><br><span class="line">            mesh_.time().timeName(),</span><br><span class="line">            mesh_,</span><br><span class="line">            IOobject::NO_READ,</span><br><span class="line">            IOobject::NO_WRITE</span><br><span class="line">        ),</span><br><span class="line">        mesh_,</span><br><span class="line">        dimensioned&lt;scalar&gt;</span><br><span class="line">        (</span><br><span class="line">            <span class="string">"zero"</span>,</span><br><span class="line">            Su.dimensions()/psi.dimensions(),</span><br><span class="line">            <span class="number">0.0</span></span><br><span class="line">        ),</span><br><span class="line">        <span class="keyword">false</span></span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    UIndirectList&lt;scalar&gt;(Sp, cells_) = injectionRate_[fieldI].second()/VDash_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fvMatrix&lt;Type&gt; 类中对“+=”操作符进行了重载，所以，eqn与Su的相加，相当于eqn+Su*mesh.V()，要不然eqn与Su的量纲不一致。</span></span><br><span class="line">    eqn += Su + fvm::SuSp(Sp, psi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>下面用一个例子来说明 <code>semiImplicitSource</code> 的作用。前提到 <code>scalarTransportFoam</code> 是使用 fvOptions 的一个最简单的求解器，这里对该求解器进一步简化，只保留瞬变项，对流和扩散项都删去，来验证 <code>semiImplicitSource</code> 的作用。<br>修改之后的 <code>TEqn</code> 为<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tmp TEqn</span><br><span class="line"><span class="list">(</span><br><span class="line">    <span class="keyword">fvm</span>:<span class="keyword">:ddt</span><span class="list">(<span class="keyword">T</span>)</span>  == fvOptions<span class="list">(<span class="keyword">T</span>)</span></span><br><span class="line">)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>然后，<code>fvOptions</code> 词典文件的设置如下：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">firstHeatSource</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title">type</span> scalarSemiImplicitSource;</span><br><span class="line">    <span class="title">active</span>          <span class="built_in">true</span>;</span><br><span class="line">    <span class="title">selectionMode</span>   cellZone;</span><br><span class="line">    <span class="title">cellZone</span>        boxSourceZone;</span><br><span class="line">    <span class="title">scalarSemiImplicitSourceCoeffs</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title">volumeMode</span> absolute;</span><br><span class="line">        <span class="title">injectionRateSuSp</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title">T</span> (<span class="number">0</span>.<span class="number">05</span> <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述设置，相当于求解如下方程<br>$$<br>\frac{\partial T}{\partial t}=S_u + S_p\cdot T<br>$$<br>其中 $S_u=0.05, S_p = 0$ 。<br>反观上面对代码的分析，可知对于当前的设置，$S_u$ 的量纲为 <code>TEqn</code> 的量纲除以体积量纲，$S_p$ 的量为 $S_u$ 量纲除以 <code>T</code> 的量纲，这与上面给出的方程是一致的。<br>但是，要注意， <code>SemiImplicitSource</code> 有两个模式：absolute 和 specific，区别在于代码里的 <code>VDash</code> 的取值不一样。对于 absolute 模式，<code>VDash = V</code>，即所选的 cellZone 的体积；对于 specific 模式，<code>VDash = 1.0</code>。而代码里的 <code>Su</code> 和 <code>Sp</code> 的值都是用在<code>fvOptions</code> 词典文件设置的值除以 <code>VDash</code> 。<br>所以，确切地说，求解的应该是如下积分方程：<br>$$<br>\int_V \frac{\partial T}{\partial t} dV - \int_V \nabla \cdot (D_T \nabla T) dV = \int_V (\frac{S_u}{V_{Dash}}+\frac{S_p}{V_{Dash}}T )dV<br>$$<br>其中 $V_{Dash}$ 是选定的 cellZone 的体积。<br>为了验证以上的推演，作了如下两个测试：</p>
<ul>
<li>源项参数设置为<code>T (0.01 0)</code>，源项作用的区域为一个体积为$V_{Dash}=0.001$ 的 cellZone，为了消除热量传递，设置 $D_T = 0$，初始整个区域的 T 均为0， 模拟时间为1 s。<br>按照上述的推演，如果是 <code>absolute</code> 模式，最终 1 s 时选定的 cellZone 的温度将是 $T=t\cdot \frac{S_u}{V_{Dash}}=1s\cdot\frac{0.01 k/s}{0.001}=10k$；如果是 <code>specific</code> 模式，那么最终1 s 时选定的 cellZone 的温度将是 $T=1s\cdot\frac{0.01 k/s}{1.0}=0.01k$。以上结果在测试算例中得到了证实。</li>
<li>源项参数设置为<code>T (1.0 2.0)</code>，同样设置 $D_T = 0$。这种情况下，可以先求微分方程<br>$$\frac{\partial T}{\partial t}=x+yT$$<br>的解，经简单计算得到<br>$$T=\frac{e^{yt}\cdot e^{yc}-x}{y}$$<br>$c$ 为任意常数。<br>若 $T|\,_{t=0}=0k$，则可以得到定解为<br>$$T=\frac{e^{yt}\cdot x-x}{y}$$<br>若使用<code>specific</code> 模式，则根据当前的设置得到1 s时的解为<br>$$T=\frac{e^{2\cdot 1}\cdot 1 -1}{2}=3.194528 k$$<br>算例测试结果为：</li>
<li>时间离散格式:Euler，$\Delta T=0.001s$，$T=3.20193k$；</li>
<li>时间离散格式：Euler，$\Delta T=0.0001s$，$T=3.19527k$，可见减小时间步后结果与解析解吻合度提高了很多。</li>
<li>时间离散格式：CrankNicolson，$\Delta T=0.001s$，$T=3.19454k$。可见用高阶的时间离散格式，在同样时间步下能得到误差更小的结果。</li>
</ul>
<p>同样，如果用<code>absolute</code> 模式，且源项设置为 <code>T (0.001 0.002)</code> ，应该能得到一样的结果，实际上算例测试正是如此。由此可以认为推演得到了证实。</p>
<p>至此，<code>SemiImplicitSource</code> 这个源项的核心部分就算是明了了。可是，现在测试的是非常简单的情形，如果在求解多个方程，且有多个方程里都加入了源项的情况下，该怎么给不同的方程设置不一样的源项呢？要解决这个问题，需要先理解清楚 <code>fvOptions</code> 的调用过程。</p>
<h5 id="fvOptions_源项的调用过程">fvOptions 源项的调用过程</h5><p>下面至下而上地来看看 fvOptions 的调用过程。</p>
<p><code>TEqn</code>里，有一个调用 <code>fvOptions</code> 的语句： <code>fvOptions(T)</code>，上一篇讲过， <code>fvOptions</code> 的定义为<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="rule"><span class="attribute">fv</span>:<span class="value">:IOoptionList <span class="function">fvOptions</span>(mesh)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>这就很明显了：建立一个 <code>IOoptionList</code> 类的对象 <code>fvOptions</code>。由此可知，求解器里的 <code>fvOptions</code> 是一个对象的名字，因此 <code>fvOptions(T)</code> 这种用法也只可能是对象调用类中重载的 <code>()</code> 运算符了。从前面的分析，可知 <code>IOoptionList</code> 本身很简单，仅是作为一个接口来用的，所以 <code>()</code> 与算符的重载要去其父类中去找。 <code>IOoptionList</code> 的作用是，从 “constant”（优先）或者 “system” 目录读取 <code>fvOptions</code> 文件，并作为 <code>IOobject</code> 类的对象传递给父类 <code>optionList</code> （从构造函数的成员初始化列表 <code>optionList(mesh, *this)</code> ）</p>
<hr>
<p>接下来，就该进入 <code>optionList</code> 类了。这个类里，所有可能出现在求解器代码里函数都有了，包括 <code>correct</code> ， <code>constrain</code> ， <code>makeRelative</code> ， <code>makeAbsolute</code> ， <code>relative</code> 以及 <code>()</code> 运算符的重载。但是，注意这里并没有具体的代码实现，而是通过类似<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">forAll(*<span class="keyword">this</span>, i)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">this</span>-&gt;<span class="keyword">operator</span>[](i).makeAbsolute(phi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用其他地方的函数。 <code>optionList</code> 的一个重要使命是，统计 <code>fvOptions</code> 文件里定义了多少个源项，并将每一个源项都作为一个储存起来，然后再根据词典的内容创建特定的源项。核心在于 <code>reset</code> 函数。为了说明这一点，先从构造函数看起<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reset<span class="list">(<span class="keyword">optionsDict</span><span class="list">(<span class="keyword">dict</span>)</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>可见构造函数里调用了 <code>reset</code> 函数，并且用 <code>optionsDict</code> 函数的返回值作为 <code>reset</code> 函数的参数。前文讲到， <code>IOoptionList</code> 类将 <code>fvOptions</code> 文件的内容以 <code>IOobject</code> 的形式传递给父类 <code>optionList</code>，所以，这里的参数 <code>dict</code> 可以理解为就是<code>fvOptions</code> 文件的内容。<code>optionsDict</code> 函数的代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Foam::dictionary&amp; Foam::fv::optionList::optionsDict</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> dictionary&amp; dict</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (dict.found(<span class="string">"options"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> dict.subDict(<span class="string">"options"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> dict;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可见，这个函数去 <code>fvOptions</code> 文件里查找关键字 <code>options</code>，如果找到，就将 <code>options</code> 关键字对应的 subDict 内容返回，否则直接返回 <code>fvOptions</code> 文件的内容。举例说，形如<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">firstHeatSource</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title">type</span> scalarSemiImplicitSource;</span><br><span class="line">    <span class="title">active</span>          <span class="built_in">true</span>;</span><br><span class="line">    <span class="title">selectionMode</span>   cellZone;</span><br><span class="line">    <span class="title">cellZone</span>        boxSourceZone;</span><br><span class="line">    <span class="title">scalarSemiImplicitSourceCoeffs</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title">volumeMode</span> absolute;</span><br><span class="line">        <span class="title">injectionRateSuSp</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title">T</span> (<span class="number">0</span>.<span class="number">001</span> <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>的，直接返回，因为这就构成了一个 dictionary；而形如<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">options</span><br><span class="line">&#123;</span><br><span class="line">    massSource1</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">type</span>            scalarSemiImplicitSource;</span><br><span class="line">        <span class="label">$injector1</span>;</span><br><span class="line"></span><br><span class="line">        scalarSemiImplicitSourceCoeffs</span><br><span class="line">        &#123;</span><br><span class="line">            volumeMode      absolute;</span><br><span class="line">            injectionRateSuSp</span><br><span class="line">            &#123;</span><br><span class="line">                thermo:rho.air     (1e-3 0); <span class="comment">// kg/s</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    momentumSource1</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">type</span>            vectorSemiImplicitSource;</span><br><span class="line">        <span class="label">$injector1</span>;</span><br><span class="line"></span><br><span class="line">        vectorSemiImplicitSourceCoeffs</span><br><span class="line">        &#123;</span><br><span class="line">            volumeMode      absolute;</span><br><span class="line">            injectionRateSuSp</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">U</span>.air           ((0 -1e-2 0) 0); <span class="comment">// kg*m/s^2</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    energySource1</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">type</span>            scalarSemiImplicitSource;</span><br><span class="line">        <span class="label">$injector1</span>;</span><br><span class="line"></span><br><span class="line">        scalarSemiImplicitSourceCoeffs</span><br><span class="line">        &#123;</span><br><span class="line">            volumeMode      absolute;</span><br><span class="line">            injectionRateSuSp</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">e</span>.air      (500 0); <span class="comment">// kg*m^2/s^3</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>的，则将options下的每一个 subDict 作为 dictionary 返回。注意，这里的 <code>dictionary</code> 类可以理解为一个容器，每一个<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xxxxx</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">...</span><span class="attribute">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>都可以作为容器里的一个成员，容器的容量（size）等于总的成员数，每一个成员，其实就对应一个源项。<br>于是，我们知道 <code>optionsDict</code> 返回了一个有一定数目成员的容器。再来看 <code>reset</code> 函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Foam::fv::optionList::reset(<span class="keyword">const</span> dictionary&amp; dict)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Count number of active fvOptions</span></span><br><span class="line">    label count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历 dict 容器，确定其成员的数目，即确定定义了几个源项。</span></span><br><span class="line">    forAllConstIter(dictionary, dict, iter) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (iter().isDict())</span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>-&gt;setSize(count); <span class="comment">// setSize 是 PtrList 类的成员，顾名思义，PtrList 是一个 List。PtrList&lt;option&gt; 类的成员是 options 类的对象。</span></span><br><span class="line">    </span><br><span class="line">    label i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 遍历 dict 容器，根据每一个 dict 容器的成员来建立对应的 option 类的对象，这通过调用 option 类的 New 函数来实现。这是使用 RuntimeSelection 机制的类的很常规的做法。</span></span><br><span class="line">    forAllConstIter(dictionary, dict, iter)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (iter().isDict())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">const</span> word&amp; name = iter().keyword(); <span class="comment">// keyword 返回的是类似 energySource1 这样的，是这个源项的一个名字</span></span><br><span class="line">            <span class="keyword">const</span> dictionary&amp; sourceDict = iter().dict();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">set</span> <span class="comment">// set 函数，肯定毫无疑问也是从 PtrList 类中继承而来的</span></span><br><span class="line">            (</span><br><span class="line">                i++,</span><br><span class="line">                option::New(name, sourceDict, mesh_) <span class="comment">// 调用 option 类的 New 函数</span></span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，最重要的是， <code>reset</code> 里实现了对父类 <code>PtrList&lt;option&gt;</code> 的初始化。<br>理解了这些，再来看 <code>correct</code> 以及 <code>()</code> 操作符重载中的代码，就好理解了：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本来 *this 应该是 optionList 类的指针，这里先作个隐式转换，转成 PtrList&lt;option&gt; 类的指针。前面reset函数已经对 PtrList&lt;option&gt; 进行了初始化，使其读入了每一个源项。所以，这里的循环就是对每一个源项进行循环，然后调用对应的函数。operator[]肯定也是在PtrList类中定义的，i 指的是 PtrList 类的第 i 个成员，这里 PtrList 的每一个成员都是一个 option 类的对象，所以，makeAbsolute 函数是定义在 option 类中的函数。</span></span><br><span class="line">forAll(*<span class="keyword">this</span>, i)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">this</span>-&gt;<span class="keyword">operator</span>[](i).makeAbsolute(phi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据上面的理解，一个很自然的推论是，定义在 <code>fvOptions</code> 文件中的源项，其作用是叠加的。也就是说，上述的 <code>fvOptions(T)</code>，对定义在 <code>fvOptions</code> 文件中的每一个源项，都会调用一次。经测试，<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="title">firstHeatSource</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title">type</span> scalarSemiImplicitSource;</span><br><span class="line">    <span class="title">active</span>          <span class="built_in">true</span>;</span><br><span class="line">    <span class="title">selectionMode</span>   cellZone;</span><br><span class="line">    <span class="title">cellZone</span>        boxSourceZone;</span><br><span class="line">    <span class="title">scalarSemiImplicitSourceCoeffs</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title">volumeMode</span> absolute;</span><br><span class="line">        <span class="title">injectionRateSuSp</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title">T</span> (<span class="number">0</span>.<span class="number">001</span> <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="title">secondHeatSource</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title">type</span> scalarSemiImplicitSource;</span><br><span class="line">    <span class="title">active</span>          <span class="built_in">true</span>;</span><br><span class="line">    <span class="title">selectionMode</span>   cellZone;</span><br><span class="line">    <span class="title">cellZone</span>        boxSourceZone;</span><br><span class="line">    <span class="title">scalarSemiImplicitSourceCoeffs</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title">volumeMode</span> absolute;</span><br><span class="line">        <span class="title">injectionRateSuSp</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title">T</span> (<span class="number">0</span>.<span class="number">0</span> <span class="number">0</span>.<span class="number">002</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>与<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">secondHeatSource</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title">type</span> scalarSemiImplicitSource;</span><br><span class="line">    <span class="title">active</span>          <span class="built_in">true</span>;</span><br><span class="line">    <span class="title">selectionMode</span>   cellZone;</span><br><span class="line">    <span class="title">cellZone</span>        boxSourceZone;</span><br><span class="line">    <span class="title">scalarSemiImplicitSourceCoeffs</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title">volumeMode</span> absolute;</span><br><span class="line">        <span class="title">injectionRateSuSp</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title">T</span> (<span class="number">0</span>.<span class="number">0001</span> <span class="number">0</span>.<span class="number">002</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>的作用是一样的，这证实了源项的作用确实是叠加的。<br>此外，还要注意一点，那就是 <code>optionList</code> 类中重载的 <code>()</code> 运算符，其实是在调用 option 类中的 <code>addSup</code> 函数，并且其返回值是 fvMatrix 类的对象。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Type&gt;</span><br><span class="line">Foam::tmp&lt;Foam::fvMatrix&lt;Type&gt; &gt; Foam::fv::optionList::<span class="keyword">operator</span>()</span><br><span class="line">(</span><br><span class="line">    GeometricField&lt;Type, fvPatchField, volMesh&gt;&amp; fld,</span><br><span class="line">    <span class="keyword">const</span> word&amp; fieldName</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    checkApplied();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> dimensionSet ds = fld.dimensions()/dimTime*dimVolume;</span><br><span class="line"></span><br><span class="line">    tmp&lt;fvMatrix&lt;Type&gt; &gt; tmtx(<span class="keyword">new</span> fvMatrix&lt;Type&gt;(fld, ds));</span><br><span class="line">    fvMatrix&lt;Type&gt;&amp; mtx = tmtx();</span><br><span class="line"></span><br><span class="line">    forAll(*<span class="keyword">this</span>, i)</span><br><span class="line">    &#123;</span><br><span class="line">        option&amp; source = <span class="keyword">this</span>-&gt;<span class="keyword">operator</span>[](i);</span><br><span class="line"></span><br><span class="line">        label fieldI = source.applyToField(fieldName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fieldI != -<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            source.setApplied(fieldI);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (source.isActive())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (debug)</span><br><span class="line">                &#123;</span><br><span class="line">                    Info&lt;&lt; <span class="string">"Applying source "</span> &lt;&lt; source.name() &lt;&lt; <span class="string">" to field "</span></span><br><span class="line">                        &lt;&lt; fieldName &lt;&lt; endl;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                source.addSup(mtx, fieldI);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmtx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>理解了以上这些，就可以进入 <code>option</code> 类了。<br>option 类是所有具体的源项类的基类，这个类里处理了所有源项都需要处理的部分，比如确定起始时间，选择源项作用的区域，这些都是在构造函数里完成的，主要是通过调用 <code>setSelection</code> 和 <code>setCellSet</code> 两个函数。这里需要注意的是数据成员 <code>cells_</code>， <code>V_</code>  以及 <code>fieldNames_</code>，分别定义源项作用区域的网格id （这里源项的作用区域是以 cell 为基础来指定的，即便是 points 模式，实际上源项作用的区域仍然是 points 所在的 cell。）， 选定区域的体积以及需要开启源项作用的场名（有时候，求解器的多个 Eqn 里有fvOptions，但是实际算例中只想针对特定的场开启源项，这可以通过指定 fieldNames_ 来实现）。</p>
<p>注意 fieldNames 在 <code>option</code> 类中并没有初始化，需要在具体的源项类中指定。此外，<code>makeRelative</code> 等在求解器中实际调用的函数，在 <code>option</code> 类中也并没有进行具体的实现（但不是声明为纯虚函数，仅仅是函数体为空的而已，这里的结果不适合用纯虚函数）</p>
<p>以 <code>SemiImplicitSource</code> 为例，主要去看 <code>addSup</code> 函数，这个函数，关键的一个参数是<code>fieldI</code>，这个参数，指的是 <code>fieldName_</code> 这个List的 <code>applyToField</code> 函数的返回值，用来判断一个 field 是否要启用源项。<code>fieldName_</code> 这个List，是在  <code>SemiImplicitSource</code> 类的 <code>setFieldData</code> 函数中赋值的，通过读取 <code>SemiImplicitSourceCoeffs</code> 中的参数来决定。但是这个 <code>fieldName_</code> 的确定方法根据不同的类有不同的做法，要具体分析。<br>到此，<code>fvOpptions</code> 源项的调用途径就打通了，接下来可以继续具体分析特定的源项了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>上篇浅析了 fvOptions 框架的结构，这篇来看一个具体的源项类： <code>semiImplicitSource</code> 。</p>]]>
    
    </summary>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="fvOptions" scheme="http://xiaopingqiu.github.io/tags/fvOptions/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[fvOptions 浅析]]></title>
    <link href="http://xiaopingqiu.github.io/2016/03/20/fvOptions1/"/>
    <id>http://xiaopingqiu.github.io/2016/03/20/fvOptions1/</id>
    <published>2016-03-20T07:24:30.000Z</published>
    <updated>2016-03-20T09:39:58.991Z</updated>
    <content type="html"><![CDATA[<p>本篇简单介绍 OpenFOAM 中的 fvOptions。按照<a href="http://www.openfoam.org/version2.2.0/fvOptions.php" target="_blank" rel="external">官方的介绍</a>，fvOptions 是一个可以在指定区域内添加源项或者其他约束（比如固定温度，或者多孔介质等）的框架。本篇对 fvOptions 框架的源码做一个浅析。</p>
<a id="more"></a>
<p>先来了解一下 fvOptions 框架的结构，以及，在求解器中是怎么调用 fvOptions 的。为了避免问题复杂化，先从一个简单的求解器开始：<code>scalarTransportFoam</code>。OpenFOAM-2.3.1 中的 <code>scalarTransportFoam</code> 中已经引入了 <code>fvOptions</code> ，而更早的 OpenFOAM-2.1.1 中，则没有使用 <code>fvOptions</code> 。对比之下，很容易发现引入 <code>fvOptions</code> 其实就只涉及到两处代码修改：1. 增加了一个头文件 <code>createFvOptions.H</code>；2. 在 T 方程中增加了一项 <code>fvOptions(T)</code> 。 根据 OpenFOAM 的习惯，可以猜测这里增加的 <code>fvOptions(T)</code>，从C++的角度来看，多半是一个基类的对象 <code>fvOptions</code> 在调用类中重载过的 <code>()</code> 操作符。以上便是从这段简单的求解器代码中产生的对 <code>fvOptions</code> 的第一印象，下面来仔细看看 <code>fvOptions</code> 这个框架的结构。</p>
<h5 id="1-_createFvOptions-H">1. createFvOptions.H</h5><p>既然求解器里只增加了这一个头文件，那就先从这个看起。这个文件位于 <code>src/fvOptions/include</code>，内容很简单，就一句话：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="rule"><span class="attribute">fv</span>:<span class="value">:IOoptionList <span class="function">fvOptions</span>(mesh)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>从这里就很清楚地可以看出， <code>scalarTransportFoam</code> 中 T 方程中增加的 <code>fvOptions</code> 是 <code>IOoptionList</code> 类的对象。</p>
<h5 id="2-_IOoptionList_类">2. IOoptionList 类</h5><p>接下来看 <code>IOoptionList</code> 类。IOoptionList 类由两个文件组成： fvOptionList.H 和 fvOptionList.C。这里的目的在于了解 fvOptions 这个框架的结构，所以重点看头文件以及构造函数的定义。</p>
<ul>
<li>fvOptionList.H <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#ifndef IOoptionList_H</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IOoptionList_H</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "fvOptionList.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "IOdictionary.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "autoPtr.H"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Foam</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">namespace</span> fv</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> IOoptionList</span><br><span class="line">:</span><br><span class="line">    <span class="keyword">public</span> IOdictionary,</span><br><span class="line">    <span class="keyword">public</span> optionList</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Private Member Functions</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Create IO object if dictionary is present</span></span><br><span class="line">        <span class="function">IOobject <span class="title">createIOobject</span><span class="params">(<span class="keyword">const</span> fvMesh&amp; mesh)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Disallow default bitwise copy construct</span></span><br><span class="line">        IOoptionList(<span class="keyword">const</span> IOoptionList&amp;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Disallow default bitwise assignment</span></span><br><span class="line">        <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> IOoptionList&amp;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Constructors</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Construct from components with list of field names</span></span><br><span class="line">        IOoptionList(<span class="keyword">const</span> fvMesh&amp; mesh);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Destructor</span></span><br><span class="line">        <span class="keyword">virtual</span> ~IOoptionList()</span><br><span class="line">        &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Member Functions</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Read dictionary</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// End namespace fv</span></span><br><span class="line">&#125; <span class="comment">// End namespace Foam</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>从头文件可以看出， <code>IOoptionList</code> 类继承自 <code>IOdictionary</code> 和 <code>optionList</code> 类。根据对 OpenFOAM 的了解，<code>IOdictionary</code> 类是处理跟 IO 有关的，所以这里这个类很可能是用来处理 fvOptions 相关的字典文件的。真正涉及到具体的 fvOptions 源项的内容，应该是在 <code>optionList</code> 中有相关定义。</p>
<ul>
<li>构造函数<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">Foam</span><span class="pseudo">::fv</span><span class="pseudo">::IOoptionList</span><span class="pseudo">::IOoptionList</span></span><br><span class="line">(</span><br><span class="line">    const fvMesh&amp; mesh</span><br><span class="line">)</span><br><span class="line">:</span><br><span class="line">    <span class="tag">IOdictionary</span>(<span class="function">createIOobject</span>(mesh)), <span class="comment">//构造函数里创建fvOptions字典文件</span></span><br><span class="line">    <span class="tag">optionList</span>(mesh, *this)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>构造函数中调用 <code>createIOobject</code> 函数来对父类 <code>IOdictionary</code> 进行初始化，并将自己(×this) 作为参数传递给了父类 <code>optionList</code> 。</p>
<ul>
<li>createIOobject 函数<br>构造函数中调用了 <code>createIOobject</code> 函数，而且这里的调用显然至关重要，所以需要看一下这个函数<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">Foam::IOobject Foam::fv::IOoptionList::createIOobject</span><br><span class="line">(</span><br><span class="line">    const fvMesh&amp; mesh</span><br><span class="line">) const</span><br><span class="line">&#123;</span><br><span class="line">    IOobject <span class="built_in">io</span></span><br><span class="line">    (</span><br><span class="line">        <span class="string">"fvOptions"</span>,</span><br><span class="line">        mesh.time().constant(),</span><br><span class="line">        mesh,</span><br><span class="line">        IOobject::MUST_READ,</span><br><span class="line">        IOobject::NO_WRITE</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">io</span>.headerOk())</span><br><span class="line">    &#123;</span><br><span class="line">        Info&lt;&lt; <span class="string">"Creating finite volume options from "</span></span><br><span class="line">            &lt;&lt; <span class="built_in">io</span>.instance()/<span class="built_in">io</span>.name() &lt;&lt; nl</span><br><span class="line">            &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">io</span>.readOpt() = IOobject::MUST_READ_IF_MODIFIED;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">io</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        // Check <span class="keyword">if</span> the fvOptions file is <span class="keyword">in</span> system</span><br><span class="line">        <span class="built_in">io</span>.instance() = mesh.time().system();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">io</span>.headerOk())</span><br><span class="line">        &#123;</span><br><span class="line">            Info&lt;&lt; <span class="string">"Creating finite volume options from "</span></span><br><span class="line">                &lt;&lt; <span class="built_in">io</span>.instance()/<span class="built_in">io</span>.name() &lt;&lt; nl</span><br><span class="line">                &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">io</span>.readOpt() = IOobject::MUST_READ_IF_MODIFIED;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">io</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Info&lt;&lt; <span class="string">"No finite volume options present"</span> &lt;&lt; nl &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">io</span>.readOpt() = IOobject::NO_READ;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">io</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这个函数的意图就很明显了：创建了一个 <code>IOobject</code> 对象，并从 <code>system</code> 中读入文件 <code>fvOptions</code> 的内容来初始化该对象。并且，如果 <code>system</code> 目录下不存在 <code>fvOptions</code> 文件，那就尝试在 <code>constant</code> 下寻找。如果仍找不到，那就放弃读取。</p>
<h5 id="3-_optionList_类">3. optionList 类</h5><p>这个类由三个源文件定义： fvOptionList.H ， fvOptionList.C 和 fvOptionListTemplates.C。这里依然是重点关注头文件。</p>
<ul>
<li>fvOptionList.H<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#ifndef optionList_H</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> optionList_H</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "PtrList.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "GeometricField.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "fvPatchField.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "fvOption.H"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Foam</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">namespace</span> fv</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> optionList</span><br><span class="line">:</span><br><span class="line">    <span class="keyword">public</span> PtrList&lt;option&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> dictionary&amp; optionsDict(<span class="keyword">const</span> dictionary&amp; dict) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">readOptions</span><span class="params">(<span class="keyword">const</span> dictionary&amp; dict)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Constructors</span></span><br><span class="line">        optionList(<span class="keyword">const</span> fvMesh&amp; mesh);</span><br><span class="line"></span><br><span class="line">        optionList(<span class="keyword">const</span> fvMesh&amp; mesh, <span class="keyword">const</span> dictionary&amp; dict);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">const</span> dictionary&amp; dict)</span></span>;</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">            <span class="comment">//- Return source for equation</span></span><br><span class="line">            <span class="comment">// 重载的括号操作符，在求解器里，方程的构造过程中调用的就是这些括号操作符。</span></span><br><span class="line">            <span class="keyword">template</span>&lt;<span class="keyword">class</span> Type&gt;</span><br><span class="line">            tmp&lt;fvMatrix&lt;Type&gt; &gt; <span class="keyword">operator</span>()</span><br><span class="line">            (</span><br><span class="line">                <span class="keyword">const</span> volScalarField&amp; rho,</span><br><span class="line">                GeometricField&lt;Type, fvPatchField, volMesh&gt;&amp; fld</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// End namespace fv</span></span><br><span class="line">&#125; <span class="comment">// End namespace Foam</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#ifdef NoRepository</span></span><br><span class="line">    <span class="preprocessor">#<span class="keyword">include</span> "fvOptionListTemplates.C"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这里注意两点，一是 <code>optionList</code> 类继承自 <code>PtrList&lt;option&gt;</code> ，另一个是，这里出现了重载的运算符 <code>()</code> 。继承自 <code>PtrList&lt;option&gt;</code> 意味着很可能 fvOptions 类是支持同时定义多个源项的。</p>
<ul>
<li>构造函数<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="rule"><span class="attribute">Foam</span>:<span class="value">:fv::optionList::<span class="function">optionList</span>(const fvMesh&amp; mesh, const dictionary&amp; dict)</span><br><span class="line">:</span><br><span class="line">    PtrList&lt;option&gt;(),</span><br><span class="line">    <span class="function">mesh_</span>(mesh),</span><br><span class="line">    <span class="function">checkTimeIndex_</span>(mesh_.<span class="function">time</span>().<span class="function">startTimeIndex</span>() + <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">reset</span>(<span class="function">optionsDict</span>(dict))</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>构造函数里，调用了 <code>reSet</code> 和 <code>optionsDict</code> 函数。下面看一下这两个函数的作用：</p>
<ul>
<li>optionsDict 函数<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Foam::dictionary&amp; Foam::fv::optionList::optionsDict</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> dictionary&amp; dict</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (dict.found(<span class="string">"options"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> dict.subDict(<span class="string">"options"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> dict;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这个函数需要一个参数 <code>const dictionary&amp; dict</code>，这个参数，显然是从构造函数的 <code>const dictionary&amp; dict</code> ，再回顾一下上文中，<code>IOoptionList</code> 中将自己本身（*this）传递给父类 <code>optionsDict</code> ，而且， <code>IOoptionList</code> 同时也继承自 <code>IOdictionary</code> 类，并且将从文件 <code>fvOptions</code> 类中读取的内容来对其父类 <code>IOdictionary</code> 类。所以这里不难理解，参数 <code>const dictionary&amp; dict</code> 其实就是文件 <code>fvOptions</code> 的内容。这里需要从文件中 <code>fvOptions</code> 寻找关键字 <code>options</code> ，如果找到，那就返回 <code>options</code> 所指定的 <code>subDict</code> ，否则就直接返回 <code>fvOptions</code> 本身。</p>
<ul>
<li>reset 函数<br>再来看 reset 函数：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Foam::fv::optionList::reset(<span class="keyword">const</span> dictionary&amp; dict)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Count number of active fvOptions</span></span><br><span class="line">    label count = <span class="number">0</span>;</span><br><span class="line">    forAllConstIter(dictionary, dict, iter)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (iter().isDict())</span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;setSize(count);</span><br><span class="line">    label i = <span class="number">0</span>;</span><br><span class="line">    forAllConstIter(dictionary, dict, iter)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (iter().isDict())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">const</span> word&amp; name = iter().keyword();</span><br><span class="line">            <span class="keyword">const</span> dictionary&amp; sourceDict = iter().dict();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">set</span></span><br><span class="line">            (</span><br><span class="line">                i++,</span><br><span class="line">                option::New(name, sourceDict, mesh_)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>注意在构造函数里，这个函数的参数是 <code>optionsDict</code> 类的返回值。这里，函数是在统计 <code>fvOptions</code> 中有效的 <code>options</code> 的个数，并根据每一个有效的 <code>options</code> ，调用 <code>option</code> 类的 <code>New</code> 函数（看到 New 函数，很自然就会想到 Run Time Selection 吧！）来构造对象指针，且将该指针存到 <code>PtrList</code> 类定义的 List 里。 这里更是直接能看出来，在文件 <code>fvOptions</code> 中，是可以同时定义多个源项的。 </p>
<h5 id="4-_option_类">4. option 类</h5><p>再继续看 <code>option</code> 类。<code>option</code> 类由四个源文件定义： <code>fvOption.H</code> ， <code>fvOption.C</code> ， <code>fvOptionI.H</code> 和 <code>fvOptionIO.C</code> 。</p>
<ul>
<li><p>fvOption.H</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#ifndef fvOption_H</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> fvOption_H</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "fvMatricesFwd.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "volFieldsFwd.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "cellSet.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "autoPtr.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "meshToMesh.H"</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "runTimeSelectionTables.H"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Foam</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">class</span> fvMesh；</span><br><span class="line"><span class="keyword">namespace</span> fv</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> option</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Public data</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Enumeration for selection mode types</span></span><br><span class="line">        <span class="keyword">enum</span> selectionModeType</span><br><span class="line">        &#123;</span><br><span class="line">            smPoints,</span><br><span class="line">            smCellSet,</span><br><span class="line">            smCellZone,</span><br><span class="line">            smMapRegion,</span><br><span class="line">            smAll</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p><code>option</code> 类终于不再继承自其他类了。而且，包含的头文件中有 <code>#include &quot;runTimeSelectionTables.H&quot;</code> 可以猜想，这个类肯定是作为接口的基类来使用的。<br>经验证，具体的源项类，如 <code>semiImplicitSource</code>，都是继承自 <code>option</code> 类的。当然，这里会用到 RTS 机制来提供灵活地源项选择。和其他的作为接口使用的基类类似， <code>option</code> 类中定义了所有的具体源项类可能用到的控制选项，比如，区域的选择（Points，cellSet，cellZone，mapRegion，all），开始时间（timeStart），持续时间（duration）激活开关（active）以及各个可能调用到的函数。</p>
</li>
</ul>
<p>至此，fvOptions 框架的结构就大体理清了，总结如下图：</p>
<p><img src="/image/fvOptions/fvOptions.png" alt="fvOptions 框架的结构"></p>
<h5 id="参考">参考</h5><ol>
<li><a href="http://www.sourceflux.de/blog/series/fvoptions/" target="_blank" rel="external">http://www.sourceflux.de/blog/series/fvoptions/</a></li>
<li><a href="http://www.openfoam.org/version2.2.0/fvOptions.php" target="_blank" rel="external">http://www.openfoam.org/version2.2.0/fvOptions.php</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>本篇简单介绍 OpenFOAM 中的 fvOptions。按照<a href="http://www.openfoam.org/version2.2.0/fvOptions.php">官方的介绍</a>，fvOptions 是一个可以在指定区域内添加源项或者其他约束（比如固定温度，或者多孔介质等）的框架。本篇对 fvOptions 框架的源码做一个浅析。</p>]]>
    
    </summary>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="fvOptions" scheme="http://xiaopingqiu.github.io/tags/fvOptions/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[湍流模型中的 RTS 机制分析]]></title>
    <link href="http://xiaopingqiu.github.io/2016/03/12/RTS2/"/>
    <id>http://xiaopingqiu.github.io/2016/03/12/RTS2/</id>
    <published>2016-03-12T06:25:54.000Z</published>
    <updated>2016-03-12T08:21:00.646Z</updated>
    <content type="html"><![CDATA[<p>有了上一篇博文的基础，就可以来填一个<a href="http://xiaopingqiu.github.io/2015/11/25/OpenFOAM-singlePhase-turbulenceModel/" target="_blank" rel="external">坑</a>了，即分析 OpenFOAM 中湍流模型框架中的 RTS 。上一篇博文，使用的程序比较简单，这里通过一个实际使用 RTS 机制的例子来加深对 RTS 的理解。</p>
<a id="more"></a>
<p>经过前面对那段简单代码的分析，可以知道， <code>declareRunTimeSelectionTable</code> 宏函数的主要功能是声明了一个 <code>hashTable</code>，并定义了一个指向这个<code>hashTable</code> 的指针， 然后还声明了几个辅助的类。 <code>defineRunTimeSelectionTable</code> 这个宏函数的主要作用是对 <code>declareRunTimeSelectionTable</code> 中的 <code>hashTable</code> 指针进行了初始化。 <code>addToRunTimeSelectionTable</code> 的主要作用是将当前类的类名以及返回当前类的对象的一个函数分别作为 <code>hashTable</code> 的 key 和 value 插入到 <code>hashTable</code> 中。下面来看这些宏函数在湍流模型框架中是怎么使用的。</p>
<h5 id="1-_turbulenceModel_类">1. turbulenceModel 类</h5><p>类体中，调用 <code>declareRunTimeNewSelectionTable</code> 宏函数<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> declareRunTimeNewSelectionTable</span><br><span class="line"> <span class="list">(</span><br><span class="line">    <span class="keyword">autoPtr</span>,</span><br><span class="line">    turbulenceModel,</span><br><span class="line">    turbulenceModel,</span><br><span class="line">    <span class="list">(</span><br><span class="line">        <span class="keyword">const</span> volVectorField&amp; U,</span><br><span class="line">        const surfaceScalarField&amp; phi,</span><br><span class="line">        transportModel&amp; transport,</span><br><span class="line">        const word&amp; turbulenceModelName</span><br><span class="line">    )</span>,</span><br><span class="line">    <span class="list">(<span class="keyword">U</span>, phi, transport, turbulenceModelName)</span></span><br><span class="line">)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>注意这里用的是 <code>declareRunTimeNewSelectionTable</code>！与 <code>declareRunTimeSelectionTable</code> 区别在于，<code>declareRunTimeNewSelectionTable</code> 这个宏函数定义的插入到 <code>hashTable</code> 中的那个函数，返回值不是派生类的对象，而是派生类中的 <code>New</code> 函数的返回值！<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static autoPtr&lt; baseType &gt; New<span class="comment">##baseType argList                      \</span></span><br><span class="line">&#123;                                                                     <span class="string">\</span></span><br><span class="line">    <span class="keyword">return</span> autoPtr&lt; baseType &gt;(baseType<span class="comment">##Type::New parList.ptr());    \</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span>                                                                <span class="string">\</span></span><br><span class="line">(                                                                 <span class="string">\</span></span><br><span class="line">   !argNames<span class="comment">##ConstructorTablePtr_-&gt;insert                        \</span></span><br><span class="line">    (                                                             <span class="string">\</span></span><br><span class="line">        lookup,                                                   <span class="string">\</span></span><br><span class="line">        New<span class="comment">##baseType                                             \</span></span><br><span class="line">    )                                                             <span class="string">\</span></span><br><span class="line">)                                                                 <span class="string">\</span></span><br></pre></td></tr></table></figure></p>
<p>这说明，这里的派生类 <code>RASModel</code> 将不会作为一个具体的湍流模型来使用。而是用来选择 <code>RAS</code>类型的具体湍流模型的一个跳板。</p>
<p>类体外，调用<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">defineTypeNameAndDebug<span class="list">(<span class="keyword">turbulenceModel</span>, <span class="number">0</span>)</span><span class="comment">;</span></span><br><span class="line">defineRunTimeSelectionTable<span class="list">(<span class="keyword">turbulenceModel</span>, turbulenceModel)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>注意，这里没有调用 <code>addToRunTimeSelectionTable</code> 宏函数， <code>turbulenceModel</code> 类是基类，也不会作为具体的湍流模型来调用，所以不需要将它自己添加到 <code>hashTable</code>。</p>
<h5 id="2-_RASModel">2. RASModel</h5><p><code>turbulenceModel</code> 类下一层的派生类是 <code>RASModel</code> 和 <code>LESModel</code> 。先来看 <code>RASModel</code>，这个类类体里调用了 <code>declareRunTimeSelectionTable</code> 。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">declareRunTimeSelectionTable</span><br><span class="line"><span class="list">(</span><br><span class="line">    <span class="keyword">autoPtr</span>,</span><br><span class="line">    RASModel,</span><br><span class="line">    dictionary,</span><br><span class="line">    <span class="list">(</span><br><span class="line">        <span class="keyword">const</span> volVectorField&amp; U,</span><br><span class="line">        const surfaceScalarField&amp; phi,</span><br><span class="line">        transportModel&amp; transport,</span><br><span class="line">        const word&amp; turbulenceModelName</span><br><span class="line">    )</span>,</span><br><span class="line">    <span class="list">(<span class="keyword">U</span>, phi, transport, turbulenceModelName)</span></span><br><span class="line">)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>类体外调用了<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">defineTypeNameAndDebug<span class="list">(<span class="keyword">RASModel</span>, <span class="number">0</span>)</span><span class="comment">;</span></span><br><span class="line">defineRunTimeSelectionTable<span class="list">(<span class="keyword">RASModel</span>, dictionary)</span><span class="comment">;</span></span><br><span class="line">addToRunTimeSelectionTable<span class="list">(<span class="keyword">turbulenceModel</span>, RASModel, turbulenceModel)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>根据前面的分析，这里 RASModel 又创建了一个新的 <code>hashTable</code>， 用的是 <code>declareRunTimeSelectionTable</code> 和 <code>defineRunTimeSelectionTable(RASModel, dictionary);</code> ，同时，RASModel类 本身又添加到了 <code>turbulenceModel</code> 中建立的 <code>hashTable</code> 里： <code>addToRunTimeSelectionTable(turbulenceModel, RASModel, turbulenceModel);</code> </p>
<p><code>RASModel</code> 类之下的派生类，就是具体的湍流模型了，这里以 <code>kEpsilon</code> 模型为例：</p>
<ul>
<li>kEpsilon<br>具体的湍流模型，如<code>kEpsilon</code> ，只需要添加到上面基类中创建的 <code>hashTable</code> 中，就能保证其能被调用到。<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addToRunTimeSelectionTable<span class="list">(<span class="keyword">RASModel</span>, kEpsilon, dictionary)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这里是添加到了 RASModel 中创建的 <code>hashTable</code> 里。</p>
<h5 id="3-_LESModel">3. LESModel</h5><p><code>LESModel</code> 类也是继承自 <code>turbulenceModel</code> 的，所以其处理方法跟 <code>RASModel</code> 是一样的。不过 <code>LES</code> 类的模型的继承关系略比 <code>RAS</code> 类的复杂一点（参看<a href="http://xiaopingqiu.github.io/2015/11/25/OpenFOAM-singlePhase-turbulenceModel/" target="_blank" rel="external">这篇</a>中的 LES 模型继承关系图）。在这个图中，中间层的 <code>GenEddyVisc</code> 等4个虚线框中的类不是作为具体的湍流模型来调用的，这里有必要看一下这样的中间类在 RTS 机制中是怎么处理的。检查这几个类的代码，可以发现 <code>GenEddyVisc</code> 和 <code>GenSGSStress</code> 中只是在类体外调用了 <code>defineTypeNameWithName(GenEddyVisc, &quot;GenEddyVisc&quot;);</code> ， <code>scaleSimilarity</code> 在类体中调用了 <code>TypeName</code>，类体外调用了 <code>defineTypeNameAndDebug</code> ，<code>DESModel</code> 中没有任何处理。可见这些类只是对 <code>typeName</code> 做了处理，并没有调用 <code>addToRunTimeSelectionTable</code> 。<br>同 <code>RASModel</code> 一样， <code>LESModel</code> 之下派生的具体的湍流模型则需要调用 <code>addToRunTimeSelectionTable</code> 来将自己添加到 <code>LESModel</code> 中定义的 <code>hashTable</code> 中。</p>
<p>由上可知，湍流模型的调用过程大致是这样的：<br>求解器里创建一个 <code>turbulenceModel</code> 类型的 <code>autoPtr</code>，并调用 <code>turbulenceModel::New</code> 来初始化。 <code>turbulenceModel::New</code> 从 turbulenceProperties 文件中读取关键字，假设读取到 simulationType 为 <code>RASModel</code> ，则 <code>turbulenceModel::New</code> 的 <code>cstrIter()</code> 返回的是 <code>RASModel::New</code>，于是 <code>cstrIter()(U, phi, transport, turbulenceModelName)</code> 则是在调用 <code>RASModel::New</code>。然后， <code>RASModel::New</code> 从 RASProperties 文件里读取关键字，并根据读取到的内容，从 <code>RASModel</code> 类中创建的 <code>hashTable</code> 里查找对应的湍流模型，假设从 RASProperties 中读取到的是 <code>kEpsilon</code>， 则返回一个 <code>kEpsilon</code> 模型的对象。最终结果是，求解器里创建的<code>turbulenceModel</code> 类型的 <code>autoPtr</code> 指向了 <code>kEpsilon</code> 类的对象，这就实现了对 <code>kEpsilon</code> 模型的调用。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>有了上一篇博文的基础，就可以来填一个<a href="http://xiaopingqiu.github.io/2015/11/25/OpenFOAM-singlePhase-turbulenceModel/">坑</a>了，即分析 OpenFOAM 中湍流模型框架中的 RTS 。上一篇博文，使用的程序比较简单，这里通过一个实际使用 RTS 机制的例子来加深对 RTS 的理解。</p>]]>
    
    </summary>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="RTS" scheme="http://xiaopingqiu.github.io/tags/RTS/"/>
    
      <category term="turbulence model" scheme="http://xiaopingqiu.github.io/tags/turbulence-model/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenFOAM 中的 Run Time Selection 机制]]></title>
    <link href="http://xiaopingqiu.github.io/2016/03/12/RTS1/"/>
    <id>http://xiaopingqiu.github.io/2016/03/12/RTS1/</id>
    <published>2016-03-12T05:06:48.000Z</published>
    <updated>2016-04-25T02:26:02.469Z</updated>
    <content type="html"><![CDATA[<p><a href="http://www.sourceflux.de/blog/series/rts-2/" target="_blank" rel="external">source flux 博客</a> 曾经出过一个解释 Run Time Selection(RTS) 机制的系列博文，推荐想理解 RTS 的读者去仔细读读。本篇算是我在读完以后做的一个笔记，以及一些总结，供读者参考。</p>
<a id="more"></a>
<p>OpenFOAM 中包含各个 CFD 相关的模块，每个模块，从 C++ 的角度来看，其实都是一个类的框架。基类用作接口，一个派生类则是一个具体的模型。OpenFOAM 中的模块广泛使用 RTS 机制，因此 OpenFOAM 的求解器中，只需要设定模型的调用接口。算例具体使用的是那个模型，则是在运行时才确定的，而且可以在算例运行过程中修改选中的模型。下面通过一个 <a href="http://www.sourceflux.de/blog/run-time-type-selection-openfoam-selecting-types-based-type-name/" target="_blank" rel="external">source flux 博客</a> 提供的代码，来解读 RTS 机制的实现原理。<br>为了方便解读，这里将代码摘录如下，代码所有权归 <a href="http://www.sourceflux.de/blog/run-time-type-selection-openfoam-selecting-types-based-type-name/" target="_blank" rel="external">source flux 博客</a> 所有：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "word.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "messageStream.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "argList.H"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Foam;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "typeInfo.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "runTimeSelectionTables.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "addToRunTimeSelectionTable.H"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Main program:</span></span><br><span class="line"><span class="keyword">class</span> AlgorithmBase</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Declare the static variable typeName of the class AlgorithmBase.</span></span><br><span class="line">        TypeName (<span class="string">"base"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Empty constructor. </span></span><br><span class="line">        AlgorithmBase () &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Word constructor.</span></span><br><span class="line">        AlgorithmBase (<span class="keyword">const</span> word&amp; algorithmName) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Destructor: needs to be declared virtual since </span></span><br><span class="line">        <span class="keyword">virtual</span> ~AlgorithmBase() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Macro for declaring stuff required for RTS </span></span><br><span class="line">        declareRunTimeSelectionTable</span><br><span class="line">        (</span><br><span class="line">            autoPtr, </span><br><span class="line">            AlgorithmBase, </span><br><span class="line">            Word, </span><br><span class="line">            (</span><br><span class="line">                <span class="keyword">const</span> word&amp; algorithmName</span><br><span class="line">            ),</span><br><span class="line">            (algorithmName)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment">// static Factory Method (selector)</span></span><br><span class="line">        <span class="keyword">static</span> autoPtr&lt;AlgorithmBase&gt; New (<span class="keyword">const</span> word&amp; algorithmName)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Find the Factory Method pointer in the RTS Table </span></span><br><span class="line">            <span class="comment">// (HashTable&lt;word, autoPtr&lt;AlgorithmBase&gt;(*)(word))</span></span><br><span class="line">            WordConstructorTable::iterator cstrIter =</span><br><span class="line">                WordConstructorTablePtr_-&gt;find(algorithmName);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If the Factory Method was not found. </span></span><br><span class="line">            <span class="keyword">if</span> (cstrIter == WordConstructorTablePtr_-&gt;end())</span><br><span class="line">            &#123;</span><br><span class="line">                FatalErrorIn</span><br><span class="line">                (</span><br><span class="line">                    <span class="string">"AlgorithmBase::New(const word&amp;)"</span></span><br><span class="line">                )   &lt;&lt; <span class="string">"Unknown AlgorithmBase type "</span></span><br><span class="line">                    &lt;&lt; algorithmName &lt;&lt; nl &lt;&lt; nl</span><br><span class="line">                    &lt;&lt; <span class="string">"Valid AlgorithmBase types are :"</span> &lt;&lt; endl</span><br><span class="line">                    &lt;&lt; WordConstructorTablePtr_-&gt;sortedToc()</span><br><span class="line">                    &lt;&lt; <span class="built_in">exit</span>(FatalError);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Call the "constructor" and return the autoPtr&lt;AlgorithmBase&gt;</span></span><br><span class="line">            <span class="keyword">return</span> cstrIter()(algorithmName);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make the class callable (function object) </span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="comment">// Overridable default implementation</span></span><br><span class="line">            Info &lt;&lt; <span class="string">"AlgorithmBase::operator()()"</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">defineTypeNameAndDebug(AlgorithmBase, <span class="number">0</span>);</span><br><span class="line">defineRunTimeSelectionTable(AlgorithmBase, Word);</span><br><span class="line">addToRunTimeSelectionTable(AlgorithmBase, AlgorithmBase, Word);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> AlgorithmNew</span><br><span class="line">:</span><br><span class="line">    <span class="keyword">public</span> AlgorithmBase</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Declare the static variable typeName of the class AlgorithmNew.</span></span><br><span class="line">        TypeName (<span class="string">"new"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Empty constructor. </span></span><br><span class="line">        AlgorithmNew () &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Word constructor.</span></span><br><span class="line">        AlgorithmNew (<span class="keyword">const</span> word&amp; algorithmName) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make the class callable (function object) </span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span><br><span class="line">        </span>&#123;</span><br><span class="line">            Info &lt;&lt; <span class="string">"AlgorithmNew::operator()()"</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">defineTypeNameAndDebug(AlgorithmNew, <span class="number">0</span>);</span><br><span class="line">addToRunTimeSelectionTable(AlgorithmBase, AlgorithmNew , Word);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> AlgorithmAdditional</span><br><span class="line">:</span><br><span class="line">    <span class="keyword">public</span> AlgorithmNew </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Declare the static variable typeName of the class AlgorithmAdditional.</span></span><br><span class="line">        TypeName (<span class="string">"additional"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Empty constructor. </span></span><br><span class="line">        AlgorithmAdditional () &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Word constructor.</span></span><br><span class="line">        AlgorithmAdditional (<span class="keyword">const</span> word&amp; algorithmName) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make the class callable (function object) </span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="comment">// Call base operator explicitly.</span></span><br><span class="line">            AlgorithmNew::<span class="keyword">operator</span>()();</span><br><span class="line">            <span class="comment">// Perform additional operations.</span></span><br><span class="line">            Info &lt;&lt; <span class="string">"AlgorithmAdditional::operator()()"</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">defineTypeNameAndDebug(AlgorithmAdditional, <span class="number">0</span>);</span><br><span class="line">addToRunTimeSelectionTable(AlgorithmBase, AlgorithmAdditional , Word);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    argList::addOption</span><br><span class="line">    (</span><br><span class="line">        <span class="string">"algorithmName"</span>,</span><br><span class="line">        <span class="string">"name of the run-time selected algorithm"</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="function">argList <span class="title">args</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (args.optionFound(<span class="string">"algorithmName"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Get the name of the algorithm from the arguments passed to the</span></span><br><span class="line">        <span class="comment">// application. </span></span><br><span class="line">        <span class="keyword">const</span> word algorithmName = args.option(<span class="string">"algorithmName"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// RTS call. </span></span><br><span class="line">        autoPtr&lt;AlgorithmBase&gt; algorithmPtr = AlgorithmBase::New(algorithmName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get the reference to the algorithm from the smart pointer.</span></span><br><span class="line">        AlgorithmBase&amp; algorithm = algorithmPtr(); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Call the algorithm.</span></span><br><span class="line">        algorithm(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        FatalErrorIn</span><br><span class="line">        (</span><br><span class="line">            <span class="string">"main()"</span></span><br><span class="line">        )   &lt;&lt; <span class="string">"Please use with the 'algorithmName' option."</span> &lt;&lt; endl</span><br><span class="line">            &lt;&lt; <span class="built_in">exit</span>(FatalError);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Info&lt;&lt; <span class="string">"\nEnd\n"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在解读原理之前，先来看看这段代码。可以发现，RTS 机制的实现跟几个函数的调用有关： <code>declareRunTimeSelectionTable</code>， <code>defineRunTimeSelectionTable</code>， <code>defineTypeNameAndDebug</code>， <code>addToRunTimeSelectionTable</code>。规律可以总结如下：</p>
<ol>
<li>基类类体里调用 <code>TypeName</code> 和 <code>declareRunTimeSelectionTable</code> 两个函数，类体外面调用 <code>defineTypeNameAndDebug</code> ， <code>defineRunTimeSelectionTable</code> 和 <code>addToRunTimeSelectionTable</code> 三个函数；</li>
<li>基类中需要一个静态 <code>New</code> 函数作为 <code>selector</code>。 </li>
<li>派生类类体中需要调用 <code>TypeName</code> 函数，类体外调用 <code>defineRunTimeSelectionTable</code> 和 <code>addToRunTimeSelectionTable</code> 两个宏函数。</li>
</ol>
<p>以上函数，经过搜索，发现都是定义在 <code>runTimeSelectionTables.H</code> 和 <code>addToRunTimeSelectionTable.H</code> 两个头文件中，而且，这些函数都是宏函数。</p>
<p>看来，理解 RTS 的第一步就需要仔细看看这几个宏函数。</p>
<p>先来看基类中的宏函数 <code>declareRunTimeSelectionTable</code> ，根据 <a href="http://www.sourceflux.de/blog/run-time-type-selection-openfoam-selecting-types-based-type-name/" target="_blank" rel="external">source flux 的博文</a>，这个宏函数针对前面的那段代码的展开结果为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> autoPtr&lt; AlgorithmBase &gt; (*WordConstructorPtr)( <span class="keyword">const</span> word&amp; algorithmName );</span><br><span class="line">   </span><br><span class="line"><span class="keyword">typedef</span> HashTable&lt; WordConstructorPtr, word, <span class="built_in">string</span>::hash &gt; WordConstructorTable;</span><br><span class="line"><span class="keyword">static</span> WordConstructorTable* WordConstructorTablePtr_;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">constructWordConstructorTables</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">destroyWordConstructorTables</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> AlgorithmBaseType &gt;</span><br><span class="line"><span class="keyword">class</span> addWordConstructorToTable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> autoPtr&lt; AlgorithmBase &gt; New ( <span class="keyword">const</span> word&amp; algorithmName )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> autoPtr&lt; AlgorithmBase &gt;(<span class="keyword">new</span> AlgorithmBaseType (algorithmName));</span><br><span class="line">    &#125;</span><br><span class="line">    addWordConstructorToTable ( <span class="keyword">const</span> word&amp; lookup = AlgorithmBaseType::typeName )</span><br><span class="line">    &#123;</span><br><span class="line">        constructWordConstructorTables();</span><br><span class="line">        <span class="keyword">if</span> (!WordConstructorTablePtr_-&gt;insert(lookup, New))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cerr</span>&lt;&lt; <span class="string">"Duplicate entry "</span></span><br><span class="line">                &lt;&lt; lookup &lt;&lt; <span class="string">" in runtime selection table "</span></span><br><span class="line">                &lt;&lt; <span class="string">"AlgorithmBase"</span> &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">            error::safePrintStack(<span class="built_in">std</span>::<span class="built_in">cerr</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~addWordConstructorToTable()</span><br><span class="line">    &#123;</span><br><span class="line">        destroyWordConstructorTables();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> AlgorithmBaseType &gt;</span><br><span class="line"><span class="keyword">class</span> addRemovableWordConstructorToTable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> word&amp; lookup_;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> autoPtr&lt; AlgorithmBase &gt; New ( <span class="keyword">const</span> word&amp; algorithmName )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> autoPtr&lt; AlgorithmBase &gt;(<span class="keyword">new</span> AlgorithmBaseType (algorithmName));</span><br><span class="line">    &#125;</span><br><span class="line">    addRemovableWordConstructorToTable ( <span class="keyword">const</span> word&amp; lookup = AlgorithmBaseType::typeName )</span><br><span class="line">    : lookup_(lookup)</span><br><span class="line">    &#123;</span><br><span class="line">        constructWordConstructorTables();</span><br><span class="line">        WordConstructorTablePtr_-&gt;<span class="built_in">set</span>(lookup, New);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    ~addRemovableWordConstructorToTable()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (WordConstructorTablePtr_)</span><br><span class="line">        &#123;</span><br><span class="line">            WordConstructorTablePtr_-&gt;erase(lookup_);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意，由于 <code>declareRunTimeSelectionTable</code> 是在基类类体里调用的，所以，以上内容都是在类体里的。这相当于在类体了定义了两个 <code>typedef</code>，一个静态数据成员，两个静态函数，还有两个类。<br>先来看这两个 <code>typedef</code> 。第一个，定义的是一个函数指针，这样定义的结果是， <code>WordConstructorPtr</code> 代表一个指向参数为 <code>const word&amp;</code>，返回类型为 <code>autoPtr&lt; AlgorithmBase &gt;</code> 的函数指针。第二个好理解，将一个 key 和 value 分别为 <code>word</code> 和 <code>WordConstructorPtr</code> 的 <code>hashTable</code> 定义了一个别名 <code>WordConstructorTable</code> 。<br>静态数据成员 <code>WordConstructorTablePtr_</code> 是一个 <code>WordConstructorTable</code> 类型的指针。<br>两个静态成员函数，这里只是声明了，并且注意到在下面定义的两个类中用到了这两个函数。</p>
<p>继续看 <code>defineRunTimeSelectionTable(AlgorithmBase, Word)</code>。这个宏展开的结果为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">AlgorithmBase::WordConstructorTable* AlgorithmBase::WordConstructorTablePtr_ = __null;</span><br><span class="line">    <span class="keyword">void</span> AlgorithmBase::constructWordConstructorTables() &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">bool</span> constructed = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!constructed) &#123;</span><br><span class="line">            constructed = <span class="keyword">true</span>;</span><br><span class="line">            AlgorithmBase::WordConstructorTablePtr_ = <span class="keyword">new</span> AlgorithmBase::WordConstructorTable;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> AlgorithmBase::destroyWordConstructorTables() &#123;</span><br><span class="line">        <span class="keyword">if</span> (AlgorithmBase::WordConstructorTablePtr_) &#123;</span><br><span class="line">            <span class="keyword">delete</span> AlgorithmBase::WordConstructorTablePtr_;</span><br><span class="line">            AlgorithmBase::WordConstructorTablePtr_ = __null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></p>
<p>这个宏函数的主要功能，是对 <code>declareRunTimeSelectionTable</code> 中定义的静态数据成员和两个静态函数进行了定义。首先对静态数据成员 <code>WordConstructorTablePtr_</code> 初始化为 <code>__null</code>，然后 <code>constructWordConstructorTables</code> 函数将 <code>WordConstructorTablePtr_</code> 指向一个动态分配的 <code>WordConstructorTable</code> 。 <code>destroyWordConstructorTables</code> 则是对指针 <code>WordConstructorTablePtr_</code> 进行销毁。</p>
<p>接着， <code>addToRunTimeSelectionTable(AlgorithmBase, AlgorithmBase, Word)</code> ，这宏函数展开以后其实就一句话：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="rule"><span class="attribute">AlgorithmBase</span>:<span class="value">:addWordConstructorToTable&lt; AlgorithmBase &gt; addAlgorithmBaseWordConstructorToAlgorithmBaseTable_</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>这个语句，定义了一个 <code>addWordConstructorToTable</code> 的对象，仅此而已。但是，注意在创建一个类的对象的时候，是要调用该类的构造函数的。回头看 <code>addWordConstructorToTable</code> 类的构造函数，有意思的地方出现了。这个类的构造函数中，首先调用了 <code>constructWordConstructorTables</code> 函数，即对指针 <code>WordConstructorTablePtr_</code> 进行了初始化。然后，对 <code>WordConstructorTablePtr_</code> 进行 <code>insert</code> 操作，即，往其指向的 <code>hashTable</code> 插入 <code>key-value</code> 对。这里的 key 是创建对象 <code>addAlgorithmBaseWordConstructorToAlgorithmBaseTable_</code> 时代入的模板参数对应的 类的 <code>typeName</code>（这一句很长很绕，需要好好理解，因为很重要！），value 则是  <code>New</code> 函数。这个 <code>New</code> 函数，指的是定义在 <code>addWordConstructorToTable</code> 中的 <code>New</code> 函数。这个 <code>New</code> 函数非常重要，再写一遍：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> autoPtr&lt; AlgorithmBase &gt; <span class="keyword">New</span> ( <span class="keyword">const</span> word&amp; algorithmName )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> autoPtr&lt; AlgorithmBase &gt;(<span class="keyword">new</span> AlgorithmBaseType (algorithmName));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个<code>New</code> 函数，返回的是一个 <code>AlgorithmBaseType</code>（这里是 AlgorithmBase ） 类型的临时对象的指针！对应这里的情形，现在可以知道这个 <code>insert</code> 操作将创建一个 “类的typeName — 返回类的临时对象的引用的函数” 映射对，并增加到 <code>WordConstructorTablePtr_</code> 中（看来 <code>ddToRunTimeSelectionTable</code> 中创建一个 <code>addWordConstructorToTable</code> 类的对象，居然目的是为了调用其构造函数。）。如果 <code>insert</code> 操作失败（原因是想要插入的 key 与 <code>hashTable</code> 已有的重复了，所以每一个类都需要不同的 typeName！），就会报条目重复的错。</p>
<p>好了，看完了基类相关的，在往下看派生类。前文已讲，派生类只需要在类体里调用 <code>TypeName</code>，然后在类体外调用 <code>addToRunTimeSelectionTable</code> 。对于派生类 <code>AlgorithmNew</code>，我们来看其具体的调用语句是<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addToRunTimeSelectionTable<span class="list">(<span class="keyword">AlgorithmBase</span>, AlgorithmNew , Word)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>展开的结果应该是<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="rule"><span class="attribute">AlgorithmBase</span>:<span class="value">:addWordConstructorToTable&lt; AlgorithmNew &gt; addAlgorithmNewWordConstructorToAlgorithmBaseTable_</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>注意，这里又创建了一个 <code>addWordConstructorToTable</code> 类的对象，只是这里代入的模板参数是 <code>AlgorithmNew</code> 。于是，调用类的构造函数时代入的模板参数也就变了，所以这时 <code>New</code> 函数返回的将是 <code>AlgorithmNew</code> 类的临时对象的指针。并且， AlgorithmNew 这个名字与其对应的 <code>New</code> 函数组成的映射对，也被 <code>insert</code> 到 <code>WordConstructorTablePtr_</code> 里面。</p>
<p>而 <code>AlgorithmAdditional</code> 这个类，虽然是继承自 <code>AlgorithmNew</code> ，但是也是间接继承 <code>AlgorithmBase</code> 。并且，在 <code>AlgorithmAdditional</code> 类的类体之后调用的宏函数 <code>addToRunTimeSelectionTable(AlgorithmBase, AlgorithmAdditional , Word)</code>  ，依然是将构建的映射对添加到了同一个 <code>hashTable</code> 里。</p>
<p>最后，再来看一下 <code>selector</code>，即基类中定义的 <code>New</code> 函数。这个函数的返回值类型为 <code>autoPtr&lt;AlgorithmBase&gt;</code> ，参数为跟类的 <code>typeName</code> 一样，都是 <code>word&amp;</code>。这个函数里面，首先定义了一个 <code>hashTable</code> 的迭代器 <code>cstrIter</code> ，利用迭代器来遍历搜索，看 <code>WordConstructorTable</code> 里面是否能找到参数 <code>algorithmName</code> 相符的 key 值，如果找不到，那就报错退出，并输出当前的 <code>WordConstructorTable</code> 中可选的项的名称（即 WordConstructorTablePtr_-&gt;sortedToc()）；如果找到了，那就返回这个 key 对应的 value。而 <code>WordConstructorTable</code> 的 value 是一个函数指针，所以 <code>cstrIter()</code> 返回的是 <code>algorithmName</code> 对应的那个 <code>New</code> 函数（不要跟基类 <code>AlgorithmBase</code> 中作为 selector 的 <code>New</code> 函数搞混了！）。进一步看， <code>cstrIter()(algorithmName)</code> 则表示的是函数调用了，传给函数的参数正是 <code>algorithmName</code>！<br><strong>所以， <code>cstrIter()(algorithmName)</code> 返回的是 <code>autoPtr&lt;AlgorithmBase&gt;</code> ，其指向的是 <code>typeName = algorithmName</code> 的类的对象！</strong><br>这样就实现了 <code>New</code> 函数作为 selector 的功能！</p>
<p>所以，RTS 机制的本质可以总结如下：</p>
<ol>
<li><p>基类里定义一个 <code>hashTable</code>，其 key 为类的 <code>typeName</code> ，value 为一个函数指针，这个函数指针指向的函数的返回值是基类类型的 <code>autoPtr</code> ，并且这个 <code>autoPtr</code> 指向类的一个临时对象（用 C++ 的 <code>new</code> 关键字创建 ）。这些在宏函数 <code>declareRunTimeSelectionTable</code> 中完成。</p>
</li>
<li><p>每创建一个派生类，都会调用一次 <code>addToRunTimeSelectionTable</code> 宏函数。这个宏函数会触发一次 <code>hashTable</code> 的更新操作。具体地说，宏函数的调用，会往基类里定义的 <code>hashTable</code> 插入一组值，这组值的 key 是该派生类的 <code>typeName</code> ，value 是一个函数，该函数返回的是指向派生类临时对象的指针。</p>
</li>
<li><p>类及其派生类编译成库，在编译过程中，会逐步往 <code>hashTable</code> 增加新元素，直到可选的模型全部添加到其中。</p>
</li>
<li><p>在需要调用这些类的地方，只需要定义基类的 <code>autoPtr</code>，并用基类中定义的 <code>New</code> 函数来初始化，即 <code>autoPtr&lt;AlgorithmBase&gt; algorithmPtr = AlgorithmBase::New(algorithmName);</code>。这样， <code>New</code> 函数就能根据调用的时候所提供的参数（即 <code>hashTable</code> 的 key），来从 <code>hashTable</code> 中选择对应的派生类（即 <code>hashTable</code> 的 value）。</p>
</li>
</ol>
<p>经过以上四步，就实现了 RTS 机制。</p>
<p>参考：<a href="http://www.sourceflux.de/blog/series/rts-2/" target="_blank" rel="external">source flux 的系列博文</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://www.sourceflux.de/blog/series/rts-2/">source flux 博客</a> 曾经出过一个解释 Run Time Selection(RTS) 机制的系列博文，推荐想理解 RTS 的读者去仔细读读。本篇算是我在读完以后做的一个笔记，以及一些总结，供读者参考。</p>]]>
    
    </summary>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="RTS" scheme="http://xiaopingqiu.github.io/tags/RTS/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[为什么要将声明和定义分离]]></title>
    <link href="http://xiaopingqiu.github.io/2016/03/06/separationOfDeclarationAndDefiniton/"/>
    <id>http://xiaopingqiu.github.io/2016/03/06/separationOfDeclarationAndDefiniton/</id>
    <published>2016-03-06T12:59:44.000Z</published>
    <updated>2016-03-14T02:59:46.281Z</updated>
    <content type="html"><![CDATA[<p>OpenFOAM 中的类基本都遵循类的声明和定义分开在不同文件的规则。具体来说，一般是类的声明放在 “xxx.H”，类的成员函数的具体定义 “xxx.C”，如果有内联函数(inline)，则还有 “xxxI.H”，并且，”xxx.H” 文件的最后会有 <code>#include   &quot;xxxI.H&quot;</code>。这么做不仅是一种代码规范，真正的目的应该是为了防止重复定义的问题。本篇博文用一个简单的例子来说明这个问题。</p>
<a id="more"></a>
<p>为了防止混淆，先说明一下概念：</p>
<ul>
<li>函数声明：即只声明函数的返回类型，函数名以及参数列表，没有函数体，不具体定义函数的功能，比如 </li>
</ul>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>函数定义：包含函数体,具体定义函数的功能。比如</li>
</ul>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a&lt;b)</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面用一个简单的例子来说明。</p>
<h4 id="测试一：非内联函数声明和定义必须分开的原因是防止重复定义问题">测试一：非内联函数声明和定义必须分开的原因是防止重复定义问题</h4><h5 id="正常测试：">正常测试：</h5><p>以下的测试代码共包括5个源文件，<code>inlinetest.H</code> ， <code>inlinetest.cpp</code> ， <code>inlinederived.H</code> ， <code>inlinederived.cpp</code> ， <code>main.cpp</code> ，分别定义如下：</p>
<ul>
<li><p>inlinetest.H</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#ifndef _INLINETEST_H</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> _INLINETEST_H</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Itest <span class="comment">//基类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">	Itest(<span class="keyword">int</span> a, <span class="keyword">int</span> b); <span class="comment">// 构造函数</span></span><br><span class="line">	<span class="keyword">int</span> a_, b_; <span class="comment">//数据成员</span></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">a</span><span class="params">()</span></span>; <span class="comment">// 内联成员函数</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">b</span><span class="params">()</span></span>; <span class="comment">//非内联成员函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> Itest::a() <span class="comment">//内联函数的定义</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a="</span> &lt;&lt; a_ &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> a_;</span><br><span class="line">&#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>inlinetest.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "inlinetest.H"</span></span><br><span class="line"></span><br><span class="line">Itest::Itest(<span class="keyword">int</span> a, <span class="keyword">int</span> b):a_(a),b_(b)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Itest::b()<span class="comment">//非内联函数的定义</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"b="</span> &lt;&lt; b_ &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> b_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>inlinederived.H</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#ifndef _INLINEDERIVED_H</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> _INLINEDERIVED_H</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "inlinetest.H"</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">class</span> Iderive: <span class="keyword">public</span> Itest <span class="comment">//派生类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> c_;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">c</span><span class="params">()</span></span>;<span class="comment">//非内联成员函数</span></span><br><span class="line">	Iderive(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>inlinederived.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "inlinederived.H"</span></span><br><span class="line"></span><br><span class="line">Iderive::Iderive(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c):Itest(a,b),c_(c)</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="keyword">int</span> Iderive::c()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"c="</span> &lt;&lt; c_ &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> c_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>main.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "inlinetest.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "inlinederived.H"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="function">Itest <span class="title">obj1</span><span class="params">(2,3)</span></span>; <span class="comment">//基类对象</span></span><br><span class="line">    <span class="function">Iderive <span class="title">obj2</span><span class="params">(1,2,3)</span></span>; <span class="comment">// 派生类对象</span></span><br><span class="line"></span><br><span class="line">    obj1.a();</span><br><span class="line">    obj1.b();</span><br><span class="line">    </span><br><span class="line">    obj2.a();</span><br><span class="line">    obj2.b();</span><br><span class="line">    obj2.c();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>以上五个源文件是可以成功编译链接成可执行文件的，运行结果与预期一致：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="setting">a=<span class="value"><span class="number">2</span></span></span></span><br><span class="line"><span class="setting">b=<span class="value"><span class="number">3</span></span></span></span><br><span class="line"><span class="setting">a=<span class="value"><span class="number">1</span></span></span></span><br><span class="line"><span class="setting">b=<span class="value"><span class="number">2</span></span></span></span><br><span class="line"><span class="setting">c=<span class="value"><span class="number">3</span></span></span></span><br></pre></td></tr></table></figure></p>
<h5 id="异常测试：">异常测试：</h5><p>下面来修改，如果将基类代码改一下，将非内联函数 <code>b</code> 的定义也放到头文件里，即：</p>
<ul>
<li><p>inlinetest.H</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#ifndef _INLINETEST_H</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> _INLINETEST_H</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Itest <span class="comment">//基类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">	Itest(<span class="keyword">int</span> a, <span class="keyword">int</span> b); <span class="comment">// 构造函数</span></span><br><span class="line">	<span class="keyword">int</span> a_, b_; <span class="comment">//数据成员</span></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">a</span><span class="params">()</span></span>; <span class="comment">// 内联成员函数</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">b</span><span class="params">()</span></span>; <span class="comment">//非内联成员函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> Itest::a() <span class="comment">//内联函数的定义</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a="</span> &lt;&lt; a_ &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> a_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Itest::b()<span class="comment">//非内联函数的定义</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"b="</span> &lt;&lt; b_ &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> b_;</span><br><span class="line">&#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>inlinetest.cpp</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include <span class="string">"inlinetest.H"</span></span><br><span class="line"></span><br><span class="line">Itest::Itest(<span class="keyword">int</span> a, <span class="keyword">int</span> b):a_(a),b_(b)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//int Itest::b()//非内联函数的定义</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; "b=" &lt;&lt; b_ &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//    return b_;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>结果是无法通过编译：<br><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">g++ -c inlinetest.cpp</span><br><span class="line">g++ -c inlinederived.cpp</span><br><span class="line">g++ -o main main.o inlinetest.o inlinederived.o</span><br><span class="line">inlinetest.o:inlinetest.cpp:(.<span class="keyword">text</span>+<span class="number">0x0</span>): multiple definition <span class="keyword">of</span> `Itest::b()<span class="comment">'</span></span><br><span class="line">main.o:main.cpp:(.<span class="keyword">text</span>+<span class="number">0x0</span>): first defined here</span><br><span class="line">inlinederived.o:inlinederived.cpp:(.<span class="keyword">text</span>+<span class="number">0x0</span>): multiple definition <span class="keyword">of</span> `Itest::b()<span class="comment">'</span></span><br><span class="line">main.o:main.cpp:(.<span class="keyword">text</span>+<span class="number">0x0</span>): first defined here</span><br><span class="line">c:/mingw/bin/../<span class="keyword">lib</span>/gcc/mingw32/<span class="number">4.8</span>.1/../../../../mingw32/bin/ld.exe: main.o: bad reloc address <span class="number">0x0</span> <span class="keyword">in</span> section `.ctors<span class="comment">'</span></span><br><span class="line">collect2.exe: <span class="keyword">error</span>: ld returned <span class="number">1</span> <span class="keyword">exit</span> status</span><br><span class="line">make: *** [main] <span class="keyword">Error</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>可见，编译过程没有出错，但是链接时出错了，报错说 <code>Itest::b()</code> 函数（即基类中的非内联成员函数）被重复定义。原因在于，<code>main.cpp</code> 里有 <code>#include &quot;inlinetest.H&quot;</code> ，这句包含了对<code>Itest::b()</code> 函数的定义；此外，<code>main.cpp</code> 里还有 <code>#include &quot;inlinederived.H&quot;</code>，而由于 <code>inlinederived.H</code> 里，也包含了<code>#include &quot;inlinetest.H&quot;</code>。所以，相当于<code>main.cpp</code> 中也对 <code>Itest::b()</code> 函数的定义了两次，于是连接过程就报错了。</p>
<p>在上面可以正常编译的情况里，即将<code>Itest::b()</code> 函数放在 <code>inlinetest.cpp</code> 里，就不会有这个问题，因为这时头文件里只有函数的声明，而函数的声明是可以重复的。</p>
<p>有人可能会问，这里的 <code>main.cpp</code> 里完全可以去掉 <code>#include &quot;inlinetest.H&quot;</code>，这样也可以解决重复定义问题。对这里的简单例子，是没问题，但是，如果是像 OpenFOAM 这样大的项目，源文件之间的关系非常复杂，那就只能通过将声明和定义分离来解决这个问题了。</p>
<p>注意：这里的内联成员函数 <code>a</code> ，声明和定义都在头文件 <code>inlinetest.H</code> 里，但是却不会报重复定义的错误。</p>
<h4 id="测试二：内联函数的声明和定义需要在同一个文件里，否则无法通过编译。">测试二：内联函数的声明和定义需要在同一个文件里，否则无法通过编译。</h4><p>将上面提到的派生类代码修改一下，将内联成员函数的定义放到 <code>inlinetest.cpp</code> 里，即</p>
<ul>
<li><p>inlinetest.H</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#ifndef _INLINETEST_H</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> _INLINETEST_H</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Itest <span class="comment">//基类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">	Itest(<span class="keyword">int</span> a, <span class="keyword">int</span> b); <span class="comment">// 构造函数</span></span><br><span class="line">	<span class="keyword">int</span> a_, b_; <span class="comment">//数据成员</span></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">a</span><span class="params">()</span></span>; <span class="comment">// 内联成员函数</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">b</span><span class="params">()</span></span>; <span class="comment">//非内联成员函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//inline int Itest::a() //内联函数的定义</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; "a=" &lt;&lt; a_ &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//return a_;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>inlinetest.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "inlinetest.H"</span></span><br><span class="line"></span><br><span class="line">Itest::Itest(<span class="keyword">int</span> a, <span class="keyword">int</span> b):a_(a),b_(b)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> Itest::a() <span class="comment">//内联函数的定义</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a="</span> &lt;&lt; a_ &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> a_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Itest::b()<span class="comment">//非内联函数的定义</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"b="</span> &lt;&lt; b_ &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> b_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这时无法通过编译，编译器报错如下：<br><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">g++ -c main.cpp</span><br><span class="line"><span class="keyword">In</span> file included <span class="keyword">from</span> main.cpp:<span class="number">2</span>:<span class="number">0</span>:</span><br><span class="line">inlinetest.H:<span class="number">13</span>:<span class="number">13</span>: warning: inline <span class="keyword">function</span> <span class="comment">'int Itest::a()' used but never defined [enabled by default]</span></span><br><span class="line">  inline int a();</span><br><span class="line">             ^</span><br><span class="line">g++ -c inlinetest.cpp</span><br><span class="line">g++ -c inlinederived.cpp</span><br><span class="line">g++ -o main main.o inlinetest.o inlinederived.o</span><br><span class="line">main.o:main.cpp:(.<span class="keyword">text</span>+<span class="number">0x5c</span>): undefined reference <span class="keyword">to</span> `Itest::a()<span class="comment">'</span></span><br><span class="line">main.o:main.cpp:(.<span class="keyword">text</span>+<span class="number">0x70</span>): undefined reference <span class="keyword">to</span> `Itest::a()<span class="comment">'</span></span><br><span class="line">c:/mingw/bin/../<span class="keyword">lib</span>/gcc/mingw32/<span class="number">4.8</span>.1/../../../../mingw32/bin/ld.exe: main.o: bad reloc address <span class="number">0x0</span> <span class="keyword">in</span> section `.ctors<span class="comment">'</span></span><br><span class="line">collect2.exe: <span class="keyword">error</span>: ld returned <span class="number">1</span> <span class="keyword">exit</span> status</span><br><span class="line">make: *** [main] <span class="keyword">Error</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>首先是编译过程有一个警告说 <code>inlinetest.H</code> 里的函数 <code>int Itest::a()</code> 没有定义，然后链接的时候报了 <code>undefined reference to &#39;Itest::a()&#39;</code>  的错误，说明如果内联函数的声明和定义分属不同源文件，编译器是无法找到函数的定义的。</p>
<h4 id="测试三_：内联函数的定义放到一个单独的源文件，并在头文件里_include_这个源文件">测试三 ：内联函数的定义放到一个单独的源文件，并在头文件里 include 这个源文件</h4><p>这个测试我做的比较简单，即将 <code>inlinetest.H</code> 拆开，内联函数 <code>a</code> 的定义放在单独的一个 <code>inlinetestI.H</code> 里：</p>
<ul>
<li><p>inlinetest.H</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#ifndef _INLINETEST_H</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> _INLINETEST_H</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Itest <span class="comment">//基类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">	Itest(<span class="keyword">int</span> a, <span class="keyword">int</span> b); <span class="comment">// 构造函数</span></span><br><span class="line">	<span class="keyword">int</span> a_, b_; <span class="comment">//数据成员</span></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">a</span><span class="params">()</span></span>; <span class="comment">// 内联成员函数</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">b</span><span class="params">()</span></span>; <span class="comment">//非内联成员函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "inlinetestI.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>inlinetestI.H</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> Itest::a() <span class="comment">//内联函数的定义</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a="</span> &lt;&lt; a_ &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> a_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>编译链接成功，运行结果跟正常预期一致。</p>
<p>经过上述简单的测试，可以得到以下结论：</p>
<ol>
<li>使用C++模板编程时，对于非内联成员函数，函数声明和定义要分开，目的在于防止重复定义的问题。</li>
<li>内联函数的声明和定义需要在同一个文件里，否则无法通过编译。</li>
<li>OpenFOAM 里将内联成员函数提取出来放到一个单独的文件里（ <code>*I.H</code> ），应该只是一种使用惯例。不是 C++ 语法的要求，将 <code>*I.H</code> 里的内容拷贝出来放到 <code>*.H</code> 后面，然后删除 <code>#include &quot;*I.H&quot;</code> 效果应该是一样的。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>OpenFOAM 中的类基本都遵循类的声明和定义分开在不同文件的规则。具体来说，一般是类的声明放在 “xxx.H”，类的成员函数的具体定义 “xxx.C”，如果有内联函数(inline)，则还有 “xxxI.H”，并且，”xxx.H” 文件的最后会有 <code>#include   &quot;xxxI.H&quot;</code>。这么做不仅是一种代码规范，真正的目的应该是为了防止重复定义的问题。本篇博文用一个简单的例子来说明这个问题。</p>]]>
    
    </summary>
    
      <category term="C++" scheme="http://xiaopingqiu.github.io/tags/C/"/>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="C++" scheme="http://xiaopingqiu.github.io/categories/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenFOAM 中的单相流湍流模型之SpalartAllmaras]]></title>
    <link href="http://xiaopingqiu.github.io/2016/03/06/OpenFOAM-singlePhase-turbulenceModel2/"/>
    <id>http://xiaopingqiu.github.io/2016/03/06/OpenFOAM-singlePhase-turbulenceModel2/</id>
    <published>2016-03-06T11:13:58.000Z</published>
    <updated>2016-03-06T13:35:35.300Z</updated>
    <content type="html"><![CDATA[<p>本篇简要分析不可压缩的 SpalartAllmaras 模型的代码。主要内容包括模型输运方程的代码说明，以及一些使用方面的细节。</p>
<a id="more"></a>
<h3 id="湍流模型代码实例">湍流模型代码实例</h3><p>这一部分分析几个 OpenFOAM 里自带的湍流模型， 并探讨修改或者添加新湍流模型的方法。</p>
<h4 id="1_SpalartAllmaras_模型">1 SpalartAllmaras 模型</h4><h5 id="1-1-_模型分析">1.1. 模型分析</h5><p>SpalartAllmaras 模型是一方程模型，它只需要求解一个输运方程。OpenFOAM 中的 SpalartAllmaras 模型是在原始论文[1] 的基础上，引入了 Ashford [2] 对这个模型的修正。下面来看这个模型在 OpenFOAM 中的实现，代码位于 <code>src/turbulenceModels/incompressible/RAS/SpalartAllmaras</code><br>首先是头文件， <code>SpalartAllmaras.H</code><br>头文件开始，声明了一个类：SpalartAllmaras<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpalartAllmaras</span></span></span><br><span class="line">:</span><br><span class="line">    <span class="keyword">public</span> RASModel</span><br></pre></td></tr></table></figure></p>
<p>说明这个类是公有继承 <code>RASModel</code> 类的。<br>接下来是一些数据成员以及成员函数的声明，这里无需赘述，直接来看函数的具体定义吧。<br>函数的具体定义，在<code>SpalartAllmaras.C</code> 里（注意到 OpenFOAM 的代码几乎都是这样讲声明和定义分开，这样做的目的，是为了防止重复声明的问题，更详细的说明，见我的<a href="http://xiaopingqiu.github.io/2016/03/06/separationOfDeclarationAndDefiniton/" target="_blank" rel="external">另一篇博文</a>）。注意，湍流模型的定义，最终是为了在求解器中进行调用的，所以，先来回顾一下湍流模型贡献给求解器中动量方程中那一项：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">turbulence-&gt;<span class="function"><span class="title">divDevReff</span><span class="params">(U)</span></span></span><br></pre></td></tr></table></figure></p>
<p>这一项，不同求解器可能会有不同，但大致的形式是这样的。<br>很显然，这个 <code>divDevReff</code> 应该是湍流模型类的成员函数，实际也的确如此， <code>SpalartAllmaras.C</code> 有这个函数的定义：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">tmp</span>&lt;<span class="tag">fvVectorMatrix</span>&gt; <span class="rule"><span class="attribute">SpalartAllmaras</span>:<span class="value">:<span class="function">divDevReff</span>(volVectorField&amp; U) const</span><br><span class="line">&#123;</span><br><span class="line">    const volScalarField <span class="function">nuEff_</span>(<span class="function">nuEff</span>())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="tag">return</span></span><br><span class="line">    (</span><br><span class="line">      <span class="tag">-</span> <span class="rule"><span class="attribute">fvm</span>:<span class="value">:<span class="function">laplacian</span>(nuEff_, U)</span><br><span class="line">      - fvc::<span class="function">div</span>(nuEff_*<span class="function">dev</span>(<span class="function">T</span>(fvc::<span class="function">grad</span>(U))))</span><br><span class="line">    )</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数，写成公式是如下形式<br>$$<br>-\nabla \cdot (\nu_{eff}\nabla U)-\nabla \cdot [\nu_{eff}dev(\nabla ^TU)]<br>$$<br>OpenFOAM 中的 <code>dev</code>运算符定义为 $dev(T)=T-\frac{1}{3}tr(T)I$ ， <code>tr</code> 为张量的迹，即主对角元素之和所以。对于张量 $\nabla ^TU$ ，$tr(\nabla ^TU) =\nabla \cdot U$，因此上式可以写为【注一】<br>$$<br>-\nabla \cdot (\nu_{eff}\nabla U)-\nabla \cdot [\nu_{eff}(\nabla^TU-\frac{1}{3}(\nabla \cdot U))]<br>$$<br>上述 <code>divDevReff</code> 函数中，变量 <code>nuEff_</code> d的值是函数 <code>nuEff()</code> 的返回值，但是，在 <code>SpalartAllmaras.C</code> 中却未见 <code>nuEff()</code> 函数的定义。这里就要记住了，C++ 的类继承的一个特性是派生类会从基类继承其中定义的成员函数。所以看到本类中没定义的函数时，<strong>don’t panic</strong>，往基类找就是了。翻看基类 <code>RASModel</code> 的代码，可以很容易从 <code>RASModel.C</code> 中找出来 <code>nuEff()</code> 的定义：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> tmp&lt;volScalarField&gt; <span class="title">nuEff</span><span class="params">()</span> <span class="keyword">const</span>  </span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tmp&lt;volScalarField&gt;</span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">new</span> volScalarField(<span class="string">"nuEff"</span>, nut() + nu())</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 函数 <code>nut()</code> 的定义可以从 <code>SpalartAllmaras.H</code> 中找到，可是 <code>nu()</code> 呢？虽然从名字可以猜到它返回的是分子粘度（可见变量命名的重要性啊），可是，它的定义在哪里？ <code>RASModel.C</code> 也没有啊…<br>答案是，继续向上找，RASModel 类没有，那就去更上一层的基类，turbulenceModel。果然，在 <code>turbulenceModel.C</code> 中能找到其定义：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inline tmp&lt;volScalarField&gt; nu() <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> transportModel_.<span class="title">nu</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p> <code>transportModel_</code> 又是什么鬼？这个不是本篇博文的内容，该回到正题了，这里应该关注的是湍流粘度 <code>nut_</code> 。<br>湍流模型不可能仅仅是给求解器贡献那一项，湍流粘度应该也随着求解器的运行而更新。是这样的，求解器中的<br><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">turbulence-&gt;correct<span class="literal">()</span>;</span><br></pre></td></tr></table></figure></p>
<p>这句代码负责湍流粘度的更新。这里又涉及到一个湍流类的成员函数： <code>corretc</code>。这个函数是湍流模型类的核心，因为湍流模型输运方程的求解，湍流粘度的更新都在这个函数里面。下面来看 <code>SpalartAllmaras</code> 模型的 <code>correct</code> 函数：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SpalartAllmaras::correct()</span><br><span class="line">&#123;</span><br><span class="line">    RASModel::correct();</span><br><span class="line">    <span class="keyword">if</span> (!turbulence_)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Re-calculate viscosity</span></span><br><span class="line">        nut_ = nuTilda_*fv1(<span class="keyword">this</span>-&gt;chi());</span><br><span class="line">        nut_.correctBoundaryConditions();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mesh_.changing())</span><br><span class="line">    &#123;</span><br><span class="line">        d_.correct();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> volScalarField chi(<span class="keyword">this</span>-&gt;chi());</span><br><span class="line">    <span class="keyword">const</span> volScalarField fv1(<span class="keyword">this</span>-&gt;fv1(chi));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> volScalarField Stilda</span><br><span class="line">    (</span><br><span class="line">        fv3(chi, fv1)*::sqrt(2.0)*mag(skew(fvc::grad(U_)))</span><br><span class="line">      + fv2(chi, fv1)*nuTilda_/sqr(kappa_*d_)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    tmp&lt;fvScalarMatrix&gt; nuTildaEqn</span><br><span class="line">    (</span><br><span class="line">        fvm::ddt(nuTilda_)</span><br><span class="line">      + fvm::div(phi_, nuTilda_)</span><br><span class="line">      - fvm::laplacian(DnuTildaEff(), nuTilda_)</span><br><span class="line">      - Cb2_/sigmaNut_*magSqr(fvc::grad(nuTilda_))</span><br><span class="line">     ==</span><br><span class="line">        Cb1_*Stilda*nuTilda_</span><br><span class="line">      - fvm::Sp(Cw1_*fw(Stilda)*nuTilda_/sqr(d_), nuTilda_)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    nuTildaEqn().relax();</span><br><span class="line">    solve(nuTildaEqn);</span><br><span class="line">    bound(nuTilda_, dimensionedScalar(<span class="string">"0"</span>, nuTilda_.dimensions(), <span class="number">0.0</span>));</span><br><span class="line">    nuTilda_.correctBoundaryConditions();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-calculate viscosity</span></span><br><span class="line">    nut_.internalField() = fv1*nuTilda_.internalField();</span><br><span class="line">    nut_.correctBoundaryConditions();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>先看核心的输运方程， <code>nuTildaEqn</code> ，这个部分的每一行写成公式，分别如下：<br>$$<br>\frac{\partial \tilde{\nu}}{\partial t} \\<br>\nabla \cdot (U \tilde{\nu}) \\<br>-\nabla \cdot [D_{\tilde{\nu}_{eff}} \nabla \tilde{\nu}] \\<br>-\frac{C_{b2}}{\sigma_{\nu_t}} \cdot |\nabla \tilde{\nu}|^2 \\<br>C_{b1}\cdot \tilde{S} \cdot \tilde{\nu} \\<br>-\frac{C_{w1}\cdot f_w\cdot \tilde{\nu}}{d^2} \cdot \tilde{\nu}\\<br>$$</p>
<p>最后两项都包含了需要求解的量 $\tilde{\nu}$， 但是处理方式却不一样，最后一项，其实是将原本的 $\tilde{\nu} ^2$ 项进行了线性化，并用 <code>fvm::Sp</code> 操作符进行隐式处理。而倒数第二项，则是作的显式处理。差别在于，倒数第二项仅仅是用上一步得到的 $\tilde{\nu}$ 代入，然后这一项被加到 $Ax=b$ 中的 $b$ 部分。而隐式处理则会对系数矩阵 $A$ 有贡献。<br>输运方程中涉及到的变量和函数，全部都在 <code>SpalartAllmaras</code> 类中有定义，这里就不再单独分析了，仅将涉及到的公式列出如下<br>$$<br>D_{\tilde{\nu}_{eff}}=\frac{\nu+\tilde{\nu}}{\sigma_{\nu_t}}<br>$$<br>$$<br>f_w=g\cdot \left [ \frac{1+C_{w3}^6}{g^6+C_{w3}^6} \right]^{1/6},\quad  g=r+C_{w2}\cdot(r^6-r) \\<br>r=min\left[ \frac{\tilde{\nu}}{max(\tilde{S}, SMALL)\cdot \kappa^2 d^2},10 \right]<br>$$</p>
<p>$$<br>\tilde{S}=f_{v3}\cdot\sqrt{2\Omega_{ij}:\Omega_{ij}}+\frac{f_{v2}\tilde{\nu}}{\kappa^2 d^2},\quad \Omega_{ij}=\frac{1}{2}(\nabla U -\nabla ^T U)<br>$$</p>
<p>$f_{v2}$ 和 $f_{v3}$ 有点特殊，因为涉及到了 Ashford 对原始模型的修正。根据作者的论文，修正的目的是防止 $\tilde{S}$ 出现负值。<br>如果不引入 Ashford 修正，则 $f_{v3}=1$；引入以后，则<br>$$<br>f_{v3}=\frac{(1+\chi \cdot f_{v1})}{c_{v2}}\cdot \frac{3+\frac{\chi}{c_{v2}} + (\frac{\chi}{c_{v2}})^2 }{(1+\frac{\chi}{c_{v2}})^3}<br>$$<br>对于 $f_{v2}$，如果不引入 Ashford 修正，则<br>$$<br>f_{v2}=\frac{1}{(1+\frac{\chi}{c_{v2}})^3}<br>$$<br>若引入，则<br>$$<br>f_{v2}=1-\frac{\chi}{1+\chi f_{v1}}<br>$$<br>此外，<br>$$<br>f_{v1}=\frac{\chi ^3}{\chi ^3 + c_{v1}^3}, \quad  \chi=\frac{\tilde{\nu}}{\nu}, \quad \nu_t = \tilde{\nu}<br>f_{v1}$$<br>$d$ 是与壁面的距离，有一个专门的类 <code>wallDist</code> 来计算它。<br>其他的没有提到的变量，则都是模型常数了。具体的值都在 <code>SpalartAllmaras</code> 类的构造函数中定义了，这里就不再赘述了。</p>
<h5 id="1-2-_一些细节">1.2. 一些细节</h5><ol>
<li><code>turbulence_</code> 这个变量<br><code>correct</code> 函数中，只有当 <code>turbulence_</code> 为 <code>true</code> 时，下面求解输运方程的部分代码才会执行。这个变量又是从 <code>RASModel</code> 类继承过来的，其初始化的语句为 <code>turbulence_(lookup(&quot;turbulence&quot;))</code> ，这意味着，这个变量的值是从 <code>RASProperties</code> 文件中读取的（详见文末的 <code>RASProperties</code> 示例）。</li>
<li>模型常数，除了使用默认值，还可以自己指定（注：除非很有把握，一般不要随便修改模型常数）。具体方法是，在 <code>RASProperties</code> 文件里，建立一个名为 <code>SpalartAllmarasCoeffs</code> 的 subDict，详见文末的示例。 </li>
<li><code>bound</code> 函数<br>这个函数的定义在头文件 <code>bound.H</code> 里，其功能是限制 $\tilde{\nu}$ 的最小值。不过这种限制其实没有多少物理意义，纯粹是数值技巧。其中用到了 <code>fvc::average</code> 函数（见我的<a href="http://xiaopingqiu.github.io/2015/05/17/OpenFOAMcode1/" target="_blank" rel="external">另一篇博文</a>）。</li>
<li><code>read</code> 成员函数<br>这个成员函数，初看之下似乎跟模型常数的初始化有关，实则不然。模型常数的初始化在类的构造函数部分完成， <code>coeffDict_</code> 这个变量在基类 <code>RASModel</code> 的构造函数中先用 <code>type()+Coeffs</code> (这里是 <code>SpalartAllmarasCoeffs</code> )这个 subDict 初始化了，然后，在 <code>SpalartAllmaras</code> 类的构造函数中，每一个模型常数都是先去 <code>coeffDict_</code> 中查找是否用用户自定义的值，如果没有，则用模型的默认值，并且将这个默认值添加到 <code>coeffDict_</code> 这个字典中。</li>
<li>其他成员函数<br><code>SpalartAllmaras</code> 显然不需要用到湍动能 <code>k</code> 以及湍动能耗散 <code>epsilon</code> ，但是在 <code>SpalartAllmaras.C</code> 中确有这两个函数的定义，而且返回值是0。这是因为，在基类 <code>turbulenceModel</code> 中， <code>k()</code>， <code>epsilon()</code> 函数被声明为纯虚函数，如果不在 <code>SpalartAllmaras</code> 中重新定义这两个函数，则 <code>SpalartAllmaras</code> 也将是包括纯虚函数的抽象类了。在 C++ 中，抽象类是无法建立对象的。<br><code>devReff</code>， <code>R</code> ， <code>divDevRhoReff</code> 这几个成员函数，是湍流模型提供给其他模型调用的函数，比如，在计算表面应力的 <code>forces</code> 类中就需要调用湍流模型的 <code>devReff</code> 函数。</li>
</ol>
<h5 id="附：_RASProperties_文件示例">附： RASProperties 文件示例</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/<span class="emphasis">*--------------------------------*</span>- C++ -<span class="emphasis">*----------------------------------*</span>\</span><br><span class="line">| =========                 |                                                 |</span><br><span class="line">| \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |</span><br><span class="line">|  \\    /   O peration     | Version:  2.3.1                                 |</span><br><span class="line">|   \\  /    A nd           | Web:      www.OpenFOAM.org                      |</span><br><span class="line">|    \\/     M anipulation  |                                                 |</span><br><span class="line">\<span class="emphasis">*---------------------------------------------------------------------------*</span>/</span><br><span class="line">FoamFile</span><br><span class="line">&#123;</span><br><span class="line"><span class="code">    version     2.0;</span></span><br><span class="line"><span class="code">    format      ascii;</span></span><br><span class="line"><span class="code">    class       dictionary;</span></span><br><span class="line"><span class="code">    location    "constant";</span></span><br><span class="line"><span class="code">    object      RASProperties;</span></span><br><span class="line">&#125;</span><br><span class="line">// <span class="bullet">* *</span> <span class="bullet">* *</span> <span class="bullet">* *</span> <span class="bullet">* *</span> <span class="bullet">* *</span> <span class="bullet">* *</span> <span class="bullet">* *</span> <span class="bullet">* *</span> <span class="bullet">* *</span> <span class="bullet">* *</span> <span class="bullet">* *</span> <span class="bullet">* *</span> <span class="bullet">* *</span> <span class="bullet">* *</span> <span class="bullet">* *</span> <span class="bullet">* *</span> <span class="bullet">* *</span> <span class="bullet">* *</span> * //</span><br><span class="line"></span><br><span class="line">RASModel        SpalartAllmaras ;</span><br><span class="line">turbulence      on; //若为 off，则湍流模型的输运方程将不会求解！</span><br><span class="line">printCoeffs     on; // 输出模型常数</span><br><span class="line"></span><br><span class="line">SpalartAllmarasCoeffs // 设置模型常数(仅为示例，具体数值不要较真)</span><br><span class="line">&#123;</span><br><span class="line"><span class="code">    Cw2       0.20;</span></span><br><span class="line"><span class="code">    Cw3       0.10;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="emphasis">***</span> //</span><br></pre></td></tr></table></figure>
<p>【注一】：N-S 方程中，这一项应该是<br>$$<br>-\nabla \cdot (\nu_{eff}\nabla U)-\nabla \cdot [\nu_{eff}(\nabla^TU-\frac{2}{3}(\nabla \cdot U))]<br>$$<br>而且，在可压缩的湍流模型中， <code>divDevReff</code> 函数用的是 <code>dev2</code> 函数，所以其定义的形式就跟 N-S 方程一致了。但不知道为什么不可压缩的湍流模型为什么要用 <code>dev</code> 函数。虽然对于不可压缩的情形，由于 $\nabla \cdot U=0$，用 <code>dev</code> 或者 <code>dev2</code> 应该关系不大，但这种做法仍然很费解。在OpenFOAM-3.0版本中，可压和不可压用的都是 <code>dev2</code> 函数了。</p>
<h5 id="参考：">参考：</h5><p>[1] P. Spalart and S. Allmaras. “A one-equation turbulence model for aerodynamic flows”. Technical Report AIAA-92-0439. American Institute of Aeronautics and Astronautics. 1992.</p>
<p>[2] “An Unstructured Grid Generation and Adaptive Solution Technique         for High Reynolds Number Compressible Flows”, G.A. Ashford, Ph.D. thesis, University of Michigan, 1996.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本篇简要分析不可压缩的 SpalartAllmaras 模型的代码。主要内容包括模型输运方程的代码说明，以及一些使用方面的细节。</p>]]>
    
    </summary>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/tags/OpenFOAM/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[两个简单的随时间变化的边界条件]]></title>
    <link href="http://xiaopingqiu.github.io/2015/12/12/timeVaryingBC1/"/>
    <id>http://xiaopingqiu.github.io/2015/12/12/timeVaryingBC1/</id>
    <published>2015-12-12T06:38:50.000Z</published>
    <updated>2015-12-12T08:41:24.219Z</updated>
    <content type="html"><![CDATA[<p>这一篇里介绍OpenFOAM自带的两个简单的随时间变化的边界条件： <code>uniformFixedValue</code> 和 <code>flowRateInletVelocity</code> 。</p>
<a id="more"></a>
<h4 id="1-_uniformFixedValue">1. uniformFixedValue</h4><p>这个边界属于第一类边界，即直接指定边界上某个量的值。跟 <code>fixedValue</code> 的不同之处在于，这个边界条件允许边界上的值随着时间变化。一般的用法如下：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type            uniformFixedValue<span class="comment">;</span></span><br><span class="line">uniformValue     table</span><br><span class="line"><span class="list">(</span><br><span class="line">    <span class="list">(<span class="number">0.000</span> <span class="list">(<span class="number">0</span> <span class="number">0</span> <span class="number">0.002</span>)</span>)</span></span><br><span class="line">    <span class="list">(<span class="number">0.010</span> <span class="list">(<span class="number">0</span> <span class="number">0</span> <span class="number">0.002</span>)</span>)</span></span><br><span class="line">    <span class="list">(<span class="number">0.011</span> <span class="list">(<span class="number">0.011</span> <span class="number">0</span> <span class="number">0.011</span>)</span>)</span></span><br><span class="line">    <span class="list">(<span class="number">0.100</span> <span class="list">(<span class="number">0.10</span> <span class="number">0</span> <span class="number">0.100</span>)</span>)</span></span><br><span class="line">)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>上面这一段指定的是速度 U （也可以是其他矢量，或者标量）的边界条件，通过一个 table 来定义边界随时间的变化行为，具体解释如下（假定时间步长等于0.001 s）：</p>
<ul>
<li>当 0.00 &lt;= t &lt;= 0.01 s 时，速度值为 (0   0   0.002);</li>
<li>当 t = 0.011 s 时，速度变为 (0.011   0   0.011);</li>
<li>0.011 &lt;= t &lt;= 0.100 之间，速度的每个分量均为线性变化的;</li>
<li>当 t &gt; 0.100 s 以后，速度保持  (0.10   0   0.100) 不变。</li>
</ul>
<p>除了通过 table 来定义随时间分段线性变化边界条件，还可以定义多项式变化的边界，比如：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type uniformFixedValue<span class="comment">;</span></span><br><span class="line">uniformValue polynomial</span><br><span class="line"><span class="list">(</span><br><span class="line">    <span class="list">(<span class="list">(<span class="number">1</span> <span class="number">0</span> <span class="number">0</span>)</span> <span class="list">(<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>)</span>)</span></span><br><span class="line">    <span class="list">(<span class="list">(<span class="number">2</span> <span class="number">2</span> <span class="number">0</span>)</span> <span class="list">(<span class="number">1</span> <span class="number">2</span> <span class="number">0</span>)</span>)</span></span><br><span class="line">    <span class="list">(<span class="list">(<span class="number">3</span> <span class="number">5</span> <span class="number">0</span>)</span> <span class="list">(<span class="number">2</span> <span class="number">4</span> <span class="number">0</span>)</span>)</span></span><br><span class="line">)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>以上这段定义的是这样一个边界：x 分量，$U_x=1+2\cdot t+3\cdot t^2$；y 分量，$U_y=2\cdot t^2+5\cdot t^4$; z 分量，$U_z=0$。<br>需要注意的是， <code>polynomial</code> 这种方式，目前测试在 2.3.x 以及以下版本不能使用，在最新的 3.0.x 版中可以使用。</p>
<p>此外，还有其他的一些定义方式，列举如下（参考<a href="http://www.geocities.jp/penguinitis2002/study/OpenFOAM/time_varying_bc.html" target="_blank" rel="external">这个网站</a>）：</p>
<h5 id="固定值">固定值</h5><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">inlet</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="title">type</span> uniformFixedValue; </span><br><span class="line">    <span class="title">uniformValue</span> constant (<span class="number">10</span> <span class="number">0</span> <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式与 <code>fixedValue</code> 效果是一样的。</p>
<h5 id="tableFile">tableFile</h5><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">inlet</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="title">type</span> uniformFixedValue; </span><br><span class="line">    <span class="title">uniformValue</span> tableFile; </span><br><span class="line">    <span class="title">tableFileCoeffs</span></span><br><span class="line">    &#123; </span><br><span class="line">	<span class="title">fileName</span> <span class="string">"<span class="variable">$FOAM_CASE</span>/velocity"</span> </span><br><span class="line">	outOfBounds clamp; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个跟 <code>table</code> 那种类似，只不过将上面 <code>table</code> 的内容写到一个文件里了（这里是 <code>velocity</code> 文件）。 <code>velocity</code> 文件的格式为<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(</span><br><span class="line">    <span class="list">(<span class="keyword">0</span>   <span class="list">(<span class="keyword">0</span> <span class="number">0</span> <span class="number">0</span>)</span>)</span></span><br><span class="line">    <span class="list">(<span class="keyword">0.01</span> <span class="list">(<span class="keyword">10</span> <span class="number">0</span> <span class="number">0</span>)</span>)</span></span><br><span class="line">)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p> outOfBounds 的可选项及其含义有：</p>
<ul>
<li>clamp：当实际时间超过 tableFile 里的最大时间（比如上述示例文件里，最大时间为0.01s）以后，保持 tableFile 最大时间定义的那个值（对上述示例文件，为(10 0 0)）不变；</li>
<li>repeat：重复前面的变化模式，比如上上述示例中，0 &lt; t &lt; 0.01 时，$U_x=1000\cdot t$，当 t 超过0.01 时，计算方法为 $U_x = 1000\cdot (t-0.01)$；</li>
<li>error：t &gt; 0.01 时，报错退出；</li>
<li>warn：给出警告，但是程序继续运行，边界值计算方法同 clamp。</li>
</ul>
<h5 id="csvFile">csvFile</h5><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">inlet</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="title">type</span> uniformFixedValue; </span><br><span class="line">    <span class="title">uniformValue</span> csvFile; </span><br><span class="line">    <span class="title">csvFileCoeffs</span> </span><br><span class="line">    &#123; </span><br><span class="line">	<span class="title">fileName</span> <span class="string">"<span class="variable">$FOAM_CASE</span>/velocity.csv"</span> </span><br><span class="line">	outOfBounds clamp; </span><br><span class="line">	<span class="title">nHeaderLine</span> <span class="number">1</span>; </span><br><span class="line">	<span class="title">mergeSeparators</span> <span class="built_in">no</span>; </span><br><span class="line">	<span class="title">separator</span> <span class="string">","</span>;</span><br><span class="line">	<span class="title">refColumn</span> <span class="number">0</span>; </span><br><span class="line">	<span class="title">componentColumns</span> (<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式是通过一个 <code>csv</code> 格式的文件来定义分段函数，文件格式为<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">time</span>,velocity-x,velocity-y,velocity-z</span><br><span class="line"><span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line"><span class="number">0.01</span>,<span class="number">10</span>,<span class="number">0</span>,<span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<h4 id="2-_flowRateInletVelocity">2. flowRateInletVelocity</h4><p>这个边界条件指定的是界面上的体积流量或者质量流量，并根据流量来反推速度。速度的方向为<strong>垂直边界并指向区域内部</strong>。一般的用法如下：<br><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">myPatch</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="class"><span class="keyword">type</span>        <span class="title">flowRateInletVelocity</span>;</span></span><br><span class="line">      volumetricFlowRate  <span class="number">0.2</span>; <span class="comment">// 体积流量</span></span><br><span class="line">      value       uniform (<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  myPatch</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="class"><span class="keyword">type</span>                <span class="title">flowRateInletVelocity</span>;</span></span><br><span class="line">      massFlowRate        <span class="number">0.2</span>; <span class="comment">// 质量流量</span></span><br><span class="line">      rho                 rho; <span class="comment">//要指定密度场的名字</span></span><br><span class="line">      rhoInlet            <span class="number">1.0</span>; <span class="comment">//如果上述指定的密度场不存在，则使用这里指定的值作为边界上的密度</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>类似的，前面 <code>uniformFixedValue</code> 边界里的那些类型，<code>table</code>， <code>tableFile</code>  <code>csvFile</code>， <code>polynomial</code> 也都可以使用，而且格式是类似的，这里就不重复了，更多细节可以参考<a href="http://www.geocities.jp/penguinitis2002/study/OpenFOAM/time_varying_bc.html" target="_blank" rel="external">这个页面</a> </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这一篇里介绍OpenFOAM自带的两个简单的随时间变化的边界条件： <code>uniformFixedValue</code> 和 <code>flowRateInletVelocity</code> 。</p>]]>
    
    </summary>
    
      <category term="Boundary conditions" scheme="http://xiaopingqiu.github.io/tags/Boundary-conditions/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/tags/OpenFOAM/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
</feed>