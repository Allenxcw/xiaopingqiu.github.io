<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Giskard's CFD Learning Tricks]]></title>
  <subtitle><![CDATA[CFD and Scientic Computing]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://xiaopingqiu.github.io/"/>
  <updated>2015-05-31T10:12:57.286Z</updated>
  <id>http://xiaopingqiu.github.io/</id>
  
  <author>
    <name><![CDATA[Giskard Q.]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[foamTimeAverage]]></title>
    <link href="http://xiaopingqiu.github.io/2015/05/31/foamTimeAverage/"/>
    <id>http://xiaopingqiu.github.io/2015/05/31/foamTimeAverage/</id>
    <published>2015-05-31T09:11:00.000Z</published>
    <updated>2015-05-31T10:12:57.286Z</updated>
    <content type="html"><![CDATA[<p> 在我的<a href="http://xiaopingqiu.github.io/2015/04/12/fieldAverage/" target="_blank" rel="external">以前的一篇博文</a>中，我介绍了<code>fieldAverage</code>这个<code>functionObject</code>的用法，其中提到， 可以用<code>window</code>这个参数来控制所计算的时均值的时间范围。如果 <code>base = time</code>且<code>window = 10</code>，那从第10s以后，每个时刻 t 输出的时均值其实相当于从 t-10 到 t 这个时间段内的时均值。但是，根据分析可以发现，这个时均值并不严格等价于从 t-10 时刻到 t 时刻某个场的时均值。有时候，需要从某个时刻才开始计算时均值，而<code>fieldAverage</code>没有参数可以控制从某个时刻才开始计算时间平均。于是我参照<code>OpenFOAM</code>的<code>patchAverage.C</code>的代码写了一个后处理程序，用来计算指定时间段内的某个场的时均值。</p>
 <a id="more"></a>
<h3 id="foamTimeAverage_简介">foamTimeAverage 简介</h3><p> <code>foamTimeAverage</code> 是一段简单的后处理程序，其功能是在算例运行结束以后，根据指定的时间段，从数据文件夹里循环读入指定时间段内指定场的数据，并计算该段时间的该指定场的时均值，结果将会输出到该时间段最后一个时刻的数据文件夹内。举例说：<br> <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foamTimeAverage <span class="tag">p</span> -<span class="tag">time</span> <span class="number">0.4</span>:<span class="number">0.5</span></span><br></pre></td></tr></table></figure></p>
<p> 将会计算<code>0.4 s-0.5 s</code>时间段内<code>p</code>的时均值，结果将输出到<code>0.5</code>内，时均值文件名为<code>p_mean</code>。这个程序只支持计算<code>volField</code>的时均值，不支持<code>surfaceField</code>。目前，这个程序只在<code>OpenFOAM-2.1.1</code>和<code>OpenFOAM-2.3.1</code>下通过可编译测试，运行的结果目前只在<code>OpenFOAM-2.1.1</code>下对<code>volScalarField</code>和<code>volVectorField</code>进行了测试。理论上讲，应该在其他版本的<code>OpenFOAM</code>下也可以正常编译和运行。</p>
<p> 以下是<code>foamTimeAverage</code>的代码：<br> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*---------------------------------------------------------------------------*\</span><br><span class="line"> *=========                 |</span><br><span class="line"> *\\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox</span><br><span class="line"> *\\     /   O peration     |</span><br><span class="line"> *\\    /    A nd           | Copyright (C) 1991-2009 OpenCFD Ltd.</span><br><span class="line"> *\\   /     M anipulation  |</span><br><span class="line"> * -------------------------------------------------------------------------------</span><br><span class="line"> license</span><br><span class="line"> This file is part of OpenFOAM.</span><br><span class="line"></span><br><span class="line"> OpenFOAM is free software; you can redistribute it and/or modify it</span><br><span class="line"> under the terms of the GNU General Public License as published by the</span><br><span class="line"> Free Software Foundation; either version 2 of the License, or (at your</span><br><span class="line"> option) any later version.</span><br><span class="line"></span><br><span class="line"> OpenFOAM is distributed in the hope that it will be useful, but WITHOUT</span><br><span class="line"> ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span><br><span class="line"> FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License</span><br><span class="line"> for more details.</span><br><span class="line"></span><br><span class="line"> You should have received a copy of the GNU General Public License</span><br><span class="line"> along with OpenFOAM; if not, write to the Free Software Foundation,</span><br><span class="line"> Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA</span><br><span class="line"></span><br><span class="line">Application</span><br><span class="line">   foamTimeAverage</span><br><span class="line"></span><br><span class="line">Author</span><br><span class="line">  Xiaoping Qiu </span><br><span class="line">  q.giskard@gmail.com</span><br><span class="line"></span><br><span class="line">Description</span><br><span class="line">Calculates the time average  of the specified volField over the specified time range.</span><br><span class="line"></span><br><span class="line">\*---------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "fvCFD.H"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> FieldType&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calcTimeAverage</span></span><br><span class="line"><span class="params">(</span><br><span class="line">    fvMesh&amp; mesh,</span><br><span class="line">    <span class="keyword">const</span> IOobject&amp; fieldHeader,</span><br><span class="line">    <span class="keyword">const</span> word&amp; fieldName,</span><br><span class="line">    Time&amp; runTime,</span><br><span class="line">    instantList&amp; timeDirs,</span><br><span class="line">    <span class="keyword">bool</span>&amp; done</span><br><span class="line">)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    label nfield = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> word meanFieldName = fieldName + <span class="string">"_mean"</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//Info &lt;&lt; "class name = " &lt;&lt; fieldHeader.headerClassName() &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//Info &lt;&lt; "typeName = " &lt;&lt; FieldType::typeName &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">if</span>(!done &amp;&amp; fieldHeader.headerClassName() == FieldType::typeName)</span><br><span class="line">    &#123;</span><br><span class="line">	<span class="function">FieldType <span class="title">dummy</span></span><br><span class="line">	    <span class="params">(</span><br><span class="line">		IOobject</span><br><span class="line">		(</span><br><span class="line">		    fieldName,</span><br><span class="line">		    runTime.timeName()</span>,</span><br><span class="line">		    mesh,</span><br><span class="line">		    IOobject::MUST_READ</span><br><span class="line">		),</span><br><span class="line">		mesh</span><br><span class="line">	    )</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">FieldType <span class="title">meanField</span></span><br><span class="line">	    <span class="params">(</span><br><span class="line">		IOobject</span><br><span class="line">		(</span><br><span class="line">		    meanFieldName,</span><br><span class="line">		    runTime.timeName()</span>,</span><br><span class="line">		    mesh,</span><br><span class="line">		    IOobject::NO_READ</span><br><span class="line">		),</span><br><span class="line">		dummy</span><br><span class="line">	    )</span>;</span><br><span class="line"></span><br><span class="line">	meanField *= scalar(<span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">	forAll(timeDirs, timeI)</span><br><span class="line">	&#123;</span><br><span class="line">	    runTime.setTime(timeDirs[timeI], timeI);</span><br><span class="line">	    Info &lt;&lt; <span class="string">"Time = "</span> &lt;&lt; runTime.timeName() &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	    <span class="function">IOobject <span class="title">io</span></span><br><span class="line">		<span class="params">(</span><br><span class="line">		    fieldName,</span><br><span class="line">		    runTime.timeName()</span>,</span><br><span class="line">		    mesh,</span><br><span class="line">		    IOobject::MUST_READ</span><br><span class="line">		)</span>;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span> (io.headerOk())</span><br><span class="line">	    &#123;</span><br><span class="line">		mesh.readUpdate();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(!done &amp;&amp; io.headerClassName() == FieldType::typeName)</span><br><span class="line">		&#123;</span><br><span class="line">		    Info &lt;&lt; <span class="string">"   Reading "</span> &lt;&lt; io.headerClassName() &lt;&lt; <span class="string">" "</span> &lt;&lt;io.name() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		    <span class="function">FieldType <span class="title">field</span><span class="params">(io, mesh)</span></span>;</span><br><span class="line"></span><br><span class="line">		    meanField += field;</span><br><span class="line">		    nfield++;</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">else</span></span><br><span class="line">	    &#123;</span><br><span class="line">		Info &lt;&lt; <span class="string">"   No Field "</span> &lt;&lt; fieldName &lt;&lt; endl; </span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(nfield &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	    Info &lt;&lt; <span class="string">"number of field = "</span> &lt;&lt; nfield &lt;&lt; endl;</span><br><span class="line">	    meanField /= nfield;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Info&lt;&lt; <span class="string">"writing to timeDir "</span> &lt;&lt; runTime.timeName()  &lt;&lt; endl;</span><br><span class="line">	meanField.write();</span><br><span class="line">	done = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Main program:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line"></span><br><span class="line">    Foam::timeSelector::addOptions();</span><br><span class="line">    <span class="preprocessor">#<span class="keyword">include</span> "addRegionOption.H"</span></span><br><span class="line">    Foam::argList::validArgs.append(<span class="string">"fieldName"</span>);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#   <span class="keyword">include</span> "setRootCase.H"</span></span><br><span class="line"><span class="preprocessor">#   <span class="keyword">include</span> "createTime.H"</span></span><br><span class="line">    instantList timeDirs = timeSelector::select0(runTime, args);</span><br><span class="line">    runTime.setTime(timeDirs[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line"><span class="preprocessor">#   <span class="keyword">include</span> "createNamedMesh.H"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// get filename from command line</span></span><br><span class="line">    <span class="keyword">const</span> word fieldName = args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">bool</span> done = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">IOobject <span class="title">fieldHeader</span></span><br><span class="line">	<span class="params">(</span><br><span class="line">	    fieldName,</span><br><span class="line">	    runTime.timeName()</span>,</span><br><span class="line">	    mesh,</span><br><span class="line">	    IOobject::MUST_READ</span><br><span class="line">	)</span>;</span><br><span class="line">    <span class="keyword">if</span>(fieldHeader.headerOk())<span class="comment">//very important!</span></span><br><span class="line">    &#123;</span><br><span class="line">	calcTimeAverage&lt;volScalarField&gt;(mesh, fieldHeader, fieldName, runTime, timeDirs, done);</span><br><span class="line">	calcTimeAverage&lt;volVectorField&gt;(mesh, fieldHeader, fieldName, runTime, timeDirs, done);</span><br><span class="line">	calcTimeAverage&lt;volTensorField&gt;(mesh, fieldHeader, fieldName, runTime, timeDirs, done);</span><br><span class="line">	calcTimeAverage&lt;volSymmTensorField&gt;(mesh, fieldHeader, fieldName, runTime, timeDirs, done);</span><br><span class="line">	calcTimeAverage&lt;volSphericalTensorField&gt;(mesh, fieldHeader, fieldName, runTime, timeDirs, done);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">	Info&lt;&lt; <span class="string">" Error! No field "</span> &lt;&lt; fieldName &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Info&lt;&lt; <span class="string">"End\n"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ************************************************************************* //</span></span><br></pre></td></tr></table></figure></p>
<p> 更详细的参考，包括编译和使用方法，见<a href="https://github.com/xiaopingqiu/foamTimeAverage" target="_blank" rel="external">代码的github页面</a>。</p>
<h3 id="一点说明">一点说明</h3><p> <code>foamTimeAverage</code> 这个程序有一个缺点，那就是只能根据输出的文件来计算时均值。举例说，假如算例的时间步长取<code>0.0001 s</code>，每<code>0.01 s</code> 输出一次，那<code>0.4 s-0.5 s</code>这个时间段的时均值就只涉及到<code>0.40s, 0.41s, 0.42s, ... 0.50s</code>这些时刻的值。有时候，如果想计算的是更精确的时均值，即<code>0.4000s, 0.4001s, 0.4002s ... 0.5000s</code>这些时刻的时均值，该怎么办呢？我没有实际测试过，但有一种方法我觉得可行，需要结合<code>fieldAverage</code>和<code>foamTimeAverage</code>来实现，具体操作如下：</p>
<ol>
<li><p>设置<code>fieldAverage</code>，注意将<code>resetOnOutput</code>设置为<code>true</code>，<code>outputControl</code>设置为<code>outputTime</code>，<code>base</code>设为<code>time</code>，<code>window</code>不需要设置，这样，应该就会在每一个输出的时间文件夹里输出一个时均值，这个时均值计算的上一次输出到下一次输出之间的时间段内的时均值，用上面的例子来说，即<code>0.5</code>文件夹内输出的<code>p</code>的时均值<code>pMean</code>是<code>0.4001s, 0.4002s, ... 0.5000s</code>这些时刻的<code>p</code>的时均值。</p>
</li>
<li><p>用<code>foamTimeAverage</code>计算指定时间段内<code>pMean</code>的时均值。举例说，<br><code>foamTimeAverage pMean -time 0.04:0.05</code> 计算的将是 <code>0.3001s, 0.3002s, ... 0.5000s</code>这些时刻的时均值，这是因为，0.04 文件夹内的<code>pMean</code>是 <code>0.3001s, 0.3002s, ... 0.4000s</code>的时均值，0.05 文件夹内的<code>pMean</code>是<code>0.4001s, 0.4002s, ... 0.5000s</code>时刻内的时均值。</p>
<p>用以上方法就可以实现计算指定时间段内同时精度更高的时均值了。<strong>再次申明一下，上述方法仅仅是我根据原理进行的推演，没有经过检验</strong>。</p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p> 在我的<a href="http://xiaopingqiu.github.io/2015/04/12/fieldAverage/">以前的一篇博文</a>中，我介绍了<code>fieldAverage</code>这个<code>functionObject</code>的用法，其中提到， 可以用<code>window</code>这个参数来控制所计算的时均值的时间范围。如果 <code>base = time</code>且<code>window = 10</code>，那从第10s以后，每个时刻 t 输出的时均值其实相当于从 t-10 到 t 这个时间段内的时均值。但是，根据分析可以发现，这个时均值并不严格等价于从 t-10 时刻到 t 时刻某个场的时均值。有时候，需要从某个时刻才开始计算时均值，而<code>fieldAverage</code>没有参数可以控制从某个时刻才开始计算时间平均。于是我参照<code>OpenFOAM</code>的<code>patchAverage.C</code>的代码写了一个后处理程序，用来计算指定时间段内的某个场的时均值。</p>]]>
    
    </summary>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/tags/OpenFOAM/"/>
    
      <category term="Postprocessing" scheme="http://xiaopingqiu.github.io/tags/Postprocessing/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[twoPhaseEulerFoam 全解读之二]]></title>
    <link href="http://xiaopingqiu.github.io/2015/05/17/twoPhaseEulerFoam2/"/>
    <id>http://xiaopingqiu.github.io/2015/05/17/twoPhaseEulerFoam2/</id>
    <published>2015-05-17T07:23:04.000Z</published>
    <updated>2015-05-20T07:34:36.336Z</updated>
    <content type="html"><![CDATA[<p>本系列将对OpenFOAM-2.1.1 中的 <code>twoPhaseEulerFoam</code> 求解器进行完全解读，共分三部分：方程推导，代码解读，补充说明。本篇对 <code>twoPhaseEulerFoam</code> 中的 <code>UEqn.H</code> 和 <code>pEqn.H</code> 中的代码进行详细地的解读。</p>
<a id="more"></a>
<h2 id="2-_代码解读">2. 代码解读</h2><h3 id="2-1-_UEqn">2.1. UEqn</h3><p>前一篇导出了分散相的动量守恒方程<br>$$<br>\begin{aligned}<br>&amp;(1+\frac{\alpha_b \rho_b}{\rho_a} C_{vm})(\frac{\partial U_a}{\partial t} + U_a\cdot \nabla U_a ) -\nabla \cdot \left[ \nu_{eff} \nabla U_a \right ] + \nabla \cdot \left[ R_{c,a}\right] + \frac{\nabla(\alpha_a)}{\alpha_a} \cdot \left[ -\nu_{eff}\nabla U_a + R_{c,a}\right] \\<br>= &amp; -\frac{\alpha_b}{\rho_a} K U_a - \frac{\alpha_b}{\rho_a} \left\{ {C_l (\alpha_b \rho_b + \alpha_a \rho_a) U_r \times (\nabla \times U) -  C_{vm}\rho_b\left[ {\frac{\partial U_b}{\partial t} + U_b \cdot \nabla U_b }\right] } \right\} -\frac{\nabla p}{\rho_a} + g + \frac{\alpha_b}{\rho_a} K U_b<br> \end{aligned}<br>$$<br>这一篇分析<code>twoPhaseEulerFoam</code>求解器是怎么来对动量方程进行离散的，以及，如果通过构建压力方程来对速度进行修正以保证两相的连续性。</p>
<p>注意上述动量方程中，有两项还需要处理一下：<br>$$U_a \cdot \nabla U_a=\nabla\cdot(U_aU_a)-U_a(\nabla\cdot U_a)$$</p>
<p>$$\frac{\nabla(\alpha_a)}{\alpha_a}\cdot\left[-\nu_{eff} \nabla U_a\right] = \nabla \cdot\left[ -\nu_{eff}\frac{(\nabla \alpha_a)}{\alpha_a}(\nabla U_a)\right]-U_a\left(\nabla\cdot(-\nu_{eff}\frac{\nabla \alpha_a}{\alpha_a}) \right)$$<br>转化前后的形式从数学上来等价的，但是在有限体积离散过程中，转化前的 $U_a \cdot \nabla U_a$  和 $\frac{\nabla(\alpha_a)}{\alpha_a}\cdot\left[-\nu_{eff} \nabla U_a\right]$ 对于$U_a$来说是非守恒的，转化后的形式是守恒的(参考<a href="http://www.sciencedirect.com/science/article/pii/S0029549309003021" target="_blank" rel="external">这篇文献</a>，注意这样转化后，动量方程空间上是守恒的，但时间上仍是不守恒的，<a href="http://www.cfd-online.com/Forums/openfoam-solving/71141-rewriting-twophaseeulerfoam-conservative-form.html" target="_blank" rel="external">这个帖子</a>也有一些有价值的信息)。</p>
<p>这样转化以后，得到的动量方程就跟<code>twoPhaseEulerFoam</code>里的定义是一模一样了:<br>$$<br>\begin{aligned}<br>&amp;(1+\frac{\alpha_b \rho_b}{\rho_a} C_{vm})\left(\frac{\partial U_a}{\partial t} + \nabla\cdot(U_aU_a)-U_a(\nabla\cdot U_a) \right)\\<br>-&amp;\nabla \cdot \left[ \nu_{eff} \nabla U_a \right ] + \nabla \cdot \left[ R_{c,a}\right] +\nabla \cdot\left[ -\nu_{eff}\frac{(\nabla \alpha_a)}{\alpha_a}(\nabla U_a)\right]-U_a\left(\nabla\cdot(-\nu_{eff}\frac{\nabla \alpha_a}{\alpha_a}) \right) \\<br>+ &amp; \frac{\nabla(\alpha_a)}{\alpha_a} \cdot \left[ R_{c,a}\right] \\<br>= &amp; -\frac{\alpha_b}{\rho_a} K U_a - \frac{\alpha_b}{\rho_a} \left\{ {C_l (\alpha_b \rho_b + \alpha_a \rho_a) U_r \times (\nabla \times U) -  C_{vm}\rho_b\left[ {\frac{\partial U_b}{\partial t} + U_b \cdot \nabla U_b }\right] } \right\} \\<br>-&amp;\frac{\nabla p}{\rho_a} + g + \frac{\alpha_b}{\rho_a} K U_b<br> \end{aligned}<br>$$</p>
<p>下面将动量方程的每一项与<code>twoPhaseEulerFoam</code>的<code>UEqn.H</code>的代码一一对应。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">scalar</span><span class="list">(<span class="number">1</span>)</span> + Cvm*rhob*beta/rhoa)</span>*</span><br><span class="line">            <span class="list">(</span><br><span class="line">                <span class="keyword">fvm</span>:<span class="keyword">:ddt</span><span class="list">(<span class="keyword">Ua</span>)</span></span><br><span class="line">              + fvm:<span class="keyword">:div</span><span class="list">(<span class="keyword">phia</span>, Ua, <span class="string">"div(phia,Ua)"</span>)</span></span><br><span class="line">              - fvm:<span class="keyword">:Sp</span><span class="list">(<span class="keyword">fvc</span>:<span class="keyword">:div</span><span class="list">(<span class="keyword">phia</span>)</span>, Ua)</span></span><br><span class="line">            )</span></span><br></pre></td></tr></table></figure></p>
<p><code>fvm::ddt(Ua)</code>对应$\frac{\partial U_a}{\partial t}$，<code>phia</code>定义为<code>fvc::interpolate(Ua) &amp; mesh.Sf()</code>，于是<code>fvm::div(phia, Ua, &quot;div(phia,Ua)&quot;)</code> 和 <code>fvm::Sp(fvc::div(phia), Ua)</code> 便分别对应 $\nabla\cdot(U_aU_a)$ 和 $U_a(\nabla\cdot U_a)$了 <strong>[ <em>注一</em> ]</strong>。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- fvm::<span class="function"><span class="title">laplacian</span><span class="params">(nuEffa, Ua)</span></span></span><br><span class="line">+ fvc::<span class="function"><span class="title">div</span><span class="params">(Rca)</span></span></span><br><span class="line">+ fvm::<span class="function"><span class="title">div</span><span class="params">(phiRa, Ua, <span class="string">"div(phia,Ua)"</span>)</span></span></span><br><span class="line">- fvm::<span class="function"><span class="title">Sp</span><span class="params">(fvc::div(phiRa)</span></span>, Ua)</span><br></pre></td></tr></table></figure>
<p><code>fvm::laplacian(nuEffa, Ua)</code>对应$\nabla \cdot \left[ \nu_{eff} \nabla U_a \right ]$，<code>fvc::div(Rca)</code>对应$\nabla \cdot \left[ R_{c,a}\right]$。<br><code>phiRa</code>的定义是<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-fvc::<span class="function"><span class="title">interpolate</span><span class="params">(nuEffa)</span></span>*mesh.<span class="function"><span class="title">magSf</span><span class="params">()</span></span>*fvc::<span class="function"><span class="title">snGrad</span><span class="params">(alpha)</span></span></span><br><span class="line">            /fvc::<span class="function"><span class="title">interpolate</span><span class="params">(alpha + scalar(<span class="number">0.001</span>)</span></span>)</span><br></pre></td></tr></table></figure></p>
<p>相当于$-\nu_{eff}\frac{\nabla \alpha_a}{\alpha_a}$ <strong>[ <em>注二</em> ]</strong>。<br>于是 <code>fvm::div(phiRa, Ua, &quot;div(phia,Ua)&quot;)</code> 和 <code>fvm::Sp(fvc::div(phiRa), Ua)</code> 便分别对应 $\nabla \cdot\left[ -\nu_{eff} \frac{(\nabla \alpha_a)}{\alpha_a}(\nabla U_a)\right] $ 和 $U_a\left(\nabla\cdot(-\nu_{eff}\frac{\nabla \alpha_a}{\alpha_a}) \right)$。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">fvc</span>:<span class="keyword">:grad</span><span class="list">(<span class="keyword">alpha</span>)</span>/<span class="list">(<span class="keyword">fvc</span>:<span class="keyword">:average</span><span class="list">(<span class="keyword">alpha</span>)</span> + scalar<span class="list">(<span class="number">0.001</span>)</span>)</span> &amp; Rca)</span></span><br></pre></td></tr></table></figure>
<p>对应$\frac{\nabla(\alpha_a)}{\alpha_a} \cdot \left[ R_{c,a}\right]$，其中<code>&amp;</code>运算符已重载为计算矢量与张量的点乘积 <strong>[ <em>注三</em> ]</strong>。</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> =<span class="ruby">=</span><br><span class="line"></span><span class="comment">//  g                          // Buoyancy term transfered to p-equation</span></span><br><span class="line">-<span class="ruby"> <span class="symbol">fvm:</span><span class="symbol">:Sp</span>(beta/rhoa*<span class="constant">K</span>, <span class="constant">Ua</span>)</span><br><span class="line"></span><span class="comment">//+ beta/rhoa*K*Ub             // Explicit drag transfered to p-equation</span></span><br><span class="line">-<span class="ruby"> beta/rhoa*(liftCoeff - <span class="constant">Cvm</span>*rhob*<span class="constant">DDtUb</span>)</span><br><span class="line"></span>        );</span><br></pre></td></tr></table></figure>
<p><code>fvm::Sp(beta/rhoa*K, Ua)</code>对应 $\frac{\alpha_b}{\rho_a} K U_a$，<code>beta/rhoa*(liftCoeff - Cvm*rhob*DDtUb)</code> 对应<br>$$<br>\frac{\alpha_b}{\rho_a} \left\{ {C_l (\alpha_b \rho_b + \alpha_a \rho_a) U_r \times (\nabla \times U) -  C_{vm}\rho_b\left[ {\frac{\partial U_b}{\partial t} + U_b \cdot \nabla U_b }\right] } \right\}<br>$$<br>其中变量<code>liftCoeff</code>定义为<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">volVectorField</span> <span class="tag">liftCoeff</span>(<span class="tag">Cl</span>*(<span class="tag">beta</span>*<span class="tag">rhob</span> + <span class="tag">alpha</span>*<span class="tag">rhoa</span>)*(<span class="tag">Ur</span> ^ <span class="rule"><span class="attribute">fvc</span>:<span class="value">:<span class="function">curl</span>(U)))</span></span>;</span><br></pre></td></tr></table></figure></p>
<p><code>DDtUb</code>定义为<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DDtUb =</span><br><span class="line">        fvc::ddt(Ub)</span><br><span class="line">      + fvc::div(phib, Ub)</span><br><span class="line">      - fvc::div(phib)*Ub;</span><br></pre></td></tr></table></figure></p>
<p>重力 $g$ 以及曳力的显式项 $\frac{\alpha_b}{\rho_a} K U_b $ 如注释所述，将会在 <code>pEqn</code> 中考虑，压力梯度项 $\frac{\nabla p}{\rho_a}$ 则将在 <code>pEqn</code> 中用来约束两相的连续性。<br>至此动量方程的每一项都与<code>UEqn.H</code>的代码对应起来了。</p>
<h3 id="2-_pEqn">2. pEqn</h3><p>压力方程的作用是修正两相速度$U_a$ 和 $U_b$以使速度满足连续性方程。将两相的连续性方程加起来，得到总体的连续性方程如下 <strong>[ <em>注四</em> ]</strong>：<br>$$\begin{aligned}<br>&amp; \frac{\partial \alpha_a}{\partial t} + \nabla \cdot (\alpha_a U_a) + \frac{\partial \alpha_b}{\partial t} + \nabla \cdot (\alpha_b U_b) \\<br>= &amp; \frac{\partial (\alpha_a+\alpha_b)}{\partial t} + \nabla \cdot (\alpha_a U_a+\alpha_b U_b) = 0<br>\end{aligned}$$<br>由于$\alpha_a+\alpha_b=1$，于是两相连续性方程等价于<br>$$<br>\nabla \cdot (\alpha_a U_a+\alpha_b U_b) = 0<br>$$</p>
<p>再来看压力方程是如何构建起来的。<br>完整的动量方程离散后，可以写作如下的统一形式：<br>$$<br>a_{p,a}U_{p,a}=H(U_a)-\frac{\nabla p}{\rho_a}+\frac{\alpha_b}{\rho_a} K U_b +g<br>$$</p>
<p>$$<br>a_{p,b}U_{p,b}=H(U_b)-\frac{\nabla p}{\rho_b}+\frac{\alpha_a}{\rho_b} K U_a +g<br>$$<br>其中$H(U_a)$ 和 $H(U_b)$ 包含了动量方程中除 压力梯度项，显式曳力项以及重力项以后所有项的贡献。<br>由此离散方程可以得到 $U_a$ 和 $U_b$ 的表达式如下：<br>$$<br>U_{a}=\frac{1}{a_{p,a}}H(U_a)-\frac{\nabla p}{a_{p,a}\rho_a}+\frac{\alpha_b}{ a_{p,a} \rho_a} K U_b +\frac{1}{a_{p,a}} g<br>$$</p>
<p>$$<br>U_{b}=\frac{1}{a_{p,b}}H(U_b)-\frac{\nabla p}{a_{p,b}\rho_b}+\frac{\alpha_a}{ a_{p,b} \rho_b} K U_a +\frac{1}{a_{p,b}} g<br>$$</p>
<p>如果此 $U_a$ 和 $U_b$ 是方程组的解，那么它们必须满足整体的连续性方程，即<br>$$\begin{aligned}<br>&amp; \nabla \cdot \left[ \alpha_a (\frac{1}{a_{p,a}}H(U_a)-\frac{\nabla p}{a_{p,a}\rho_a}+\frac{\alpha_b}{ a_{p,a} \rho_a} K U_b +\frac{1}{a_{p,a}} g)\right] \\<br>+ &amp; \nabla \cdot \left[ \alpha_b (\frac{1}{a_{p,b}}H(U_b)-\frac{\nabla p}{a_{p,b}\rho_b}+\frac{\alpha_a}{ a_{p,b} \rho_b} K U_a +\frac{1}{a_{p,b}} g ) \right] = 0<br>\end{aligned}$$<br>将压力梯度项移到方程的一边，得到<br>$$\begin{aligned}<br>&amp; \nabla \cdot \left[ \alpha_a (\frac{1}{a_{p,a}}H(U_a)+\frac{\alpha_b}{ a_{p,a} \rho_a} K U_b +\frac{1}{a_{p,a}} g)\right] + \nabla \cdot \left[ \alpha_b (\frac{1}{a_{p,b}}H(U_b)+\frac{\alpha_a}{ a_{p,b} \rho_b} K U_a +\frac{1}{a_{p,b}} g ) \right] \\<br>= &amp;\nabla \cdot \left[ (\frac{\alpha_a }{a_{p,a}\rho_a} + \frac{\alpha_b }{a_{p,b}\rho_b})  \nabla p \right ]<br>\end{aligned}$$<br><strong>这便是压力修正方程的原型</strong>。<br>在<code>pEqn.H</code>中，压力方程其实修正的是界面通量，压力方程迭代收敛以后能保证界面通量的连续性。所以，散度表达式需要根据高斯定理写成界面通量之和的形式：<br>$$\begin{aligned}<br>&amp; \nabla \cdot \left[ \alpha_a (\frac{1}{a_{p,a}}H(U_a)+\frac{\alpha_b}{ a_{p,a} \rho_a} K U_b +\frac{1}{a_{p,a}} g)\right] \\<br>= &amp; (\alpha_a)_f \left[\sum_f(\frac{1}{a_{p,a}})_f H(U_a)\cdot S_f + \sum_f(\frac{\alpha_b K}{ a_{p,a} \rho_a})_f U_b \cdot S_f +\sum_f(\frac{1}{a_{p,a}})_f g \cdot S_f \right ]<br>\end{aligned}$$<br>下标 $_f$ 表示该项将要在代码中用界面上的变量来表示，在OpenFOAM中，即<code>surfaceScalarField</code>，$S_f$ 表示界面的面积矢量，下面的公式里也是一样。<br>$$\begin{aligned}<br>&amp; \nabla \cdot \left[ \alpha_b (\frac{1}{a_{p,b}}H(U_b)+\frac{\alpha_a}{ a_{p,b} \rho_b} K U_a +\frac{1}{a_{p,b}} g)\right] \\<br>= &amp; (\alpha_b)_f \left[\sum_f(\frac{1}{a_{p,b}})_f H(U_b)\cdot S_f + \sum_f(\frac{\alpha_a K}{ a_{p,b} \rho_b})_f U_a \cdot S_f +\sum_f(\frac{1}{a_{p,b}})_f g \cdot S_f \right]<br>\end{aligned}$$</p>
<p>以及<br>$$<br> \nabla \cdot \left[ (\frac{\alpha_a }{a_{p,a}\rho_a} + \frac{\alpha_b }{a_{p,b}\rho_b})  \nabla p \right ] = \sum_f (\frac{\alpha_a }{a_{p,a}\rho_a} + \frac{\alpha_b }{a_{p,b}\rho_b})_f (\nabla p) \cdot S_f<br>$$<br>下面是<code>pEqn</code>定义了几个跟界面通量有关的变量：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">surfaceScalarField alphaf(fvc::interpolate(alpha));</span><br><span class="line">surfaceScalarField betaf(scalar(<span class="number">1</span>) - alphaf);</span><br><span class="line"></span><br><span class="line">volScalarField rUaA(<span class="number">1.0</span>/UaEqn.A());</span><br><span class="line">volScalarField rUbA(<span class="number">1.0</span>/UbEqn.A());</span><br><span class="line"></span><br><span class="line">phia == (fvc::interpolate(Ua) &amp; mesh.Sf());</span><br><span class="line">phib == (fvc::interpolate(Ub) &amp; mesh.Sf());</span><br><span class="line"></span><br><span class="line">rUaAf = fvc::interpolate(rUaA);</span><br><span class="line">surfaceScalarField rUbAf(fvc::interpolate(rUbA));</span><br><span class="line"></span><br><span class="line">Ua = rUaA*UaEqn.H();</span><br><span class="line">Ub = rUbA*UbEqn.H();</span><br><span class="line"></span><br><span class="line">surfaceScalarField phiDraga</span><br><span class="line">(</span><br><span class="line">    fvc::interpolate(beta/rhoa*K*rUaA)*phib + rUaAf*(g &amp; mesh.Sf())</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">surfaceScalarField phiDragb</span><br><span class="line">(</span><br><span class="line">    fvc::interpolate(alpha/rhob*K*rUbA)*phia + rUbAf*(g &amp; mesh.Sf())</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">phia = (fvc::interpolate(Ua) &amp; mesh.Sf()) + fvc::ddtPhiCorr(rUaA, Ua, phia) + phiDraga;</span><br><span class="line">phib = (fvc::interpolate(Ub) &amp; mesh.Sf()) + fvc::ddtPhiCorr(rUbA, Ub, phib) + phiDragb;</span><br><span class="line"></span><br><span class="line">phi = alphaf*phia + betaf*phib;</span><br><span class="line"></span><br><span class="line">surfaceScalarField Dp</span><br><span class="line">(</span><br><span class="line">    <span class="string">"(rho*(1|A(U)))"</span>,</span><br><span class="line">    alphaf*rUaAf/rhoa + betaf*rUbAf/rhob</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p><code>phiDraga</code> 和 <code>phiDragb</code> 分别对应 $(\frac{\alpha_b K}{ a_{p,a} \rho_a})_f U_b \cdot S_f +(\frac{1}{a_{p,a}})_f g \cdot S_f$ 和 $(\frac{\alpha_a K}{ a_{p,b} \rho_b})_f U_a \cdot S_f +(\frac{1}{a_{p,b}})_f g \cdot S_f$</p>
<p>由于13-14行的定义，28-29行中的 <code>(fvc::interpolate(Ua) &amp; mesh.Sf())</code> 和 <code>(fvc::interpolate(Ub) &amp; mesh.Sf())</code> 便分别对应的是 $(\frac{1}{a_{p,a}})_f H(U_a)\cdot S_f$ 和 $(\frac{1}{a_{p,b}})_f H(U_b)\cdot S_f$ 。</p>
<p>有了上面的定义，可以看出31行定义的<code>phi=alphaf*phia + betaf*phib</code>便表示了压力方程的左边。</p>
<p>再看33-36行定义的<code>Dp</code>，很显然，表示的是压力方程右边的$(\frac{\alpha_a }{a_{p,a}\rho_a} + \frac{\alpha_b }{a_{p,b}\rho_b})_f$。</p>
<p>有了以上的定义，便可以构建用于修正界面通量的压力方程了：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fvScalarMatrix pEqn</span><br><span class="line">  <span class="list">(</span><br><span class="line">     <span class="keyword">fvm</span>:<span class="keyword">:laplacian</span><span class="list">(<span class="keyword">Dp</span>, p)</span> == fvc:<span class="keyword">:div</span><span class="list">(<span class="keyword">phi</span>)</span></span><br><span class="line">  )</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>如上所述，<code>pEqn</code>收敛以后，得到的就是满足连续性的界面通量了，然后再利用求得的界面通量来修正两相的速度，便得到了满足两相连续性的速度：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Ua += fvc::reconstruct(phiDraga - rUaAf<span class="keyword">*</span>SfGradp/rhoa);</span><br><span class="line">Ua.correctBoundaryConditions();</span><br><span class="line"></span><br><span class="line">Ub += fvc::reconstruct(phiDragb - rUbAf<span class="keyword">*</span>SfGradp/rhob);</span><br><span class="line">Ub.correctBoundaryConditions();</span><br><span class="line"></span><br><span class="line">U = alpha<span class="keyword">*</span>Ua + beta<span class="keyword">*</span>Ub;</span><br></pre></td></tr></table></figure></p>
<p>注意，<code>Ua</code>和<code>Ub</code>为什么是这样来修正呢？回想上面变量定义那个代码段的13-14行，这两行将<code>Ua</code>和<code>Ub</code>分别定义成了$\frac{1}{a_{p,a}} H(U_a)$ 和 $\frac{1}{a_{p,b}} H(U_b)$。<br>回想<code>Ua</code>和<code>Ub</code>的离散方程的统一形式<br>$$<br>U_{a}=\frac{1}{a_{p,a}}H(U_a)-\frac{\nabla p}{a_{p,a}\rho_a}+\frac{\alpha_b}{ a_{p,a} \rho_a} K U_b +\frac{1}{a_{p,a}} g<br>$$</p>
<p>$$<br>U_{b}=\frac{1}{a_{p,b}}H(U_b)-\frac{\nabla p}{a_{p,b}\rho_b}+\frac{\alpha_a}{ a_{p,b} \rho_b} K U_a +\frac{1}{a_{p,b}} g<br>$$</p>
<p>会发现13-14行定义的<code>Ua</code>和<code>Ub</code>都少了几项，所以缺了的这几项的贡献需要在速度修正步骤加回来，而<code>Ua+=</code>后面的<code>fvc::reconstruct(phiDraga - rUaAf*SfGradp/rhoa)</code>刚好就对应着<code>Ua</code>缺少的那几项。因为经过压力方程修正以后，界面通量是连续的，所以，将缺失的几项对应的界面通量通过<code>reconstruct</code>函数从界面通量重构从对体中心的速度的贡献，便得到了满足连续性的体中心速度了。对<code>Ub</code>也是同样的。</p>
<p>经过以上步骤，便能得到满足整体连续性的两相速度<code>Ua</code> 和 <code>Ub</code>了。</p>
<h2 id="注释">注释</h2><p><strong>注一</strong>：OpenFOAM 里的<code>div</code>函数，字面意义上看起来好像是散度的意思，实际上，<code>div</code>函数执行的是<strong>加和</strong>运算。举例说，对于<code>fvc::div(phia)</code>，<code>phia</code>是<code>surfaceScalarField</code>，其值为<code>(fvc::interpolate(Ua) &amp; mesh.Sf())</code>，即将存储在体中心的<code>Ua</code>插值到每个网格对应的面的面心，然后用面心的速度与该面的面积矢量点乘。从代码中看，<code>fvc::div(phia)</code>对应的是 $\nabla \cdot U_a$，根据高斯定理，也就是 $\sum_f (U_a)_f \cdot S_f$，而<code>phia</code>对应着 $(U_a)_f \cdot S_f$，所以，<code>fvc::div(phia)</code>实际进行的运算是将包围每个网格的面上的通量加起来。更详细的说明见我的<a href="http://xiaopingqiu.github.io/2015/05/17/OpenFOAMcode1/" target="_blank" rel="external">另一篇博文</a>。<br><strong>注二</strong>：注意这里的$\frac{\nabla \alpha_a}{\alpha_a}$ 在代码中的表示方法，详细说明见我的<a href="http://xiaopingqiu.github.io/2015/05/17/OpenFOAMcode1/" target="_blank" rel="external">另一篇博文</a>。<br><strong>注三</strong>：注意这里的$\frac{\nabla \alpha_a}{\alpha_a}$ 在代码中的表示方法，以及与上一个$\frac{\nabla \alpha_a}{\alpha_a}$ 的区别，详细说明见我的<a href="http://xiaopingqiu.github.io/2015/05/17/OpenFOAMcode1/" target="_blank" rel="external">另一篇博文</a>。<br><strong>注四</strong>：这里说的总体的连续性方程指的是<strong>总体体积的守恒</strong>，而不是总体质量的守恒，这二者的差异见Henrik Rusche 的 PHD 论文 P112 的说明。</p>
<h2 id="参考资料">参考资料</h2><ol>
<li>Henrik Rusche， PHD Thesis， Computational Fluid Dynamics of Dispersed Two-Phase Flows at High Phase Fractions， Imperial College of Science, Technology &amp; Medicine, Department of Mechanical Engineering, 2002</li>
<li><a href="https://openfoamwiki.net/index.php/BubbleFoam" target="_blank" rel="external">https://openfoamwiki.net/index.php/BubbleFoam</a></li>
<li><a href="http://www.cfd-online.com/Forums/openfoam-solving/71141-rewriting-twophaseeulerfoam-conservative-form.html" target="_blank" rel="external">http://www.cfd-online.com/Forums/openfoam-solving/71141-rewriting-twophaseeulerfoam-conservative-form.html</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>本系列将对OpenFOAM-2.1.1 中的 <code>twoPhaseEulerFoam</code> 求解器进行完全解读，共分三部分：方程推导，代码解读，补充说明。本篇对 <code>twoPhaseEulerFoam</code> 中的 <code>UEqn.H</code> 和 <code>pEqn.H</code> 中的代码进行详细地的解读。</p>]]>
    
    </summary>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/tags/OpenFOAM/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[twoPhaseEulerFoam 全解读之一]]></title>
    <link href="http://xiaopingqiu.github.io/2015/05/17/twoPhaseEulerFoam1/"/>
    <id>http://xiaopingqiu.github.io/2015/05/17/twoPhaseEulerFoam1/</id>
    <published>2015-05-17T06:46:07.000Z</published>
    <updated>2015-05-17T07:16:05.037Z</updated>
    <content type="html"><![CDATA[<p>本系列将对OpenFOAM-2.1.1 中的 <code>twoPhaseEulerFoam</code> 求解器进行完全解读，共分三部分：方程推导，代码解读，补充说明。本篇进行方程推导，详细介绍如果从双流体模型出发得到 <code>twoPhaseEulerFoam</code> 中的 <code>UEqn.H</code> 对应的模型方程形式。</p>
<a id="more"></a>
<h2 id="1-_方程推导">1. 方程推导</h2><p>双流体模型方程可以表达成如下形式：</p>
<p><strong>连续性方程</strong>：<br>$$\frac{\partial(\alpha_\phi\rho_\phi)}{\partial t}+\nabla\cdot(\alpha_\phi\rho_\phi U_\phi)=0$$<br><strong>动量守恒方程</strong>:<br>$$\frac{\partial(\alpha_\phi\rho_\phi U_\phi)}{\partial t}+\nabla\cdot(\alpha_\phi\rho_\phi U_\phi U_\phi)+\nabla\cdot(\alpha_\phi\tau_\phi)+\nabla\cdot(\alpha_\phi\rho_\phi R_\phi )=-\alpha_\phi\nabla p+\alpha_\phi\rho_\phi g+M_\phi$$<br>式中，下标$\phi=a,b$分别代表分散相和连续相，$\tau_\phi$表示粘性应力项，$R_\phi$表示雷诺应力项，$M_\phi$表示相间作用项。<br>上述方程是完全守恒形式的，但是注意到上述动量方程的瞬变项是$\frac{\partial(\alpha_\phi\rho_\phi U_\phi)}{\partial t}$，等于说解这个方程能得到的是每个时间步的动量，若要转化成速度，则需要用动量除以密度与体积分率的乘积，即$\frac{(\alpha_\phi\rho_\phi U_\phi)}{\alpha_\phi\rho_\phi}$。那么当离散相a的体积分率$\alpha_a\to0$时，这个除法就要出问题了。于是，Weller [1] 提出通过构造一种”phase-intensive”形式的动量方程来避开这个问题，见下面的详细推导。<br>Weller提出的方法的核心是将$\alpha_\phi\rho_\phi$从动量方程的瞬变项中剥离出来，以使动量方程直接对速度进行演化，而不是动量。<br>首先对动量方程的瞬变项和对流项进行如下转化：<br>$$\frac{\partial(\alpha_\phi\rho_\phi U_\phi)}{\partial t}=\alpha_\phi\rho_\phi\frac{\partial( U_\phi)}{\partial t}+U_\phi\frac{\partial(\alpha_\phi\rho_\phi )}{\partial t}$$</p>
<p>$$\nabla\cdot(\alpha_\phi\rho_\phi U_\phi U_\phi)= \alpha_\phi\rho_\phi U_\phi\cdot \nabla( U_\phi) + U_\phi\nabla\cdot(\alpha_\phi\rho_\phi  U_\phi)$$<br>注：这里到了张量运算公式$[\nabla\cdot \mathbf{vw}]=[\mathbf{v}\cdot\nabla\mathbf{w}]+\mathbf{w}(\nabla\cdot\mathbf{v})$，具体可参考 Bird 的 Transport Phenomenon 的 Appendix A。</p>
<p>于是，瞬变项和对流项的加和可以写成如下形式：<br>$$\frac{\partial(\alpha_\phi\rho_\phi U_\phi)}{\partial t}+\nabla\cdot(\alpha_\phi\rho_\phi U_\phi U_\phi)=\alpha_\phi\rho_\phi\left[\frac{\partial( U_\phi)}{\partial t}+U_\phi \cdot \nabla( U_\phi)\right]+U_\phi \left[ \frac{\partial(\alpha_\phi\rho_\phi )}{\partial t}+\nabla\cdot(\alpha_\phi\rho_\phi  U_\phi)\right]$$<br>注意右边第二项的括号里其实就是连续性方程的左边，其值为0，因此得到：<br>$$\frac{\partial(\alpha_\phi\rho_\phi U_\phi)}{\partial t}+\nabla\cdot(\alpha_\phi\rho_\phi U_\phi U_\phi) = \alpha_\phi\rho_\phi\left[\frac{\partial( U_\phi)}{\partial t}+U_\phi \cdot \nabla( U_\phi)\right]$$</p>
<p>于是得到第一步转化之后的动量方程：<br>$$\alpha_\phi\rho_\phi\left[\frac{\partial( U_\phi)}{\partial t}+U_\phi\cdot\nabla( U_\phi)\right] + \nabla\cdot(\alpha_\phi\tau_\phi) + \nabla\cdot(\alpha_\phi\rho_\phi R_\phi ) = -\alpha_\phi\nabla p + \alpha_\phi\rho_\phi g + M_\phi$$</p>
<p>下面处理粘性应力项和雷诺应力项。</p>
<p>$$\nabla\cdot(\alpha_\phi\tau_\phi) + \nabla\cdot(\alpha_\phi\rho_\phi R_\phi )=\nabla\cdot\left[\alpha_\phi\rho_\phi(\frac{\tau_\phi}{\rho_\phi}+R_\phi)\right] = \nabla\cdot\left[\alpha_\phi\rho_\phi R_{eff,\phi}\right ]$$</p>
<p>其中 $R_{eff,\phi}=\frac{\tau_\phi}{\rho_\phi}+R_\phi$。</p>
<p>根据定义(此处参考<a href="https://openfoamwiki.net/index.php/BubbleFoam" target="_blank" rel="external">BubbleFoam的Wiki页面</a>)：<br>$$<br>\boldsymbol{\tau}_{\phi} = - \rho_{\phi} \nu_{\phi} \left[\nabla \mathbf{U}_{\phi} + \nabla^{\textrm{T}} \mathbf{U}_{\phi} \right] + \frac{2}{3}\rho_{\phi}\nu_{\phi} \left( \nabla \cdot \mathbf{U}_{\phi} \right) \mathbf{I}<br>$$<br>以及<br>$$<br>\mathbf{R}_{\phi} = -  \nu_{\phi,\textrm{t}} \left[ \nabla \mathbf{U}_{\phi} +\nabla^{\textrm{T}} \mathbf{U}_{\phi} \right] + \frac{2}{3}  \nu_{\phi,\textrm{t}} \left( \nabla \cdot \mathbf{U}_{\phi} \right) \mathbf{I} + \frac{2}{3} k_{\phi} \mathbf{I}<br>$$<br>代入到 $R_{eff,\phi}$中，得：<br>$$R_{eff,\phi}=-(\nu_\phi+\nu_{\phi , t})\left[ \nabla \mathbf{U}_{\phi} +\nabla^{\textrm{T}} \mathbf{U}_{\phi} \right]+\frac{2}{3}(\nu_\phi+\nu_{\phi , t}) \left (\nabla \cdot \mathbf{U}_{\phi}\right )  \mathbf{I} + \frac{2}{3} k_{\phi} \mathbf{I}$$<br>令 $\nu_{eff}=\nu_\phi+\nu_{\phi , t}$ ，则：<br>$$<br>R_{eff,\phi}=-\nu_{eff}\left[ \nabla \mathbf{U}_{\phi} +\nabla^{\textrm{T}} \mathbf{U}_{\phi} \right]+\frac{2}{3}\nu_{eff}<br>\left (\nabla \cdot \mathbf{U}_{\phi}\right )  \mathbf{I} + \frac{2}{3} k_{\phi} \mathbf{I} = -\nu_{eff}\nabla U_\phi + R_{c,\phi}<br>$$<br>其中$$R_{c,\phi}=-\nu_{eff} \nabla \mathbf{U}^\textrm{T}_{\phi}+\frac{2}{3}\nu_{eff}<br>\left (\nabla \cdot \mathbf{U}_{\phi}\right )  \mathbf{I} + \frac{2}{3} k_{\phi} \mathbf{I}$$</p>
<p>于是得到：<br> $$\begin{aligned}<br>\nabla\cdot\left[\alpha_\phi\rho_\phi R_{eff,\phi}\right ] = &amp; \nabla(\alpha_\phi\rho_\phi)\cdot\left[ R_{eff,\phi}\right] + \alpha_\phi\rho_\phi\nabla\cdot \left [ R_{eff,\phi}\right ]\\<br>=&amp; \alpha_\phi\rho_\phi\nabla\cdot\left[ -\nu_{eff}\nabla U_\phi\right] + \alpha_\phi\rho_\phi\nabla\cdot\left[ R_{c,\phi}\right] + \nabla(\alpha_\phi\rho_\phi)\left[ -\nu_{eff}\nabla U_\phi + R_{c,\phi}\right]<br>\end{aligned}<br> $$</p>
<p>代入到动量方程中，并且方程两边同时除以$\alpha_\phi\rho_\phi$，得到：<br> $$<br> \frac{\partial U_\phi}{\partial t} + U_\phi\cdot\nabla U_\phi -\nabla \cdot \left[ \nu_{eff} \nabla U_\phi \right ] + \nabla \cdot \left[ R_{c,\phi}\right] + \frac{\nabla(\alpha_\phi\rho_\phi)}{\alpha_\phi\rho_\phi}\cdot \left[ -\nu_{eff}\nabla U_\phi + R_{c,\phi}\right] = -\frac{\nabla p}{\rho_\phi} + g + \frac{M_\phi}{\alpha_\phi\rho_\phi}<br> $$</p>
<p>如果假定两相流体均为不可压缩，密度恒为常数，于是可以得到不可压缩的双流体模型的方程组：</p>
<p><strong>连续性方程</strong><br>$$\frac{\partial(\alpha_\phi)}{\partial t}+\nabla\cdot(\alpha_\phi U_\phi)=0$$</p>
<p><strong>动量方程</strong><br> $$<br> \frac{\partial U_\phi}{\partial t} + U_\phi\cdot\nabla U_\phi -\nabla \cdot \left[ \nu_{eff} \nabla U_\phi \right ] + \nabla \cdot \left[ R_{c,\phi}\right] + \frac{\nabla(\alpha_\phi)}{\alpha_\phi} \cdot \left[ -\nu_{eff}\nabla U_\phi + R_{c,\phi}\right] = -\frac{\nabla p}{\rho_\phi} + g + \frac{M_\phi}{\alpha_\phi\rho_\phi}<br> $$</p>
<p>方程中还剩下相间作用项没有处理，对于分散相和连续项形式，相间作用力是大小相等符号想反，这里只考虑分散相的形式，令$\phi=a$，则得到分散相的动量方程：<br>$$<br> \frac{\partial U_a}{\partial t} + U_a\cdot\nabla U_a -\nabla \cdot \left[ \nu_{eff} \nabla U_a \right ] + \nabla \cdot \left[ R_{c,a}\right] + \frac{\nabla(\alpha_a)}{\alpha_a} \cdot \left[ -\nu_{eff}\nabla U_a + R_{c,a}\right] = -\frac{\nabla p}{\rho_a} + g + \frac{M_a}{\alpha_a\rho_a}<br> $$</p>
<p> 相间作用只考虑曳力，升力以及虚拟质量力，即$M,a=M_{drag}+M_{lift}+M_{vm}$，下面分别考虑每一种相间作用力。</p>
<ul>
<li>曳力<br>$M_{drag}=-\beta(U_a-U_b)$，其中$\beta$为曳力系数。</li>
<li>升力<br>$M_{lift}=-\alpha_a\alpha_b C_l (\alpha_b \rho_b + \alpha_a \rho_a)U_r \times (\nabla \times U)$ ，其中 $U_r=U_a-U_b$，$U=\alpha_a U_a + \alpha_b U_b$</li>
<li>虚拟质量力<br>$M_{vm}=\alpha_a\alpha_b C_{vm}\rho_b\left[ \frac{DU_b}{Dt}-\frac{DU_a}{Dt}\right]$，其中$\frac{D}{Dt}$表示物质导数，$\frac{DU_b}{Dt}=\frac{\partial U_b}{\partial t} + U_b \cdot \nabla U_b$，$\frac{DU_a}{Dt}=\frac{\partial U_a}{\partial t}+U_a \cdot \nabla U_a$</li>
</ul>
<p>考虑到形式的统一，令$K=\frac{\beta}{\alpha_a\alpha_b}$，则曳力可表示为$M_{drag}=-\alpha_a\alpha_b K(U_a-U_b)$</p>
<p>代入到分散相a的动量方程中，得到：<br>$$\begin{aligned}<br>&amp;\frac{\partial U_a}{\partial t} + U_a\cdot \nabla U_a -\nabla \cdot \left[ \nu_{eff} \nabla U_a \right ] + \nabla \cdot \left[ R_{c,a}\right] + \frac{\nabla(\alpha_a)}{\alpha_a} \cdot \left[ -\nu_{eff}\nabla U_a + R_{c,a}\right] \\<br>= &amp; -\frac{\nabla p}{\rho_a} + g - \frac{\alpha_b}{\rho_a} K (U_a-U_b) - \frac{\alpha_b}{\rho_a}<br> C_l (\alpha_b \rho_b + \alpha_a \rho_a) U_r \times (\nabla \times U) \\<br> +&amp;  \frac{\alpha_b}{\rho_a} C_{vm}\rho_b\left[ \frac{\partial U_b}{\partial t} + U_b \cdot \nabla U_b - (\frac{\partial U_a}{\partial t}+U_a \cdot \nabla U_a)\right]<br> \end{aligned}$$</p>
<p>将相关的项合并，并调整顺序，便得到与<code>twoPhaseEulerFoam</code>求解器的<code>UEqn.H</code>文件中相同形式的分散相动量方程：<br>$$<br>\begin{aligned}<br>&amp;(1+\frac{\alpha_b \rho_b}{\rho_a} C_{vm})(\frac{\partial U_a}{\partial t} + U_a\cdot \nabla U_a ) -\nabla \cdot \left[ \nu_{eff} \nabla U_a \right ] + \nabla \cdot \left[ R_{c,a}\right] + \frac{\nabla(\alpha_a)}{\alpha_a} \cdot \left[ -\nu_{eff}\nabla U_a + R_{c,a}\right] \\<br>= &amp; -\frac{\alpha_b}{\rho_a} K U_a - \frac{\alpha_b}{\rho_a} \left\{ {C_l (\alpha_b \rho_b + \alpha_a \rho_a) U_r \times (\nabla \times U) -  C_{vm}\rho_b\left[ {\frac{\partial U_b}{\partial t} + U_b \cdot \nabla U_b }\right] } \right\} \\<br>- &amp; \frac{\nabla p}{\rho_a} + g + \frac{\alpha_b}{\rho_a} K U_b<br>\end{aligned}<br>$$</p>
<p>连续相b的动量方程形式相仿，这里就不再重复了。这里有几点<strong>注意事项</strong>：</p>
<ol>
<li>此处的双流体模型在推导的过程中，是把a当作分散相，b当作连续相的。分散相的体积分率$\alpha_a$可以等于0，但是连续项体积分率$\alpha_b$不能等于0 ，否则会出问题。</li>
<li>曳力系数 $\beta$ 的形式就是文献中常见的形式，比如，WenYu 曳力系数 $\beta=\frac{3}{4}\frac{(1-\alpha_b)\alpha_b}{d_{p,a}}|U_b-U_a|C_{D0}\alpha_b^{-2.7}$，Ergun 曳力系数 $\beta=150\frac{(1-\alpha_b)^2\mu_b}{\alpha_b d_a^2}+1.75\frac{(1-\alpha_b)\rho_b{U_b-U_a}}{d_a}$。而程序中定义的$K=\frac{\beta}{\alpha_a\alpha_b}$，所以，当$\alpha_b\to 0$时，如果用WenYu曳力那还不会出错，因为曳力系数中的分子里同时含有$\alpha_a\alpha_b$，运算$K=\frac{\beta}{\alpha_a\alpha_b}$不会出现除以0的问题；但如果用Ergun曳力，那就要出问题了，因为Ergun曳力系数中两项的分子都没有$\alpha_b$，所以运算$K=\frac{\beta}{\alpha_a\alpha_b}$就要出问题了。</li>
</ol>
<h2 id="参考资料">参考资料</h2><ol>
<li>Henrik Rusche， PHD Thesis， Computational Fluid Dynamics of Dispersed Two-Phase Flows at High Phase Fractions， Imperial College of Science, Technology &amp; Medicine, Department of Mechanical Engineering, 2002</li>
<li><a href="https://openfoamwiki.net/index.php/BubbleFoam" target="_blank" rel="external">https://openfoamwiki.net/index.php/BubbleFoam</a></li>
<li><a href="http://dyfluid.com/pdf/%E5%8F%8C%E6%B5%81%E4%BD%93%E6%A8%A1%E5%9E%8B%E5%9C%A8OpenFOAM%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90.pdf" target="_blank" rel="external">http://dyfluid.com/pdf/%E5%8F%8C%E6%B5%81%E4%BD%93%E6%A8%A1%E5%9E%8B%E5%9C%A8OpenFOAM%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90.pdf</a></li>
<li><a href="http://www.cfd-online.com/Forums/openfoam-solving/71141-rewriting-twophaseeulerfoam-conservative-form.html" target="_blank" rel="external">http://www.cfd-online.com/Forums/openfoam-solving/71141-rewriting-twophaseeulerfoam-conservative-form.html</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>本系列将对OpenFOAM-2.1.1 中的 <code>twoPhaseEulerFoam</code> 求解器进行完全解读，共分三部分：方程推导，代码解读，补充说明。本篇进行方程推导，详细介绍如果从双流体模型出发得到 <code>twoPhaseEulerFoam</code> 中的 <code>UEqn.H</code> 对应的模型方程形式。</p>]]>
    
    </summary>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/tags/OpenFOAM/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenFOAM 中的 div 与 snGrad 操作符]]></title>
    <link href="http://xiaopingqiu.github.io/2015/05/17/OpenFOAMcode1/"/>
    <id>http://xiaopingqiu.github.io/2015/05/17/OpenFOAMcode1/</id>
    <published>2015-05-17T06:02:37.000Z</published>
    <updated>2015-06-03T02:54:38.137Z</updated>
    <content type="html"><![CDATA[<p>OpenFOAM 的方便之处之一是利用<code>C++</code>的类模板和函数重载等技术定义了很多各种离散操作符，如<code>div</code>,<code>laplacian</code>,<code>grad</code> 等等。利用这些操作符，很容易就能对偏微分方程进行离散，并构建起线性方程组。但是，这些操作符真正执行的运算，却需要结合有限体积方法的本质来理解一番才能真正掌握。下面尝试着对 OpenFOAM 中的 <code>div</code> 和 <code>snGrad</code> 操作符进行一点解读。</p>
<a id="more"></a>
<h3 id="1-_div_操作符的本质">1. div 操作符的本质</h3><p> <code>div</code>操作符表面看，是计算散度的，实际上，在OpenFAOM中，div 操作符的作用是<strong>加和</strong>，比如说 $ \nabla \cdot (UU)$，在OpenFOAM中表示为<code>fvm::div(phi,U)</code>，这段代码真正执行的是$\sum_f U_f \phi_f$运算，即将每个网格包含的面上的流率与速度乘积，然后再加起来。再比如，<code>twoPhaseEulerFoam</code>的<code>UaEqn</code>方程有一项是<code>fvm::sp(fvc::div(phia),Ua)</code>，其对应的公式是 $U_a(\nabla \cdot U_a)$。为什么是这样呢？以下试图对背后的原理做一点解释：<br>单相流的动量守恒方程的微分形式如下：<br>$$\frac{\partial U}{\partial t}+\nabla\cdot (UU)+\nabla \cdot dev(-\nu_{eff} (\nabla U+(\nabla U)^T))=-\nabla p +Q$$<br>为了使用有限体积方法，需要将动量方程写成积分形式，即<br>$$\int_V\left [\frac{\partial U}{\partial t}+\nabla\cdot (UU)+\nabla \cdot dev(-\nu_{eff} (\nabla U+(\nabla U)^T))\right ]dV=\int_V\left [ -\nabla p +Q \right ]dV$$<br>这里只分析$\int_V \nabla\cdot (UU) dV$这一项，利用高斯定理，可以将这一个体积分，转化成对包围该体积微元的表面的面积分:$\oint_{\partial V} (UU)\cdot dS$，其中 $dS$ 是面积微元矢量。又因为实际操作中，一个体积微元总是由有限的几个面组成的，所以$$\oint_{\partial V} (UU)\cdot dS=\sum_f\int_{S_f}(UU)\cdot dS_f=\sum_f(UU)_f\cdot S_f$$，其中$$(UU)_f=\frac{1}{mag(S_f)}\int_{S_f}(UU)\cdot dS_f$$。<br>这里做一个近似：$$(UU)_f\approx(U_fU_f)$$<br>于是得到$$\sum_f(UU)_f\cdot S_f\approx \sum_f(U_fU_f)\cdot S_f$$<br>运用张量计算规则$[\mathbf{uv}\cdot\mathbf{w}]=\mathbf{u}(\mathbf{v} \cdot \mathbf{w})$，得到<br>$$\sum_f(U_fU_f)\cdot S_f=\sum_fU_f(U_f\cdot S_f)=\sum_fU_f\phi_f$$<br>综上，OpenFOAM中的代码<code>fvm::div(UU)</code>对应的公式其实是$\int_V \nabla\cdot (UU) dV$，而根据推导，在有限体积方法中 $\int_V \nabla\cdot (UU) dV=\sum_f(U_f\phi_f)$，所以，<code>fvm::div(UU)</code>实质上<strong>进行的运算是，把网格当作体积微元，将网格中心的速度 $U$ 插值到包围该网格的所有面上的面心上得到 $U_f$，并计算每个面上的速度通量 $\phi_f$，然后返回每一个面上的速度与通量乘积的加和</strong>。$U_f$的计算需要用到本网格与邻近网格的速度值，离散格式的作用就体现在如果利用本网格与邻近网格的速度得到面上的速度。</p>
<p> 再来看上面提到的另一项$U_a(\nabla \cdot U_a)$，根据上面类似的推导<br>$$\int_V\left [ U_a(\nabla \cdot U_a)\right ]dV=U_a\int_V(\nabla \cdot U_a)dV$$<br>注意，这里之所以能这样变换，是因为在一个体积微元dV内，Ua是常数。根据高斯定理<br>$$\int_V(\nabla \cdot U_a)dV=\oint_{\partial V}U_a\cdot dS=\sum_f(U_a)_f\cdot S_f=\sum_f(\phi_a)_f$$<br>于是得到<br>$$\int_V\left [ U_a(\nabla \cdot U_a)\right ]dV=U_a\sum_f(\phi_a)_f$$<br>这一项在OpenFOAM中的表达是<code>fvm::sp(fvc::div(phia),Ua)</code>，含义就很明显了,这一项相当于是一个系数与需要求解的量$U_a$的乘积，所以被当作隐式的源项来处里。注意我先前以为把$(\nabla \cdot U_a)$当作显式处理是人为简化的结果，其实不然，这是自然而然的结果。而在这里也可以看出，$\sum_f(\phi_a)_f$对应的代码是<code>fvc::div(phia)</code>，也印证了上面的观点，即<code>div</code>操作符<strong>本质上是在作加和运算</strong>。</p>
<h3 id="2-_grad_与_snGrad">2. grad 与 snGrad</h3><p>在<code>twoPhaseEulerFoam</code>中，$\frac{\nabla \alpha}{\alpha}$在两个不同的地方用了两种不同的表示。<br>$$<br>\nabla \cdot \left \{ [\nu_{eff,a} \frac{\nabla \alpha}{\alpha}][U_a] \right \}<br>$$<br>对应的代码是：<code>fvm::div(phiRa,Ua)</code>，其中<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">phiRa=-fvc::interpolate(nuEffa)*mesh.magSf()*fvc::snGrad(alpha)</span><br><span class="line">     /fvc::interpolate(alpha + scalar(0.001));</span><br></pre></td></tr></table></figure></p>
<p>而另一项<br>$$[\frac{\nabla \alpha }{\alpha}]\cdot{Rca}$$<br>对应的代码是<code>fvc::grad(alpha)/fvc::average(alpha + scalar(0.001)) &amp; Rca</code></p>
<p> <strong>下面是我对这个的理解</strong>：<br>对于<br>$$<br>\nabla \cdot \left \{ [\nu_{eff,a} \frac{\nabla \alpha}{\alpha}][U_a] \right \}<br>$$</p>
<p>其处理方法跟$\nabla \cdot(U_aU_a)$是一样的，因为$ \frac{\nabla \alpha}{\alpha}$也是一个矢量。<code>phiRa</code>相当于是 $\left [\nu_{eff,a} \frac{\nabla \alpha}{\alpha} \right ]$这个矢量的界面通量，类比于<code>phia</code>。<code>phia</code>的定义是<code>linearInterpolate(Ua) &amp; mesh.Sf()</code>，而<code>phiRa</code>理论上应该也可以定义成类似于<code>linearInterpolate(gradalpha) &amp; mesh.Sf()</code>，前提是要先定义一个 <code>volVectorField gradalpha=-nuEffa*fvc::grad(alpha)/alpha</code>。但是考虑到界面通量本质上是先将一个<code>volVectorField</code>插值到面上，并乘以面积矢量，对于 $\frac{\nabla \alpha}{\alpha}$，完全可以直接求出每个面上的$\frac{\nabla \alpha}{\alpha}$，然后乘以面积矢量，而不需要先建立体中心的$\frac{\nabla \alpha}{\alpha}$再插值到面上。<code>snGrad</code>就是这样一个用来求面上的梯度量的函数，它求解面上的梯度时，采用如下公式：<br>$$(\nabla \phi)_f=\frac{\phi_N-\phi_P}{|\mathbf{d}|}$$<br>即用相邻网格的值减去面所属网格的值，再除以两个网格中心矢量的模。注意这个处理对于正交网格是精确的，对于非正交网格，只是一个近似处理。而且要注意，这样求得的面上的梯度值已经是一个标量了。再回到<code>phiRa</code>的定义，既然<code>fvc::snGrad(alpha)</code>已经是标量了，那只要再乘以面积矢量的模<code>mesh.magSf()</code>，便是界面上的通量了。<code>fvc::interpolate(nuEffa)</code>和<code>fvc::interpolate(alpha + scalar(0.001))</code>则分别是将volField插值到面。</p>
<p> 再来看$$[\frac{\nabla \alpha }{\alpha}]\cdot{Rca}$$<br> 这一项是被当作显式的源项来处理，所以，我们需要得到的是一个volVcetorField。所以这里将$\nabla \alpha$处理成 volVectorField，再与作为 volTensorField 的 <code>Rca</code> 进行点乘，得到的就是 volVcetorField。因此，这里的$\frac{\nabla \alpha }{\alpha}$对应的代码是 <code>fvc::grad(alpha)/fvc::average(alpha + scalar(0.001))</code>。注意这里的 <code>fvc::average()</code> 函数的定义<a href="http://foam.sourceforge.net/docs/cpp/a05323_source.html#l00046" target="_blank" rel="external">如下</a>：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">43</span> <span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line"> <span class="number">44</span> tmp&lt;<span class="type">GeometricField</span>&lt;<span class="type">Type</span>, fvPatchField, volMesh&gt; &gt;</span><br><span class="line"> <span class="number">45</span> average</span><br><span class="line"> <span class="number">46</span> (</span><br><span class="line"> <span class="number">47</span>     <span class="keyword">const</span> <span class="type">GeometricField</span>&lt;<span class="type">Type</span>, fvsPatchField, surfaceMesh&gt;&amp; ssf</span><br><span class="line"> <span class="number">48</span> )</span><br><span class="line"> <span class="number">49</span> &#123;</span><br><span class="line"> <span class="number">50</span>     <span class="keyword">const</span> fvMesh&amp; mesh = ssf.mesh();</span><br><span class="line"> <span class="number">51</span> </span><br><span class="line"> <span class="number">52</span>     tmp&lt;<span class="type">GeometricField</span>&lt;<span class="type">Type</span>, fvPatchField, volMesh&gt; &gt; taverage</span><br><span class="line"> <span class="number">53</span>     (</span><br><span class="line"> <span class="number">54</span>         new <span class="type">GeometricField</span>&lt;<span class="type">Type</span>, fvPatchField, volMesh&gt;</span><br><span class="line"> <span class="number">55</span>         (</span><br><span class="line"> <span class="number">56</span>             <span class="type">IOobject</span></span><br><span class="line"> <span class="number">57</span>             (</span><br><span class="line"> <span class="number">58</span>                 <span class="string">"average("</span>+ssf.name()+')',</span><br><span class="line"> <span class="number">59</span>                 ssf.instance(),</span><br><span class="line"> <span class="number">60</span>                 mesh,</span><br><span class="line"> <span class="number">61</span>                 <span class="type">IOobject</span>::<span class="type">NO</span>\_READ,</span><br><span class="line"> <span class="number">62</span>                 <span class="type">IOobject</span>::<span class="type">NO</span>\_WRITE</span><br><span class="line"> <span class="number">63</span>             ),</span><br><span class="line"> <span class="number">64</span>             mesh,</span><br><span class="line"> <span class="number">65</span>             ssf.dimensions()</span><br><span class="line"> <span class="number">66</span>         )</span><br><span class="line"> <span class="number">67</span>     );</span><br><span class="line"> <span class="number">68</span> </span><br><span class="line"> <span class="number">69</span>     <span class="type">GeometricField</span>&lt;<span class="type">Type</span>, fvPatchField, volMesh&gt;&amp; av = taverage();</span><br><span class="line"> <span class="number">70</span> </span><br><span class="line"> <span class="number">71</span>     av.internalField() =</span><br><span class="line"> <span class="number">72</span>     (</span><br><span class="line"> <span class="number">73</span>         surfaceSum(mesh.magSf()*ssf)/surfaceSum(mesh.magSf())</span><br><span class="line"> <span class="number">74</span>     )().internalField();</span><br><span class="line"> <span class="number">75</span> </span><br><span class="line"> <span class="number">76</span>     typename <span class="type">GeometricField</span>&lt;<span class="type">Type</span>, fvPatchField, volMesh&gt;::</span><br><span class="line"> <span class="number">77</span>     <span class="type">GeometricBoundaryField</span>&amp; bav = av.boundaryField();</span><br><span class="line"> <span class="number">78</span> </span><br><span class="line"> <span class="number">79</span>     forAll(bav, patchi)</span><br><span class="line"> <span class="number">80</span>     &#123;</span><br><span class="line"> <span class="number">81</span>         bav[patchi] = ssf.boundaryField()[patchi];</span><br><span class="line"> <span class="number">82</span>     &#125;</span><br><span class="line"> <span class="number">83</span> </span><br><span class="line"> <span class="number">84</span>     av.correctBoundaryConditions();</span><br><span class="line"> <span class="number">85</span> </span><br><span class="line"> <span class="number">86</span>     <span class="keyword">return</span> taverage;</span><br><span class="line"> <span class="number">87</span> &#125;</span><br><span class="line"> <span class="number">88</span> </span><br><span class="line"> <span class="number">89</span> </span><br><span class="line"> <span class="number">90</span> <span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line"> <span class="number">91</span> tmp&lt;<span class="type">GeometricField</span>&lt;<span class="type">Type</span>, fvPatchField, volMesh&gt; &gt;</span><br><span class="line"> <span class="number">92</span> average</span><br><span class="line"> <span class="number">93</span> (</span><br><span class="line"> <span class="number">94</span>     <span class="keyword">const</span> tmp&lt;<span class="type">GeometricField</span>&lt;<span class="type">Type</span>, fvsPatchField, surfaceMesh&gt; &gt;&amp; tssf</span><br><span class="line"> <span class="number">95</span> )</span><br><span class="line"> <span class="number">96</span> &#123;</span><br><span class="line"> <span class="number">97</span>     tmp&lt;<span class="type">GeometricField</span>&lt;<span class="type">Type</span>, fvPatchField, volMesh&gt; &gt; taverage</span><br><span class="line"> <span class="number">98</span>     (</span><br><span class="line"> <span class="number">99</span>         fvc::average(tssf())</span><br><span class="line"><span class="number">100</span>     );</span><br><span class="line"><span class="number">101</span>     tssf.clear();</span><br><span class="line"><span class="number">102</span>     <span class="keyword">return</span> taverage;</span><br><span class="line"><span class="number">103</span> &#125;</span><br><span class="line"><span class="number">104</span> </span><br><span class="line"><span class="number">105</span> </span><br><span class="line"><span class="number">106</span> <span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line"><span class="number">107</span> tmp&lt;<span class="type">GeometricField</span>&lt;<span class="type">Type</span>, fvPatchField, volMesh&gt; &gt;</span><br><span class="line"><span class="number">108</span> average</span><br><span class="line"><span class="number">109</span> (</span><br><span class="line"><span class="number">110</span>     <span class="keyword">const</span> <span class="type">GeometricField</span>&lt;<span class="type">Type</span>, fvPatchField, volMesh&gt;&amp; vtf</span><br><span class="line"><span class="number">111</span> )</span><br><span class="line"><span class="number">112</span> &#123;</span><br><span class="line"><span class="number">113</span>     <span class="keyword">return</span> fvc::average(linearInterpolate(vtf));</span><br><span class="line"><span class="number">114</span> &#125;</span><br><span class="line"><span class="number">115</span> </span><br><span class="line"><span class="number">116</span> </span><br><span class="line"><span class="number">117</span> <span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line"><span class="number">118</span> tmp&lt;<span class="type">GeometricField</span>&lt;<span class="type">Type</span>, fvPatchField, volMesh&gt; &gt;</span><br><span class="line"><span class="number">119</span> average</span><br><span class="line"><span class="number">120</span> (</span><br><span class="line"><span class="number">121</span>     <span class="keyword">const</span> tmp&lt;<span class="type">GeometricField</span>&lt;<span class="type">Type</span>, fvPatchField, volMesh&gt; &gt;&amp; tvtf</span><br><span class="line"><span class="number">122</span> )</span><br><span class="line"><span class="number">123</span> &#123;</span><br><span class="line"><span class="number">124</span>     tmp&lt;<span class="type">GeometricField</span>&lt;<span class="type">Type</span>, fvPatchField, volMesh&gt; &gt; taverage</span><br><span class="line"><span class="number">125</span>     (</span><br><span class="line"><span class="number">126</span>         fvc::average(tvtf())</span><br><span class="line"><span class="number">127</span>     );</span><br><span class="line"><span class="number">128</span>     tvtf.clear();</span><br><span class="line"><span class="number">129</span>     <span class="keyword">return</span> taverage;</span><br><span class="line"><span class="number">130</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出，<code>fvc::average()</code>函数的返回类型是<code>tmp&lt;GeometricField&lt;Type, fvPatchField, volMesh&gt; &gt;</code>，对应<code>alpha</code>，返回类型就是<code>tmp&lt;GeometricField&lt;scalar, fvPatchField, volMesh&gt; &gt;</code>，即<code>tmp&lt;volScalarField&gt;</code>。<code>average</code>函数的核心定义见代码71-74行，可见<code>average</code>采用的是面积加权平均，即$$\overline{\phi}=\frac{\sum_f\phi_f*|S_f|}{\sum_f |S_f|}$$。如果给<code>average</code>的参数类型是surfaceFiled，那么直接计算平均值后返回volField，如果给的参数的volField，那就先将volField插值到面，计算平均值后再返回volField，见代码106-114行。</p>
<h3 id="参考资料">参考资料</h3><ol>
<li><a href="http://www.openfoam.org/docs/cpp/" target="_blank" rel="external">http://www.openfoam.org/docs/cpp/</a></li>
<li>OpenFOAM: A little User-Manual, Gerhard Holzinger, <a href="https://github.com/ParticulateFlow/OSCCAR-doc" target="_blank" rel="external">https://github.com/ParticulateFlow/OSCCAR-doc</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>OpenFOAM 的方便之处之一是利用<code>C++</code>的类模板和函数重载等技术定义了很多各种离散操作符，如<code>div</code>,<code>laplacian</code>,<code>grad</code> 等等。利用这些操作符，很容易就能对偏微分方程进行离散，并构建起线性方程组。但是，这些操作符真正执行的运算，却需要结合有限体积方法的本质来理解一番才能真正掌握。下面尝试着对 OpenFOAM 中的 <code>div</code> 和 <code>snGrad</code> 操作符进行一点解读。</p>]]>
    
    </summary>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/tags/OpenFOAM/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[利用functionObjects对指定区域内进行后处理]]></title>
    <link href="http://xiaopingqiu.github.io/2015/05/09/functionObjects/"/>
    <id>http://xiaopingqiu.github.io/2015/05/09/functionObjects/</id>
    <published>2015-05-09T07:24:56.000Z</published>
    <updated>2015-05-09T07:42:05.792Z</updated>
    <content type="html"><![CDATA[<p>CFD中很重要的一个环节是模拟结果的后处理。而后处理过程中，常常涉及到对某个指定区域的某个物理量进行操作，比如，求指定截面上的流率，或者求某个区域内的平均空隙率，等等。这里介绍一种利用 OpenFOAM 中的 <code>functionObjects</code> 来对指定区域进行后处理的方法。本方法一共分三步：1). 将指定区域内的网格(或者面)提取到 cellZone（或faceZone）; 2). 在 controlDict 里写后处理 functions；3). 运行后处理。<br><a id="more"></a></p>
<h3 id="1-_将指定区域的网格(或面)提取到_cellZone_(或faceZone)">1. 将指定区域的网格(或面)提取到 cellZone (或faceZone)</h3><p>这一步有很多方法可以实现，这里介绍用<code>setSet</code>结合<code>setsToZones</code>的方法。</p>
<h4 id="1-1_setSet的基本用法">1.1 <code>setSet</code>的基本用法</h4><p><code>setSet</code>是 OpenFOAM 提供的一个用于生成网格集合(cellSet)、面集合（faceSet）以及点集合（pointSet）的交互式工具，终端里运行<code>setSet</code>，便进入交互模式：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">$ setSet</span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------------------------------------------------------------------------*\</span><br><span class="line">| =========                 |                                                 |</span><br><span class="line">| \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |</span><br><span class="line">|  \\    /   O peration     | Version:  2.3.1                                 |</span><br><span class="line">|   \\  /    A nd           | Web:      www.OpenFOAM.org                      |</span><br><span class="line">|    \\/     M anipulation  |                                                 |</span><br><span class="line">\*---------------------------------------------------------------------------*/</span></span><br><span class="line"><span class="string">Build  :</span> <span class="number">2.3</span>.1-bcfaaa7b8660</span><br><span class="line"><span class="string">Exec   :</span> setSet</span><br><span class="line"><span class="string">Date   :</span> May <span class="number">09</span> <span class="number">2015</span></span><br><span class="line"><span class="string">Time   :</span> <span class="number">13</span>:<span class="number">50</span>:<span class="number">44</span></span><br><span class="line"><span class="string">Host   :</span> <span class="string">"xxxxx"</span></span><br><span class="line"><span class="string">PID    :</span> <span class="number">11255</span></span><br><span class="line"><span class="string">Case   :</span> <span class="regexp">/home/</span>xxxxx<span class="regexp">/OpenFOAM/</span>xxxx-<span class="number">2.3</span>.1<span class="regexp">/run/</span>volField/cavity</span><br><span class="line"><span class="string">nProcs :</span> <span class="number">1</span></span><br><span class="line"><span class="string">sigFpe :</span> Enabling floating point exception trapping (FOAM_SIGFPE).</span><br><span class="line"><span class="string">fileModificationChecking :</span> Monitoring run-time modified files using timeStampMaster</span><br><span class="line"><span class="string">allowSystemOperations :</span> Allowing user-supplied system call operations</span><br><span class="line"></span><br><span class="line"><span class="comment">// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //</span></span><br><span class="line">Create time</span><br><span class="line"></span><br><span class="line">Create polyMesh <span class="keyword">for</span> time = <span class="number">0</span></span><br><span class="line"><span class="label"></span><br><span class="line">Time:</span><span class="number">0</span>  <span class="string">cells:</span><span class="number">9</span>  <span class="string">faces:</span><span class="number">42</span>  <span class="string">points:</span><span class="number">32</span>  <span class="string">patches:</span><span class="number">3</span>  <span class="string">bb:</span>(<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>) (<span class="number">0.1</span> <span class="number">0.1</span> <span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line">Successfully read history from .setSet</span><br><span class="line">Time = <span class="number">0</span></span><br><span class="line">    mesh not changed.</span><br><span class="line">Please type <span class="string">'help'</span>, <span class="string">'quit'</span> or a set command after prompt.</span><br><span class="line">readline&gt;</span><br></pre></td></tr></table></figure></p>
<p><code>setSet</code>的基本语法是：<code>cellSet|faceSet|pointSet &lt;setName&gt; &lt;action&gt; &lt;source&gt;</code>。第一个字段，是选择需要建立的是哪一类集合(cellSet|faceSet|pointSet)，第二个字段是<code>setName</code>，顾名思义，给集合取个名字，第三个字段是<code>action</code>，即具体的操作，比如<code>new</code>(新建)，<code>add</code>(增加）等，最后一个字段是<code>source</code>，即指定cell(face,point)的来源，比如有一种是<code>boxToCell</code>，这种来源要求定义一个box，并将中心在这个box里的网格当作操作的对象。下面举几个例子：</p>
<ul>
<li><code>faceSet f0 new boxToFace (0 0 0) (1 1 1)</code>: 建立一个新的面集f0，并将面心落在对角线顶点分别为(0 0 0)和(1 1 1)的立方体中的面提取出来放到该集合中;</li>
<li><code>cellSet f0 new boxToCell (0 0 0) (1 1 1)</code>:建立一个新的网格集f0，并将面心落在对角线顶点分别为(0 0 0)和(1 1 1)的立方体中的网格提取出来放到该集合中;</li>
<li><code>faceSet f0 new patchToFace movingWall</code>:新建一个面集f0，并将边界<code>movingWall</code>的所有面放到该集合中；</li>
<li><code>cellSet c0 new faceToCell f0 any</code>: 新建一个网格集合c0，并将面集f0中所有的面对应的网格放到网格集合c0中；</li>
<li><code>cellSet c0 add pointToCell p0 any</code>，将点集p0中所有的点对应的网格添加到<strong>已经存在</strong>的网格集c0中。</li>
</ul>
<p>如果要一次建立很多个集合，那么可以将建立规则写在一个文本文件里，每个规则一行，写好后的文件大致是这样<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">faceSet f0 <span class="keyword">new</span> boxToFace (<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>) (<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>)</span><br><span class="line">faceSet f1 <span class="keyword">new</span> boxToFace (<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>) (<span class="number">2</span> <span class="number">2</span> <span class="number">2</span>)</span><br><span class="line">cellSet c0 <span class="keyword">new</span> faceToCell f0 <span class="keyword">any</span></span><br><span class="line">cellSet c1 <span class="keyword">new</span> faceToCell f1 <span class="keyword">any</span></span><br></pre></td></tr></table></figure></p>
<p>然后运行命令<br><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>Set -batch <span class="variable">&lt;filename&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>进行批处理。但是这样会针对每一个时间步都运行一次，如果只想运行一次，可以指定时间<br><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>Set -batch <span class="variable">&lt;filename&gt;</span> -time <span class="number">0</span></span><br><span class="line">或者</span><br><span class="line"><span class="built_in">set</span>Set -batch <span class="variable">&lt;filename&gt;</span> -latestTime</span><br></pre></td></tr></table></figure></p>
<p>运行结束以后，程序会将sets信息放在<code>polyMesh/sets</code>目录下，同时生成相应的vtk文件在算例根目录下的VTK目录里，方便在paraview中查看。<br>关于<code>setSet</code>更详细的信息可以参考<code>setSet</code>提供的 help（终端里运行<code>setSet</code>进入交互模式以后输入<code>help</code>）。</p>
<h4 id="1-2_setsToZones">1.2 setsToZones</h4><p>这一步非常简单，只需要在终端里运行<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setsToZones</span><br></pre></td></tr></table></figure></p>
<p>就可以将前面建立好的 cellSet(faceSet,pointSet)转换成 cellZone(faceZone,pointZone)。</p>
<p>其实除了<code>setSet</code>和<code>setsToZones</code>结合的方法，还可以用<code>topoSet</code>来生成cellZone，本篇不详述了，可以参考 <a href="https://openfoamwiki.net/index.php/TopoSet" target="_blank" rel="external">OpenFOAMWiki</a>。</p>
<h3 id="2-_在_controlDict_里写_functions">2. 在 controlDict 里写 functions</h3><p>有了前面建立好的cellZone (faceZone,pointZone) 以后，就可以在 controlDict 写 functions 来对指定的区域进行后处理了。funtions 的基本写法是在 controlDict 文件的最后，添加类似如下的信息：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">functions</span><br><span class="line">(</span><br><span class="line">   cell0</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">type</span> cellSource; <span class="comment">// 指定操作区域的类型，cellsource 表示是操作区域是一个基于网格(cell)的，比如cellZone。</span></span><br><span class="line">     functionObjectLibs <span class="comment">// 指定需要加载的动态库</span></span><br><span class="line">     (</span><br><span class="line">         <span class="comment">//"libsimpleFunctionObjects.so" // swak4Foam 提供的一个函数库</span></span><br><span class="line">         <span class="string">"libfieldFunctionObjects.so"</span>  <span class="comment">// OpenFOAM自带的一个函数库</span></span><br><span class="line">     );</span><br><span class="line">     verbose <span class="literal">true</span>; <span class="comment">//是否要在终端里输出程序运行过程</span></span><br><span class="line">     <span class="comment">//outputControl timeStep; // 每一个时间步都运行</span></span><br><span class="line">     outputControl outputTime; <span class="comment">// 只在需要输出的时间步才运行，参考controlDict的 writeControl和writeInterval</span></span><br><span class="line">     <span class="keyword">log</span>           <span class="literal">true</span>; <span class="comment">// 是否生成 log</span></span><br><span class="line">     valueOutput   <span class="literal">true</span>; <span class="comment">// 是否需要在每一个时间步对应的数据文件夹里(0.1 0.2 之类的) 将指定 source 的值输出来。</span></span><br><span class="line">     source        cellZone; <span class="comment">//指定操作区域的具体的组成，这里cellZone表示操作区域是由一个cellZone组成的。</span></span><br><span class="line">     sourceName    f0; <span class="comment">// cellZone 的名字</span></span><br><span class="line">     operation     volAverage; <span class="comment">//操作方法，这里是体积平均</span></span><br><span class="line">     fields <span class="comment">// 需要进行操作的物理量</span></span><br><span class="line">     (</span><br><span class="line">         T</span><br><span class="line">     );</span><br><span class="line">   &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>注意这里的结构，<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">functions</span></span><br><span class="line">(</span><br><span class="line">  ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>是最外一层，包括在其中的就是各种功能的 <code>functionObjects</code>了。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">cell0</span></span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代表的是一个<code>functionObject</code>，其中<code>cell0</code>是该<code>functionObject</code>的名字。里面内容的含义参照上面示例中的注释。如果需要写多个<code>functionObjects</code>，那只需要依次都写下来就好了，注意<code>functionObjects</code>的名字不能重复，结构如下<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">functions</span></span><br><span class="line">(</span><br><span class="line">   cell0</span><br><span class="line">   &#123;</span><br><span class="line">   ...</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   cell1</span><br><span class="line">   &#123;</span><br><span class="line">    ...</span><br><span class="line">   &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h3 id="3-_运行后处理">3. 运行后处理</h3><p>写好<code>functions</code>以后，就可以运行后处理了。在终端里运行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span>FlowFunctionObjects</span><br></pre></td></tr></table></figure></p>
<p>就能执行定义在controlDict里的后处理函数了。<br>有时候，可能会报错，说找不到<code>phi</code>，那这时可以加上<code>-noFlow</code>选项<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">execFlowFunctionObjects</span>  -<span class="built_in">no</span>Flow</span><br></pre></td></tr></table></figure></p>
<p>当然，时间相关的选项也是可以用的<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">execFlowFunctionObjects</span>  -<span class="built_in">no</span>Flow -time <span class="number">3</span></span><br><span class="line">execFlowFunctionObjects  -<span class="built_in">no</span>Flow -latestTime</span><br></pre></td></tr></table></figure></p>
<p>注意，本篇强调的是后处理，即算例运行完以后对数据进行的处理。实际上，熟悉OpenFOAM都知道，写在 controlDict 的functions是会随着算例的运行而同时运行的，所以，如果是运行一个新算例，那么你也完全可以事先规划好后处理相关的操作，然后在controlDict写好functions，这样等算例运行结束，所需要的后处理结果也同时生成了。</p>
<p>有人会问，我怎么知道那些 type，source，operation 等有哪些选项可用呢？这里介绍一种的方法，即所谓的<a href="https://openfoamwiki.net/index.php/OpenFOAM_guide/Use_bananas" target="_blank" rel="external">香蕉大法</a>。比如对于 type，你不知道有哪些可用，那么将type设置为 banana  (将上面第2节示例的中 <code>type cellSource</code>改成<code>type banana</code>)，然后运行<code>execFlowFunctionObjects</code>，这时，会得到如下信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">--&gt; FOAM FATAL ERROR: </span><br><span class="line">Unknown <span class="keyword">function</span> <span class="built_in">type</span> banana</span><br><span class="line">Valid <span class="built_in">functions</span> are : </span><br><span class="line"><span class="number">14</span></span><br><span class="line">(</span><br><span class="line">cellSource</span><br><span class="line">faceSource</span><br><span class="line">fieldAverage</span><br><span class="line">fieldCoordinateSystemTransform</span><br><span class="line">fieldM<span class="keyword">in</span>Max</span><br><span class="line">initSwakFunctionObject</span><br><span class="line">nearWallFields</span><br><span class="line">patchProbes</span><br><span class="line">probes</span><br><span class="line"><span class="built_in">read</span>Fields</span><br><span class="line">sets</span><br><span class="line">streamLine</span><br><span class="line">surfaceInterpolateFields</span><br><span class="line">surfaces</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>这回就知道了所有可用选项了吧。对于 source 和 operation 也可以同样的方法得到所有可用的选项。注意，source和operation的可用选项，是随着type的不同而不同的，这里就不详述了。<br>P.S：banana不是OpenFOAM定义的特殊字符串，改成任意非有效的字符串，效果都一样。</p>
<p>最后，上面只是介绍了一些一般性的原则，如果读者想参考一些实际的例子，可以去 OpenFOAM 的 tutorials 里挖掘，这里给一个找出 OpenFOAM 中有哪些算例运用了 functions 的方法，供大家参考。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find</span> $WM_PROJECT_DIR -name controlDict | xargs <span class="keyword">grep</span> <span class="string">"functions"</span></span><br></pre></td></tr></table></figure>
<p>在我的电脑上，运行结果如下：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/src/</span>postProcessing<span class="regexp">/functionObjects/</span>systemCall/<span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/src/</span>postProcessing<span class="regexp">/functionObjects/</span>utilities<span class="regexp">/timeActivatedFileUpdate/</span><span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/src/</span>postProcessing<span class="regexp">/functionObjects/</span>field<span class="regexp">/fieldAverage/</span><span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/src/</span>postProcessing<span class="regexp">/functionObjects/</span>field<span class="regexp">/nearWallFields/</span><span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/src/</span>postProcessing<span class="regexp">/functionObjects/</span>field<span class="regexp">/fieldValues/</span><span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/src/</span>postProcessing<span class="regexp">/functionObjects/</span>field<span class="regexp">/streamLine/</span><span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/src/</span>postProcessing<span class="regexp">/functionObjects/</span>field<span class="regexp">/fieldMinMax/</span><span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/src/</span>postProcessing<span class="regexp">/functionObjects/</span>field<span class="regexp">/wallBoundedStreamLine/</span><span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/src/</span>postProcessing<span class="regexp">/functionObjects/</span>IO/<span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>incompressible<span class="regexp">/pimpleFoam/</span>TJunctionFan<span class="regexp">/system/</span><span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>incompressible<span class="regexp">/pimpleFoam/</span>channel395<span class="regexp">/system/</span><span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>incompressible<span class="regexp">/pimpleFoam/</span>TJunction<span class="regexp">/system/</span><span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>incompressible<span class="regexp">/pisoFoam/</span>les<span class="regexp">/pitzDailyMapped/</span>system/<span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>incompressible<span class="regexp">/pisoFoam/</span>les<span class="regexp">/pitzDaily/</span>system/<span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>incompressible<span class="regexp">/pisoFoam/</span>les<span class="regexp">/motorBike/</span>lesFiles/<span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>incompressible<span class="regexp">/pisoFoam/</span>les<span class="regexp">/motorBike/</span>motorBike<span class="regexp">/system/</span><span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>incompressible<span class="regexp">/pimpleDyMFoam/</span>wingMotion<span class="regexp">/wingMotion2D_simpleFoam/</span>system/<span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>incompressible<span class="regexp">/pimpleDyMFoam/</span>propeller<span class="regexp">/system/</span><span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>incompressible<span class="regexp">/pimpleDyMFoam/</span>movingCone<span class="regexp">/system/</span><span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>incompressible<span class="regexp">/simpleFoam/</span>pitzDaily<span class="regexp">/system/</span><span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>incompressible<span class="regexp">/simpleFoam/</span>pitzDailyExptInlet<span class="regexp">/system/</span><span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>incompressible<span class="regexp">/simpleFoam/</span>motorBike<span class="regexp">/system/</span><span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>lagrangian<span class="regexp">/reactingParcelFoam/</span>verticalChannel<span class="regexp">/system/</span><span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>lagrangian<span class="regexp">/LTSReactingParcelFoam/</span>verticalChannel<span class="regexp">/system/</span><span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>lagrangian<span class="regexp">/simpleReactingParcelFoam/</span>verticalChannel<span class="regexp">/system/</span><span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>multiphase<span class="regexp">/interFoam/</span>ras<span class="regexp">/waterChannel/</span>LTSInterFoam<span class="regexp">/system/</span><span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>multiphase<span class="regexp">/interFoam/</span>ras<span class="regexp">/waterChannel/</span>system/<span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>multiphase<span class="regexp">/interDyMFoam/</span>ras<span class="regexp">/sloshingTank3D3DoF/</span>system/<span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>multiphase<span class="regexp">/interDyMFoam/</span>ras<span class="regexp">/sloshingTank3D6DoF/</span>system/<span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>multiphase<span class="regexp">/interDyMFoam/</span>ras<span class="regexp">/sloshingTank2D3DoF/</span>system/<span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>multiphase<span class="regexp">/interDyMFoam/</span>ras<span class="regexp">/DTCHull/</span>system/<span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>multiphase<span class="regexp">/interDyMFoam/</span>ras<span class="regexp">/sloshingTank3D/</span>system/<span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>multiphase<span class="regexp">/interDyMFoam/</span>ras<span class="regexp">/sloshingTank2D/</span>system/<span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>multiphase<span class="regexp">/twoPhaseEulerFoam/</span>laminar<span class="regexp">/bubbleColumn/</span>system/<span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>multiphase<span class="regexp">/twoPhaseEulerFoam/</span>laminar<span class="regexp">/bubbleColumnIATE/</span>system/<span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>multiphase<span class="regexp">/twoPhaseEulerFoam/</span>laminar<span class="regexp">/fluidisedBed/</span>system/<span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>multiphase<span class="regexp">/twoPhaseEulerFoam/</span>LES<span class="regexp">/bubbleColumn/</span>system/<span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>multiphase<span class="regexp">/twoPhaseEulerFoam/</span>RAS<span class="regexp">/bubbleColumn/</span>system/<span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>multiphase<span class="regexp">/twoPhaseEulerFoam/</span>RAS<span class="regexp">/fluidisedBed/</span>system/<span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>multiphase<span class="regexp">/potentialFreeSurfaceDyMFoam/</span>oscillatingBox<span class="regexp">/system/</span><span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>multiphase<span class="regexp">/LTSInterFoam/</span>DTCHull<span class="regexp">/system/</span><span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>multiphase<span class="regexp">/cavitatingFoam/</span>les<span class="regexp">/throttle3D/</span>system/<span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>multiphase<span class="regexp">/cavitatingFoam/</span>les<span class="regexp">/throttle/</span>system/<span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>multiphase<span class="regexp">/compressibleInterDyMFoam/</span>ras<span class="regexp">/sloshingTank2D/</span>system/<span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>multiphase<span class="regexp">/potentialFreeSurfaceFoam/</span>oscillatingBox<span class="regexp">/system/</span><span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>multiphase<span class="regexp">/multiphaseEulerFoam/</span>bubbleColumn<span class="regexp">/system/</span><span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>discreteMethods<span class="regexp">/dsmcFoam/</span>freeSpaceStream<span class="regexp">/system/</span><span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>discreteMethods<span class="regexp">/dsmcFoam/</span>wedge15Ma5<span class="regexp">/system/</span><span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>discreteMethods<span class="regexp">/dsmcFoam/</span>supersonicCorner<span class="regexp">/system/</span><span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>discreteMethods<span class="regexp">/dsmcFoam/</span>freeSpacePeriodic<span class="regexp">/system/</span><span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>basic<span class="regexp">/potentialFoam/</span>cylinder<span class="regexp">/system/</span><span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>compressible<span class="regexp">/rhoPimpleFoam/</span>les<span class="regexp">/pitzDaily/</span>system/<span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>compressible<span class="regexp">/sonicFoam/</span>ras<span class="regexp">/nacaAirfoil/</span>system/<span class="string">controlDict:</span>functions</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>CFD中很重要的一个环节是模拟结果的后处理。而后处理过程中，常常涉及到对某个指定区域的某个物理量进行操作，比如，求指定截面上的流率，或者求某个区域内的平均空隙率，等等。这里介绍一种利用 OpenFOAM 中的 <code>functionObjects</code> 来对指定区域进行后处理的方法。本方法一共分三步：1). 将指定区域内的网格(或者面)提取到 cellZone（或faceZone）; 2). 在 controlDict 里写后处理 functions；3). 运行后处理。<br>]]>
    
    </summary>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/tags/OpenFOAM/"/>
    
      <category term="Postprocessing" scheme="http://xiaopingqiu.github.io/tags/Postprocessing/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ParaView 的远程模式]]></title>
    <link href="http://xiaopingqiu.github.io/2015/05/03/paraview-remote/"/>
    <id>http://xiaopingqiu.github.io/2015/05/03/paraview-remote/</id>
    <published>2015-05-03T12:49:02.000Z</published>
    <updated>2015-05-03T14:58:20.758Z</updated>
    <content type="html"><![CDATA[<p>OpenFOAM 用户肯定都用过<a href="http://www.paraview.org/" target="_blank" rel="external">ParaView</a>可视化软件，这款软件可以方便地读取 OpenFOAM 的数据进行种类丰富的可视化操作。用 ParaView 可视化 OpenFOAM数据很简单，只需要在算例目录下运行<code>paraFoam</code>即可(注一)。但是，如果你不是在本地机器上运行 OpenFOAM，而是在远程机器上运行，这时候想在本地直接用 ParaView 来可视化远程机器上的数据，该怎么办呢？这个问题要分情况讨论：</p>
<ol>
<li>远程机器没有禁止远程开启GUI<ul>
<li>本地机器安装的是Linux系统，那么可以这样做：<code>ssh -X your_remote_machine</code> 登录到远程机器，注意这里加了<code>-X</code>选项，正常的话，应该直接在终端里运行<code>paraFoam</code>就可以远程启动 ParaView。</li>
<li>本地机器安装的是 Windows，这种情况下可以通过安装一个 Xserver，比如<a href="http://sourceforge.net/projects/xming/" target="_blank" rel="external">Xming</a>，然后用一个支持 X11 Forwarding 的 SSH 客户端（比如 putty）用<code>ssh -X</code>登录到远程机器，正常的话，直接运行<code>paraFoam</code>可以远程启动 ParaView。但根据我的使用经验，这种方法稳定性很差，容易崩溃。</li>
</ul>
</li>
<li>远程机器设置了禁止远程开启GUI程序<br>这种情况下上面提到的两种方法就都不奏效了。这时，下面要介绍的 ParaView 远程模式就能派上用场了。</li>
</ol>
<p>ParaView 远程模式基本的使用方法是，在远程机器上启动一个<code>pvserver</code>，然后用本地机器安装的 ParaView 连接到这个 server上(Client/Server 模式)，或者反过来，本地机器开启一个 server，然后让远程机器连接到本地的 server(Client/Server(reverse connection) 模式),以下将一一介绍。</p>
<a id="more"></a>
<h4 id="Client/Server_模式">Client/Server 模式</h4><p>建立方法如下：</p>
<ol>
<li>在远程机器上运行pvserver；</li>
<li>运行本地机器上的 ParaView，点击菜单栏左上角的“Connect”，出来如下界面：<br><img src="/image/paraview_remote/cs1.png" alt=""></li>
<li>选择 “Add server”，然后在如下界面中设置 server：<br><img src="/image/paraview_remote/cs2.png" alt=""><br>“Server Type”选择”Client/Server”，”Host”填写远程的机器的 IP，”Port”默认即可。点”configure”，便添加了一个 server，这个设置会自动保存下来，下次再打开 “Connect”时，默认就会看到保存的 server 列表。<br><img src="/image/paraview_remote/cs3.png" alt=""></li>
<li>双击列表中需要连接的 server，正常地话便连接到远程机器了，这时候点打开文件，看到的便是远程机器上的文件了！</li>
</ol>
<p><strong>注意事项</strong>：本地机器和远程机器的必须安装同一个版本的ParaView，否则会报错。此外，这种连接方式不能使用”PointSprite_Plugin”插件来显示颗粒。</p>
<h4 id="Client/Server(reverse_connection)_模式">Client/Server(reverse connection) 模式</h4><p>有时候，远程机器上无法正常运行<code>pvserver</code>, 比如报如下错误：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Waiting <span class="keyword">for</span> client… </span><br><span class="line">Connection <span class="string">URL:</span> <span class="string">cs:</span><span class="comment">//A402:11111 </span></span><br><span class="line"><span class="string">ERROR:</span> In <span class="regexp">/home/</span>utkarsh<span class="regexp">/Dashboards/</span>MyTests<span class="regexp">/NightlyMaster/</span>ParaViewSuperbuild-Release<span class="regexp">/paraview/</span>src<span class="regexp">/paraview/</span>VTK<span class="regexp">/Common/</span>System/vtkSocket.cxx, line <span class="number">206</span> </span><br><span class="line">vtkServerSocket (<span class="number">0x1a1206e0</span>): Socket error <span class="keyword">in</span> call to bind. Address already <span class="keyword">in</span> use.</span><br><span class="line"><span class="string">ERROR:</span> In <span class="regexp">/home/</span>utkarsh<span class="regexp">/Dashboards/</span>MyTests<span class="regexp">/NightlyMaster/</span>ParaViewSuperbuild-Release<span class="regexp">/paraview/</span>src<span class="regexp">/paraview/</span>ParaViewCore<span class="regexp">/ClientServerCore/</span>Core/vtkTCPNetworkAccessManager.cxx, line <span class="number">355</span> </span><br><span class="line">vtkTCPNetworkAccessManager (<span class="number">0x1983fa00</span>): Failed to set up server socket.</span><br><span class="line"> Exiting…</span><br></pre></td></tr></table></figure></p>
<p>这时，可以采用Client/Server(reverse connection) 模式，这种模式是在本地机器上开启一个 server，然后让远程机器连上它，具体做法如下：</p>
<ol>
<li>先在本地机器上启动 ParaView，并按照上面所述的方法建立一个server，注意这里”Server Type” 要选择 “Client/Server(reverse connection)”，如下图：<br><img src="/image/paraview_remote/rc1.png" alt=""></li>
<li>连接上这个新建的 server：<br><img src="/image/paraview_remote/rc2.png" alt=""><br>连上以后，显示”waiting for server to connect”，如下<br><img src="/image/paraview_remote/rc3.png" alt=""></li>
<li><p>在远程机器上运行 </p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">pvserver</span> -rc -ch=<span class="number">192.168.1.34</span></span><br></pre></td></tr></table></figure>
<p>注意这里用选项-rc开启reverse connection 模式，-ch选项指定本地机器的 IP。这样就建立了从远程机器到本地机器的连接。 </p>
</li>
<li>连接建立以后，点打开文件，看到的便是远程机器上的文件了，跟 Client/Server 模式一样。</li>
</ol>
<p><strong>一个细节值得注意</strong>：当用 Client/Server 模式或Client/Server(reverse connection) 模式建立起本地机器与远程机器的连接以后，”Save Screenshot”, “Save Animation”, “Export Scene” 以及”Save state”会输出到本地机器，而”Save Data”和”Save Geometry”将仍然输出到远程机器。</p>
<p>注一：<code>paraFoam</code>的正常运行依赖于 libPV3reader.so 等几个库，有时候这几个库不能正常编译生成。ParaView 自从 4.0 版本以后，不需要使用<code>paraFoam</code>直接就能读取 OpenFOAM的数据，用户只需要在算例下新建一个<code>.foam</code>结尾的空文件，然后用 ParaView打开这个空文件即可。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>OpenFOAM 用户肯定都用过<a href="http://www.paraview.org/">ParaView</a>可视化软件，这款软件可以方便地读取 OpenFOAM 的数据进行种类丰富的可视化操作。用 ParaView 可视化 OpenFOAM数据很简单，只需要在算例目录下运行<code>paraFoam</code>即可(注一)。但是，如果你不是在本地机器上运行 OpenFOAM，而是在远程机器上运行，这时候想在本地直接用 ParaView 来可视化远程机器上的数据，该怎么办呢？这个问题要分情况讨论：</p>
<ol>
<li>远程机器没有禁止远程开启GUI<ul>
<li>本地机器安装的是Linux系统，那么可以这样做：<code>ssh -X your_remote_machine</code> 登录到远程机器，注意这里加了<code>-X</code>选项，正常的话，应该直接在终端里运行<code>paraFoam</code>就可以远程启动 ParaView。</li>
<li>本地机器安装的是 Windows，这种情况下可以通过安装一个 Xserver，比如<a href="http://sourceforge.net/projects/xming/">Xming</a>，然后用一个支持 X11 Forwarding 的 SSH 客户端（比如 putty）用<code>ssh -X</code>登录到远程机器，正常的话，直接运行<code>paraFoam</code>可以远程启动 ParaView。但根据我的使用经验，这种方法稳定性很差，容易崩溃。</li>
</ul>
</li>
<li>远程机器设置了禁止远程开启GUI程序<br>这种情况下上面提到的两种方法就都不奏效了。这时，下面要介绍的 ParaView 远程模式就能派上用场了。</li>
</ol>
<p>ParaView 远程模式基本的使用方法是，在远程机器上启动一个<code>pvserver</code>，然后用本地机器安装的 ParaView 连接到这个 server上(Client/Server 模式)，或者反过来，本地机器开启一个 server，然后让远程机器连接到本地的 server(Client/Server(reverse connection) 模式),以下将一一介绍。</p>]]>
    
    </summary>
    
      <category term="Postprocessing" scheme="http://xiaopingqiu.github.io/tags/Postprocessing/"/>
    
      <category term="paraview" scheme="http://xiaopingqiu.github.io/tags/paraview/"/>
    
      <category term="Paraview" scheme="http://xiaopingqiu.github.io/categories/Paraview/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[fieldAverage 使用说明]]></title>
    <link href="http://xiaopingqiu.github.io/2015/04/12/fieldAverage/"/>
    <id>http://xiaopingqiu.github.io/2015/04/12/fieldAverage/</id>
    <published>2015-04-12T09:00:54.000Z</published>
    <updated>2015-05-03T14:57:35.043Z</updated>
    <content type="html"><![CDATA[<p><code>fieldAverage</code>是 OpenFOAM 中的一种 functionObject，用来计算时均值。其基本用法是作为一个 function object 放在 controlDict 文件中，运行 solver 的同时计算指定场的时均值，以下是一个示例：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">functions</span><br><span class="line">&#123;</span><br><span class="line">    fieldAverage1</span><br><span class="line">    &#123;</span><br><span class="line">        type            fieldAverage;</span><br><span class="line">        functionObjectLibs ( <span class="string">"libfieldFunctionObjects.so"</span> );</span><br><span class="line">        outputControl   outputTime;</span><br><span class="line">        fields</span><br><span class="line">        (</span><br><span class="line">            Ua</span><br><span class="line">            &#123;</span><br><span class="line">                 mean        <span class="function_start"><span class="keyword">on</span></span>;</span><br><span class="line">                 prime2Mean  off;</span><br><span class="line">                 base        <span class="property">time</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Ub</span><br><span class="line">            &#123;</span><br><span class="line">                 mean        <span class="function_start"><span class="keyword">on</span></span>;</span><br><span class="line">                 prime2Mean  off;</span><br><span class="line">                 base        <span class="property">time</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>但是，在有效地使用<code>fieldAverage</code>之前，有一些问题需要澄清，其中最重要的一个是：<strong><code>fieldAverage</code>到底在对哪个时间段求的时间平均</strong>？本文通过对<code>fieldAverage</code>的源码进行分析，试图厘清这些细节，并给出一个可靠的<code>fieldAverage</code>使用说明。涉及到的源文件包括：<code>fieldAverage.H</code>, <code>fieldAverage.C</code>, <code>fieldAverageTemplates.C</code>, <code>fieldAverageItem.C</code>，位于目录<code>$WM_PROJECT_DIR/src/postProcessing/functionObjects/field/fieldAverage</code>下。</p>
<h5 id="首要问题：fieldAverage对哪个时间区间进行时均计算？">首要问题：<strong><code>fieldAverage</code>对哪个时间区间进行时均计算</strong>？</h5><p>上面这段代码是从我运行的一个算例的 controlDict 中摘出来的。算例运行过程中发现，每一个时间步都要调用计算时均值相关的代码，并屏幕上的输出也会打印出<code>Calculating averages</code>，而每一个输出数据文件里，都有<code>*Mean</code>数据，其中<code>*</code>表示在<code>controlDict</code>中定义了需要求解时均值的某个场。<br>经过摸索发现，跟时均值求解密切相关的一段代码位于<a href="http://foam.sourceforge.net/docs/cpp/a08780_source.html" target="_blank" rel="external"><code>fieldAverageTemplates.C</code></a>，下面是从中摘出来的一段核心代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">182</span> <span class="keyword">template</span>&lt;<span class="keyword">class</span> Type&gt;</span><br><span class="line"><span class="number">183</span> <span class="keyword">void</span> Foam::fieldAverage::calculateMeanFieldType(<span class="keyword">const</span> label fieldI) <span class="keyword">const</span></span><br><span class="line"><span class="number">184</span> &#123;</span><br><span class="line"><span class="number">185</span>  <span class="keyword">const</span> word&amp; fieldName = faItems_[fieldI].fieldName();</span><br><span class="line"><span class="number">187</span>  <span class="keyword">if</span> (obr_.foundObject&lt;Type&gt;(fieldName))</span><br><span class="line"><span class="number">188</span>  &#123;</span><br><span class="line"><span class="number">189</span>    <span class="keyword">const</span> Type&amp; baseField = obr_.lookupObject&lt;Type&gt;(fieldName);</span><br><span class="line"><span class="number">190</span> </span><br><span class="line"><span class="number">191</span>    Type&amp; meanField = <span class="keyword">const_cast</span>&lt;Type&amp;&gt;</span><br><span class="line"><span class="number">192</span>    (</span><br><span class="line"><span class="number">193</span>    obr_.lookupObject&lt;Type&gt;(faItems_[fieldI].meanFieldName())</span><br><span class="line"><span class="number">194</span>    );</span><br><span class="line"><span class="number">195</span> </span><br><span class="line"><span class="number">196</span>    scalar dt = obr_.time().deltaTValue();</span><br><span class="line"><span class="number">197</span>    scalar Dt = totalTime_[fieldI];</span><br><span class="line"><span class="number">198</span> </span><br><span class="line"><span class="number">199</span>    <span class="keyword">if</span> (faItems_[fieldI].iterBase())</span><br><span class="line"><span class="number">200</span>    &#123;</span><br><span class="line"><span class="number">201</span>      dt = <span class="number">1.0</span>;</span><br><span class="line"><span class="number">202</span>      Dt = scalar(totalIter_[fieldI]);</span><br><span class="line"><span class="number">203</span>    &#125;</span><br><span class="line"><span class="number">204</span> </span><br><span class="line"><span class="number">205</span>    scalar alpha = (Dt - dt)/Dt;</span><br><span class="line"><span class="number">206</span>    scalar beta = dt/Dt;</span><br><span class="line"><span class="number">207</span> </span><br><span class="line"><span class="number">208</span>    <span class="keyword">if</span> (faItems_[fieldI].window() &gt; <span class="number">0</span>)</span><br><span class="line"><span class="number">209</span>    &#123;</span><br><span class="line"><span class="number">210</span>      <span class="keyword">const</span> scalar w = faItems_[fieldI].window();</span><br><span class="line"><span class="number">211</span> </span><br><span class="line"><span class="number">212</span>      <span class="keyword">if</span> (Dt - dt &gt;= w)</span><br><span class="line"><span class="number">213</span>      &#123;</span><br><span class="line"><span class="number">214</span>        alpha = (w - dt)/w;</span><br><span class="line"><span class="number">215</span>        beta = dt/w;</span><br><span class="line"><span class="number">216</span>      &#125;</span><br><span class="line"><span class="number">217</span>    &#125;</span><br><span class="line"><span class="number">219</span>    meanField = alpha*meanField + beta*baseField;</span><br><span class="line"><span class="number">220</span>  &#125;</span><br><span class="line"><span class="number">221</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p>以下是我根据理解整理的代码解析：</p>
<ol>
<li>变量<code>baseField</code>定义为当前时间步计算得到的场的值(Ua)，<code>meanField</code>定义为上一个时间步对应的场的时均值(UaMean)。</li>
<li><code>dt</code>定义为时间步长，<code>Dt</code>定义为当前所在的时间。注意199行，<code>iterBase()</code>这个函数定义为当<code>base</code>(见controlDict)为<code>ITER</code>时，返回<code>true</code>。此时，<code>dt</code>定义为1，意义很显然，当以时间步数为基准的时候，下一步和上一步当然是只相差1个时间步；<code>Dt</code>则被定义为当前所在的时间步(第xx步)。所以，<code>Dt</code>和<code>dt</code>的真实含义取决于<code>base</code>。<strong><code>fieldAverageItem.C</code>中给<code>base</code>赋了默认值为<code>ITER</code></strong>。<code>base</code>可以指定为<code>time</code>，具体见下文。</li>
<li><p>alpha 定义为(Dt-dt)/Dt, beta 定义为 dt/Dt。然后当前时间步的<code>meanField</code>定义为<code>alpha*meanField + beta*baseField</code>。举例说明，假设dt = 1, Dt = 20, 假设上一时间步的时均值为<code>meanField_pre</code>，则新时刻时均值为</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">19/20<span class="keyword">*</span>meanField_pre + 1/20<span class="keyword">*</span>baseField) = (19<span class="keyword">*</span>meanField_pre + baseField)/20</span><br></pre></td></tr></table></figure>
<p><code>19*meanField_pre</code>的含义很明显，前19步的时均值乘以总时间步数，也就是前 19 步 Field 值的加和，再加上当前时间步的值<code>baseField</code>，就是前 20 步的 Field 值的和。用这个值除以20，得到新时刻的时均值<code>meanField</code>。由此可见，在这种情况下，<strong>每个时间步输出的时均值是从开始时刻到当前时间步的Field值对总时间的平均</strong>。</p>
</li>
<li><p>很多时候，我们并不想得到从开始到结束整个模拟时段内的平均值，而希望得到指定时段内的平均值，这时，可以通过指定<code>window</code>变量的值来达到目的。代码208行，注意到这里出现了一个新函数<code>window</code>。可以查到<code>window</code>函数返回值默认是<code>-1</code>。但可以在controlDict中<code>base</code>下面定义变量<code>windows</code>的值，当<code>window</code>函数返回值大于0时，208-217将被执行。接着上一点的假设，dt = 1, 定义并初始化为<code>window</code>函数的返回值，假设为20。则： </p>
<ul>
<li>当 <code>Dt</code> 小于或等于20时，不满足<code>Dt - dt &gt;= w</code>，此时时均值将按照上一点叙述的进行计算。</li>
<li>当 <code>Dt</code>大于20以后，假设<code>Dt = 21</code>，此时 <code>alpha = (w-dt)/w = (20-1)/20</code>，<code>bata = dt/w = 1/19</code>。令<code>meanField_pre</code>为<code>Dt = 20</code> 时的时均值，则<code>Dt = 21</code>时的时均值<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">meanField = 19/20 <span class="keyword">*</span> meanField_pre + 1/20 <span class="keyword">*</span> baseField = (19 <span class="keyword">*</span> meanField_pre + baseField)/20</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>对比发现，如果<code>window = -1</code>(默认值)，则<code>Dt = 21</code>的时均值应该是<code>20/21 * meanField_pre + 1/21 * baseField</code>。而定义了<code>windows = 20</code>以后，此处的<code>19 * meanField_pre</code> 可以理解为<code>Dt = 21</code>这一步之前的19步的Field值的和，加上<code>baseField</code>，则为<code>Dt = 21</code> 以及其之前19步，共20步的Field值的和。再除以20，则为 <code>Dt = 21</code>以及其之前19步这20步的时均值。<strong>所以，当设定<code>window</code>为一正整数<code>w</code>时，输出的时均值是当前时间步以及其之前<code>w-1</code>步，这<code>w</code>步内Field的时均值</strong>。</p>
</li>
</ol>
<p>附上一个更一般化的示例：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">fieldAverage1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">type</span> fieldAverage;</span><br><span class="line">    functionObjectLibs (<span class="string">"libfieldFunctionObjects.so"</span>);</span><br><span class="line">    resetOnRestart true;</span><br><span class="line">    resetOnOutput false;</span><br><span class="line">    outputControl   outputTime;</span><br><span class="line">    fields</span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">U</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">mean</span>            <span class="keyword">on</span>;</span><br><span class="line">            prime2Mean      <span class="keyword">on</span>;</span><br><span class="line">            base            time; <span class="comment">//以物理时间为基础来计算平均，而不是时间步数。</span></span><br><span class="line">            <span class="keyword">window</span>          10.0;</span><br><span class="line">            windowName      w1; <span class="comment">//optional</span></span><br><span class="line">        &#125;</span><br><span class="line">        p</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">mean</span>            <span class="keyword">on</span>;</span><br><span class="line">            prime2Mean      <span class="keyword">on</span>;</span><br><span class="line">            base            time;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>resetOnRestart</code>的值决定当solver继续运行时，是否要读取最近一个时间步的<code>meanField</code>的值来计算接下来时刻的时均值；<code>resetOnOutput</code>，顾名思义，是否要在每一次输出到文件以后重置<code>meanField</code>的值。这两个开关的默认值都是<code>false</code>。<br><code>mean</code>这个开关的含义无需多言，计算公式如下：<br>$$ \overline {x} = \frac{1}{N} \sum \limits _{i=0}^{N} x_i $$<br><code>prime2Mean</code>的计算公式如下：<br>$$ \overline{x’}^{\, 2} = \frac{1}{N}\displaystyle\sum\limits_{i=0}^N (x_i - \overline{x})^2 $$<br>所以，如果<code>prime2Mean</code>为<code>on</code>，<code>mean</code>必须为<code>on</code>。</p>
<p>此外，如果计算已经结束，controlDict 中定义的 function 仍可以用<code>execFlowFunctionObjects</code>来执行。只是，这样的运行只能利用输出到文件的数据来进行计算了。举例说，假如时间步长是 0.001s， 每 0.1s 输出一次，那么同样是1-2s的时均值，solver运行过程中求解的公式是:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( field.<span class="function"><span class="title">at</span><span class="params">(<span class="number">1.001</span>)</span></span> +field.<span class="function"><span class="title">at</span><span class="params">(<span class="number">1.002</span>)</span></span> + ... + field.<span class="function"><span class="title">at</span><span class="params">(<span class="number">2.0</span>)</span></span> )/<span class="number">1000</span></span><br></pre></td></tr></table></figure></p>
<p>而solver运行完以后利用<code>execFlowFunctionObjects</code>计算的时均值应该是：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( field.<span class="function"><span class="title">at</span><span class="params">(<span class="number">1.1</span>)</span></span> + field.<span class="function"><span class="title">at</span><span class="params">(<span class="number">1.2</span>)</span></span> + ... + field.<span class="function"><span class="title">at</span><span class="params">(<span class="number">2</span>)</span></span> )/<span class="number">10</span></span><br></pre></td></tr></table></figure></p>
<p>注意，这个结果没有经过直接的验证，是我根据原理推演的结果。<br>有时候，运行<code>execFlowFunctionObjects</code>会报错说找不到<code>phi</code>，这时加上<code>-noFlow</code>选项，就不会报错了。</p>
<h5 id="小结">小结</h5><ol>
<li><code>base</code>用来指定作时间平均的基础，是基于时间步数(ITER)还是物理时间(time);</li>
<li><code>window</code>用来作平均的时间段的长度，如果不设定，则求的是从开始到当前时间这个时间段的平均值。<code>window</code>的数值的实际含义依<code>base</code>而定，如果<code>base</code>是<code>ITER</code>，则<code>window=20</code>表示当前步及其前 19 个时间步从 20 个时间步内的平均，而如果<code>base</code>是<code>time</code>,则表示的是 20s 内的平均。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p><code>fieldAverage</code>是 OpenFOAM 中的一种 functionObject，用来计算时均值。其基本用法是作为一个 function object 放在 controlDict 文件中，运行 solver 的同时计算指定场的时均值，以下是一个示例：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">functions</span><br><span class="line">&#123;</span><br><span class="line">    fieldAverage1</span><br><span class="line">    &#123;</span><br><span class="line">        type            fieldAverage;</span><br><span class="line">        functionObjectLibs ( <span class="string">"libfieldFunctionObjects.so"</span> );</span><br><span class="line">        outputControl   outputTime;</span><br><span class="line">        fields</span><br><span class="line">        (</span><br><span class="line">            Ua</span><br><span class="line">            &#123;</span><br><span class="line">                 mean        <span class="function_start"><span class="keyword">on</span></span>;</span><br><span class="line">                 prime2Mean  off;</span><br><span class="line">                 base        <span class="property">time</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Ub</span><br><span class="line">            &#123;</span><br><span class="line">                 mean        <span class="function_start"><span class="keyword">on</span></span>;</span><br><span class="line">                 prime2Mean  off;</span><br><span class="line">                 base        <span class="property">time</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/tags/OpenFOAM/"/>
    
      <category term="Postprocessing" scheme="http://xiaopingqiu.github.io/tags/Postprocessing/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello World]]></title>
    <link href="http://xiaopingqiu.github.io/2015/04/04/hello-world/"/>
    <id>http://xiaopingqiu.github.io/2015/04/04/hello-world/</id>
    <published>2015-04-04T02:00:00.000Z</published>
    <updated>2015-04-10T14:57:00.000Z</updated>
    <content type="html"><![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start">Quick Start</h2><h3 id="Create_a_new_post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
<h4 id="Test_code">Test code</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"hello world!"</span> &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="中文支持测试">中文支持测试</h4><p>看看是否支持中文。</p>
<h4 id="数学公式">数学公式</h4><p>$$ x=\frac{-b\pm \sqrt{b^2-4ac}}{2a} $$</p>
<h4 id="本地图片测试">本地图片测试</h4><p><img src="/image/juperter_impact.jpg" alt="Jupiter"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io]]>
    </summary>
    
      <category term="test" scheme="http://xiaopingqiu.github.io/tags/test/"/>
    
      <category term="test" scheme="http://xiaopingqiu.github.io/categories/test/"/>
    
  </entry>
  
</feed>