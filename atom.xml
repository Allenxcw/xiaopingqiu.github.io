<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Giskard's CFD Learning Tricks]]></title>
  <subtitle><![CDATA[CFD and Scientific Computing]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://xiaopingqiu.github.io/"/>
  <updated>2016-04-03T03:42:14.824Z</updated>
  <id>http://xiaopingqiu.github.io/</id>
  
  <author>
    <name><![CDATA[Giskard Q.]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[OpenFOAM 中的边界条件（四）]]></title>
    <link href="http://xiaopingqiu.github.io/2016/04/02/Boundary-conditions-in-OpenFOAM4/"/>
    <id>http://xiaopingqiu.github.io/2016/04/02/Boundary-conditions-in-OpenFOAM4/</id>
    <published>2016-04-02T10:16:39.000Z</published>
    <updated>2016-04-03T03:42:14.824Z</updated>
    <content type="html"><![CDATA[<h4 id="JohnsonJackson_边界条件">JohnsonJackson 边界条件</h4><p>本篇来看用于气固两相流模拟的 JohnsonJackson 边界条件。这组边界条件用于设定双流体模型中固相在壁面的速度和颗粒温度。根据 <a href="http://www.sciencedirect.com/science/article/pii/S0009250908003904" target="_blank" rel="external">N. Reuge 2008, CES</a>，壁面上的固相速度和颗粒温度可以表示为：<br><img src="/image/boundaryConditions/JJ.png" alt="JohnsonJackson boundary conditions"><br>其中，$u_m$ 指的是 m 相在壁面切向上的滑移速度。<br>下面来看 OpenFOAM 中对这两个边界条件的实现</p>
<a id="more"></a>
<p>在看 JohnsonJackson 边界条件之前，先要看一下 <code>partialSlip</code> 边界。</p>
<h5 id="partialSlip">partialSlip</h5><p><code>partialSlipFvPatchField</code> 继承自 <code>transformFvPatchField</code><br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line">class partialSlipFvPatchField</span><br><span class="line">:</span><br><span class="line">    public transformFvPatchField&lt;<span class="type">Type</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    // <span class="type">Private</span> data</span><br><span class="line"></span><br><span class="line">        //- <span class="type">Fraction</span> (<span class="number">0</span>-<span class="number">1</span>) <span class="keyword">of</span> value used <span class="keyword">for</span> boundary condition</span><br><span class="line">        scalarField valueFraction_;</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其定义了一个标量形式的 <code>valueFraction_</code> 。</p>
<ul>
<li>evaluate 函数<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">template<span class="subst">&lt;</span>class <span class="keyword">Type</span><span class="subst">&gt;</span></span><br><span class="line"><span class="literal">void</span> Foam<span class="tag">::partialSlipFvPatchField</span><span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::evaluate</span></span><br><span class="line">(</span><br><span class="line">    const Pstream<span class="tag">::commsTypes</span></span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="subst">!</span>this<span class="subst">-&gt;</span>updated())</span><br><span class="line">    &#123;</span><br><span class="line">        this<span class="subst">-&gt;</span>updateCoeffs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tmp<span class="subst">&lt;</span>vectorField<span class="subst">&gt;</span> nHat <span class="subst">=</span> this<span class="subst">-&gt;</span>patch()<span class="built_in">.</span>nf();</span><br><span class="line"></span><br><span class="line">    Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::operator</span><span class="subst">=</span></span><br><span class="line">    (</span><br><span class="line">        (<span class="number">1.0</span> <span class="subst">-</span> valueFraction_)</span><br><span class="line">       <span class="subst">*</span>transform(I <span class="subst">-</span> sqr(nHat), this<span class="subst">-&gt;</span>patchInternalField())</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    transformFvPatchField<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::evaluate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>与 <code>basicSymmetry</code> 相比，只是多了一项 <code>1.0 - valueFraction_</code> 。当 <code>valueFraction_ = 0</code> 时，其与 <code>basicSymmetry</code> 是一样的。</p>
<ul>
<li>snGradTransformDiag<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Type&gt;</span><br><span class="line">Foam::tmp&lt;Foam::Field&lt;Type&gt; &gt;</span><br><span class="line">Foam::partialSlipFvPatchField&lt;Type&gt;::snGradTransformDiag() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> vectorField <span class="title">nHat</span><span class="params">(<span class="keyword">this</span>-&gt;patch()</span>.<span class="title">nf</span><span class="params">()</span>)</span>;</span><br><span class="line">    <span class="function">vectorField <span class="title">diag</span><span class="params">(nHat.size()</span>)</span>;</span><br><span class="line"></span><br><span class="line">    diag.replace(<span class="built_in">vector</span>::X, mag(nHat.component(<span class="built_in">vector</span>::X)));</span><br><span class="line">    diag.replace(<span class="built_in">vector</span>::Y, mag(nHat.component(<span class="built_in">vector</span>::Y)));</span><br><span class="line">    diag.replace(<span class="built_in">vector</span>::Z, mag(nHat.component(<span class="built_in">vector</span>::Z)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        valueFraction_*pTraits&lt;Type&gt;::one</span><br><span class="line">      + (<span class="number">1.0</span> - valueFraction_)</span><br><span class="line">       *transformFieldMask&lt;Type&gt;(<span class="built_in">pow</span>&lt;<span class="built_in">vector</span>, pTraits&lt;Type&gt;::rank&gt;(diag));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>当 <code>valueFraction_ = 0</code> 时，这里的返回值与 <code>basicSymmetry</code> 也是一样的。</p>
<ul>
<li>snGrad<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class <span class="constant">Type&gt;</span></span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:tmp&lt;Foam</span><span class="symbol">:</span><span class="symbol">:Field&lt;Type&gt;</span> &gt;</span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:partialSlipFvPatchField&lt;Type&gt;</span><span class="symbol">:</span><span class="symbol">:snGrad</span>() const</span><br><span class="line">&#123;</span><br><span class="line">    tmp&lt;vectorField&gt; nHat = this-&gt;patch().nf();</span><br><span class="line">    const <span class="constant">Field&lt;Type&gt;</span> pif(this-&gt;patchInternalField());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    (</span><br><span class="line">        (<span class="number">1.0</span> - valueFraction<span class="constant">_</span>)*transform(<span class="constant">I </span>- sqr(nHat), pif) - pif</span><br><span class="line">    )*this-&gt;patch().deltaCoeffs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><a href="http://cfd.direct/openfoam/user-guide/boundaries/" target="_blank" rel="external">User guide</a> 里说这个边界是 <code>slip</code> 和 <code>zeroGradient</code> 的混合。 <code>valueFraction_ = 0</code> 时， <code>partialSlip</code> 与 <code>slip</code> 等价，这一点上面说明了。不过， 另一个极端，<code>valueFraction_ = 1</code> 时，却似乎不是跟 <code>zeroGradient</code> 等价。至少， <code>evaluate</code> 函数在<code>valueFraction_ = 1</code> 时与 <code>zeroGradient</code> 中的是不一样的。</p>
<p>这里提到了 <code>slip</code> 这个边界，顺便再说一下， <code>slip</code> 边界继承自 <code>basicSymmetry</code> ，而且没有增加任何新的定义，所以， <code>slip</code> 与  <code>basicSymmetry</code> 的效果是等价的。对于标量， <code>slip</code> 与 <code>zeroGradient</code> 一样；对于矢量，以速度为例， <code>slip</code> 定义的边界上的速度值等于边界所属网格的速度的平行边界的分量，即<br>$$<br>u_p = u_C - (\mathbf{I}-\overrightarrow{n} \otimes \overrightarrow{n})\cdot u_C<br>$$</p>
<h5 id="JohnsonJacksonParticleSlip">JohnsonJacksonParticleSlip</h5><p>这个边界条件继承自 <code>partialSlip</code>，在此基础上额外定义了镜面反弹系数 <code>specularityCoefficient_</code> 。代码的核心在 <code>updateCoeffs</code> 函数<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Foam::JohnsonJacksonParticleSlipFvPatchVectorField::updateCoeffs()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (updated())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lookup the fluid model and the phase</span></span><br><span class="line">    <span class="keyword">const</span> twoPhaseSystem&amp; fluid = db().lookupObject&lt;twoPhaseSystem&gt;</span><br><span class="line">    (</span><br><span class="line">        <span class="string">"phaseProperties"</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> phaseModel&amp; phased</span><br><span class="line">    (</span><br><span class="line">        fluid.phase1().name() == dimensionedInternalField().group()</span><br><span class="line">      ? fluid.phase1()</span><br><span class="line">      : fluid.phase2()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lookup all the fields on this patch</span></span><br><span class="line">    <span class="keyword">const</span> fvPatchScalarField&amp; alpha</span><br><span class="line">    (</span><br><span class="line">        patch().lookupPatchField&lt;volScalarField, scalar&gt;</span><br><span class="line">        (</span><br><span class="line">            phased.volScalarField::name()</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> fvPatchScalarField&amp; gs0</span><br><span class="line">    (</span><br><span class="line">        patch().lookupPatchField&lt;volScalarField, scalar&gt;</span><br><span class="line">        (</span><br><span class="line">            IOobject::groupName(<span class="string">"gs0"</span>, phased.name())</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> scalarField nu</span><br><span class="line">    (</span><br><span class="line">        patch().lookupPatchField&lt;volScalarField, scalar&gt;</span><br><span class="line">        (</span><br><span class="line">            IOobject::groupName(<span class="string">"nut"</span>, phased.name())</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    word ThetaName(IOobject::groupName(<span class="string">"Theta"</span>, phased.name()));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> fvPatchScalarField&amp; Theta</span><br><span class="line">    (</span><br><span class="line">        db().foundObject&lt;volScalarField&gt;(ThetaName)</span><br><span class="line">      ? patch().lookupPatchField&lt;volScalarField, scalar&gt;(ThetaName)</span><br><span class="line">      : alpha</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lookup the packed volume fraction</span></span><br><span class="line">    dimensionedScalar alphaMax</span><br><span class="line">    (</span><br><span class="line">        <span class="string">"alphaMax"</span>,</span><br><span class="line">        dimless,</span><br><span class="line">        db()</span><br><span class="line">       .lookupObject&lt;IOdictionary&gt;</span><br><span class="line">        (</span><br><span class="line">            IOobject::groupName(<span class="string">"turbulenceProperties"</span>, phased.name())</span><br><span class="line">        )</span><br><span class="line">       .subDict(<span class="string">"RAS"</span>)</span><br><span class="line">       .subDict(<span class="string">"kineticTheoryCoeffs"</span>)</span><br><span class="line">       .lookup(<span class="string">"alphaMax"</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// calculate the slip value fraction</span></span><br><span class="line">    scalarField c</span><br><span class="line">    (</span><br><span class="line">        constant::mathematical::pi</span><br><span class="line">       *alpha</span><br><span class="line">       *gs0</span><br><span class="line">       *specularityCoefficient_.value()</span><br><span class="line">       *sqrt(3.0*Theta)</span><br><span class="line">       /max(6.0*nu*alphaMax.value(), SMALL)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;valueFraction() = c/(c + patch().deltaCoeffs());</span><br><span class="line"></span><br><span class="line">    partialSlipFvPatchVectorField::updateCoeffs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数主要的功能是重定义了继承自 <code>partialSlip</code> 中的 <code>valueFraction_</code>。结合 <code>partialSlip</code> 中的定义，可以知道最终 <code>JohnsonJacksonParticleSlip</code> 定义的边界速度的值为<br>$$<br>u_m=(1-\frac{c}{c+\Delta}) \cdot (\mathbf{I}-\overrightarrow{n}\otimes\overrightarrow{n})\cdot u_c<br>$$<br>其中 $u_c$ 为邻近壁面网格的 m 相的速度。<code>c</code> 的定义为：<br>$$<br>c=\frac{\pi \varepsilon_m g_0 \phi\sqrt{3\Theta}}{6.0\nu_m\varepsilon_m^{max}}<br>$$<br>对照上述公式(34)，根据 $c$ 的定义，这里可以把公式(34)简写为<br>$$<br>\frac{\partial u_m}{\partial x}=-cu_m<br>$$<br>写成差分形式，即<br>$$<br>(u_m-u_{ct})\cdot \Delta=-cu_m<br>$$<br>于是得到<br>$$<br>u_m = \frac{\Delta}{c+\Delta}u_{ct}<br>$$<br>若 $u_{ct}$ 定义为邻近壁面网格的速度壁面切向分量，则公式(34)与代码是一致的。</p>
<h5 id="JohnsonJacksonParticleTheta">JohnsonJacksonParticleTheta</h5><p>这个边界条件继承自 <code>mixed</code> ，此外新增了两个数据成员： <code>specularityCoefficient_</code> 和 <code>restitutionCoefficient_</code> 。核心的函数也是 <code>updateCoeffs</code> 。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Foam::JohnsonJacksonParticleThetaFvPatchScalarField::updateCoeffs()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (updated())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lookup the fluid model and the phase</span></span><br><span class="line">    <span class="keyword">const</span> twoPhaseSystem&amp; fluid = db().lookupObject&lt;twoPhaseSystem&gt;</span><br><span class="line">    (</span><br><span class="line">        <span class="string">"phaseProperties"</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> phaseModel&amp; phased</span><br><span class="line">    (</span><br><span class="line">        fluid.phase1().name() == dimensionedInternalField().group()</span><br><span class="line">      ? fluid.phase1()</span><br><span class="line">      : fluid.phase2()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lookup all the fields on this patch</span></span><br><span class="line">    <span class="keyword">const</span> fvPatchScalarField&amp; alpha</span><br><span class="line">    (</span><br><span class="line">        patch().lookupPatchField&lt;volScalarField, scalar&gt;</span><br><span class="line">        (</span><br><span class="line">            phased.volScalarField::name()</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> fvPatchVectorField&amp; U</span><br><span class="line">    (</span><br><span class="line">        patch().lookupPatchField&lt;volVectorField, vector&gt;</span><br><span class="line">        (</span><br><span class="line">            IOobject::groupName(<span class="string">"U"</span>, phased.name())</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> fvPatchScalarField&amp; gs0</span><br><span class="line">    (</span><br><span class="line">        patch().lookupPatchField&lt;volScalarField, scalar&gt;</span><br><span class="line">        (</span><br><span class="line">            IOobject::groupName(<span class="string">"gs0"</span>, phased.name())</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> fvPatchScalarField&amp; kappa</span><br><span class="line">    (</span><br><span class="line">        patch().lookupPatchField&lt;volScalarField, scalar&gt;</span><br><span class="line">        (</span><br><span class="line">            IOobject::groupName(<span class="string">"kappa"</span>, phased.name())</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> scalarField Theta(patchInternalField());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lookup the packed volume fraction</span></span><br><span class="line">    dimensionedScalar alphaMax</span><br><span class="line">    (</span><br><span class="line">        <span class="string">"alphaMax"</span>,</span><br><span class="line">        dimless,</span><br><span class="line">        db()</span><br><span class="line">       .lookupObject&lt;IOdictionary&gt;</span><br><span class="line">        (</span><br><span class="line">            IOobject::groupName(<span class="string">"turbulenceProperties"</span>, phased.name())</span><br><span class="line">        )</span><br><span class="line">       .subDict(<span class="string">"RAS"</span>)</span><br><span class="line">       .subDict(<span class="string">"kineticTheoryCoeffs"</span>)</span><br><span class="line">       .lookup(<span class="string">"alphaMax"</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// calculate the reference value and the value fraction</span></span><br><span class="line">    <span class="keyword">if</span> (restitutionCoefficient_.value() != <span class="number">1.0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;refValue() =</span><br><span class="line">            (<span class="number">2.0</span>/<span class="number">3.0</span>)</span><br><span class="line">           *specularityCoefficient_.value()</span><br><span class="line">           *magSqr(U)</span><br><span class="line">           /(scalar(<span class="number">1</span>) - sqr(restitutionCoefficient_.value()));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>-&gt;refGrad() = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">        scalarField c</span><br><span class="line">        (</span><br><span class="line">             constant::mathematical::pi</span><br><span class="line">            *alpha</span><br><span class="line">            *gs0</span><br><span class="line">            *(scalar(1) - sqr(restitutionCoefficient_.value()))</span><br><span class="line">            *sqrt(3.0*Theta)</span><br><span class="line">            /max(4.0*kappa*alphaMax.value(), SMALL)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>-&gt;valueFraction() = c/(c + patch().deltaCoeffs());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for a restitution coefficient of 1, the boundary degenerates to a fixed</span></span><br><span class="line">    <span class="comment">// gradient condition</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;refValue() = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>-&gt;refGrad() =</span><br><span class="line">            pos(alpha - SMALL)</span><br><span class="line">           *constant::mathematical::pi</span><br><span class="line">           *specularityCoefficient_.value()</span><br><span class="line">           *alpha</span><br><span class="line">           *gs0</span><br><span class="line">           *sqrt(3.0*Theta)</span><br><span class="line">           *magSqr(U)</span><br><span class="line">           /max(6.0*kappa*alphaMax.value(), SMALL);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>-&gt;valueFraction() = <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mixedFvPatchScalarField::updateCoeffs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里分两种情况，即 <code>restitutionCoefficient_</code> 是否等于1。其实从公式(35)也能看出来，$e_w=1$ 与 $e_w \neq 1$ 是不一样的。</p>
<ul>
<li><p>$e_w\neq 1$<br>这时，重定义了 <code>refValue</code> 和 <code>valueFraction</code>。利用辅助变量 $c$ 的定义，可以将公式(35)简化如下：<br>$$<br>\frac{\partial \Theta_m}{\partial x}=c \cdot refValue - c \cdot \Theta_m<br>$$<br>写成差分形式<br>$$<br>(\Theta_m-\Theta_c) \cdot \Delta = c\cdot refValue - c \cdot \Theta_m<br>$$<br>得<br>$$<br>\Theta_m=\frac{c}{c+\Delta}\cdot refValue + \frac{\Delta}{c+\Delta} \cdot \Theta_c<br>$$<br>其中 $\Theta_c$ 为邻近壁面网格的颗粒温度。<br>根据 <code>mixed</code> 的定义，壁面的值应当是 <code>valureFraction * refValue + (1-valueFraction)*(patchInternalField() + refGrad/delta)</code>。 这里将 <code>refGrad</code> 赋值为0，就与公式一致了。</p>
</li>
<li><p>$e_w = 1$<br>这种情况下， <code>JohnsonJacksonParticleTheta</code> 就退化为简单的 <code>fixedGradient</code> 了。若 $ \varepsilon_m $ 特别小，则为零梯度，否则，固定梯度，梯度值等于公式(35)的右边第一项。</p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="JohnsonJackson_边界条件">JohnsonJackson 边界条件</h4><p>本篇来看用于气固两相流模拟的 JohnsonJackson 边界条件。这组边界条件用于设定双流体模型中固相在壁面的速度和颗粒温度。根据 <a href="http://www.sciencedirect.com/science/article/pii/S0009250908003904">N. Reuge 2008, CES</a>，壁面上的固相速度和颗粒温度可以表示为：<br><img src="/image/boundaryConditions/JJ.png" alt="JohnsonJackson boundary conditions"><br>其中，$u_m$ 指的是 m 相在壁面切向上的滑移速度。<br>下面来看 OpenFOAM 中对这两个边界条件的实现</p>]]>
    
    </summary>
    
      <category term="Boundary conditions" scheme="http://xiaopingqiu.github.io/tags/Boundary-conditions/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenFOAM 中的边界条件（三）]]></title>
    <link href="http://xiaopingqiu.github.io/2016/04/02/Boundary-conditions-in-OpenFOAM3/"/>
    <id>http://xiaopingqiu.github.io/2016/04/02/Boundary-conditions-in-OpenFOAM3/</id>
    <published>2016-04-02T09:29:16.000Z</published>
    <updated>2016-04-03T07:44:44.840Z</updated>
    <content type="html"><![CDATA[<p>OpenFOAM 中有很多复杂的边界都是继承自上篇中提到的三个基础边界条件，这些边界条件的代码在上一篇的基础上就很容易看懂了。只不过，还有一些边界条件，不是继承自这三个基础边界条件的，其中有一些都直接或间接继承自另一个重要的边界条件： <code>transformFvPatchField</code>。本篇来看看这个 <code>transformFvPatchField</code> 以及几个继承自它的边界条件。</p>
<a id="more"></a>
<h5 id="5-_transform">5. transform</h5><p>这是一个抽象基类，主要注意一下四个函数的定义：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line">tmp&lt;<span class="type">Field</span>&lt;<span class="type">Type</span>&gt; &gt; transformFvPatchField&lt;<span class="type">Type</span>&gt;::valueInternalCoeffs</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;scalarField&gt;&amp;</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> pTraits&lt;<span class="type">Type</span>&gt;::one - snGradTransformDiag();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line">tmp&lt;<span class="type">Field</span>&lt;<span class="type">Type</span>&gt; &gt; transformFvPatchField&lt;<span class="type">Type</span>&gt;::valueBoundaryCoeffs</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;scalarField&gt;&amp;</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        *this</span><br><span class="line">      - cmptMultiply</span><br><span class="line">        (</span><br><span class="line">            valueInternalCoeffs(this-&gt;patch().weights()),</span><br><span class="line">            this-&gt;patchInternalField()</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line">tmp&lt;<span class="type">Field</span>&lt;<span class="type">Type</span>&gt; &gt; transformFvPatchField&lt;<span class="type">Type</span>&gt;::gradientInternalCoeffs() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> -this-&gt;patch().deltaCoeffs()*snGradTransformDiag();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line">tmp&lt;<span class="type">Field</span>&lt;<span class="type">Type</span>&gt; &gt; transformFvPatchField&lt;<span class="type">Type</span>&gt;::gradientBoundaryCoeffs() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        snGrad()</span><br><span class="line">      - cmptMultiply(gradientInternalCoeffs(), this-&gt;patchInternalField());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于 <code>snGrad</code> 和 <code>snGradTransformDiag</code> 都是纯虚函数，所以这四个函数的具体返回值需要在派生类中实现了 <code>snGrad</code> 和 <code>snGradTransformDiag</code> 之后才能确定。<br>另外注意，当模板参数为 <code>scalar</code> 时， <code>gradientInternalCoeffs</code> 函数有特殊的定义：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line">tmp&lt;scalarField &gt; transformFvPatchField&lt;scalar&gt;::gradientInternalCoeffs() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> tmp&lt;scalarField &gt;(new scalarField(size(), <span class="number">0</span>.<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="6-_directionMixed">6. directionMixed</h5><p>这个类，跟前面的 <code>mixed</code> 有点类似，但是又继承自 <code>transform</code> ，所以，似乎是二者的结合。<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">template&lt;<span class="keyword">class</span> <span class="keyword">Type</span>&gt;</span><br><span class="line"><span class="keyword">class</span> directionMixedFvPatchField</span><br><span class="line">:</span><br><span class="line">    <span class="keyword">public</span> transformFvPatchField&lt;<span class="keyword">Type</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    // <span class="keyword">Private</span> <span class="type">data</span></span><br><span class="line"></span><br><span class="line">        //- <span class="keyword">Value</span> field</span><br><span class="line">        Field&lt;<span class="keyword">Type</span>&gt; refValue_;</span><br><span class="line"></span><br><span class="line">        //- Normal gradient field</span><br><span class="line">        Field&lt;<span class="keyword">Type</span>&gt; refGrad_;</span><br><span class="line"></span><br><span class="line">        //- <span class="built_in">Fraction</span> (<span class="number">0</span>-<span class="number">1</span>) of <span class="keyword">value</span> used for boundary condition</span><br><span class="line">        symmTensorField valueFraction_;</span><br></pre></td></tr></table></figure></p>
<p>与 <code>mixed</code> 相似之处是，这里也定义了 <code>refValue_</code> ， <code>refGrad_</code> 和 <code>valueFraction_</code> 三个参数，所不同的是，这里的 <code>valueFraction_</code> 是一个对称张量。</p>
<p>接下来， <code>directionMixed</code> 定义了 <code>snGrad</code> 和 <code>snGradTransformDiag</code> 这两个函数</p>
<ul>
<li><p><code>snGrad</code> 和 <code>snGradTransformDiag</code></p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class <span class="constant">Type&gt;</span></span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:tmp&lt;Foam</span><span class="symbol">:</span><span class="symbol">:Field&lt;Type&gt;</span> &gt;</span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:directionMixedFvPatchField&lt;Type&gt;</span><span class="symbol">:</span><span class="symbol">:snGrad</span>() const</span><br><span class="line">&#123;</span><br><span class="line">    const <span class="constant">Field&lt;Type&gt;</span> pif(this-&gt;patchInternalField());</span><br><span class="line"></span><br><span class="line">    tmp&lt;<span class="constant">Field&lt;Type&gt;</span> &gt; normalValue = transform(valueFraction<span class="constant">_</span>, refValue<span class="constant">_</span>);</span><br><span class="line"></span><br><span class="line">    tmp&lt;<span class="constant">Field&lt;Type&gt;</span> &gt; gradValue = pif + refGrad<span class="constant">_</span>/this-&gt;patch().deltaCoeffs();</span><br><span class="line"></span><br><span class="line">    tmp&lt;<span class="constant">Field&lt;Type&gt;</span> &gt; transformGradValue =</span><br><span class="line">        transform(<span class="constant">I </span>- valueFraction<span class="constant">_</span>, gradValue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        (normalValue + transformGradValue - pif)*</span><br><span class="line">        this-&gt;patch().deltaCoeffs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class <span class="constant">Type&gt;</span></span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:tmp&lt;Foam</span><span class="symbol">:</span><span class="symbol">:Field&lt;Type&gt;</span> &gt;</span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:directionMixedFvPatchField&lt;Type&gt;</span><span class="symbol">:</span><span class="symbol">:snGradTransformDiag</span>() const</span><br><span class="line">&#123;</span><br><span class="line">    vectorField diag(valueFraction<span class="constant">_</span>.size());</span><br><span class="line"></span><br><span class="line">    diag.replace</span><br><span class="line">    (</span><br><span class="line">        <span class="symbol">vector:</span><span class="symbol">:X</span>,</span><br><span class="line">        sqrt(mag(valueFraction<span class="constant">_</span>.component(<span class="symbol">symmTensor:</span><span class="symbol">:XX</span>)))</span><br><span class="line">    );</span><br><span class="line">    diag.replace</span><br><span class="line">    (</span><br><span class="line">        <span class="symbol">vector:</span><span class="symbol">:Y</span>,</span><br><span class="line">        sqrt(mag(valueFraction<span class="constant">_</span>.component(<span class="symbol">symmTensor:</span><span class="symbol">:YY</span>)))</span><br><span class="line">    );</span><br><span class="line">    diag.replace</span><br><span class="line">    (</span><br><span class="line">        <span class="symbol">vector:</span><span class="symbol">:Z</span>,</span><br><span class="line">        sqrt(mag(valueFraction<span class="constant">_</span>.component(<span class="symbol">symmTensor:</span><span class="symbol">:ZZ</span>)))</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> transformFieldMask&lt;<span class="constant">Type&gt;</span>(pow&lt;vector, pTraits&lt;<span class="constant">Type&gt;</span><span class="symbol">:</span><span class="symbol">:rank&gt;</span>(diag));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>evaluate</code> 函数</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">template<span class="subst">&lt;</span>class <span class="keyword">Type</span><span class="subst">&gt;</span></span><br><span class="line"><span class="literal">void</span> Foam<span class="tag">::directionMixedFvPatchField</span><span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::evaluate</span>(const Pstream<span class="tag">::commsTypes</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="subst">!</span>this<span class="subst">-&gt;</span>updated())</span><br><span class="line">    &#123;</span><br><span class="line">        this<span class="subst">-&gt;</span>updateCoeffs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tmp<span class="subst">&lt;</span>Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span> <span class="subst">&gt;</span> normalValue <span class="subst">=</span> transform(valueFraction_, refValue_);</span><br><span class="line"></span><br><span class="line">    tmp<span class="subst">&lt;</span>Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span> <span class="subst">&gt;</span> gradValue <span class="subst">=</span></span><br><span class="line">        this<span class="subst">-&gt;</span>patchInternalField() <span class="subst">+</span> refGrad_/this<span class="subst">-&gt;</span>patch()<span class="built_in">.</span>deltaCoeffs();</span><br><span class="line"></span><br><span class="line">    tmp<span class="subst">&lt;</span>Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span> <span class="subst">&gt;</span> transformGradValue <span class="subst">=</span></span><br><span class="line">        transform(I <span class="subst">-</span> valueFraction_, gradValue);</span><br><span class="line"></span><br><span class="line">    Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::operator</span><span class="subst">=</span>(normalValue <span class="subst">+</span> transformGradValue);</span><br><span class="line"></span><br><span class="line">    transformFvPatchField<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::evaluate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="7-_basicSymmetry">7. basicSymmetry</h5><p>这个类的结构与 <code>directionMixed</code> 类似，对 <code>snGrad</code> ， <code>snGradTransformDiag</code> 和 <code>evaluate</code> 等几个函数进行了重新定义。</p>
<ul>
<li><p><code>snGrad</code> 和 <code>snGradTransformDiag</code></p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class <span class="constant">Type&gt;</span></span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:tmp&lt;Foam</span><span class="symbol">:</span><span class="symbol">:Field&lt;Type&gt;</span> &gt;</span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:basicSymmetryFvPatchField&lt;Type&gt;</span><span class="symbol">:</span><span class="symbol">:snGrad</span>() const</span><br><span class="line">&#123;</span><br><span class="line">    tmp&lt;vectorField&gt; nHat = this-&gt;patch().nf();</span><br><span class="line"></span><br><span class="line">    const <span class="constant">Field&lt;Type&gt;</span> iF(this-&gt;patchInternalField());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        (transform(<span class="constant">I </span>- <span class="number">2.0</span>*sqr(nHat), iF) - iF)</span><br><span class="line">       *(this-&gt;patch().deltaCoeffs()/<span class="number">2.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class <span class="constant">Type&gt;</span></span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:tmp&lt;Foam</span><span class="symbol">:</span><span class="symbol">:Field&lt;Type&gt;</span> &gt;</span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:basicSymmetryFvPatchField&lt;Type&gt;</span><span class="symbol">:</span><span class="symbol">:snGradTransformDiag</span>() const</span><br><span class="line">&#123;</span><br><span class="line">    const vectorField nHat(this-&gt;patch().nf());</span><br><span class="line"></span><br><span class="line">    vectorField diag(nHat.size());</span><br><span class="line"></span><br><span class="line">    diag.replace(<span class="symbol">vector:</span><span class="symbol">:X</span>, mag(nHat.component(<span class="symbol">vector:</span><span class="symbol">:X</span>)));</span><br><span class="line">    diag.replace(<span class="symbol">vector:</span><span class="symbol">:Y</span>, mag(nHat.component(<span class="symbol">vector:</span><span class="symbol">:Y</span>)));</span><br><span class="line">    diag.replace(<span class="symbol">vector:</span><span class="symbol">:Z</span>, mag(nHat.component(<span class="symbol">vector:</span><span class="symbol">:Z</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> transformFieldMask&lt;<span class="constant">Type&gt;</span>(pow&lt;vector, pTraits&lt;<span class="constant">Type&gt;</span><span class="symbol">:</span><span class="symbol">:rank&gt;</span>(diag));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>evaluate</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">template<span class="subst">&lt;</span>class <span class="keyword">Type</span><span class="subst">&gt;</span></span><br><span class="line"><span class="literal">void</span> Foam<span class="tag">::basicSymmetryFvPatchField</span><span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::evaluate</span>(const Pstream<span class="tag">::commsTypes</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="subst">!</span>this<span class="subst">-&gt;</span>updated())</span><br><span class="line">    &#123;</span><br><span class="line">        this<span class="subst">-&gt;</span>updateCoeffs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tmp<span class="subst">&lt;</span>vectorField<span class="subst">&gt;</span> nHat <span class="subst">=</span> this<span class="subst">-&gt;</span>patch()<span class="built_in">.</span>nf();</span><br><span class="line"></span><br><span class="line">    const Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span> <span class="keyword">iF</span>(this<span class="subst">-&gt;</span>patchInternalField());</span><br><span class="line"></span><br><span class="line">    Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::operator</span><span class="subst">=</span></span><br><span class="line">    (</span><br><span class="line">        (<span class="keyword">iF</span> <span class="subst">+</span> transform(I <span class="subst">-</span> <span class="number">2.0</span><span class="subst">*</span>sqr(nHat), <span class="keyword">iF</span>))/<span class="number">2.0</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    transformFvPatchField<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::evaluate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>另外，值得注意的是，当模板参数 <code>Type</code> 是 <code>scalar</code> 时， <code>snGrad</code> 和 <code>evaluate</code> 函数有其他的定义：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">Foam</span>::tmp&lt;<span class="type">Foam</span>::scalarField&gt;</span><br><span class="line"><span class="type">Foam</span>::basicSymmetryFvPatchField&lt;<span class="type">Foam</span>::scalar&gt;::snGrad() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> tmp&lt;scalarField &gt;(new scalarField(size(), <span class="number">0</span>.<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="type">Foam</span>::basicSymmetryFvPatchField&lt;<span class="type">Foam</span>::scalar&gt;::evaluate</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> <span class="type">Pstream</span>::commsTypes</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!updated())</span><br><span class="line">    &#123;</span><br><span class="line">        updateCoeffs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    scalarField::operator=(patchInternalField());</span><br><span class="line">    transformFvPatchField&lt;scalar&gt;::evaluate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从这两个函数可推断，当 <code>Type = scalar</code> 时， <code>basicSymmetry</code> 其实就相当于 <code>zeroGradient</code>。 </p>
<p>关于 <code>transform</code> 和 <code>transformFieldMask</code> 这两个函数，摸索了很久。前者涉及的源文件有 <a href="http://foam.sourceforge.net/docs/cpp/a07932_source.html" target="_blank" rel="external"><code>symmTransformField.C</code></a> ，<a href="http://foam.sourceforge.net/docs/cpp/a07942_source.html" target="_blank" rel="external"> <code>transformFieldTemplates.C</code> </a>；后者的定义在 <a href="http://foam.sourceforge.net/docs/cpp/a07933_source.html" target="_blank" rel="external"><code>symmTransformField.H</code></a>，涉及到的 <code>pow</code> 函数的定义在<a href="http://foam.sourceforge.net/docs/cpp/a07889_source.html" target="_blank" rel="external"><code>FieldFunctions.C</code></a>。此外，这两个函数还需要用到类似 <code>TFOR_ALL_F_OP_FUNC_F_F</code> 的宏，定义在<a href="http://foam.sourceforge.net/docs/cpp/a07893_source.html#l00153" target="_blank" rel="external"><code>fieldM.H</code></a>，而这个宏里涉及到的类似 <code>List_ELEM</code> 这样的宏，则定义在 <a href="http://foam.sourceforge.net/docs/cpp/a07587_source.html" target="_blank" rel="external"><code>ListLoopM.H</code></a>。</p>
<p>看了这么多，仍然无法完全确定这两个函数的具体的行为。主要的障碍在于那个 <code>pow</code> 函数实在看不明白。最后只好来对这两个函数进行了一些测试，测试结果总结如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">transform</span><span class="params">(tensorField p1, vectorField p2)</span></span></span><br></pre></td></tr></table></figure></p>
<p>返回的是另一个 <code>vectorField</code> ，其值等于 <code>p1</code> 与 <code>p2</code> 的内积（即点乘）。注意，一般使用过程中总能保证 <code>p1.size() == p2.size()</code>，但是如果 <code>p1.size() &gt; p2.size()</code>， 则返回结果的 <code>size</code> 等于 <code>p2.size()</code> ，值则等于 <code>p1</code> 的前 <code>p2.size()</code> 部分与 <code>p2</code> 的内积。<br><a href="http://www.slideshare.net/fumiyanozaki96/boundary-conditions-in-openfoam" target="_blank" rel="external">Boundary Conditions in OpenFOAM</a> 这个 silde 也提到了29页也同样提到了 <code>transform</code> 函数的作用<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">inline scalar transform(constsymmTensor&amp;, <span class="keyword">const</span> scalar s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Cmpt</span>&gt;</span><br><span class="line">inline <span class="type">Vector</span>&lt;<span class="type">Cmpt</span>&gt; transform(<span class="keyword">const</span> symmTensor&amp; stt, <span class="keyword">const</span> <span class="type">Vector</span>&lt;<span class="type">Cmpt</span>&gt;&amp; v)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> stt &amp; v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而 <code>transformFieldMask</code><br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transformFieldMask&lt;Type&gt;<span class="list">(<span class="keyword">pow&lt;vector</span>, pTraits&lt;Type&gt;:<span class="keyword">:rank&gt;</span><span class="list">(<span class="keyword">diag</span>)</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>目前测试的结果是，其返回值等于 <code>diag</code> 。</p>
<p>有了上面对 <code>transform</code> 和 <code>transformFieldMask</code> 两个函数的测试结果，就可以来分析 <code>basicSymmetry</code> 和 <code>directionMixed</code> 两个边界条件的行为了。</p>
<h5 id="basicSymmetry">basicSymmetry</h5><p>对于标量，前面说过其等价于 <code>zeroGradient</code>，所以这里只分析矢量的情形。<br>从 <code>evaluate</code> 函数，可以得到如下公式<br>$$<br>\begin{align}<br>\overrightarrow{\phi}_b = &amp; \left [\overrightarrow{\phi}_c + (\mathrm{I} - 2\overrightarrow{n} \otimes \overrightarrow{n})\cdot \overrightarrow{\phi}_c  \right ] \cdot \frac{1}{2.0} \\<br>= &amp;  \overrightarrow{\phi}_c- \left ( \overrightarrow{\phi}_c \cdot  \overrightarrow{n} \right)\cdot \overrightarrow{n}<br>\end{align}<br>$$<br>这意味着，边界上的值等于其邻近网格中心的值的切向分量。<br>为了方便分析四个系数，将上式写成分量的形式:<br>$$<br>\begin{align}<br>\begin{bmatrix}<br>\phi_{px} \\<br>\phi_{py} \\<br>\phi_{pz}<br>\end{bmatrix} = &amp;<br>\begin{bmatrix}<br>\phi_{cx} \\<br>\phi_{cy} \\<br>\phi_{cz}<br>\end{bmatrix} -<br>\begin{bmatrix}<br>(\phi_{cx}n_x + \phi_{cy}n_y + \phi_{cz}n_z)n_x \\<br>(\phi_{cx}n_x + \phi_{cy}n_y + \phi_{cz}n_z)n_y \\<br>(\phi_{cx}n_x + \phi_{cy}n_y + \phi_{cz}n_z)n_z<br>\end{bmatrix} \\<br>= &amp; \begin{bmatrix}<br>(1-n_xn_x)\phi_{cx} \\<br>(1-n_yn_y)\phi_{cy} \\<br>(1-n_zn_z)\phi_{cz}<br>\end{bmatrix} -<br>\begin{bmatrix}<br>\phi_{cy}n_yn_x + \phi_{cz}n_zn_x \\<br>\phi_{cx}n_xn_y + \phi_{cz}n_zn_y \\<br>\phi_{cx}n_xn_z + \phi_{cy}n_yn_z<br>\end{bmatrix}<br>\end{align}<br>$$<br>照此公式，可以分析得到四个系数如下：<br>$$<br>valueInternalCoeffs =<br>\begin{bmatrix}<br>(1-n_xn_x) \\<br>(1-n_yn_y) \\<br>(1-n_zn_z)<br>\end{bmatrix}<br>$$<br>$$<br>valueBoundaryCoeffs =<br>\begin{bmatrix}<br>\phi_{px} \\<br>\phi_{py} \\<br>\phi_{pz}<br>\end{bmatrix} - valueInternalCoeffs<br>\begin{bmatrix}<br>\phi_{cx} \\<br>\phi_{cy} \\<br>\phi_{cz}<br>\end{bmatrix}<br>$$<br>$$<br>gradientInternalCoeffs= - \Delta<br>\begin{bmatrix}<br>(n_xn_x) \\<br>(n_yn_y) \\<br>(n_zn_z)<br>\end{bmatrix}<br>$$<br>$$<br>gradientBoundaryCoeffs = - \begin{bmatrix}<br>(\phi_{cx}n_x + \phi_{cy}n_y + \phi_{cz}n_z)n_x \\<br>(\phi_{cx}n_x + \phi_{cy}n_y + \phi_{cz}n_z)n_y \\<br>(\phi_{cx}n_x + \phi_{cy}n_y + \phi_{cz}n_z)n_z<br>\end{bmatrix}  \Delta - gradientInternalCoeffs<br>\begin{bmatrix}<br>\phi_{cx} \\<br>\phi_{cy} \\<br>\phi_{cz}<br>\end{bmatrix}<br>$$</p>
<p><strong> 但是，实际上 OpenFOAM 里不是这么实现的</strong>！关键就在于这个 <code>snGradTransformDiag</code> 函数的定义与预期不符。<br>根据我的测试， <code>snGradTransformDiag</code> 函数返回值应该是<br>$$<br>snGradTransformDiag =<br>\begin{bmatrix}<br>|n_x| \\<br>|n_y| \\<br>|n_z|<br>\end{bmatrix}<br>$$<br>即，张量 $\overrightarrow{n}\otimes\overrightarrow{n}$ 的主对角线元素组成的矢量。</p>
<p>而 <code>snGrad</code> 函数的返回值，根据代码可知<br>$$<br>snGrad = - \left ( \overrightarrow{\phi}_c \cdot  \overrightarrow{n} \right)\cdot \overrightarrow{n}\cdot \Delta<br>$$<br>所以，OpenFOAM 中定义的四个系数为：<br>$$<br>valueInternalCoeffs =<br>\begin{bmatrix}<br>(1-|n_x|) \\<br>(1-|n_y|) \\<br>(1-|n_z|)<br>\end{bmatrix}<br>$$<br>$$<br>valueBoundaryCoeffs =<br>\begin{bmatrix}<br>\phi_{px} \\<br>\phi_{py} \\<br>\phi_{pz}<br>\end{bmatrix} - valueInternalCoeffs<br>\begin{bmatrix}<br>\phi_{cx} \\<br>\phi_{cy} \\<br>\phi_{cz}<br>\end{bmatrix}<br>$$<br>$$<br>gradientInternalCoeffs= - \Delta<br>\begin{bmatrix}<br>|n_x| \\<br>|n_y| \\<br>|n_z|<br>\end{bmatrix}<br>$$<br>$$<br>gradientBoundaryCoeffs = - \begin{bmatrix}<br>(\phi_{cx}n_x + \phi_{cy}n_y + \phi_{cz}n_z)n_x \\<br>(\phi_{cx}n_x + \phi_{cy}n_y + \phi_{cz}n_z)n_y \\<br>(\phi_{cx}n_x + \phi_{cy}n_y + \phi_{cz}n_z)n_z<br>\end{bmatrix}  \Delta - gradientInternalCoeffs<br>\begin{bmatrix}<br>\phi_{cx} \\<br>\phi_{cy} \\<br>\phi_{cz}<br>\end{bmatrix}<br>$$</p>
<p>这里的 $\Delta$ 代表代码中的 <code>deltaCoeffs</code> 。</p>
<h5 id="directionMixed">directionMixed</h5><p><code>directionMixed</code> 与 <code>basicSymmetry</code> 是类似的，差别在于 <code>directionMixed</code> 所使用的对称张量是指定的，而不一定是 $\overrightarrow{n}\otimes\overrightarrow{n}$。<br>根据 <code>evaluate</code> 函数，可以得到如下公式：<br>$$<br>\begin{align}<br>\overrightarrow{\phi}_b = &amp; \overrightarrow{\phi}_{ref}\cdot \mathbf{vF} + (\mathrm{I} - \mathbf{vF}) \cdot \left (\overrightarrow{\phi}_c + \frac{\overrightarrow{G}}{\Delta} \right)\\<br>= &amp;  (\mathrm{I} - \mathbf{vF}) \cdot \overrightarrow{\phi}_c + \overrightarrow{\phi}_{ref}\cdot vF + (\mathrm{I} - \mathbf{vF}) \cdot \frac{\overrightarrow{G}}{\Delta}<br>\end{align}<br>$$<br>其中，$\overrightarrow{\phi}_{ref}=refValue$，$\overrightarrow{G}=refGrad$，$\mathbf{vF}=valueFraction$<br>同样，为了方便分析，将上述公式的部分写成分量形式：<br>$$<br>\begin{align}<br>\begin{bmatrix}<br>\phi_{px} \\<br>\phi_{py} \\<br>\phi_{pz}<br>\end{bmatrix} = &amp; \begin{bmatrix}<br>\phi_{cx} \\<br>\phi_{cy} \\<br>\phi_{cz}<br>\end{bmatrix} - \begin{bmatrix}<br>vF_{xx}\phi_{cx} + vF_{xy}\phi_{cy} + vF_{xz}\phi_{cz}\\<br>vF_{yx}\phi_{cx} + vF_{yy}\phi_{cy} + vF_{yz}\phi_{cz} \\<br>vF_{zx}\phi_{cx} + vF_{zy}\phi_{cy} + vF_{zz}\phi_{cz}<br>\end{bmatrix} + \overrightarrow{\phi}_{ref}\cdot \mathbf{vF} + (\mathrm{I} - \mathbf{vF}) \cdot \frac{\overrightarrow{G}}{\Delta} \\<br>= &amp; \begin{bmatrix}<br>(1-vF_{xx})\phi_{cx} \\<br>(1-vF_{yy})\phi_{cy} \\<br>(1-vF_{zz})\phi_{cz}<br>\end{bmatrix} - \begin{bmatrix}<br>vF_{xy}\phi_{cy} + vF_{xz}\phi_{cz}\\<br>vF_{yx}\phi_{cx} + vF_{yz}\phi_{cz} \\<br>vF_{zx}\phi_{cx} + vF_{zy}\phi_{cy}<br>\end{bmatrix} + \overrightarrow{\phi}_{ref}\cdot \mathbf{vF} + (\mathrm{I} - \mathbf{vF}) \cdot \frac{\overrightarrow{G}}{\Delta}<br>\end{align}<br>$$<br>同样的，OpenFOAM 中四个系数的实现也与预期的不一样。主要还是 <code>snGradTransformDiag</code> 的定义与预期的不符:<br>$$<br>snGradTransformDiag =<br>\begin{bmatrix}<br>\sqrt{|vF_{xx}|} \\<br>\sqrt{|vF_{yy}|} \\<br>\sqrt{|vF_{zz}|}<br>\end{bmatrix}<br>$$</p>
<p>结合代码，可以得到四个系数如下：<br>$$<br>valueInternalCoeffs =<br>\begin{bmatrix}<br>(1-\sqrt{|vF_{xx}|}) \\<br>(1-\sqrt{|vF_{yy}|}) \\<br>(1-\sqrt{|vF_{zz}|})<br>\end{bmatrix}<br>$$<br>$$<br>valueBoundaryCoeffs =<br>\begin{bmatrix}<br>\phi_{px} \\<br>\phi_{py} \\<br>\phi_{pz}<br>\end{bmatrix} - valueInternalCoeffs<br>\begin{bmatrix}<br>\phi_{cx} \\<br>\phi_{cy} \\<br>\phi_{cz}<br>\end{bmatrix}<br>$$<br>$$<br>gradientInternalCoeffs= - \Delta<br>\begin{bmatrix}<br>\sqrt{|vF_{xx}|} \\<br>\sqrt{|vF_{yy}|} \\<br>\sqrt{|vF_{zz}|}<br>\end{bmatrix}<br>$$<br>$$<br>gradientBoundaryCoeffs = - \mathbf{vF} \cdot \overrightarrow{\phi}_c \cdot \Delta+ \overrightarrow{\phi}_{ref}\cdot \mathbf{vF} \cdot \Delta + (\mathrm{I} - \mathbf{vF}) \cdot \overrightarrow{G} - gradientInternalCoeffs \cdot \overrightarrow{\phi}_c<br>$$</p>
<p>代码里的 <code>snGrad</code> 函数对应公式为：<br>$$<br>\left [ \overrightarrow{\phi}_{ref}\cdot \mathbf{vF} + (\mathrm{I} - \mathbf{vF}) \cdot (\overrightarrow{\phi}_c + \frac{\overrightarrow{G}}{\Delta}) - \overrightarrow{\phi}_c \right ]\cdot \Delta<br>$$</p>
<p>不知道为什么 <code>snGradTransformDiag</code> 要按照这种方式来定义，可能是为了数值稳定性。不过，由于 <code>valueBoundaryCoeffs</code> 和 <code>gradientBoundaryCoeffs</code> 分别是在 <code>valueInternalCoeffs</code> 和 <code>gradientInternalCoeffs</code> 的基础之上定义的，所以总是能保证 <code>evaluate</code> 的结果与预期一致。</p>
<p>可以将 <code>directionMixed</code> 的行为总结如下：<br><img src="/image/boundaryConditions/boundary-conditions-in-openfoam-90.jpg" alt="directionMixed 的行为"></p>
<p>不过，如果 <code>valueFraction</code> 的值是任意指定的，而不是由 $\overrightarrow{n}\otimes\overrightarrow{n}$ 构成的，那又另当别论了。</p>
<p><strong>参考资料</strong>：<br><a href="http://www.slideshare.net/fumiyanozaki96/boundary-conditions-in-openfoam" target="_blank" rel="external">Boundary Conditions in OpenFOAM</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>OpenFOAM 中有很多复杂的边界都是继承自上篇中提到的三个基础边界条件，这些边界条件的代码在上一篇的基础上就很容易看懂了。只不过，还有一些边界条件，不是继承自这三个基础边界条件的，其中有一些都直接或间接继承自另一个重要的边界条件： <code>transformFvPatchField</code>。本篇来看看这个 <code>transformFvPatchField</code> 以及几个继承自它的边界条件。</p>]]>
    
    </summary>
    
      <category term="Boundary conditions" scheme="http://xiaopingqiu.github.io/tags/Boundary-conditions/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenFOAM 中的边界条件（二）]]></title>
    <link href="http://xiaopingqiu.github.io/2016/04/02/Boundary-conditions-in-OpenFOAM2/"/>
    <id>http://xiaopingqiu.github.io/2016/04/02/Boundary-conditions-in-OpenFOAM2/</id>
    <published>2016-04-02T08:40:43.000Z</published>
    <updated>2016-04-02T09:27:58.296Z</updated>
    <content type="html"><![CDATA[<p>本篇在上一篇的基础上来解读 OpenFOAM 中的基础边界条件。基础边界条件一般包括三类，一是Dirichlet 边界，二是 Neumann 边界，三是混合 Dirichlet 和 Neumann 的边界。</p>
<a id="more"></a>
<h5 id="1-_fixedalue">1. fixedalue</h5><p>这个是 OpenFOAM 中的 Dirichlet 边界条件。</p>
<ul>
<li>构造函数<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line">fixedValueFvPatchField&lt;<span class="type">Type</span>&gt;::fixedValueFvPatchField</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> fvPatch&amp; p,</span><br><span class="line">    <span class="keyword">const</span> <span class="type">DimensionedField</span>&lt;<span class="type">Type</span>, volMesh&gt;&amp; iF,</span><br><span class="line">    <span class="keyword">const</span> dictionary&amp; dict</span><br><span class="line">)</span><br><span class="line">:</span><br><span class="line">    fvPatchField&lt;<span class="type">Type</span>&gt;(p, iF, dict, <span class="literal">true</span>)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>熟悉 OpenFOAM 的人都知道， <code>fixedValue</code> 这个边界条件需要用 <code>value</code> 关键字来指定边界的值。<code>value</code> 这个关键字是通过 <code>DimensionedField</code> 类来处理的。 <code>DimensionedField</code> 这个类将读取 <code>value</code> 关键字对应的场的值用来初始化边界上的值。</p>
<ul>
<li>coefficients<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line">tmp&lt;<span class="type">Field</span>&lt;<span class="type">Type</span>&gt; &gt; fixedValueFvPatchField&lt;<span class="type">Type</span>&gt;::valueInternalCoeffs</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;scalarField&gt;&amp;</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> tmp&lt;<span class="type">Field</span>&lt;<span class="type">Type</span>&gt; &gt;</span><br><span class="line">    (</span><br><span class="line">        new <span class="type">Field</span>&lt;<span class="type">Type</span>&gt;(this-&gt;size(), pTraits&lt;<span class="type">Type</span>&gt;::zero)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line">tmp&lt;<span class="type">Field</span>&lt;<span class="type">Type</span>&gt; &gt; fixedValueFvPatchField&lt;<span class="type">Type</span>&gt;::valueBoundaryCoeffs</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;scalarField&gt;&amp;</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> *this;</span><br><span class="line">&#125;</span><br><span class="line">这里 <span class="string">"*this"</span> 表示类本身，即当前边界上的值。这个值在上面的构造函数中进行了初始化，所以，可以理解为 valueBoundaryCoeffs 函数返回的正是关键字 <span class="string">"value"</span> 所对应的值。</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line">tmp&lt;<span class="type">Field</span>&lt;<span class="type">Type</span>&gt; &gt; fixedValueFvPatchField&lt;<span class="type">Type</span>&gt;::gradientInternalCoeffs() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> -pTraits&lt;<span class="type">Type</span>&gt;::one*this-&gt;patch().deltaCoeffs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line">tmp&lt;<span class="type">Field</span>&lt;<span class="type">Type</span>&gt; &gt; fixedValueFvPatchField&lt;<span class="type">Type</span>&gt;::gradientBoundaryCoeffs() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> this-&gt;patch().deltaCoeffs()*(*this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>$$<br>\begin{align}<br>valueInternalCoeffs &amp; = 0 \\<br>valueBoundaryCoeffs &amp; = value \\<br>gradientInternalCoeffs &amp; = -delta \\<br>gradientBoundaryCoeffs &amp; = delta* value<br>\end{align}<br>$$</p>
<p>其中 $delta$ 为面心与面所属网格中心的距离的倒数。<br>从上述系数，可以知道，fixedValue 边界条件对边界的值和梯度值的计算为如下：<br>$$<br>\begin{align}<br>x_p &amp; = value \\<br>\nabla x_p &amp; = - delta \cdot x_C + delta \cdot value = (value - x_C) \cdot delta<br>\end{align}<br>$$<br>这与预期是一致的。</p>
<h5 id="2-_zeroGradient">2. zeroGradient</h5><p>这个是 OpenFOAM 中的一种特殊的 Neumann 边界条件，即边界的梯度为零。</p>
<ul>
<li>evaluate 函数<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">template<span class="subst">&lt;</span>class <span class="keyword">Type</span><span class="subst">&gt;</span></span><br><span class="line"><span class="literal">void</span> zeroGradientFvPatchField<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::evaluate</span>(const Pstream<span class="tag">::commsTypes</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="subst">!</span>this<span class="subst">-&gt;</span>updated())</span><br><span class="line">    &#123;</span><br><span class="line">        this<span class="subst">-&gt;</span>updateCoeffs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fvPatchField<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::operator</span><span class="subst">==</span>(this<span class="subst">-&gt;</span>patchInternalField());</span><br><span class="line">    fvPatchField<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::evaluate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>注意，这里的 <code>operator==</code> 与 <code>operator=</code> 的作用是一样的，都是赋值运算，而不是比较。</p>
<ul>
<li>coefficients<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">template<span class="subst">&lt;</span>class <span class="keyword">Type</span><span class="subst">&gt;</span></span><br><span class="line">tmp<span class="subst">&lt;</span>Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span> <span class="subst">&gt;</span> zeroGradientFvPatchField<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::valueInternalCoeffs</span></span><br><span class="line">(</span><br><span class="line">    const tmp<span class="subst">&lt;</span>scalarField<span class="subst">&gt;&amp;</span></span><br><span class="line">) const</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> tmp<span class="subst">&lt;</span>Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span> <span class="subst">&gt;</span></span><br><span class="line">    (</span><br><span class="line">        <span class="literal">new</span> Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span>(this<span class="subst">-&gt;</span>size(), pTraits<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::one</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template<span class="subst">&lt;</span>class <span class="keyword">Type</span><span class="subst">&gt;</span></span><br><span class="line">tmp<span class="subst">&lt;</span>Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span> <span class="subst">&gt;</span> zeroGradientFvPatchField<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::valueBoundaryCoeffs</span></span><br><span class="line">(</span><br><span class="line">    const tmp<span class="subst">&lt;</span>scalarField<span class="subst">&gt;&amp;</span></span><br><span class="line">) const</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> tmp<span class="subst">&lt;</span>Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span> <span class="subst">&gt;</span></span><br><span class="line">    (</span><br><span class="line">        <span class="literal">new</span> Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span>(this<span class="subst">-&gt;</span>size(), pTraits<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::zero</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template<span class="subst">&lt;</span>class <span class="keyword">Type</span><span class="subst">&gt;</span></span><br><span class="line">tmp<span class="subst">&lt;</span>Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span> <span class="subst">&gt;</span> zeroGradientFvPatchField<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::gradientInternalCoeffs</span>() const</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> tmp<span class="subst">&lt;</span>Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span> <span class="subst">&gt;</span></span><br><span class="line">    (</span><br><span class="line">        <span class="literal">new</span> Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span>(this<span class="subst">-&gt;</span>size(), pTraits<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::zero</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template<span class="subst">&lt;</span>class <span class="keyword">Type</span><span class="subst">&gt;</span></span><br><span class="line">tmp<span class="subst">&lt;</span>Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span> <span class="subst">&gt;</span> zeroGradientFvPatchField<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::gradientBoundaryCoeffs</span>() const</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> tmp<span class="subst">&lt;</span>Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span> <span class="subst">&gt;</span></span><br><span class="line">    (</span><br><span class="line">        <span class="literal">new</span> Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span>(this<span class="subst">-&gt;</span>size(), pTraits<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::zero</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>$$<br>\begin{align}<br>valueInternalCoeffs &amp; = 1 \\<br>valueBoundaryCoeffs &amp; = 0 \\<br>gradientInternalCoeffs &amp; = 0 \\<br>gradientBoundaryCoeffs &amp; = 0<br>\end{align}<br>$$</p>
<p>从上述系数，可以知道，fixedValue 边界条件对边界的值和梯度值的计算为如下：</p>
<p>$$<br>\begin{align}<br>x_p &amp; = x_C \\<br>\nabla x_p &amp; = 0<br>\end{align}<br>$$<br>这与预期是一致的。</p>
<h5 id="3-_fixedGradient">3. fixedGradient</h5><p>这个是 OpenFOAM 中的 Neumann 边界条件，可以指定边界上的梯度值。</p>
<ul>
<li>构造函数<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line">fixedGradientFvPatchField&lt;<span class="type">Type</span>&gt;::fixedGradientFvPatchField</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> fvPatch&amp; p,</span><br><span class="line">    <span class="keyword">const</span> <span class="type">DimensionedField</span>&lt;<span class="type">Type</span>, volMesh&gt;&amp; iF,</span><br><span class="line">    <span class="keyword">const</span> dictionary&amp; dict</span><br><span class="line">)</span><br><span class="line">:</span><br><span class="line">    fvPatchField&lt;<span class="type">Type</span>&gt;(p, iF, dict),</span><br><span class="line">    gradient_(<span class="string">"gradient"</span>, dict, p.size())</span><br><span class="line">&#123;</span><br><span class="line">    evaluate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>需要读取关键字 “gradient” 对应的值来初始化变量 <code>gradient_</code>。</p>
<ul>
<li>evaluate 函数<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">template<span class="subst">&lt;</span>class <span class="keyword">Type</span><span class="subst">&gt;</span></span><br><span class="line"><span class="literal">void</span> fixedGradientFvPatchField<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::evaluate</span>(const Pstream<span class="tag">::commsTypes</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="subst">!</span>this<span class="subst">-&gt;</span>updated())</span><br><span class="line">    &#123;</span><br><span class="line">        this<span class="subst">-&gt;</span>updateCoeffs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::operator</span><span class="subst">=</span></span><br><span class="line">    (</span><br><span class="line">        this<span class="subst">-&gt;</span>patchInternalField() <span class="subst">+</span> gradient_/this<span class="subst">-&gt;</span>patch()<span class="built_in">.</span>deltaCoeffs()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    fvPatchField<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::evaluate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>$$<br>x_p = x_C + \frac{gradient} {delta}<br>$$<br>其中 $delta$ 为面心与面所属网格中心的距离的倒数。</p>
<ul>
<li>coefficients<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line">tmp&lt;<span class="type">Field</span>&lt;<span class="type">Type</span>&gt; &gt; fixedGradientFvPatchField&lt;<span class="type">Type</span>&gt;::valueInternalCoeffs</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;scalarField&gt;&amp;</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> tmp&lt;<span class="type">Field</span>&lt;<span class="type">Type</span>&gt; &gt;(new <span class="type">Field</span>&lt;<span class="type">Type</span>&gt;(this-&gt;size(), pTraits&lt;<span class="type">Type</span>&gt;::one));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line">tmp&lt;<span class="type">Field</span>&lt;<span class="type">Type</span>&gt; &gt; fixedGradientFvPatchField&lt;<span class="type">Type</span>&gt;::valueBoundaryCoeffs</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;scalarField&gt;&amp;</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> gradient()/this-&gt;patch().deltaCoeffs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line">tmp&lt;<span class="type">Field</span>&lt;<span class="type">Type</span>&gt; &gt; fixedGradientFvPatchField&lt;<span class="type">Type</span>&gt;::</span><br><span class="line">gradientInternalCoeffs() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> tmp&lt;<span class="type">Field</span>&lt;<span class="type">Type</span>&gt; &gt;</span><br><span class="line">    (</span><br><span class="line">        new <span class="type">Field</span>&lt;<span class="type">Type</span>&gt;(this-&gt;size(), pTraits&lt;<span class="type">Type</span>&gt;::zero)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line">tmp&lt;<span class="type">Field</span>&lt;<span class="type">Type</span>&gt; &gt; fixedGradientFvPatchField&lt;<span class="type">Type</span>&gt;::</span><br><span class="line">gradientBoundaryCoeffs() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> gradient();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>$$<br>\begin{align}<br>valueInternalCoeffs &amp; = 1 \\<br>valueBoundaryCoeffs &amp; = \tfrac{gradient}{delta} \\<br>gradientInternalCoeffs &amp; = 0 \\<br>gradientBoundaryCoeffs &amp; = gradient<br>\end{align}<br>$$</p>
<h5 id="4-_mixed">4. mixed</h5><p>这是 OpenFOAM 中的混合边界条件。</p>
<ul>
<li>构造函数<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line">mixedFvPatchField&lt;<span class="type">Type</span>&gt;::mixedFvPatchField</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> fvPatch&amp; p,</span><br><span class="line">    <span class="keyword">const</span> <span class="type">DimensionedField</span>&lt;<span class="type">Type</span>, volMesh&gt;&amp; iF,</span><br><span class="line">    <span class="keyword">const</span> dictionary&amp; dict</span><br><span class="line">)</span><br><span class="line">:</span><br><span class="line">    fvPatchField&lt;<span class="type">Type</span>&gt;(p, iF, dict),</span><br><span class="line">    refValue_(<span class="string">"refValue"</span>, dict, p.size()),</span><br><span class="line">    refGrad_(<span class="string">"refGradient"</span>, dict, p.size()),</span><br><span class="line">    valueFraction_(<span class="string">"valueFraction"</span>, dict, p.size())</span><br><span class="line">&#123;</span><br><span class="line">    evaluate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>需要读取三个参数。</p>
<ul>
<li>evaluate<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">template<span class="subst">&lt;</span>class <span class="keyword">Type</span><span class="subst">&gt;</span></span><br><span class="line"><span class="literal">void</span> mixedFvPatchField<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::evaluate</span>(const Pstream<span class="tag">::commsTypes</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="subst">!</span>this<span class="subst">-&gt;</span>updated())</span><br><span class="line">    &#123;</span><br><span class="line">        this<span class="subst">-&gt;</span>updateCoeffs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Field<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::operator</span><span class="subst">=</span></span><br><span class="line">    (</span><br><span class="line">        valueFraction_<span class="subst">*</span>refValue_</span><br><span class="line">      <span class="subst">+</span></span><br><span class="line">        (<span class="number">1.0</span> <span class="subst">-</span> valueFraction_)<span class="subst">*</span></span><br><span class="line">        (</span><br><span class="line">            this<span class="subst">-&gt;</span>patchInternalField()</span><br><span class="line">          <span class="subst">+</span> refGrad_/this<span class="subst">-&gt;</span>patch()<span class="built_in">.</span>deltaCoeffs()</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">    fvPatchField<span class="subst">&lt;</span><span class="keyword">Type</span><span class="subst">&gt;</span><span class="tag">::evaluate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>$$<br>x_p = valueFraction \cdot refValue + (1-valueFraction) \cdot (x_C + \frac{refGrad}{delta})<br>$$</p>
<ul>
<li>coefficients<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line">tmp&lt;<span class="type">Field</span>&lt;<span class="type">Type</span>&gt; &gt; mixedFvPatchField&lt;<span class="type">Type</span>&gt;::valueInternalCoeffs</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;scalarField&gt;&amp;</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Type</span>(pTraits&lt;<span class="type">Type</span>&gt;::one)*(<span class="number">1</span>.<span class="number">0</span> - valueFraction_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line">tmp&lt;<span class="type">Field</span>&lt;<span class="type">Type</span>&gt; &gt; mixedFvPatchField&lt;<span class="type">Type</span>&gt;::valueBoundaryCoeffs</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> tmp&lt;scalarField&gt;&amp;</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">         valueFraction_*refValue_</span><br><span class="line">       + (<span class="number">1</span>.<span class="number">0</span> - valueFraction_)*refGrad_/this-&gt;patch().deltaCoeffs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line">tmp&lt;<span class="type">Field</span>&lt;<span class="type">Type</span>&gt; &gt; mixedFvPatchField&lt;<span class="type">Type</span>&gt;::gradientInternalCoeffs() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="type">Type</span>(pTraits&lt;<span class="type">Type</span>&gt;::one)*valueFraction_*this-&gt;patch().deltaCoeffs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line">tmp&lt;<span class="type">Field</span>&lt;<span class="type">Type</span>&gt; &gt; mixedFvPatchField&lt;<span class="type">Type</span>&gt;::gradientBoundaryCoeffs() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        valueFraction_*this-&gt;patch().deltaCoeffs()*refValue_</span><br><span class="line">      + (<span class="number">1</span>.<span class="number">0</span> - valueFraction_)*refGrad_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>$$<br>\begin{align}<br>valueInternalCoeffs &amp; = 1-valueFraction \\<br>valueBoundaryCoeffs &amp; = valueFraction \cdot refValue + (1-valueFraction) \cdot \tfrac{refGrad}{delta} \\<br>gradientInternalCoeffs &amp; = -valueFraction \cdot delta \\<br>gradientBoundaryCoeffs &amp; = valueFraction \cdot refValue \cdot delta + (1-valueFraction) \cdot refGrad<br>\end{align}<br>$$</p>
<p>附注：本篇中所有的下标 $p$ 都表示当前边界（present boundary patch），下标 $C$ 表示当前边界所属的网格的中心。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本篇在上一篇的基础上来解读 OpenFOAM 中的基础边界条件。基础边界条件一般包括三类，一是Dirichlet 边界，二是 Neumann 边界，三是混合 Dirichlet 和 Neumann 的边界。</p>]]>
    
    </summary>
    
      <category term="Boundary conditions" scheme="http://xiaopingqiu.github.io/tags/Boundary-conditions/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenFOAM 中的边界条件（一）]]></title>
    <link href="http://xiaopingqiu.github.io/2016/04/02/Boundary-conditions-in-OpenFOAM1/"/>
    <id>http://xiaopingqiu.github.io/2016/04/02/Boundary-conditions-in-OpenFOAM1/</id>
    <published>2016-04-02T07:29:24.000Z</published>
    <updated>2016-04-03T07:27:24.175Z</updated>
    <content type="html"><![CDATA[<p>本系列解读 OpenFOAM 中边界条件的实现。主要关心一些几个问题：</p>
<ol>
<li>OpenFOAM 中边界条件是怎样与有限体积离散部分交互的？</li>
<li>怎么从代码看懂一个边界条件具体是怎么计算边界上的值的？</li>
<li>怎么定制一个边界条件？</li>
</ol>
<p>本篇先阐述第一个问题。</p>
<a id="more"></a>
<p>从有限体积离散的角度来看，离散过程中，可能要用到的边界信息包括两类：一是某个场在边界上的值，另一是某个场在边界上的梯度。前者在对流项的离散中需要用到，举例说<br>$$<br>\int_v \nabla \cdot (\rho \mathbf{U} \phi) dV = \sum_f m_f \phi_f<br>$$<br>当组成体积元的面中有边界面时，需要用到这些边界面上的值 $\phi_f$。<br>而在扩散项的离散过程中<br>$$<br>\int_v \nabla \cdot (\Gamma \nabla \phi) dV = \sum_f (\Gamma \nabla \phi)_f \cdot \mathbf{S}_f<br>$$<br>这时，如果组成体积元的某个面是边界面，就需要该边界面上 $\phi$ 的梯度值 $\nabla \phi_f$ 了。</p>
<p>边界上的某个场值，或者梯度值，其计算方法可以用如下通式表示<br>$$<br>\begin{align}<br>\phi_f &amp; = A_1 \phi_C + B_1 \\<br>\nabla \phi_f &amp; = A_2 \phi_C + B_2<br>\end{align}<br>$$<br>这里，$ \phi_C$ 表示 $\phi$ 在邻近边界的网格中心的值，$A_1$ ，$B_1$，$A_2$，$B_2$ 是系数。</p>
<p>OpenFOAM 中的边界条件类中，有四个函数分别对应上面四个系数：<code>valueInternalCoeffs</code> 对应 $A_1$，<code>valueBoundaryCoeffs</code> 对应 $B_1$，<code>gradientInternalCoeffs</code> 对应 $A_2$，<code>gradientBoundaryCoeffs</code> 对应 $B_2$。<br>所以，看懂 OpenFOAM 中的边界条件，很关键的一步就是看懂这四个函数的定义。</p>
<p>此外，还有一个函数，<code>updateCoeffs</code>， 也很重要。这个函数负责对边界条件进行显式地更新。浏览一下 OpenFOAM 边界条件的代码，会发现很多边界条件都是在 <code>updateCoeffs</code> 这个函数中进行边界值的计算的。</p>
<p>另外，还有些边界条件，似乎是在 <code>evaluate</code> 函数中进行边界值的指定的。</p>
<p>至于边界条件是在什么地方调用的，cfd-online 上有<a href="http://www.cfd-online.com/Forums/openfoam-programming-development/129271-how-boundary-conditions-called-openfoam-solvers.html" target="_blank" rel="external">一个帖子</a>，Hrvoje Jasak 对这个问题的回答是：<br>“<br>Easy:<br>- on correctBoundaryConditions() for a field<br>- on updateCoeffs() at matrix creation<br>correctBoundaryConditions is also called after the linear solver call automatically.<br>”<br>其他网友还提供了一些有价值的信息，比如，在 <code>correctBoundaryConditions</code> 函数中，<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">Type</span>, <span class="keyword">template</span>&lt;class&gt; class <span class="type">PatchField</span>, class <span class="type">GeoMesh</span>&gt;</span><br><span class="line"><span class="type">void</span> <span class="type">Foam</span>::<span class="type">GeometricField</span>&lt;<span class="type">Type</span>, <span class="type">PatchField</span>, <span class="type">GeoMesh</span>&gt;::</span><br><span class="line">correctBoundaryConditions()</span><br><span class="line">&#123;</span><br><span class="line">    this-&gt;setUpToDate();</span><br><span class="line">    storeOldTimes();</span><br><span class="line">    boundaryField_.evaluate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用了 <code>evaluate</code> 函数。<br>为什么有些边界条件用 <code>updateCoeffs()</code>，而有些则用 <code>evaluate()</code> 呢？目前的理解是这样的： <code>updateCoeffs()</code> 主要用来显式地计算并更新变量在边界上的值，当边界上的值是通过某个依赖于外部参数的公式来计算，并且值会随着迭代的进行而不断改变时，则需要用 <code>updateCoeffs()</code>。有些边界条件，比如最基本的 <code>zeroGradient()</code>，不需要外部的参数，只需要每一次将临近网格的值赋给边界就可以了，这时就可以用 <code>evaluate()</code>。</p>
<p>关于边界条件调用的具体过程，需要在看了 <code>fvMatrix</code> 类以后才能更深入地理解，博主目前只能给出一个粗浅的理解。</p>
<p><strong>参考资料</strong>：<br>The Finite Volume Method in Computational Fluid Dynamics: An Advanced Introduction with OpenFOAM® and Matlab®</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本系列解读 OpenFOAM 中边界条件的实现。主要关心一些几个问题：</p>
<ol>
<li>OpenFOAM 中边界条件是怎样与有限体积离散部分交互的？</li>
<li>怎么从代码看懂一个边界条件具体是怎么计算边界上的值的？</li>
<li>怎么定制一个边界条件？</li>
</ol>
<p>本篇先阐述第一个问题。</p>]]>
    
    </summary>
    
      <category term="Boundary conditions" scheme="http://xiaopingqiu.github.io/tags/Boundary-conditions/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[fvOptions 之 semiImplicitSource]]></title>
    <link href="http://xiaopingqiu.github.io/2016/03/20/fvOptions2/"/>
    <id>http://xiaopingqiu.github.io/2016/03/20/fvOptions2/</id>
    <published>2016-03-20T07:24:41.000Z</published>
    <updated>2016-03-20T11:58:34.325Z</updated>
    <content type="html"><![CDATA[<p>上篇浅析了 fvOptions 框架的结构，这篇来看一个具体的源项类： <code>semiImplicitSource</code> 。</p>
<a id="more"></a>
<p>先来看看这个源项代码中的关键部分。</p>
<ul>
<li>SemiImplicitSource.C<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "SemiImplicitSource.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "fvMesh.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "fvMatrices.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "DimensionedField.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "fvmSup.H"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Type&gt;</span><br><span class="line"><span class="keyword">const</span> Foam::wordList Foam::fv::SemiImplicitSource&lt;Type&gt;::volumeModeTypeNames_</span><br><span class="line">(</span><br><span class="line">    IStringStream(<span class="string">"(absolute specific)"</span>)()  <span class="comment">// 初始化 volumeModeTypeNames_，这里有两种模式， `absolute` 和 `specific` ，具体含义下面会解释。 </span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Type&gt;</span><br><span class="line"><span class="keyword">typename</span> Foam::fv::SemiImplicitSource&lt;Type&gt;::volumeModeType</span><br><span class="line">Foam::fv::SemiImplicitSource&lt;Type&gt;::wordToVolumeModeType <span class="comment">// 将字符串转换成 volumeModeType</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> word&amp; vmtName</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    forAll(volumeModeTypeNames_, i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (vmtName == volumeModeTypeNames_[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> volumeModeType(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FatalErrorIn</span><br><span class="line">    (</span><br><span class="line">        <span class="string">"SemiImplicitSource&lt;Type&gt;::volumeModeType"</span></span><br><span class="line">        <span class="string">"SemiImplicitSource&lt;Type&gt;::wordToVolumeModeType(const word&amp;)"</span></span><br><span class="line">    )   &lt;&lt; <span class="string">"Unknown volumeMode type "</span> &lt;&lt; vmtName</span><br><span class="line">        &lt;&lt; <span class="string">". Valid volumeMode types are:"</span> &lt;&lt; nl &lt;&lt; volumeModeTypeNames_</span><br><span class="line">        &lt;&lt; <span class="built_in">exit</span>(FatalError);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> volumeModeType(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Type&gt;</span><br><span class="line">Foam::word Foam::fv::SemiImplicitSource&lt;Type&gt;::volumeModeTypeToWord</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> volumeModeType&amp; vmtType</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (vmtType &gt; volumeModeTypeNames_.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"UNKNOWN"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> volumeModeTypeNames_[vmtType];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Type&gt;</span><br><span class="line"><span class="keyword">void</span> Foam::fv::SemiImplicitSource&lt;Type&gt;::setFieldData(<span class="keyword">const</span> dictionary&amp; dict)</span><br><span class="line">&#123;</span><br><span class="line">    fieldNames_.setSize(dict.toc().size());</span><br><span class="line">    injectionRate_.setSize(fieldNames_.size());</span><br><span class="line"></span><br><span class="line">    applied_.setSize(fieldNames_.size(), <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    label i = <span class="number">0</span>;</span><br><span class="line">    forAllConstIter(dictionary, dict, iter)</span><br><span class="line">    &#123;</span><br><span class="line">        fieldNames_[i] = iter().keyword();</span><br><span class="line">        dict.lookup(iter().keyword()) &gt;&gt; injectionRate_[i];</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set volume normalisation</span></span><br><span class="line">    <span class="keyword">if</span> (volumeMode_ == vmAbsolute)</span><br><span class="line">    &#123;</span><br><span class="line">        VDash_ = V_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Type&gt;</span><br><span class="line">Foam::fv::SemiImplicitSource&lt;Type&gt;::SemiImplicitSource</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> word&amp; name,</span><br><span class="line">    <span class="keyword">const</span> word&amp; modelType,</span><br><span class="line">    <span class="keyword">const</span> dictionary&amp; dict,</span><br><span class="line">    <span class="keyword">const</span> fvMesh&amp; mesh</span><br><span class="line">)</span><br><span class="line">:</span><br><span class="line">    option(name, modelType, dict, mesh),</span><br><span class="line">    volumeMode_(vmAbsolute), volumeMode 初始值为 vmAbsolute，也就是字典里的 <span class="function">absolute</span><br><span class="line">    <span class="title">VDash_</span><span class="params">(1.0)</span>, <span class="comment">// VDash 初始值为 1.0</span></span><br><span class="line">    <span class="title">injectionRate_</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    read(dict);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Type&gt;</span><br><span class="line"><span class="keyword">void</span> Foam::fv::SemiImplicitSource&lt;Type&gt;::addSup <span class="comment">// 这个是最关键的函数，求解器里的 fvOptions(T)，最终就是转换为调用这个函数。</span></span><br><span class="line">(</span><br><span class="line">    fvMatrix&lt;Type&gt;&amp; eqn,</span><br><span class="line">    <span class="keyword">const</span> label fieldI</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (debug)</span><br><span class="line">    &#123;</span><br><span class="line">        Info&lt;&lt; <span class="string">"SemiImplicitSource&lt;"</span> &lt;&lt; pTraits&lt;Type&gt;::typeName</span><br><span class="line">            &lt;&lt; <span class="string">"&gt;::addSup for source "</span> &lt;&lt; name_ &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// psi 表示方程中的未知量，比如，eqn(fvm::ddt(T))，则psi其实就相当于T，其量纲也与T的量纲一致。</span></span><br><span class="line">    <span class="keyword">const</span> GeometricField&lt;Type, fvPatchField, volMesh&gt;&amp; psi = eqn.psi();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个场 Su，其量纲为方程eqn的量纲除以体积的量纲。注意，经测试，假设eqn为（fvm::ddt(T)），则eqn的量纲为k.m^3/s。</span></span><br><span class="line">    DimensionedField&lt;Type, volMesh&gt; Su</span><br><span class="line">    (</span><br><span class="line">        IOobject</span><br><span class="line">        (</span><br><span class="line">            name_ + fieldNames_[fieldI] + <span class="string">"Su"</span>,</span><br><span class="line">            mesh_.time().timeName(),</span><br><span class="line">            mesh_,</span><br><span class="line">            IOobject::NO_READ,</span><br><span class="line">            IOobject::NO_WRITE</span><br><span class="line">        ),</span><br><span class="line">        mesh_,</span><br><span class="line">        dimensioned&lt;Type&gt;</span><br><span class="line">        (</span><br><span class="line">            <span class="string">"zero"</span>,</span><br><span class="line">            eqn.dimensions()/dimVolume,</span><br><span class="line">            pTraits&lt;Type&gt;::zero</span><br><span class="line">        ),</span><br><span class="line">        <span class="keyword">false</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这一句的意思是，将属于cells_这个集合的网格的Su赋值为fvoptions里所设置的第一个参数的值除以体积VDash。这里的VDash,如果模式为absolute，则值为cells_这个集合的网格体积之和，如果模式为specific，则其值为1. </span></span><br><span class="line">    <span class="comment">// UUIndirectList&lt;Type&gt;(Su, cells_)这一句是利用Su和cells为参数，构建一个UUIndirectList类的临时对象，并调用这个类的重载的“=”操作符对Su进行重新赋值。</span></span><br><span class="line">    </span><br><span class="line">    UIndirectList&lt;Type&gt;(Su, cells_) = injectionRate_[fieldI].first()/VDash_;</span><br><span class="line"></span><br><span class="line">    DimensionedField&lt;scalar, volMesh&gt; Sp</span><br><span class="line">    (</span><br><span class="line">        IOobject</span><br><span class="line">        (</span><br><span class="line">            name_ + fieldNames_[fieldI] + <span class="string">"Sp"</span>,</span><br><span class="line">            mesh_.time().timeName(),</span><br><span class="line">            mesh_,</span><br><span class="line">            IOobject::NO_READ,</span><br><span class="line">            IOobject::NO_WRITE</span><br><span class="line">        ),</span><br><span class="line">        mesh_,</span><br><span class="line">        dimensioned&lt;scalar&gt;</span><br><span class="line">        (</span><br><span class="line">            <span class="string">"zero"</span>,</span><br><span class="line">            Su.dimensions()/psi.dimensions(),</span><br><span class="line">            <span class="number">0.0</span></span><br><span class="line">        ),</span><br><span class="line">        <span class="keyword">false</span></span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    UIndirectList&lt;scalar&gt;(Sp, cells_) = injectionRate_[fieldI].second()/VDash_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fvMatrix&lt;Type&gt; 类中对“+=”操作符进行了重载，所以，eqn与Su的相加，相当于eqn+Su*mesh.V()，要不然eqn与Su的量纲不一致。</span></span><br><span class="line">    eqn += Su + fvm::SuSp(Sp, psi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>下面用一个例子来说明 <code>semiImplicitSource</code> 的作用。前提到 <code>scalarTransportFoam</code> 是使用 fvOptions 的一个最简单的求解器，这里对该求解器进一步简化，只保留瞬变项，对流和扩散项都删去，来验证 <code>semiImplicitSource</code> 的作用。<br>修改之后的 <code>TEqn</code> 为<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tmp TEqn</span><br><span class="line"><span class="list">(</span><br><span class="line">    <span class="keyword">fvm</span>:<span class="keyword">:ddt</span><span class="list">(<span class="keyword">T</span>)</span>  == fvOptions<span class="list">(<span class="keyword">T</span>)</span></span><br><span class="line">)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>然后，<code>fvOptions</code> 词典文件的设置如下：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">firstHeatSource</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title">type</span> scalarSemiImplicitSource;</span><br><span class="line">    <span class="title">active</span>          <span class="built_in">true</span>;</span><br><span class="line">    <span class="title">selectionMode</span>   cellZone;</span><br><span class="line">    <span class="title">cellZone</span>        boxSourceZone;</span><br><span class="line">    <span class="title">scalarSemiImplicitSourceCoeffs</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title">volumeMode</span> absolute;</span><br><span class="line">        <span class="title">injectionRateSuSp</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title">T</span> (<span class="number">0</span>.<span class="number">05</span> <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述设置，相当于求解如下方程<br>$$<br>\frac{\partial T}{\partial t}=S_u + S_p\cdot T<br>$$<br>其中 $S_u=0.05, S_p = 0$ 。<br>反观上面对代码的分析，可知对于当前的设置，$S_u$ 的量纲为 <code>TEqn</code> 的量纲除以体积量纲，$S_p$ 的量为 $S_u$ 量纲除以 <code>T</code> 的量纲，这与上面给出的方程是一致的。<br>但是，要注意， <code>SemiImplicitSource</code> 有两个模式：absolute 和 specific，区别在于代码里的 <code>VDash</code> 的取值不一样。对于 absolute 模式，<code>VDash = V</code>，即所选的 cellZone 的体积；对于 specific 模式，<code>VDash = 1.0</code>。而代码里的 <code>Su</code> 和 <code>Sp</code> 的值都是用在<code>fvOptions</code> 词典文件设置的值除以 <code>VDash</code> 。<br>所以，确切地说，求解的应该是如下积分方程：<br>$$<br>\int_V \frac{\partial T}{\partial t} dV - \int_V \nabla \cdot (D_T \nabla T) dV = \int_V (\frac{S_u}{V_{Dash}}+\frac{S_p}{V_{Dash}}T )dV<br>$$<br>其中 $V_{Dash}$ 是选定的 cellZone 的体积。<br>为了验证以上的推演，作了如下两个测试：</p>
<ul>
<li>源项参数设置为<code>T (0.01 0)</code>，源项作用的区域为一个体积为$V_{Dash}=0.001$ 的 cellZone，为了消除热量传递，设置 $D_T = 0$，初始整个区域的 T 均为0， 模拟时间为1 s。<br>按照上述的推演，如果是 <code>absolute</code> 模式，最终 1 s 时选定的 cellZone 的温度将是 $T=t\cdot \frac{S_u}{V_{Dash}}=1s\cdot\frac{0.01 k/s}{0.001}=10k$；如果是 <code>specific</code> 模式，那么最终1 s 时选定的 cellZone 的温度将是 $T=1s\cdot\frac{0.01 k/s}{1.0}=0.01k$。以上结果在测试算例中得到了证实。</li>
<li>源项参数设置为<code>T (1.0 2.0)</code>，同样设置 $D_T = 0$。这种情况下，可以先求微分方程<br>$$\frac{\partial T}{\partial t}=x+yT$$<br>的解，经简单计算得到<br>$$T=\frac{e^{yt}\cdot e^{yc}-x}{y}$$<br>$c$ 为任意常数。<br>若 $T|\,_{t=0}=0k$，则可以得到定解为<br>$$T=\frac{e^{yt}\cdot x-x}{y}$$<br>若使用<code>specific</code> 模式，则根据当前的设置得到1 s时的解为<br>$$T=\frac{e^{2\cdot 1}\cdot 1 -1}{2}=3.194528 k$$<br>算例测试结果为：</li>
<li>时间离散格式:Euler，$\Delta T=0.001s$，$T=3.20193k$；</li>
<li>时间离散格式：Euler，$\Delta T=0.0001s$，$T=3.19527k$，可见减小时间步后结果与解析解吻合度提高了很多。</li>
<li>时间离散格式：CrankNicolson，$\Delta T=0.001s$，$T=3.19454k$。可见用高阶的时间离散格式，在同样时间步下能得到误差更小的结果。</li>
</ul>
<p>同样，如果用<code>absolute</code> 模式，且源项设置为 <code>T (0.001 0.002)</code> ，应该能得到一样的结果，实际上算例测试正是如此。由此可以认为推演得到了证实。</p>
<p>至此，<code>SemiImplicitSource</code> 这个源项的核心部分就算是明了了。可是，现在测试的是非常简单的情形，如果在求解多个方程，且有多个方程里都加入了源项的情况下，该怎么给不同的方程设置不一样的源项呢？要解决这个问题，需要先理解清楚 <code>fvOptions</code> 的调用过程。</p>
<h5 id="fvOptions_源项的调用过程">fvOptions 源项的调用过程</h5><p>下面至下而上地来看看 fvOptions 的调用过程。</p>
<p><code>TEqn</code>里，有一个调用 <code>fvOptions</code> 的语句： <code>fvOptions(T)</code>，上一篇讲过， <code>fvOptions</code> 的定义为<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="rule"><span class="attribute">fv</span>:<span class="value">:IOoptionList <span class="function">fvOptions</span>(mesh)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>这就很明显了：建立一个 <code>IOoptionList</code> 类的对象 <code>fvOptions</code>。由此可知，求解器里的 <code>fvOptions</code> 是一个对象的名字，因此 <code>fvOptions(T)</code> 这种用法也只可能是对象调用类中重载的 <code>()</code> 运算符了。从前面的分析，可知 <code>IOoptionList</code> 本身很简单，仅是作为一个接口来用的，所以 <code>()</code> 与算符的重载要去其父类中去找。 <code>IOoptionList</code> 的作用是，从 “constant”（优先）或者 “system” 目录读取 <code>fvOptions</code> 文件，并作为 <code>IOobject</code> 类的对象传递给父类 <code>optionList</code> （从构造函数的成员初始化列表 <code>optionList(mesh, *this)</code> ）</p>
<hr>
<p>接下来，就该进入 <code>optionList</code> 类了。这个类里，所有可能出现在求解器代码里函数都有了，包括 <code>correct</code> ， <code>constrain</code> ， <code>makeRelative</code> ， <code>makeAbsolute</code> ， <code>relative</code> 以及 <code>()</code> 运算符的重载。但是，注意这里并没有具体的代码实现，而是通过类似<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">forAll(*<span class="keyword">this</span>, i)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">this</span>-&gt;<span class="keyword">operator</span>[](i).makeAbsolute(phi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用其他地方的函数。 <code>optionList</code> 的一个重要使命是，统计 <code>fvOptions</code> 文件里定义了多少个源项，并将每一个源项都作为一个储存起来，然后再根据词典的内容创建特定的源项。核心在于 <code>reset</code> 函数。为了说明这一点，先从构造函数看起<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reset<span class="list">(<span class="keyword">optionsDict</span><span class="list">(<span class="keyword">dict</span>)</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>可见构造函数里调用了 <code>reset</code> 函数，并且用 <code>optionsDict</code> 函数的返回值作为 <code>reset</code> 函数的参数。前文讲到， <code>IOoptionList</code> 类将 <code>fvOptions</code> 文件的内容以 <code>IOobject</code> 的形式传递给父类 <code>optionList</code>，所以，这里的参数 <code>dict</code> 可以理解为就是<code>fvOptions</code> 文件的内容。<code>optionsDict</code> 函数的代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Foam::dictionary&amp; Foam::fv::optionList::optionsDict</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> dictionary&amp; dict</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (dict.found(<span class="string">"options"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> dict.subDict(<span class="string">"options"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> dict;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可见，这个函数去 <code>fvOptions</code> 文件里查找关键字 <code>options</code>，如果找到，就将 <code>options</code> 关键字对应的 subDict 内容返回，否则直接返回 <code>fvOptions</code> 文件的内容。举例说，形如<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">firstHeatSource</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title">type</span> scalarSemiImplicitSource;</span><br><span class="line">    <span class="title">active</span>          <span class="built_in">true</span>;</span><br><span class="line">    <span class="title">selectionMode</span>   cellZone;</span><br><span class="line">    <span class="title">cellZone</span>        boxSourceZone;</span><br><span class="line">    <span class="title">scalarSemiImplicitSourceCoeffs</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title">volumeMode</span> absolute;</span><br><span class="line">        <span class="title">injectionRateSuSp</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title">T</span> (<span class="number">0</span>.<span class="number">001</span> <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>的，直接返回，因为这就构成了一个 dictionary；而形如<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">options</span><br><span class="line">&#123;</span><br><span class="line">    massSource1</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">type</span>            scalarSemiImplicitSource;</span><br><span class="line">        <span class="label">$injector1</span>;</span><br><span class="line"></span><br><span class="line">        scalarSemiImplicitSourceCoeffs</span><br><span class="line">        &#123;</span><br><span class="line">            volumeMode      absolute;</span><br><span class="line">            injectionRateSuSp</span><br><span class="line">            &#123;</span><br><span class="line">                thermo:rho.air     (1e-3 0); <span class="comment">// kg/s</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    momentumSource1</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">type</span>            vectorSemiImplicitSource;</span><br><span class="line">        <span class="label">$injector1</span>;</span><br><span class="line"></span><br><span class="line">        vectorSemiImplicitSourceCoeffs</span><br><span class="line">        &#123;</span><br><span class="line">            volumeMode      absolute;</span><br><span class="line">            injectionRateSuSp</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">U</span>.air           ((0 -1e-2 0) 0); <span class="comment">// kg*m/s^2</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    energySource1</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">type</span>            scalarSemiImplicitSource;</span><br><span class="line">        <span class="label">$injector1</span>;</span><br><span class="line"></span><br><span class="line">        scalarSemiImplicitSourceCoeffs</span><br><span class="line">        &#123;</span><br><span class="line">            volumeMode      absolute;</span><br><span class="line">            injectionRateSuSp</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">e</span>.air      (500 0); <span class="comment">// kg*m^2/s^3</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>的，则将options下的每一个 subDict 作为 dictionary 返回。注意，这里的 <code>dictionary</code> 类可以理解为一个容器，每一个<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xxxxx</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">...</span><span class="attribute">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>都可以作为容器里的一个成员，容器的容量（size）等于总的成员数，每一个成员，其实就对应一个源项。<br>于是，我们知道 <code>optionsDict</code> 返回了一个有一定数目成员的容器。再来看 <code>reset</code> 函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Foam::fv::optionList::reset(<span class="keyword">const</span> dictionary&amp; dict)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Count number of active fvOptions</span></span><br><span class="line">    label count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历 dict 容器，确定其成员的数目，即确定定义了几个源项。</span></span><br><span class="line">    forAllConstIter(dictionary, dict, iter) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (iter().isDict())</span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>-&gt;setSize(count); <span class="comment">// setSize 是 PtrList 类的成员，顾名思义，PtrList 是一个 List。PtrList&lt;option&gt; 类的成员是 options 类的对象。</span></span><br><span class="line">    </span><br><span class="line">    label i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 遍历 dict 容器，根据每一个 dict 容器的成员来建立对应的 option 类的对象，这通过调用 option 类的 New 函数来实现。这是使用 RuntimeSelection 机制的类的很常规的做法。</span></span><br><span class="line">    forAllConstIter(dictionary, dict, iter)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (iter().isDict())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">const</span> word&amp; name = iter().keyword(); <span class="comment">// keyword 返回的是类似 energySource1 这样的，是这个源项的一个名字</span></span><br><span class="line">            <span class="keyword">const</span> dictionary&amp; sourceDict = iter().dict();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">set</span> <span class="comment">// set 函数，肯定毫无疑问也是从 PtrList 类中继承而来的</span></span><br><span class="line">            (</span><br><span class="line">                i++,</span><br><span class="line">                option::New(name, sourceDict, mesh_) <span class="comment">// 调用 option 类的 New 函数</span></span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，最重要的是， <code>reset</code> 里实现了对父类 <code>PtrList&lt;option&gt;</code> 的初始化。<br>理解了这些，再来看 <code>correct</code> 以及 <code>()</code> 操作符重载中的代码，就好理解了：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本来 *this 应该是 optionList 类的指针，这里先作个隐式转换，转成 PtrList&lt;option&gt; 类的指针。前面reset函数已经对 PtrList&lt;option&gt; 进行了初始化，使其读入了每一个源项。所以，这里的循环就是对每一个源项进行循环，然后调用对应的函数。operator[]肯定也是在PtrList类中定义的，i 指的是 PtrList 类的第 i 个成员，这里 PtrList 的每一个成员都是一个 option 类的对象，所以，makeAbsolute 函数是定义在 option 类中的函数。</span></span><br><span class="line">forAll(*<span class="keyword">this</span>, i)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">this</span>-&gt;<span class="keyword">operator</span>[](i).makeAbsolute(phi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据上面的理解，一个很自然的推论是，定义在 <code>fvOptions</code> 文件中的源项，其作用是叠加的。也就是说，上述的 <code>fvOptions(T)</code>，对定义在 <code>fvOptions</code> 文件中的每一个源项，都会调用一次。经测试，<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="title">firstHeatSource</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title">type</span> scalarSemiImplicitSource;</span><br><span class="line">    <span class="title">active</span>          <span class="built_in">true</span>;</span><br><span class="line">    <span class="title">selectionMode</span>   cellZone;</span><br><span class="line">    <span class="title">cellZone</span>        boxSourceZone;</span><br><span class="line">    <span class="title">scalarSemiImplicitSourceCoeffs</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title">volumeMode</span> absolute;</span><br><span class="line">        <span class="title">injectionRateSuSp</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title">T</span> (<span class="number">0</span>.<span class="number">001</span> <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="title">secondHeatSource</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title">type</span> scalarSemiImplicitSource;</span><br><span class="line">    <span class="title">active</span>          <span class="built_in">true</span>;</span><br><span class="line">    <span class="title">selectionMode</span>   cellZone;</span><br><span class="line">    <span class="title">cellZone</span>        boxSourceZone;</span><br><span class="line">    <span class="title">scalarSemiImplicitSourceCoeffs</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title">volumeMode</span> absolute;</span><br><span class="line">        <span class="title">injectionRateSuSp</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title">T</span> (<span class="number">0</span>.<span class="number">0</span> <span class="number">0</span>.<span class="number">002</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>与<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">secondHeatSource</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title">type</span> scalarSemiImplicitSource;</span><br><span class="line">    <span class="title">active</span>          <span class="built_in">true</span>;</span><br><span class="line">    <span class="title">selectionMode</span>   cellZone;</span><br><span class="line">    <span class="title">cellZone</span>        boxSourceZone;</span><br><span class="line">    <span class="title">scalarSemiImplicitSourceCoeffs</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title">volumeMode</span> absolute;</span><br><span class="line">        <span class="title">injectionRateSuSp</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title">T</span> (<span class="number">0</span>.<span class="number">0001</span> <span class="number">0</span>.<span class="number">002</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>的作用是一样的，这证实了源项的作用确实是叠加的。<br>此外，还要注意一点，那就是 <code>optionList</code> 类中重载的 <code>()</code> 运算符，其实是在调用 option 类中的 <code>addSup</code> 函数，并且其返回值是 fvMatrix 类的对象。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Type&gt;</span><br><span class="line">Foam::tmp&lt;Foam::fvMatrix&lt;Type&gt; &gt; Foam::fv::optionList::<span class="keyword">operator</span>()</span><br><span class="line">(</span><br><span class="line">    GeometricField&lt;Type, fvPatchField, volMesh&gt;&amp; fld,</span><br><span class="line">    <span class="keyword">const</span> word&amp; fieldName</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    checkApplied();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> dimensionSet ds = fld.dimensions()/dimTime*dimVolume;</span><br><span class="line"></span><br><span class="line">    tmp&lt;fvMatrix&lt;Type&gt; &gt; tmtx(<span class="keyword">new</span> fvMatrix&lt;Type&gt;(fld, ds));</span><br><span class="line">    fvMatrix&lt;Type&gt;&amp; mtx = tmtx();</span><br><span class="line"></span><br><span class="line">    forAll(*<span class="keyword">this</span>, i)</span><br><span class="line">    &#123;</span><br><span class="line">        option&amp; source = <span class="keyword">this</span>-&gt;<span class="keyword">operator</span>[](i);</span><br><span class="line"></span><br><span class="line">        label fieldI = source.applyToField(fieldName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fieldI != -<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            source.setApplied(fieldI);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (source.isActive())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (debug)</span><br><span class="line">                &#123;</span><br><span class="line">                    Info&lt;&lt; <span class="string">"Applying source "</span> &lt;&lt; source.name() &lt;&lt; <span class="string">" to field "</span></span><br><span class="line">                        &lt;&lt; fieldName &lt;&lt; endl;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                source.addSup(mtx, fieldI);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmtx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>理解了以上这些，就可以进入 <code>option</code> 类了。<br>option 类是所有具体的源项类的基类，这个类里处理了所有源项都需要处理的部分，比如确定起始时间，选择源项作用的区域，这些都是在构造函数里完成的，主要是通过调用 <code>setSelection</code> 和 <code>setCellSet</code> 两个函数。这里需要注意的是数据成员 <code>cells_</code>， <code>V_</code>  以及 <code>fieldNames_</code>，分别定义源项作用区域的网格id （这里源项的作用区域是以 cell 为基础来指定的，即便是 points 模式，实际上源项作用的区域仍然是 points 所在的 cell。）， 选定区域的体积以及需要开启源项作用的场名（有时候，求解器的多个 Eqn 里有fvOptions，但是实际算例中只想针对特定的场开启源项，这可以通过指定 fieldNames_ 来实现）。</p>
<p>注意 fieldNames 在 <code>option</code> 类中并没有初始化，需要在具体的源项类中指定。此外，<code>makeRelative</code> 等在求解器中实际调用的函数，在 <code>option</code> 类中也并没有进行具体的实现（但不是声明为纯虚函数，仅仅是函数体为空的而已，这里的结果不适合用纯虚函数）</p>
<p>以 <code>SemiImplicitSource</code> 为例，主要去看 <code>addSup</code> 函数，这个函数，关键的一个参数是<code>fieldI</code>，这个参数，指的是fieldName<em>这个List的 <code>applyToField</code> 函数的返回值，用来判断一个field是否要启用源项。fieldName</em>这个List，是在  <code>SemiImplicitSource</code> 类的 <code>setFieldData</code> 函数中赋值的，通过读取 <code>SemiImplicitSourceCoeffs</code> 中的参数来决定。但是这个fieldName_ 的确定方法根据不同的类有不同的做法，要具体分析。<br>到此，<code>fvOpptions</code> 源项的调用途径就打通了，接下来可以继续具体分析特定的源项了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>上篇浅析了 fvOptions 框架的结构，这篇来看一个具体的源项类： <code>semiImplicitSource</code> 。</p>]]>
    
    </summary>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="fvOptions" scheme="http://xiaopingqiu.github.io/tags/fvOptions/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[fvOptions 浅析]]></title>
    <link href="http://xiaopingqiu.github.io/2016/03/20/fvOptions1/"/>
    <id>http://xiaopingqiu.github.io/2016/03/20/fvOptions1/</id>
    <published>2016-03-20T07:24:30.000Z</published>
    <updated>2016-03-20T09:39:58.991Z</updated>
    <content type="html"><![CDATA[<p>本篇简单介绍 OpenFOAM 中的 fvOptions。按照<a href="http://www.openfoam.org/version2.2.0/fvOptions.php" target="_blank" rel="external">官方的介绍</a>，fvOptions 是一个可以在指定区域内添加源项或者其他约束（比如固定温度，或者多孔介质等）的框架。本篇对 fvOptions 框架的源码做一个浅析。</p>
<a id="more"></a>
<p>先来了解一下 fvOptions 框架的结构，以及，在求解器中是怎么调用 fvOptions 的。为了避免问题复杂化，先从一个简单的求解器开始：<code>scalarTransportFoam</code>。OpenFOAM-2.3.1 中的 <code>scalarTransportFoam</code> 中已经引入了 <code>fvOptions</code> ，而更早的 OpenFOAM-2.1.1 中，则没有使用 <code>fvOptions</code> 。对比之下，很容易发现引入 <code>fvOptions</code> 其实就只涉及到两处代码修改：1. 增加了一个头文件 <code>createFvOptions.H</code>；2. 在 T 方程中增加了一项 <code>fvOptions(T)</code> 。 根据 OpenFOAM 的习惯，可以猜测这里增加的 <code>fvOptions(T)</code>，从C++的角度来看，多半是一个基类的对象 <code>fvOptions</code> 在调用类中重载过的 <code>()</code> 操作符。以上便是从这段简单的求解器代码中产生的对 <code>fvOptions</code> 的第一印象，下面来仔细看看 <code>fvOptions</code> 这个框架的结构。</p>
<h5 id="1-_createFvOptions-H">1. createFvOptions.H</h5><p>既然求解器里只增加了这一个头文件，那就先从这个看起。这个文件位于 <code>src/fvOptions/include</code>，内容很简单，就一句话：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="rule"><span class="attribute">fv</span>:<span class="value">:IOoptionList <span class="function">fvOptions</span>(mesh)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>从这里就很清楚地可以看出， <code>scalarTransportFoam</code> 中 T 方程中增加的 <code>fvOptions</code> 是 <code>IOoptionList</code> 类的对象。</p>
<h5 id="2-_IOoptionList_类">2. IOoptionList 类</h5><p>接下来看 <code>IOoptionList</code> 类。IOoptionList 类由两个文件组成： fvOptionList.H 和 fvOptionList.C。这里的目的在于了解 fvOptions 这个框架的结构，所以重点看头文件以及构造函数的定义。</p>
<ul>
<li>fvOptionList.H <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#ifndef IOoptionList_H</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IOoptionList_H</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "fvOptionList.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "IOdictionary.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "autoPtr.H"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Foam</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">namespace</span> fv</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> IOoptionList</span><br><span class="line">:</span><br><span class="line">    <span class="keyword">public</span> IOdictionary,</span><br><span class="line">    <span class="keyword">public</span> optionList</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Private Member Functions</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Create IO object if dictionary is present</span></span><br><span class="line">        <span class="function">IOobject <span class="title">createIOobject</span><span class="params">(<span class="keyword">const</span> fvMesh&amp; mesh)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Disallow default bitwise copy construct</span></span><br><span class="line">        IOoptionList(<span class="keyword">const</span> IOoptionList&amp;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Disallow default bitwise assignment</span></span><br><span class="line">        <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> IOoptionList&amp;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Constructors</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Construct from components with list of field names</span></span><br><span class="line">        IOoptionList(<span class="keyword">const</span> fvMesh&amp; mesh);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Destructor</span></span><br><span class="line">        <span class="keyword">virtual</span> ~IOoptionList()</span><br><span class="line">        &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Member Functions</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Read dictionary</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// End namespace fv</span></span><br><span class="line">&#125; <span class="comment">// End namespace Foam</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>从头文件可以看出， <code>IOoptionList</code> 类继承自 <code>IOdictionary</code> 和 <code>optionList</code> 类。根据对 OpenFOAM 的了解，<code>IOdictionary</code> 类是处理跟 IO 有关的，所以这里这个类很可能是用来处理 fvOptions 相关的字典文件的。真正涉及到具体的 fvOptions 源项的内容，应该是在 <code>optionList</code> 中有相关定义。</p>
<ul>
<li>构造函数<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">Foam</span><span class="pseudo">::fv</span><span class="pseudo">::IOoptionList</span><span class="pseudo">::IOoptionList</span></span><br><span class="line">(</span><br><span class="line">    const fvMesh&amp; mesh</span><br><span class="line">)</span><br><span class="line">:</span><br><span class="line">    <span class="tag">IOdictionary</span>(<span class="function">createIOobject</span>(mesh)), <span class="comment">//构造函数里创建fvOptions字典文件</span></span><br><span class="line">    <span class="tag">optionList</span>(mesh, *this)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>构造函数中调用 <code>createIOobject</code> 函数来对父类 <code>IOdictionary</code> 进行初始化，并将自己(×this) 作为参数传递给了父类 <code>optionList</code> 。</p>
<ul>
<li>createIOobject 函数<br>构造函数中调用了 <code>createIOobject</code> 函数，而且这里的调用显然至关重要，所以需要看一下这个函数<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">Foam::IOobject Foam::fv::IOoptionList::createIOobject</span><br><span class="line">(</span><br><span class="line">    const fvMesh&amp; mesh</span><br><span class="line">) const</span><br><span class="line">&#123;</span><br><span class="line">    IOobject <span class="built_in">io</span></span><br><span class="line">    (</span><br><span class="line">        <span class="string">"fvOptions"</span>,</span><br><span class="line">        mesh.time().constant(),</span><br><span class="line">        mesh,</span><br><span class="line">        IOobject::MUST_READ,</span><br><span class="line">        IOobject::NO_WRITE</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">io</span>.headerOk())</span><br><span class="line">    &#123;</span><br><span class="line">        Info&lt;&lt; <span class="string">"Creating finite volume options from "</span></span><br><span class="line">            &lt;&lt; <span class="built_in">io</span>.instance()/<span class="built_in">io</span>.name() &lt;&lt; nl</span><br><span class="line">            &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">io</span>.readOpt() = IOobject::MUST_READ_IF_MODIFIED;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">io</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        // Check <span class="keyword">if</span> the fvOptions file is <span class="keyword">in</span> system</span><br><span class="line">        <span class="built_in">io</span>.instance() = mesh.time().system();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">io</span>.headerOk())</span><br><span class="line">        &#123;</span><br><span class="line">            Info&lt;&lt; <span class="string">"Creating finite volume options from "</span></span><br><span class="line">                &lt;&lt; <span class="built_in">io</span>.instance()/<span class="built_in">io</span>.name() &lt;&lt; nl</span><br><span class="line">                &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">io</span>.readOpt() = IOobject::MUST_READ_IF_MODIFIED;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">io</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Info&lt;&lt; <span class="string">"No finite volume options present"</span> &lt;&lt; nl &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">io</span>.readOpt() = IOobject::NO_READ;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">io</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这个函数的意图就很明显了：创建了一个 <code>IOobject</code> 对象，并从 <code>system</code> 中读入文件 <code>fvOptions</code> 的内容来初始化该对象。并且，如果 <code>system</code> 目录下不存在 <code>fvOptions</code> 文件，那就尝试在 <code>constant</code> 下寻找。如果仍找不到，那就放弃读取。</p>
<h5 id="3-_optionList_类">3. optionList 类</h5><p>这个类由三个源文件定义： fvOptionList.H ， fvOptionList.C 和 fvOptionListTemplates.C。这里依然是重点关注头文件。</p>
<ul>
<li>fvOptionList.H<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#ifndef optionList_H</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> optionList_H</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "PtrList.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "GeometricField.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "fvPatchField.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "fvOption.H"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Foam</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">namespace</span> fv</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> optionList</span><br><span class="line">:</span><br><span class="line">    <span class="keyword">public</span> PtrList&lt;option&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> dictionary&amp; optionsDict(<span class="keyword">const</span> dictionary&amp; dict) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">readOptions</span><span class="params">(<span class="keyword">const</span> dictionary&amp; dict)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Constructors</span></span><br><span class="line">        optionList(<span class="keyword">const</span> fvMesh&amp; mesh);</span><br><span class="line"></span><br><span class="line">        optionList(<span class="keyword">const</span> fvMesh&amp; mesh, <span class="keyword">const</span> dictionary&amp; dict);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">const</span> dictionary&amp; dict)</span></span>;</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">            <span class="comment">//- Return source for equation</span></span><br><span class="line">            <span class="comment">// 重载的括号操作符，在求解器里，方程的构造过程中调用的就是这些括号操作符。</span></span><br><span class="line">            <span class="keyword">template</span>&lt;<span class="keyword">class</span> Type&gt;</span><br><span class="line">            tmp&lt;fvMatrix&lt;Type&gt; &gt; <span class="keyword">operator</span>()</span><br><span class="line">            (</span><br><span class="line">                <span class="keyword">const</span> volScalarField&amp; rho,</span><br><span class="line">                GeometricField&lt;Type, fvPatchField, volMesh&gt;&amp; fld</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// End namespace fv</span></span><br><span class="line">&#125; <span class="comment">// End namespace Foam</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#ifdef NoRepository</span></span><br><span class="line">    <span class="preprocessor">#<span class="keyword">include</span> "fvOptionListTemplates.C"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这里注意两点，一是 <code>optionList</code> 类继承自 <code>PtrList&lt;option&gt;</code> ，另一个是，这里出现了重载的运算符 <code>()</code> 。继承自 <code>PtrList&lt;option&gt;</code> 意味着很可能 fvOptions 类是支持同时定义多个源项的。</p>
<ul>
<li>构造函数<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="rule"><span class="attribute">Foam</span>:<span class="value">:fv::optionList::<span class="function">optionList</span>(const fvMesh&amp; mesh, const dictionary&amp; dict)</span><br><span class="line">:</span><br><span class="line">    PtrList&lt;option&gt;(),</span><br><span class="line">    <span class="function">mesh_</span>(mesh),</span><br><span class="line">    <span class="function">checkTimeIndex_</span>(mesh_.<span class="function">time</span>().<span class="function">startTimeIndex</span>() + <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">reset</span>(<span class="function">optionsDict</span>(dict))</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>构造函数里，调用了 <code>reSet</code> 和 <code>optionsDict</code> 函数。下面看一下这两个函数的作用：</p>
<ul>
<li>optionsDict 函数<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Foam::dictionary&amp; Foam::fv::optionList::optionsDict</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> dictionary&amp; dict</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (dict.found(<span class="string">"options"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> dict.subDict(<span class="string">"options"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> dict;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这个函数需要一个参数 <code>const dictionary&amp; dict</code>，这个参数，显然是从构造函数的 <code>const dictionary&amp; dict</code> ，再回顾一下上文中，<code>IOoptionList</code> 中将自己本身（*this）传递给父类 <code>optionsDict</code> ，而且， <code>IOoptionList</code> 同时也继承自 <code>IOdictionary</code> 类，并且将从文件 <code>fvOptions</code> 类中读取的内容来对其父类 <code>IOdictionary</code> 类。所以这里不难理解，参数 <code>const dictionary&amp; dict</code> 其实就是文件 <code>fvOptions</code> 的内容。这里需要从文件中 <code>fvOptions</code> 寻找关键字 <code>options</code> ，如果找到，那就返回 <code>options</code> 所指定的 <code>subDict</code> ，否则就直接返回 <code>fvOptions</code> 本身。</p>
<ul>
<li>reset 函数<br>再来看 reset 函数：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Foam::fv::optionList::reset(<span class="keyword">const</span> dictionary&amp; dict)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Count number of active fvOptions</span></span><br><span class="line">    label count = <span class="number">0</span>;</span><br><span class="line">    forAllConstIter(dictionary, dict, iter)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (iter().isDict())</span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;setSize(count);</span><br><span class="line">    label i = <span class="number">0</span>;</span><br><span class="line">    forAllConstIter(dictionary, dict, iter)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (iter().isDict())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">const</span> word&amp; name = iter().keyword();</span><br><span class="line">            <span class="keyword">const</span> dictionary&amp; sourceDict = iter().dict();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">set</span></span><br><span class="line">            (</span><br><span class="line">                i++,</span><br><span class="line">                option::New(name, sourceDict, mesh_)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>注意在构造函数里，这个函数的参数是 <code>optionsDict</code> 类的返回值。这里，函数是在统计 <code>fvOptions</code> 中有效的 <code>options</code> 的个数，并根据每一个有效的 <code>options</code> ，调用 <code>option</code> 类的 <code>New</code> 函数（看到 New 函数，很自然就会想到 Run Time Selection 吧！）来构造对象指针，且将该指针存到 <code>PtrList</code> 类定义的 List 里。 这里更是直接能看出来，在文件 <code>fvOptions</code> 中，是可以同时定义多个源项的。 </p>
<h5 id="4-_option_类">4. option 类</h5><p>再继续看 <code>option</code> 类。<code>option</code> 类由四个源文件定义： <code>fvOption.H</code> ， <code>fvOption.C</code> ， <code>fvOptionI.H</code> 和 <code>fvOptionIO.C</code> 。</p>
<ul>
<li><p>fvOption.H</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#ifndef fvOption_H</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> fvOption_H</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "fvMatricesFwd.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "volFieldsFwd.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "cellSet.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "autoPtr.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "meshToMesh.H"</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "runTimeSelectionTables.H"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Foam</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">class</span> fvMesh；</span><br><span class="line"><span class="keyword">namespace</span> fv</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> option</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Public data</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Enumeration for selection mode types</span></span><br><span class="line">        <span class="keyword">enum</span> selectionModeType</span><br><span class="line">        &#123;</span><br><span class="line">            smPoints,</span><br><span class="line">            smCellSet,</span><br><span class="line">            smCellZone,</span><br><span class="line">            smMapRegion,</span><br><span class="line">            smAll</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p><code>option</code> 类终于不再继承自其他类了。而且，包含的头文件中有 <code>#include &quot;runTimeSelectionTables.H&quot;</code> 可以猜想，这个类肯定是作为接口的基类来使用的。<br>经验证，具体的源项类，如 <code>semiImplicitSource</code>，都是继承自 <code>option</code> 类的。当然，这里会用到 RTS 机制来提供灵活地源项选择。和其他的作为接口使用的基类类似， <code>option</code> 类中定义了所有的具体源项类可能用到的控制选项，比如，区域的选择（Points，cellSet，cellZone，mapRegion，all），开始时间（timeStart），持续时间（duration）激活开关（active）以及各个可能调用到的函数。</p>
</li>
</ul>
<p>至此，fvOptions 框架的结构就大体理清了，总结如下图：</p>
<p><img src="/image/fvOptions/fvOptions.png" alt="fvOptions 框架的结构"></p>
<h5 id="参考">参考</h5><ol>
<li><a href="http://www.sourceflux.de/blog/series/fvoptions/" target="_blank" rel="external">http://www.sourceflux.de/blog/series/fvoptions/</a></li>
<li><a href="http://www.openfoam.org/version2.2.0/fvOptions.php" target="_blank" rel="external">http://www.openfoam.org/version2.2.0/fvOptions.php</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>本篇简单介绍 OpenFOAM 中的 fvOptions。按照<a href="http://www.openfoam.org/version2.2.0/fvOptions.php">官方的介绍</a>，fvOptions 是一个可以在指定区域内添加源项或者其他约束（比如固定温度，或者多孔介质等）的框架。本篇对 fvOptions 框架的源码做一个浅析。</p>]]>
    
    </summary>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="fvOptions" scheme="http://xiaopingqiu.github.io/tags/fvOptions/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[湍流模型中的 RTS 机制分析]]></title>
    <link href="http://xiaopingqiu.github.io/2016/03/12/RTS2/"/>
    <id>http://xiaopingqiu.github.io/2016/03/12/RTS2/</id>
    <published>2016-03-12T06:25:54.000Z</published>
    <updated>2016-03-12T08:21:00.646Z</updated>
    <content type="html"><![CDATA[<p>有了上一篇博文的基础，就可以来填一个<a href="http://xiaopingqiu.github.io/2015/11/25/OpenFOAM-singlePhase-turbulenceModel/" target="_blank" rel="external">坑</a>了，即分析 OpenFOAM 中湍流模型框架中的 RTS 。上一篇博文，使用的程序比较简单，这里通过一个实际使用 RTS 机制的例子来加深对 RTS 的理解。</p>
<a id="more"></a>
<p>经过前面对那段简单代码的分析，可以知道， <code>declareRunTimeSelectionTable</code> 宏函数的主要功能是声明了一个 <code>hashTable</code>，并定义了一个指向这个<code>hashTable</code> 的指针， 然后还声明了几个辅助的类。 <code>defineRunTimeSelectionTable</code> 这个宏函数的主要作用是对 <code>declareRunTimeSelectionTable</code> 中的 <code>hashTable</code> 指针进行了初始化。 <code>addToRunTimeSelectionTable</code> 的主要作用是将当前类的类名以及返回当前类的对象的一个函数分别作为 <code>hashTable</code> 的 key 和 value 插入到 <code>hashTable</code> 中。下面来看这些宏函数在湍流模型框架中是怎么使用的。</p>
<h5 id="1-_turbulenceModel_类">1. turbulenceModel 类</h5><p>类体中，调用 <code>declareRunTimeNewSelectionTable</code> 宏函数<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> declareRunTimeNewSelectionTable</span><br><span class="line"> <span class="list">(</span><br><span class="line">    <span class="keyword">autoPtr</span>,</span><br><span class="line">    turbulenceModel,</span><br><span class="line">    turbulenceModel,</span><br><span class="line">    <span class="list">(</span><br><span class="line">        <span class="keyword">const</span> volVectorField&amp; U,</span><br><span class="line">        const surfaceScalarField&amp; phi,</span><br><span class="line">        transportModel&amp; transport,</span><br><span class="line">        const word&amp; turbulenceModelName</span><br><span class="line">    )</span>,</span><br><span class="line">    <span class="list">(<span class="keyword">U</span>, phi, transport, turbulenceModelName)</span></span><br><span class="line">)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>注意这里用的是 <code>declareRunTimeNewSelectionTable</code>！与 <code>declareRunTimeSelectionTable</code> 区别在于，<code>declareRunTimeNewSelectionTable</code> 这个宏函数定义的插入到 <code>hashTable</code> 中的那个函数，返回值不是派生类的对象，而是派生类中的 <code>New</code> 函数的返回值！<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static autoPtr&lt; baseType &gt; New<span class="comment">##baseType argList                      \</span></span><br><span class="line">&#123;                                                                     <span class="string">\</span></span><br><span class="line">    <span class="keyword">return</span> autoPtr&lt; baseType &gt;(baseType<span class="comment">##Type::New parList.ptr());    \</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span>                                                                <span class="string">\</span></span><br><span class="line">(                                                                 <span class="string">\</span></span><br><span class="line">   !argNames<span class="comment">##ConstructorTablePtr_-&gt;insert                        \</span></span><br><span class="line">    (                                                             <span class="string">\</span></span><br><span class="line">        lookup,                                                   <span class="string">\</span></span><br><span class="line">        New<span class="comment">##baseType                                             \</span></span><br><span class="line">    )                                                             <span class="string">\</span></span><br><span class="line">)                                                                 <span class="string">\</span></span><br></pre></td></tr></table></figure></p>
<p>这说明，这里的派生类 <code>RASModel</code> 将不会作为一个具体的湍流模型来使用。而是用来选择 <code>RAS</code>类型的具体湍流模型的一个跳板。</p>
<p>类体外，调用<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">defineTypeNameAndDebug<span class="list">(<span class="keyword">turbulenceModel</span>, <span class="number">0</span>)</span><span class="comment">;</span></span><br><span class="line">defineRunTimeSelectionTable<span class="list">(<span class="keyword">turbulenceModel</span>, turbulenceModel)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>注意，这里没有调用 <code>addToRunTimeSelectionTable</code> 宏函数， <code>turbulenceModel</code> 类是基类，也不会作为具体的湍流模型来调用，所以不需要将它自己添加到 <code>hashTable</code>。</p>
<h5 id="2-_RASModel">2. RASModel</h5><p><code>turbulenceModel</code> 类下一层的派生类是 <code>RASModel</code> 和 <code>LESModel</code> 。先来看 <code>RASModel</code>，这个类类体里调用了 <code>declareRunTimeSelectionTable</code> 。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">declareRunTimeSelectionTable</span><br><span class="line"><span class="list">(</span><br><span class="line">    <span class="keyword">autoPtr</span>,</span><br><span class="line">    RASModel,</span><br><span class="line">    dictionary,</span><br><span class="line">    <span class="list">(</span><br><span class="line">        <span class="keyword">const</span> volVectorField&amp; U,</span><br><span class="line">        const surfaceScalarField&amp; phi,</span><br><span class="line">        transportModel&amp; transport,</span><br><span class="line">        const word&amp; turbulenceModelName</span><br><span class="line">    )</span>,</span><br><span class="line">    <span class="list">(<span class="keyword">U</span>, phi, transport, turbulenceModelName)</span></span><br><span class="line">)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>类体外调用了<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">defineTypeNameAndDebug<span class="list">(<span class="keyword">RASModel</span>, <span class="number">0</span>)</span><span class="comment">;</span></span><br><span class="line">defineRunTimeSelectionTable<span class="list">(<span class="keyword">RASModel</span>, dictionary)</span><span class="comment">;</span></span><br><span class="line">addToRunTimeSelectionTable<span class="list">(<span class="keyword">turbulenceModel</span>, RASModel, turbulenceModel)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>根据前面的分析，这里 RASModel 又创建了一个新的 <code>hashTable</code>， 用的是 <code>declareRunTimeSelectionTable</code> 和 <code>defineRunTimeSelectionTable(RASModel, dictionary);</code> ，同时，RASModel类 本身又添加到了 <code>turbulenceModel</code> 中建立的 <code>hashTable</code> 里： <code>addToRunTimeSelectionTable(turbulenceModel, RASModel, turbulenceModel);</code> </p>
<p><code>RASModel</code> 类之下的派生类，就是具体的湍流模型了，这里以 <code>kEpsilon</code> 模型为例：</p>
<ul>
<li>kEpsilon<br>具体的湍流模型，如<code>kEpsilon</code> ，只需要添加到上面基类中创建的 <code>hashTable</code> 中，就能保证其能被调用到。<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addToRunTimeSelectionTable<span class="list">(<span class="keyword">RASModel</span>, kEpsilon, dictionary)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这里是添加到了 RASModel 中创建的 <code>hashTable</code> 里。</p>
<h5 id="3-_LESModel">3. LESModel</h5><p><code>LESModel</code> 类也是继承自 <code>turbulenceModel</code> 的，所以其处理方法跟 <code>RASModel</code> 是一样的。不过 <code>LES</code> 类的模型的继承关系略比 <code>RAS</code> 类的复杂一点（参看<a href="http://xiaopingqiu.github.io/2015/11/25/OpenFOAM-singlePhase-turbulenceModel/" target="_blank" rel="external">这篇</a>中的 LES 模型继承关系图）。在这个图中，中间层的 <code>GenEddyVisc</code> 等4个虚线框中的类不是作为具体的湍流模型来调用的，这里有必要看一下这样的中间类在 RTS 机制中是怎么处理的。检查这几个类的代码，可以发现 <code>GenEddyVisc</code> 和 <code>GenSGSStress</code> 中只是在类体外调用了 <code>defineTypeNameWithName(GenEddyVisc, &quot;GenEddyVisc&quot;);</code> ， <code>scaleSimilarity</code> 在类体中调用了 <code>TypeName</code>，类体外调用了 <code>defineTypeNameAndDebug</code> ，<code>DESModel</code> 中没有任何处理。可见这些类只是对 <code>typeName</code> 做了处理，并没有调用 <code>addToRunTimeSelectionTable</code> 。<br>同 <code>RASModel</code> 一样， <code>LESModel</code> 之下派生的具体的湍流模型则需要调用 <code>addToRunTimeSelectionTable</code> 来将自己添加到 <code>LESModel</code> 中定义的 <code>hashTable</code> 中。</p>
<p>由上可知，湍流模型的调用过程大致是这样的：<br>求解器里创建一个 <code>turbulenceModel</code> 类型的 <code>autoPtr</code>，并调用 <code>turbulenceModel::New</code> 来初始化。 <code>turbulenceModel::New</code> 从 turbulenceProperties 文件中读取关键字，假设读取到 simulationType 为 <code>RASModel</code> ，则 <code>turbulenceModel::New</code> 的 <code>cstrIter()</code> 返回的是 <code>RASModel::New</code>，于是 <code>cstrIter()(U, phi, transport, turbulenceModelName)</code> 则是在调用 <code>RASModel::New</code>。然后， <code>RASModel::New</code> 从 RASProperties 文件里读取关键字，并根据读取到的内容，从 <code>RASModel</code> 类中创建的 <code>hashTable</code> 里查找对应的湍流模型，假设从 RASProperties 中读取到的是 <code>kEpsilon</code>， 则返回一个 <code>kEpsilon</code> 模型的对象。最终结果是，求解器里创建的<code>turbulenceModel</code> 类型的 <code>autoPtr</code> 指向了 <code>kEpsilon</code> 类的对象，这就实现了对 <code>kEpsilon</code> 模型的调用。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>有了上一篇博文的基础，就可以来填一个<a href="http://xiaopingqiu.github.io/2015/11/25/OpenFOAM-singlePhase-turbulenceModel/">坑</a>了，即分析 OpenFOAM 中湍流模型框架中的 RTS 。上一篇博文，使用的程序比较简单，这里通过一个实际使用 RTS 机制的例子来加深对 RTS 的理解。</p>]]>
    
    </summary>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="RTS" scheme="http://xiaopingqiu.github.io/tags/RTS/"/>
    
      <category term="turbulence model" scheme="http://xiaopingqiu.github.io/tags/turbulence-model/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenFOAM 中的 Run Time Selection 机制]]></title>
    <link href="http://xiaopingqiu.github.io/2016/03/12/RTS1/"/>
    <id>http://xiaopingqiu.github.io/2016/03/12/RTS1/</id>
    <published>2016-03-12T05:06:48.000Z</published>
    <updated>2016-04-23T06:22:36.077Z</updated>
    <content type="html"><![CDATA[<p><a href="http://www.sourceflux.de/blog/series/rts-2/" target="_blank" rel="external">source flux 博客</a> 曾经出过一个解释 Run Time Selection(RTS) 机制的系列博文，推荐想理解 RTS 的读者去仔细读读。本篇算是我在读完以后做的一个笔记，以及一些总结，供读者参考。</p>
<a id="more"></a>
<p>OpenFOAM 中包含各个 CFD 相关的模块，每个模块，从 C++ 的角度来看，其实都是一个类的框架。基类用作接口，一个派生类则是一个具体的模型。OpenFOAM 中的模块广泛使用 RTS 机制，因此 OpenFOAM 的求解器中，只需要设定模型的调用接口。算例具体使用的是那个模型，则是在运行时才确定的，而且可以在算例运行过程中修改选中的模型。下面通过一个 <a href="http://www.sourceflux.de/blog/run-time-type-selection-openfoam-selecting-types-based-type-name/" target="_blank" rel="external">source flux 博客</a> 提供的代码，来解读 RTS 机制的实现原理。<br>为了方便解读，这里将代码摘录如下，代码所有权归 <a href="http://www.sourceflux.de/blog/run-time-type-selection-openfoam-selecting-types-based-type-name/" target="_blank" rel="external">source flux 博客</a> 所有：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "word.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "messageStream.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "argList.H"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Foam;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "typeInfo.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "runTimeSelectionTables.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "addToRunTimeSelectionTable.H"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Main program:</span></span><br><span class="line"><span class="keyword">class</span> AlgorithmBase</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Declare the static variable typeName of the class AlgorithmBase.</span></span><br><span class="line">        TypeName (<span class="string">"base"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Empty constructor. </span></span><br><span class="line">        AlgorithmBase () &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Word constructor.</span></span><br><span class="line">        AlgorithmBase (<span class="keyword">const</span> word&amp; algorithmName) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Destructor: needs to be declared virtual since </span></span><br><span class="line">        <span class="keyword">virtual</span> ~AlgorithmBase() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Macro for declaring stuff required for RTS </span></span><br><span class="line">        declareRunTimeSelectionTable</span><br><span class="line">        (</span><br><span class="line">            autoPtr, </span><br><span class="line">            AlgorithmBase, </span><br><span class="line">            Word, </span><br><span class="line">            (</span><br><span class="line">                <span class="keyword">const</span> word&amp; algorithmName</span><br><span class="line">            ),</span><br><span class="line">            (algorithmName)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment">// static Factory Method (selector)</span></span><br><span class="line">        <span class="keyword">static</span> autoPtr&lt;AlgorithmBase&gt; New (<span class="keyword">const</span> word&amp; algorithmName)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Find the Factory Method pointer in the RTS Table </span></span><br><span class="line">            <span class="comment">// (HashTable&lt;word, autoPtr&lt;AlgorithmBase&gt;(*)(word))</span></span><br><span class="line">            WordConstructorTable::iterator cstrIter =</span><br><span class="line">                WordConstructorTablePtr_-&gt;find(algorithmName);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If the Factory Method was not found. </span></span><br><span class="line">            <span class="keyword">if</span> (cstrIter == WordConstructorTablePtr_-&gt;end())</span><br><span class="line">            &#123;</span><br><span class="line">                FatalErrorIn</span><br><span class="line">                (</span><br><span class="line">                    <span class="string">"AlgorithmBase::New(const word&amp;)"</span></span><br><span class="line">                )   &lt;&lt; <span class="string">"Unknown AlgorithmBase type "</span></span><br><span class="line">                    &lt;&lt; algorithmName &lt;&lt; nl &lt;&lt; nl</span><br><span class="line">                    &lt;&lt; <span class="string">"Valid AlgorithmBase types are :"</span> &lt;&lt; endl</span><br><span class="line">                    &lt;&lt; WordConstructorTablePtr_-&gt;sortedToc()</span><br><span class="line">                    &lt;&lt; <span class="built_in">exit</span>(FatalError);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Call the "constructor" and return the autoPtr&lt;AlgorithmBase&gt;</span></span><br><span class="line">            <span class="keyword">return</span> cstrIter()(algorithmName);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make the class callable (function object) </span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="comment">// Overridable default implementation</span></span><br><span class="line">            Info &lt;&lt; <span class="string">"AlgorithmBase::operator()()"</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">defineTypeNameAndDebug(AlgorithmBase, <span class="number">0</span>);</span><br><span class="line">defineRunTimeSelectionTable(AlgorithmBase, Word);</span><br><span class="line">addToRunTimeSelectionTable(AlgorithmBase, AlgorithmBase, Word);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> AlgorithmNew</span><br><span class="line">:</span><br><span class="line">    <span class="keyword">public</span> AlgorithmBase</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Declare the static variable typeName of the class AlgorithmNew.</span></span><br><span class="line">        TypeName (<span class="string">"new"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Empty constructor. </span></span><br><span class="line">        AlgorithmNew () &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Word constructor.</span></span><br><span class="line">        AlgorithmNew (<span class="keyword">const</span> word&amp; algorithmName) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make the class callable (function object) </span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span><br><span class="line">        </span>&#123;</span><br><span class="line">            Info &lt;&lt; <span class="string">"AlgorithmNew::operator()()"</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">defineTypeNameAndDebug(AlgorithmNew, <span class="number">0</span>);</span><br><span class="line">addToRunTimeSelectionTable(AlgorithmBase, AlgorithmNew , Word);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> AlgorithmAdditional</span><br><span class="line">:</span><br><span class="line">    <span class="keyword">public</span> AlgorithmNew </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Declare the static variable typeName of the class AlgorithmAdditional.</span></span><br><span class="line">        TypeName (<span class="string">"additional"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Empty constructor. </span></span><br><span class="line">        AlgorithmAdditional () &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Word constructor.</span></span><br><span class="line">        AlgorithmAdditional (<span class="keyword">const</span> word&amp; algorithmName) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make the class callable (function object) </span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="comment">// Call base operator explicitly.</span></span><br><span class="line">            AlgorithmNew::<span class="keyword">operator</span>()();</span><br><span class="line">            <span class="comment">// Perform additional operations.</span></span><br><span class="line">            Info &lt;&lt; <span class="string">"AlgorithmAdditional::operator()()"</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">defineTypeNameAndDebug(AlgorithmAdditional, <span class="number">0</span>);</span><br><span class="line">addToRunTimeSelectionTable(AlgorithmBase, AlgorithmAdditional , Word);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    argList::addOption</span><br><span class="line">    (</span><br><span class="line">        <span class="string">"algorithmName"</span>,</span><br><span class="line">        <span class="string">"name of the run-time selected algorithm"</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="function">argList <span class="title">args</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (args.optionFound(<span class="string">"algorithmName"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Get the name of the algorithm from the arguments passed to the</span></span><br><span class="line">        <span class="comment">// application. </span></span><br><span class="line">        <span class="keyword">const</span> word algorithmName = args.option(<span class="string">"algorithmName"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// RTS call. </span></span><br><span class="line">        autoPtr&lt;AlgorithmBase&gt; algorithmPtr = AlgorithmBase::New(algorithmName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get the reference to the algorithm from the smart pointer.</span></span><br><span class="line">        AlgorithmBase&amp; algorithm = algorithmPtr(); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Call the algorithm.</span></span><br><span class="line">        algorithm(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        FatalErrorIn</span><br><span class="line">        (</span><br><span class="line">            <span class="string">"main()"</span></span><br><span class="line">        )   &lt;&lt; <span class="string">"Please use with the 'algorithmName' option."</span> &lt;&lt; endl</span><br><span class="line">            &lt;&lt; <span class="built_in">exit</span>(FatalError);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Info&lt;&lt; <span class="string">"\nEnd\n"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在解读原理之前，先来看看这段代码。可以发现，RTS 机制的实现跟几个函数的调用有关： <code>declareRunTimeSelectionTable</code>， <code>defineRunTimeSelectionTable</code>， <code>defineTypeNameAndDebug</code>， <code>addToRunTimeSelectionTable</code>。规律可以总结如下：</p>
<ol>
<li>基类类体里调用 <code>TypeName</code> 和 <code>declareRunTimeSelectionTable</code> 两个函数，类体外面调用 <code>defineTypeNameAndDebug</code> ， <code>defineRunTimeSelectionTable</code> 和 <code>addToRunTimeSelectionTable</code> 三个函数；</li>
<li>基类中需要一个静态 <code>New</code> 函数作为 <code>selector</code>。 </li>
<li>派生类类体中需要调用 <code>TypeName</code> 函数，类体外调用 <code>defineRunTimeSelectionTable</code> 和 <code>addToRunTimeSelectionTable</code> 两个宏函数。</li>
</ol>
<p>以上函数，经过搜索，发现都是定义在 <code>runTimeSelectionTables.H</code> 和 <code>addToRunTimeSelectionTable.H</code> 两个头文件中，而且，这些函数都是宏函数。</p>
<p>看来，理解 RTS 的第一步就需要仔细看看这几个宏函数。</p>
<p>先来看基类中的宏函数 <code>declareRunTimeSelectionTable</code> ，根据 <a href="">source flux 的博文</a>，这个宏函数针对前面的那段代码的展开结果为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> autoPtr&lt; AlgorithmBase &gt; (*WordConstructorPtr)( <span class="keyword">const</span> word&amp; algorithmName );</span><br><span class="line">   </span><br><span class="line"><span class="keyword">typedef</span> HashTable&lt; WordConstructorPtr, word, <span class="built_in">string</span>::hash &gt; WordConstructorTable;</span><br><span class="line"><span class="keyword">static</span> WordConstructorTable* WordConstructorTablePtr_;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">constructWordConstructorTables</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">destroyWordConstructorTables</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> AlgorithmBaseType &gt;</span><br><span class="line"><span class="keyword">class</span> addWordConstructorToTable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> autoPtr&lt; AlgorithmBase &gt; New ( <span class="keyword">const</span> word&amp; algorithmName )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> autoPtr&lt; AlgorithmBase &gt;(<span class="keyword">new</span> AlgorithmBaseType (algorithmName));</span><br><span class="line">    &#125;</span><br><span class="line">    addWordConstructorToTable ( <span class="keyword">const</span> word&amp; lookup = AlgorithmBaseType::typeName )</span><br><span class="line">    &#123;</span><br><span class="line">        constructWordConstructorTables();</span><br><span class="line">        <span class="keyword">if</span> (!WordConstructorTablePtr_-&gt;insert(lookup, New))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cerr</span>&lt;&lt; <span class="string">"Duplicate entry "</span></span><br><span class="line">                &lt;&lt; lookup &lt;&lt; <span class="string">" in runtime selection table "</span></span><br><span class="line">                &lt;&lt; <span class="string">"AlgorithmBase"</span> &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">            error::safePrintStack(<span class="built_in">std</span>::<span class="built_in">cerr</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~addWordConstructorToTable()</span><br><span class="line">    &#123;</span><br><span class="line">        destroyWordConstructorTables();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> AlgorithmBaseType &gt;</span><br><span class="line"><span class="keyword">class</span> addRemovableWordConstructorToTable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> word&amp; lookup_;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> autoPtr&lt; AlgorithmBase &gt; New ( <span class="keyword">const</span> word&amp; algorithmName )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> autoPtr&lt; AlgorithmBase &gt;(<span class="keyword">new</span> AlgorithmBaseType (algorithmName));</span><br><span class="line">    &#125;</span><br><span class="line">    addRemovableWordConstructorToTable ( <span class="keyword">const</span> word&amp; lookup = AlgorithmBaseType::typeName )</span><br><span class="line">    : lookup_(lookup)</span><br><span class="line">    &#123;</span><br><span class="line">        constructWordConstructorTables();</span><br><span class="line">        WordConstructorTablePtr_-&gt;<span class="built_in">set</span>(lookup, New);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    ~addRemovableWordConstructorToTable()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (WordConstructorTablePtr_)</span><br><span class="line">        &#123;</span><br><span class="line">            WordConstructorTablePtr_-&gt;erase(lookup_);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意，由于 <code>declareRunTimeSelectionTable</code> 是在基类类体里调用的，所以，以上内容都是在类体里的。这相当于在类体了定义了两个 <code>typedef</code>，一个静态数据成员，两个静态函数，还有两个类。<br>先来看这两个 <code>typedef</code> 。第一个，定义的是一个函数指针，这样定义的结果是， <code>WordConstructorPtr</code> 代表一个指向参数为 <code>const word&amp;</code>，返回类型为 <code>autoPtr&lt; AlgorithmBase &gt;</code> 的函数指针。第二个好理解，将一个 key 和 value 分别为 <code>word</code> 和 <code>WordConstructorPtr</code> 的 <code>hashTable</code> 定义了一个别名 <code>WordConstructorTable</code> 。<br>静态数据成员 <code>WordConstructorTablePtr_</code> 是一个 <code>WordConstructorTable</code> 类型的指针。<br>两个静态成员函数，这里只是声明了，并且注意到在下面定义的两个类中用到了这两个函数。</p>
<p>继续看 <code>defineRunTimeSelectionTable(AlgorithmBase, Word)</code>。这个宏展开的结果为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">AlgorithmBase::WordConstructorTable* AlgorithmBase::WordConstructorTablePtr_ = __null;</span><br><span class="line">    <span class="keyword">void</span> AlgorithmBase::constructWordConstructorTables() &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">bool</span> constructed = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!constructed) &#123;</span><br><span class="line">            constructed = <span class="keyword">true</span>;</span><br><span class="line">            AlgorithmBase::WordConstructorTablePtr_ = <span class="keyword">new</span> AlgorithmBase::WordConstructorTable;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> AlgorithmBase::destroyWordConstructorTables() &#123;</span><br><span class="line">        <span class="keyword">if</span> (AlgorithmBase::WordConstructorTablePtr_) &#123;</span><br><span class="line">            <span class="keyword">delete</span> AlgorithmBase::WordConstructorTablePtr_;</span><br><span class="line">            AlgorithmBase::WordConstructorTablePtr_ = __null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></p>
<p>这个宏函数的主要功能，是对 <code>declareRunTimeSelectionTable</code> 中定义的静态数据成员和两个静态函数进行了定义。首先对静态数据成员 <code>WordConstructorTablePtr_</code> 初始化为 <code>__null</code>，然后 <code>constructWordConstructorTables</code> 函数将 <code>WordConstructorTablePtr_</code> 指向一个动态分配的 <code>WordConstructorTable</code> 。 <code>destroyWordConstructorTables</code> 则是对指针 <code>WordConstructorTablePtr_</code> 进行销毁。</p>
<p>接着， <code>addToRunTimeSelectionTable(AlgorithmBase, AlgorithmBase, Word)</code> ，这宏函数展开以后其实就一句话：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="rule"><span class="attribute">AlgorithmBase</span>:<span class="value">:addWordConstructorToTable&lt; AlgorithmBase &gt; addAlgorithmBaseWordConstructorToAlgorithmBaseTable_</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>这个语句，定义了一个 <code>addWordConstructorToTable</code> 的对象，仅此而已。但是，注意在创建一个类的对象的时候，是要调用该类的构造函数的。回头看 <code>addWordConstructorToTable</code> 类的构造函数，有意思的地方出现了。这个类的构造函数中，首先调用了 <code>constructWordConstructorTables</code> 函数，即对指针 <code>WordConstructorTablePtr_</code> 进行了初始化。然后，对 <code>WordConstructorTablePtr_</code> 进行 <code>insert</code> 操作，即，往其指向的 <code>hashTable</code> 插入 <code>key-value</code> 对。这里的 key 是创建对象 <code>addAlgorithmBaseWordConstructorToAlgorithmBaseTable_</code> 时代入的模板参数对应的 类的 <code>typeName</code>（这一句很长很绕，需要好好理解，因为很重要！），value 则是  <code>New</code> 函数。这个 <code>New</code> 函数，指的是定义在 <code>addWordConstructorToTable</code> 中的 <code>New</code> 函数。这个 <code>New</code> 函数非常重要，再写一遍：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> autoPtr&lt; AlgorithmBase &gt; <span class="keyword">New</span> ( <span class="keyword">const</span> word&amp; algorithmName )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> autoPtr&lt; AlgorithmBase &gt;(<span class="keyword">new</span> AlgorithmBaseType (algorithmName));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个<code>New</code> 函数，返回的是一个 <code>AlgorithmBaseType</code>（这里是 AlgorithmBase ） 类型的临时对象的指针！对应这里的情形，现在可以知道这个 <code>insert</code> 操作将创建一个 “类的typeName — 返回类的临时对象的引用的函数” 映射对，并增加到 <code>WordConstructorTablePtr_</code> 中（看来 <code>ddToRunTimeSelectionTable</code> 中创建一个 <code>addWordConstructorToTable</code> 类的对象，居然目的是为了调用其构造函数。）。如果 <code>insert</code> 操作失败（原因是想要插入的 key 与 <code>hashTable</code> 已有的重复了，所以每一个类都需要不同的 typeName！），就会报条目重复的错。</p>
<p>好了，看完了基类相关的，在往下看派生类。前文已讲，派生类只需要在类体里调用 <code>TypeName</code>，然后在类体外调用 <code>addToRunTimeSelectionTable</code> 。对于派生类 <code>AlgorithmNew</code>，我们来看其具体的调用语句是<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addToRunTimeSelectionTable<span class="list">(<span class="keyword">AlgorithmBase</span>, AlgorithmNew , Word)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>展开的结果应该是<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="rule"><span class="attribute">AlgorithmBase</span>:<span class="value">:addWordConstructorToTable&lt; AlgorithmNew &gt; addAlgorithmNewWordConstructorToAlgorithmBaseTable_</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>注意，这里又创建了一个 <code>addWordConstructorToTable</code> 类的对象，只是这里代入的模板参数是 <code>AlgorithmNew</code> 。于是，调用类的构造函数时代入的模板参数也就变了，所以这时 <code>New</code> 函数返回的将是 <code>AlgorithmNew</code> 类的临时对象的指针。并且， AlgorithmNew 这个名字与其对应的 <code>New</code> 函数组成的映射对，也被 <code>insert</code> 到 <code>WordConstructorTablePtr_</code> 里面。</p>
<p>而 <code>AlgorithmAdditional</code> 这个类，虽然是继承自 <code>AlgorithmNew</code> ，但是也是间接继承 <code>AlgorithmBase</code> 。并且，在 <code>AlgorithmAdditional</code> 类的类体之后调用的宏函数 <code>addToRunTimeSelectionTable(AlgorithmBase, AlgorithmAdditional , Word)</code>  ，依然是将构建的映射对添加到了同一个 <code>hashTable</code> 里。</p>
<p>最后，再来看一下 <code>selector</code>，即基类中定义的 <code>New</code> 函数。这个函数的返回值类型为 <code>autoPtr&lt;AlgorithmBase&gt;</code> ，参数为跟类的 <code>typeName</code> 一样，都是 <code>word&amp;</code>。这个函数里面，首先定义了一个 <code>hashTable</code> 的迭代器 <code>cstrIter</code> ，利用迭代器来遍历搜索，看 <code>WordConstructorTable</code> 里面是否能找到参数 <code>algorithmName</code> 相符的 key 值，如果找不到，那就报错退出，并输出当前的 <code>WordConstructorTable</code> 中可选的项的名称（即 WordConstructorTablePtr_-&gt;sortedToc()）；如果找到了，那就返回这个 key 对应的 value。而 <code>WordConstructorTable</code> 的 value 是一个函数指针，所以 <code>cstrIter()</code> 返回的是 <code>algorithmName</code> 对应的那个 <code>New</code> 函数（不要跟基类 <code>AlgorithmBase</code> 中作为 selector 的 <code>New</code> 函数搞混了！）。进一步看， <code>cstrIter()(algorithmName)</code> 则表示的是函数调用了，传给函数的参数正是 <code>algorithmName</code>！<br><strong>所以， <code>cstrIter()(algorithmName)</code> 返回的是 <code>autoPtr&lt;AlgorithmBase&gt;</code> ，其指向的是 <code>typeName = algorithmName</code> 的类的对象！</strong><br>这样就实现了 <code>New</code> 函数作为 selector 的功能！</p>
<p>所以，RTS 机制的本质可以总结如下：</p>
<ol>
<li>基类里定义一个 <code>hashTable</code>，其 key 为类的 <code>typeName</code> ，value 为一个函数指针，这个函数指针指向的函数的返回值是基类类型的 <code>autoPtr</code> ，并且这个 <code>autoPtr</code> 指向类的一个临时对象（用 C++ 的 <code>new</code> 关键字创建 ）。</li>
<li>每创建一个派生类，就需要创建一个这样的函数（函数名一样，但是代入的模板参数不一样，相当于一个新的函数），且该函数中会创建一个派生类的临时对象。函数的返回值则是指向当前派生类的临时对象的基类 <code>autoPtr</code>。此外，派生类的 <code>typeName</code> 和该函数组成的映射对，会增加到基类中定义的 <code>hashTable</code> 中。</li>
<li>类及其派生类编译成库，在编译过程中，会得到一个 <code>hashTable</code> ，其中包含了所有的派生类。</li>
<li>在需要调用这些类的地方，只需要定义基类的 <code>autoPtr</code>，并用基类中定义的 <code>New</code> 函数来初始化，即 <code>autoPtr&lt;AlgorithmBase&gt; algorithmPtr = AlgorithmBase::New(algorithmName);</code>。这样， <code>New</code> 函数就能根据调用的时候所提供的参数，来从 <code>hashTable</code> 中选择对应的派生类。</li>
</ol>
<p>经过以上四步，就实现了 RTS 机制。</p>
<p>参考：<a href="http://www.sourceflux.de/blog/series/rts-2/" target="_blank" rel="external">source flux 的系列博文</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://www.sourceflux.de/blog/series/rts-2/">source flux 博客</a> 曾经出过一个解释 Run Time Selection(RTS) 机制的系列博文，推荐想理解 RTS 的读者去仔细读读。本篇算是我在读完以后做的一个笔记，以及一些总结，供读者参考。</p>]]>
    
    </summary>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="RTS" scheme="http://xiaopingqiu.github.io/tags/RTS/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[为什么要将声明和定义分离]]></title>
    <link href="http://xiaopingqiu.github.io/2016/03/06/separationOfDeclarationAndDefiniton/"/>
    <id>http://xiaopingqiu.github.io/2016/03/06/separationOfDeclarationAndDefiniton/</id>
    <published>2016-03-06T12:59:44.000Z</published>
    <updated>2016-03-14T02:59:46.281Z</updated>
    <content type="html"><![CDATA[<p>OpenFOAM 中的类基本都遵循类的声明和定义分开在不同文件的规则。具体来说，一般是类的声明放在 “xxx.H”，类的成员函数的具体定义 “xxx.C”，如果有内联函数(inline)，则还有 “xxxI.H”，并且，”xxx.H” 文件的最后会有 <code>#include   &quot;xxxI.H&quot;</code>。这么做不仅是一种代码规范，真正的目的应该是为了防止重复定义的问题。本篇博文用一个简单的例子来说明这个问题。</p>
<a id="more"></a>
<p>为了防止混淆，先说明一下概念：</p>
<ul>
<li>函数声明：即只声明函数的返回类型，函数名以及参数列表，没有函数体，不具体定义函数的功能，比如 </li>
</ul>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>函数定义：包含函数体,具体定义函数的功能。比如</li>
</ul>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a&lt;b)</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面用一个简单的例子来说明。</p>
<h4 id="测试一：非内联函数声明和定义必须分开的原因是防止重复定义问题">测试一：非内联函数声明和定义必须分开的原因是防止重复定义问题</h4><h5 id="正常测试：">正常测试：</h5><p>以下的测试代码共包括5个源文件，<code>inlinetest.H</code> ， <code>inlinetest.cpp</code> ， <code>inlinederived.H</code> ， <code>inlinederived.cpp</code> ， <code>main.cpp</code> ，分别定义如下：</p>
<ul>
<li><p>inlinetest.H</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#ifndef _INLINETEST_H</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> _INLINETEST_H</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Itest <span class="comment">//基类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">	Itest(<span class="keyword">int</span> a, <span class="keyword">int</span> b); <span class="comment">// 构造函数</span></span><br><span class="line">	<span class="keyword">int</span> a_, b_; <span class="comment">//数据成员</span></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">a</span><span class="params">()</span></span>; <span class="comment">// 内联成员函数</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">b</span><span class="params">()</span></span>; <span class="comment">//非内联成员函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> Itest::a() <span class="comment">//内联函数的定义</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a="</span> &lt;&lt; a_ &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> a_;</span><br><span class="line">&#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>inlinetest.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "inlinetest.H"</span></span><br><span class="line"></span><br><span class="line">Itest::Itest(<span class="keyword">int</span> a, <span class="keyword">int</span> b):a_(a),b_(b)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Itest::b()<span class="comment">//非内联函数的定义</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"b="</span> &lt;&lt; b_ &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> b_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>inlinederived.H</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#ifndef _INLINEDERIVED_H</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> _INLINEDERIVED_H</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "inlinetest.H"</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">class</span> Iderive: <span class="keyword">public</span> Itest <span class="comment">//派生类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> c_;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">c</span><span class="params">()</span></span>;<span class="comment">//非内联成员函数</span></span><br><span class="line">	Iderive(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>inlinederived.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "inlinederived.H"</span></span><br><span class="line"></span><br><span class="line">Iderive::Iderive(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c):Itest(a,b),c_(c)</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="keyword">int</span> Iderive::c()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"c="</span> &lt;&lt; c_ &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> c_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>main.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "inlinetest.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "inlinederived.H"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="function">Itest <span class="title">obj1</span><span class="params">(2,3)</span></span>; <span class="comment">//基类对象</span></span><br><span class="line">    <span class="function">Iderive <span class="title">obj2</span><span class="params">(1,2,3)</span></span>; <span class="comment">// 派生类对象</span></span><br><span class="line"></span><br><span class="line">    obj1.a();</span><br><span class="line">    obj1.b();</span><br><span class="line">    </span><br><span class="line">    obj2.a();</span><br><span class="line">    obj2.b();</span><br><span class="line">    obj2.c();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>以上五个源文件是可以成功编译链接成可执行文件的，运行结果与预期一致：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="setting">a=<span class="value"><span class="number">2</span></span></span></span><br><span class="line"><span class="setting">b=<span class="value"><span class="number">3</span></span></span></span><br><span class="line"><span class="setting">a=<span class="value"><span class="number">1</span></span></span></span><br><span class="line"><span class="setting">b=<span class="value"><span class="number">2</span></span></span></span><br><span class="line"><span class="setting">c=<span class="value"><span class="number">3</span></span></span></span><br></pre></td></tr></table></figure></p>
<h5 id="异常测试：">异常测试：</h5><p>下面来修改，如果将基类代码改一下，将非内联函数 <code>b</code> 的定义也放到头文件里，即：</p>
<ul>
<li><p>inlinetest.H</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#ifndef _INLINETEST_H</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> _INLINETEST_H</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Itest <span class="comment">//基类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">	Itest(<span class="keyword">int</span> a, <span class="keyword">int</span> b); <span class="comment">// 构造函数</span></span><br><span class="line">	<span class="keyword">int</span> a_, b_; <span class="comment">//数据成员</span></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">a</span><span class="params">()</span></span>; <span class="comment">// 内联成员函数</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">b</span><span class="params">()</span></span>; <span class="comment">//非内联成员函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> Itest::a() <span class="comment">//内联函数的定义</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a="</span> &lt;&lt; a_ &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> a_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Itest::b()<span class="comment">//非内联函数的定义</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"b="</span> &lt;&lt; b_ &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> b_;</span><br><span class="line">&#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>inlinetest.cpp</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include <span class="string">"inlinetest.H"</span></span><br><span class="line"></span><br><span class="line">Itest::Itest(<span class="keyword">int</span> a, <span class="keyword">int</span> b):a_(a),b_(b)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//int Itest::b()//非内联函数的定义</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; "b=" &lt;&lt; b_ &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//    return b_;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>结果是无法通过编译：<br><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">g++ -c inlinetest.cpp</span><br><span class="line">g++ -c inlinederived.cpp</span><br><span class="line">g++ -o main main.o inlinetest.o inlinederived.o</span><br><span class="line">inlinetest.o:inlinetest.cpp:(.<span class="keyword">text</span>+<span class="number">0x0</span>): multiple definition <span class="keyword">of</span> `Itest::b()<span class="comment">'</span></span><br><span class="line">main.o:main.cpp:(.<span class="keyword">text</span>+<span class="number">0x0</span>): first defined here</span><br><span class="line">inlinederived.o:inlinederived.cpp:(.<span class="keyword">text</span>+<span class="number">0x0</span>): multiple definition <span class="keyword">of</span> `Itest::b()<span class="comment">'</span></span><br><span class="line">main.o:main.cpp:(.<span class="keyword">text</span>+<span class="number">0x0</span>): first defined here</span><br><span class="line">c:/mingw/bin/../<span class="keyword">lib</span>/gcc/mingw32/<span class="number">4.8</span>.1/../../../../mingw32/bin/ld.exe: main.o: bad reloc address <span class="number">0x0</span> <span class="keyword">in</span> section `.ctors<span class="comment">'</span></span><br><span class="line">collect2.exe: <span class="keyword">error</span>: ld returned <span class="number">1</span> <span class="keyword">exit</span> status</span><br><span class="line">make: *** [main] <span class="keyword">Error</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>可见，编译过程没有出错，但是链接时出错了，报错说 <code>Itest::b()</code> 函数（即基类中的非内联成员函数）被重复定义。原因在于，<code>main.cpp</code> 里有 <code>#include &quot;inlinetest.H&quot;</code> ，这句包含了对<code>Itest::b()</code> 函数的定义；此外，<code>main.cpp</code> 里还有 <code>#include &quot;inlinederived.H&quot;</code>，而由于 <code>inlinederived.H</code> 里，也包含了<code>#include &quot;inlinetest.H&quot;</code>。所以，相当于<code>main.cpp</code> 中也对 <code>Itest::b()</code> 函数的定义了两次，于是连接过程就报错了。</p>
<p>在上面可以正常编译的情况里，即将<code>Itest::b()</code> 函数放在 <code>inlinetest.cpp</code> 里，就不会有这个问题，因为这时头文件里只有函数的声明，而函数的声明是可以重复的。</p>
<p>有人可能会问，这里的 <code>main.cpp</code> 里完全可以去掉 <code>#include &quot;inlinetest.H&quot;</code>，这样也可以解决重复定义问题。对这里的简单例子，是没问题，但是，如果是像 OpenFOAM 这样大的项目，源文件之间的关系非常复杂，那就只能通过将声明和定义分离来解决这个问题了。</p>
<p>注意：这里的内联成员函数 <code>a</code> ，声明和定义都在头文件 <code>inlinetest.H</code> 里，但是却不会报重复定义的错误。</p>
<h4 id="测试二：内联函数的声明和定义需要在同一个文件里，否则无法通过编译。">测试二：内联函数的声明和定义需要在同一个文件里，否则无法通过编译。</h4><p>将上面提到的派生类代码修改一下，将内联成员函数的定义放到 <code>inlinetest.cpp</code> 里，即</p>
<ul>
<li><p>inlinetest.H</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#ifndef _INLINETEST_H</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> _INLINETEST_H</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Itest <span class="comment">//基类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">	Itest(<span class="keyword">int</span> a, <span class="keyword">int</span> b); <span class="comment">// 构造函数</span></span><br><span class="line">	<span class="keyword">int</span> a_, b_; <span class="comment">//数据成员</span></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">a</span><span class="params">()</span></span>; <span class="comment">// 内联成员函数</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">b</span><span class="params">()</span></span>; <span class="comment">//非内联成员函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//inline int Itest::a() //内联函数的定义</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; "a=" &lt;&lt; a_ &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//return a_;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>inlinetest.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "inlinetest.H"</span></span><br><span class="line"></span><br><span class="line">Itest::Itest(<span class="keyword">int</span> a, <span class="keyword">int</span> b):a_(a),b_(b)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> Itest::a() <span class="comment">//内联函数的定义</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a="</span> &lt;&lt; a_ &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> a_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Itest::b()<span class="comment">//非内联函数的定义</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"b="</span> &lt;&lt; b_ &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> b_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这时无法通过编译，编译器报错如下：<br><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">g++ -c main.cpp</span><br><span class="line"><span class="keyword">In</span> file included <span class="keyword">from</span> main.cpp:<span class="number">2</span>:<span class="number">0</span>:</span><br><span class="line">inlinetest.H:<span class="number">13</span>:<span class="number">13</span>: warning: inline <span class="keyword">function</span> <span class="comment">'int Itest::a()' used but never defined [enabled by default]</span></span><br><span class="line">  inline int a();</span><br><span class="line">             ^</span><br><span class="line">g++ -c inlinetest.cpp</span><br><span class="line">g++ -c inlinederived.cpp</span><br><span class="line">g++ -o main main.o inlinetest.o inlinederived.o</span><br><span class="line">main.o:main.cpp:(.<span class="keyword">text</span>+<span class="number">0x5c</span>): undefined reference <span class="keyword">to</span> `Itest::a()<span class="comment">'</span></span><br><span class="line">main.o:main.cpp:(.<span class="keyword">text</span>+<span class="number">0x70</span>): undefined reference <span class="keyword">to</span> `Itest::a()<span class="comment">'</span></span><br><span class="line">c:/mingw/bin/../<span class="keyword">lib</span>/gcc/mingw32/<span class="number">4.8</span>.1/../../../../mingw32/bin/ld.exe: main.o: bad reloc address <span class="number">0x0</span> <span class="keyword">in</span> section `.ctors<span class="comment">'</span></span><br><span class="line">collect2.exe: <span class="keyword">error</span>: ld returned <span class="number">1</span> <span class="keyword">exit</span> status</span><br><span class="line">make: *** [main] <span class="keyword">Error</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>首先是编译过程有一个警告说 <code>inlinetest.H</code> 里的函数 <code>int Itest::a()</code> 没有定义，然后链接的时候报了 <code>undefined reference to &#39;Itest::a()&#39;</code>  的错误，说明如果内联函数的声明和定义分属不同源文件，编译器是无法找到函数的定义的。</p>
<h4 id="测试三_：内联函数的定义放到一个单独的源文件，并在头文件里_include_这个源文件">测试三 ：内联函数的定义放到一个单独的源文件，并在头文件里 include 这个源文件</h4><p>这个测试我做的比较简单，即将 <code>inlinetest.H</code> 拆开，内联函数 <code>a</code> 的定义放在单独的一个 <code>inlinetestI.H</code> 里：</p>
<ul>
<li><p>inlinetest.H</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#ifndef _INLINETEST_H</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> _INLINETEST_H</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Itest <span class="comment">//基类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">	Itest(<span class="keyword">int</span> a, <span class="keyword">int</span> b); <span class="comment">// 构造函数</span></span><br><span class="line">	<span class="keyword">int</span> a_, b_; <span class="comment">//数据成员</span></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">a</span><span class="params">()</span></span>; <span class="comment">// 内联成员函数</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">b</span><span class="params">()</span></span>; <span class="comment">//非内联成员函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "inlinetestI.H"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>inlinetestI.H</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> Itest::a() <span class="comment">//内联函数的定义</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a="</span> &lt;&lt; a_ &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> a_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>编译链接成功，运行结果跟正常预期一致。</p>
<p>经过上述简单的测试，可以得到以下结论：</p>
<ol>
<li>使用C++模板编程时，对于非内联成员函数，函数声明和定义要分开，目的在于防止重复定义的问题。</li>
<li>内联函数的声明和定义需要在同一个文件里，否则无法通过编译。</li>
<li>OpenFOAM 里将内联成员函数提取出来放到一个单独的文件里（ <code>*I.H</code> ），应该只是一种使用惯例。不是 C++ 语法的要求，将 <code>*I.H</code> 里的内容拷贝出来放到 <code>*.H</code> 后面，然后删除 <code>#include &quot;*I.H&quot;</code> 效果应该是一样的。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>OpenFOAM 中的类基本都遵循类的声明和定义分开在不同文件的规则。具体来说，一般是类的声明放在 “xxx.H”，类的成员函数的具体定义 “xxx.C”，如果有内联函数(inline)，则还有 “xxxI.H”，并且，”xxx.H” 文件的最后会有 <code>#include   &quot;xxxI.H&quot;</code>。这么做不仅是一种代码规范，真正的目的应该是为了防止重复定义的问题。本篇博文用一个简单的例子来说明这个问题。</p>]]>
    
    </summary>
    
      <category term="C++" scheme="http://xiaopingqiu.github.io/tags/C/"/>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="C++" scheme="http://xiaopingqiu.github.io/categories/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenFOAM 中的单相流湍流模型之SpalartAllmaras]]></title>
    <link href="http://xiaopingqiu.github.io/2016/03/06/OpenFOAM-singlePhase-turbulenceModel2/"/>
    <id>http://xiaopingqiu.github.io/2016/03/06/OpenFOAM-singlePhase-turbulenceModel2/</id>
    <published>2016-03-06T11:13:58.000Z</published>
    <updated>2016-03-06T13:35:35.300Z</updated>
    <content type="html"><![CDATA[<p>本篇简要分析不可压缩的 SpalartAllmaras 模型的代码。主要内容包括模型输运方程的代码说明，以及一些使用方面的细节。</p>
<a id="more"></a>
<h3 id="湍流模型代码实例">湍流模型代码实例</h3><p>这一部分分析几个 OpenFOAM 里自带的湍流模型， 并探讨修改或者添加新湍流模型的方法。</p>
<h4 id="1_SpalartAllmaras_模型">1 SpalartAllmaras 模型</h4><h5 id="1-1-_模型分析">1.1. 模型分析</h5><p>SpalartAllmaras 模型是一方程模型，它只需要求解一个输运方程。OpenFOAM 中的 SpalartAllmaras 模型是在原始论文[1] 的基础上，引入了 Ashford [2] 对这个模型的修正。下面来看这个模型在 OpenFOAM 中的实现，代码位于 <code>src/turbulenceModels/incompressible/RAS/SpalartAllmaras</code><br>首先是头文件， <code>SpalartAllmaras.H</code><br>头文件开始，声明了一个类：SpalartAllmaras<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpalartAllmaras</span></span></span><br><span class="line">:</span><br><span class="line">    <span class="keyword">public</span> RASModel</span><br></pre></td></tr></table></figure></p>
<p>说明这个类是公有继承 <code>RASModel</code> 类的。<br>接下来是一些数据成员以及成员函数的声明，这里无需赘述，直接来看函数的具体定义吧。<br>函数的具体定义，在<code>SpalartAllmaras.C</code> 里（注意到 OpenFOAM 的代码几乎都是这样讲声明和定义分开，这样做的目的，是为了防止重复声明的问题，更详细的说明，见我的<a href="http://xiaopingqiu.github.io/2016/03/06/separationOfDeclarationAndDefiniton/" target="_blank" rel="external">另一篇博文</a>）。注意，湍流模型的定义，最终是为了在求解器中进行调用的，所以，先来回顾一下湍流模型贡献给求解器中动量方程中那一项：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">turbulence-&gt;<span class="function"><span class="title">divDevReff</span><span class="params">(U)</span></span></span><br></pre></td></tr></table></figure></p>
<p>这一项，不同求解器可能会有不同，但大致的形式是这样的。<br>很显然，这个 <code>divDevReff</code> 应该是湍流模型类的成员函数，实际也的确如此， <code>SpalartAllmaras.C</code> 有这个函数的定义：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">tmp</span>&lt;<span class="tag">fvVectorMatrix</span>&gt; <span class="rule"><span class="attribute">SpalartAllmaras</span>:<span class="value">:<span class="function">divDevReff</span>(volVectorField&amp; U) const</span><br><span class="line">&#123;</span><br><span class="line">    const volScalarField <span class="function">nuEff_</span>(<span class="function">nuEff</span>())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="tag">return</span></span><br><span class="line">    (</span><br><span class="line">      <span class="tag">-</span> <span class="rule"><span class="attribute">fvm</span>:<span class="value">:<span class="function">laplacian</span>(nuEff_, U)</span><br><span class="line">      - fvc::<span class="function">div</span>(nuEff_*<span class="function">dev</span>(<span class="function">T</span>(fvc::<span class="function">grad</span>(U))))</span><br><span class="line">    )</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数，写成公式是如下形式<br>$$<br>-\nabla \cdot (\nu_{eff}\nabla U)-\nabla \cdot [\nu_{eff}dev(\nabla ^TU)]<br>$$<br>OpenFOAM 中的 <code>dev</code>运算符定义为 $dev(T)=T-\frac{1}{3}tr(T)I$ ， <code>tr</code> 为张量的迹，即主对角元素之和所以。对于张量 $\nabla ^TU$ ，$tr(\nabla ^TU) =\nabla \cdot U$，因此上式可以写为【注一】<br>$$<br>-\nabla \cdot (\nu_{eff}\nabla U)-\nabla \cdot [\nu_{eff}(\nabla^TU-\frac{1}{3}(\nabla \cdot U))]<br>$$<br>上述 <code>divDevReff</code> 函数中，变量 <code>nuEff_</code> d的值是函数 <code>nuEff()</code> 的返回值，但是，在 <code>SpalartAllmaras.C</code> 中却未见 <code>nuEff()</code> 函数的定义。这里就要记住了，C++ 的类继承的一个特性是派生类会从基类继承其中定义的成员函数。所以看到本类中没定义的函数时，<strong>don’t panic</strong>，往基类找就是了。翻看基类 <code>RASModel</code> 的代码，可以很容易从 <code>RASModel.C</code> 中找出来 <code>nuEff()</code> 的定义：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> tmp&lt;volScalarField&gt; <span class="title">nuEff</span><span class="params">()</span> <span class="keyword">const</span>  </span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tmp&lt;volScalarField&gt;</span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">new</span> volScalarField(<span class="string">"nuEff"</span>, nut() + nu())</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 函数 <code>nut()</code> 的定义可以从 <code>SpalartAllmaras.H</code> 中找到，可是 <code>nu()</code> 呢？虽然从名字可以猜到它返回的是分子粘度（可见变量命名的重要性啊），可是，它的定义在哪里？ <code>RASModel.C</code> 也没有啊…<br>答案是，继续向上找，RASModel 类没有，那就去更上一层的基类，turbulenceModel。果然，在 <code>turbulenceModel.C</code> 中能找到其定义：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inline tmp&lt;volScalarField&gt; nu() <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> transportModel_.<span class="title">nu</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p> <code>transportModel_</code> 又是什么鬼？这个不是本篇博文的内容，该回到正题了，这里应该关注的是湍流粘度 <code>nut_</code> 。<br>湍流模型不可能仅仅是给求解器贡献那一项，湍流粘度应该也随着求解器的运行而更新。是这样的，求解器中的<br><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">turbulence-&gt;correct<span class="literal">()</span>;</span><br></pre></td></tr></table></figure></p>
<p>这句代码负责湍流粘度的更新。这里又涉及到一个湍流类的成员函数： <code>corretc</code>。这个函数是湍流模型类的核心，因为湍流模型输运方程的求解，湍流粘度的更新都在这个函数里面。下面来看 <code>SpalartAllmaras</code> 模型的 <code>correct</code> 函数：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SpalartAllmaras::correct()</span><br><span class="line">&#123;</span><br><span class="line">    RASModel::correct();</span><br><span class="line">    <span class="keyword">if</span> (!turbulence_)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Re-calculate viscosity</span></span><br><span class="line">        nut_ = nuTilda_*fv1(<span class="keyword">this</span>-&gt;chi());</span><br><span class="line">        nut_.correctBoundaryConditions();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mesh_.changing())</span><br><span class="line">    &#123;</span><br><span class="line">        d_.correct();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> volScalarField chi(<span class="keyword">this</span>-&gt;chi());</span><br><span class="line">    <span class="keyword">const</span> volScalarField fv1(<span class="keyword">this</span>-&gt;fv1(chi));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> volScalarField Stilda</span><br><span class="line">    (</span><br><span class="line">        fv3(chi, fv1)*::sqrt(2.0)*mag(skew(fvc::grad(U_)))</span><br><span class="line">      + fv2(chi, fv1)*nuTilda_/sqr(kappa_*d_)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    tmp&lt;fvScalarMatrix&gt; nuTildaEqn</span><br><span class="line">    (</span><br><span class="line">        fvm::ddt(nuTilda_)</span><br><span class="line">      + fvm::div(phi_, nuTilda_)</span><br><span class="line">      - fvm::laplacian(DnuTildaEff(), nuTilda_)</span><br><span class="line">      - Cb2_/sigmaNut_*magSqr(fvc::grad(nuTilda_))</span><br><span class="line">     ==</span><br><span class="line">        Cb1_*Stilda*nuTilda_</span><br><span class="line">      - fvm::Sp(Cw1_*fw(Stilda)*nuTilda_/sqr(d_), nuTilda_)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    nuTildaEqn().relax();</span><br><span class="line">    solve(nuTildaEqn);</span><br><span class="line">    bound(nuTilda_, dimensionedScalar(<span class="string">"0"</span>, nuTilda_.dimensions(), <span class="number">0.0</span>));</span><br><span class="line">    nuTilda_.correctBoundaryConditions();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-calculate viscosity</span></span><br><span class="line">    nut_.internalField() = fv1*nuTilda_.internalField();</span><br><span class="line">    nut_.correctBoundaryConditions();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>先看核心的输运方程， <code>nuTildaEqn</code> ，这个部分的每一行写成公式，分别如下：<br>$$<br>\frac{\partial \tilde{\nu}}{\partial t} \\<br>\nabla \cdot (U \tilde{\nu}) \\<br>-\nabla \cdot [D_{\tilde{\nu}_{eff}} \nabla \tilde{\nu}] \\<br>-\frac{C_{b2}}{\sigma_{\nu_t}} \cdot |\nabla \tilde{\nu}|^2 \\<br>C_{b1}\cdot \tilde{S} \cdot \tilde{\nu} \\<br>-\frac{C_{w1}\cdot f_w\cdot \tilde{\nu}}{d^2} \cdot \tilde{\nu}\\<br>$$</p>
<p>最后两项都包含了需要求解的量 $\tilde{\nu}$， 但是处理方式却不一样，最后一项，其实是将原本的 $\tilde{\nu} ^2$ 项进行了线性化，并用 <code>fvm::Sp</code> 操作符进行隐式处理。而倒数第二项，则是作的显式处理。差别在于，倒数第二项仅仅是用上一步得到的 $\tilde{\nu}$ 代入，然后这一项被加到 $Ax=b$ 中的 $b$ 部分。而隐式处理则会对系数矩阵 $A$ 有贡献。<br>输运方程中涉及到的变量和函数，全部都在 <code>SpalartAllmaras</code> 类中有定义，这里就不再单独分析了，仅将涉及到的公式列出如下<br>$$<br>D_{\tilde{\nu}_{eff}}=\frac{\nu+\tilde{\nu}}{\sigma_{\nu_t}}<br>$$<br>$$<br>f_w=g\cdot \left [ \frac{1+C_{w3}^6}{g^6+C_{w3}^6} \right]^{1/6},\quad  g=r+C_{w2}\cdot(r^6-r) \\<br>r=min\left[ \frac{\tilde{\nu}}{max(\tilde{S}, SMALL)\cdot \kappa^2 d^2},10 \right]<br>$$</p>
<p>$$<br>\tilde{S}=f_{v3}\cdot\sqrt{2\Omega_{ij}:\Omega_{ij}}+\frac{f_{v2}\tilde{\nu}}{\kappa^2 d^2},\quad \Omega_{ij}=\frac{1}{2}(\nabla U -\nabla ^T U)<br>$$</p>
<p>$f_{v2}$ 和 $f_{v3}$ 有点特殊，因为涉及到了 Ashford 对原始模型的修正。根据作者的论文，修正的目的是防止 $\tilde{S}$ 出现负值。<br>如果不引入 Ashford 修正，则 $f_{v3}=1$；引入以后，则<br>$$<br>f_{v3}=\frac{(1+\chi \cdot f_{v1})}{c_{v2}}\cdot \frac{3+\frac{\chi}{c_{v2}} + (\frac{\chi}{c_{v2}})^2 }{(1+\frac{\chi}{c_{v2}})^3}<br>$$<br>对于 $f_{v2}$，如果不引入 Ashford 修正，则<br>$$<br>f_{v2}=\frac{1}{(1+\frac{\chi}{c_{v2}})^3}<br>$$<br>若引入，则<br>$$<br>f_{v2}=1-\frac{\chi}{1+\chi f_{v1}}<br>$$<br>此外，<br>$$<br>f_{v1}=\frac{\chi ^3}{\chi ^3 + c_{v1}^3}, \quad  \chi=\frac{\tilde{\nu}}{\nu}, \quad \nu_t = \tilde{\nu}<br>f_{v1}$$<br>$d$ 是与壁面的距离，有一个专门的类 <code>wallDist</code> 来计算它。<br>其他的没有提到的变量，则都是模型常数了。具体的值都在 <code>SpalartAllmaras</code> 类的构造函数中定义了，这里就不再赘述了。</p>
<h5 id="1-2-_一些细节">1.2. 一些细节</h5><ol>
<li><code>turbulence_</code> 这个变量<br><code>correct</code> 函数中，只有当 <code>turbulence_</code> 为 <code>true</code> 时，下面求解输运方程的部分代码才会执行。这个变量又是从 <code>RASModel</code> 类继承过来的，其初始化的语句为 <code>turbulence_(lookup(&quot;turbulence&quot;))</code> ，这意味着，这个变量的值是从 <code>RASProperties</code> 文件中读取的（详见文末的 <code>RASProperties</code> 示例）。</li>
<li>模型常数，除了使用默认值，还可以自己指定（注：除非很有把握，一般不要随便修改模型常数）。具体方法是，在 <code>RASProperties</code> 文件里，建立一个名为 <code>SpalartAllmarasCoeffs</code> 的 subDict，详见文末的示例。 </li>
<li><code>bound</code> 函数<br>这个函数的定义在头文件 <code>bound.H</code> 里，其功能是限制 $\tilde{\nu}$ 的最小值。不过这种限制其实没有多少物理意义，纯粹是数值技巧。其中用到了 <code>fvc::average</code> 函数（见我的<a href="http://xiaopingqiu.github.io/2015/05/17/OpenFOAMcode1/" target="_blank" rel="external">另一篇博文</a>）。</li>
<li><code>read</code> 成员函数<br>这个成员函数，初看之下似乎跟模型常数的初始化有关，实则不然。模型常数的初始化在类的构造函数部分完成， <code>coeffDict_</code> 这个变量在基类 <code>RASModel</code> 的构造函数中先用 <code>type()+Coeffs</code> (这里是 <code>SpalartAllmarasCoeffs</code> )这个 subDict 初始化了，然后，在 <code>SpalartAllmaras</code> 类的构造函数中，每一个模型常数都是先去 <code>coeffDict_</code> 中查找是否用用户自定义的值，如果没有，则用模型的默认值，并且将这个默认值添加到 <code>coeffDict_</code> 这个字典中。</li>
<li>其他成员函数<br><code>SpalartAllmaras</code> 显然不需要用到湍动能 <code>k</code> 以及湍动能耗散 <code>epsilon</code> ，但是在 <code>SpalartAllmaras.C</code> 中确有这两个函数的定义，而且返回值是0。这是因为，在基类 <code>turbulenceModel</code> 中， <code>k()</code>， <code>epsilon()</code> 函数被声明为纯虚函数，如果不在 <code>SpalartAllmaras</code> 中重新定义这两个函数，则 <code>SpalartAllmaras</code> 也将是包括纯虚函数的抽象类了。在 C++ 中，抽象类是无法建立对象的。<br><code>devReff</code>， <code>R</code> ， <code>divDevRhoReff</code> 这几个成员函数，是湍流模型提供给其他模型调用的函数，比如，在计算表面应力的 <code>forces</code> 类中就需要调用湍流模型的 <code>devReff</code> 函数。</li>
</ol>
<h5 id="附：_RASProperties_文件示例">附： RASProperties 文件示例</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/<span class="emphasis">*--------------------------------*</span>- C++ -<span class="emphasis">*----------------------------------*</span>\</span><br><span class="line">| =========                 |                                                 |</span><br><span class="line">| \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |</span><br><span class="line">|  \\    /   O peration     | Version:  2.3.1                                 |</span><br><span class="line">|   \\  /    A nd           | Web:      www.OpenFOAM.org                      |</span><br><span class="line">|    \\/     M anipulation  |                                                 |</span><br><span class="line">\<span class="emphasis">*---------------------------------------------------------------------------*</span>/</span><br><span class="line">FoamFile</span><br><span class="line">&#123;</span><br><span class="line"><span class="code">    version     2.0;</span></span><br><span class="line"><span class="code">    format      ascii;</span></span><br><span class="line"><span class="code">    class       dictionary;</span></span><br><span class="line"><span class="code">    location    "constant";</span></span><br><span class="line"><span class="code">    object      RASProperties;</span></span><br><span class="line">&#125;</span><br><span class="line">// <span class="bullet">* *</span> <span class="bullet">* *</span> <span class="bullet">* *</span> <span class="bullet">* *</span> <span class="bullet">* *</span> <span class="bullet">* *</span> <span class="bullet">* *</span> <span class="bullet">* *</span> <span class="bullet">* *</span> <span class="bullet">* *</span> <span class="bullet">* *</span> <span class="bullet">* *</span> <span class="bullet">* *</span> <span class="bullet">* *</span> <span class="bullet">* *</span> <span class="bullet">* *</span> <span class="bullet">* *</span> <span class="bullet">* *</span> * //</span><br><span class="line"></span><br><span class="line">RASModel        SpalartAllmaras ;</span><br><span class="line">turbulence      on; //若为 off，则湍流模型的输运方程将不会求解！</span><br><span class="line">printCoeffs     on; // 输出模型常数</span><br><span class="line"></span><br><span class="line">SpalartAllmarasCoeffs // 设置模型常数(仅为示例，具体数值不要较真)</span><br><span class="line">&#123;</span><br><span class="line"><span class="code">    Cw2       0.20;</span></span><br><span class="line"><span class="code">    Cw3       0.10;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="emphasis">***</span> //</span><br></pre></td></tr></table></figure>
<p>【注一】：N-S 方程中，这一项应该是<br>$$<br>-\nabla \cdot (\nu_{eff}\nabla U)-\nabla \cdot [\nu_{eff}(\nabla^TU-\frac{2}{3}(\nabla \cdot U))]<br>$$<br>而且，在可压缩的湍流模型中， <code>divDevReff</code> 函数用的是 <code>dev2</code> 函数，所以其定义的形式就跟 N-S 方程一致了。但不知道为什么不可压缩的湍流模型为什么要用 <code>dev</code> 函数。虽然对于不可压缩的情形，由于 $\nabla \cdot U=0$，用 <code>dev</code> 或者 <code>dev2</code> 应该关系不大，但这种做法仍然很费解。在OpenFOAM-3.0版本中，可压和不可压用的都是 <code>dev2</code> 函数了。</p>
<h5 id="参考：">参考：</h5><p>[1] P. Spalart and S. Allmaras. “A one-equation turbulence model for aerodynamic flows”. Technical Report AIAA-92-0439. American Institute of Aeronautics and Astronautics. 1992.</p>
<p>[2] “An Unstructured Grid Generation and Adaptive Solution Technique         for High Reynolds Number Compressible Flows”, G.A. Ashford, Ph.D. thesis, University of Michigan, 1996.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本篇简要分析不可压缩的 SpalartAllmaras 模型的代码。主要内容包括模型输运方程的代码说明，以及一些使用方面的细节。</p>]]>
    
    </summary>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/tags/OpenFOAM/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[两个简单的随时间变化的边界条件]]></title>
    <link href="http://xiaopingqiu.github.io/2015/12/12/timeVaryingBC1/"/>
    <id>http://xiaopingqiu.github.io/2015/12/12/timeVaryingBC1/</id>
    <published>2015-12-12T06:38:50.000Z</published>
    <updated>2015-12-12T08:41:24.219Z</updated>
    <content type="html"><![CDATA[<p>这一篇里介绍OpenFOAM自带的两个简单的随时间变化的边界条件： <code>uniformFixedValue</code> 和 <code>flowRateInletVelocity</code> 。</p>
<a id="more"></a>
<h4 id="1-_uniformFixedValue">1. uniformFixedValue</h4><p>这个边界属于第一类边界，即直接指定边界上某个量的值。跟 <code>fixedValue</code> 的不同之处在于，这个边界条件允许边界上的值随着时间变化。一般的用法如下：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type            uniformFixedValue<span class="comment">;</span></span><br><span class="line">uniformValue     table</span><br><span class="line"><span class="list">(</span><br><span class="line">    <span class="list">(<span class="number">0.000</span> <span class="list">(<span class="number">0</span> <span class="number">0</span> <span class="number">0.002</span>)</span>)</span></span><br><span class="line">    <span class="list">(<span class="number">0.010</span> <span class="list">(<span class="number">0</span> <span class="number">0</span> <span class="number">0.002</span>)</span>)</span></span><br><span class="line">    <span class="list">(<span class="number">0.011</span> <span class="list">(<span class="number">0.011</span> <span class="number">0</span> <span class="number">0.011</span>)</span>)</span></span><br><span class="line">    <span class="list">(<span class="number">0.100</span> <span class="list">(<span class="number">0.10</span> <span class="number">0</span> <span class="number">0.100</span>)</span>)</span></span><br><span class="line">)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>上面这一段指定的是速度 U （也可以是其他矢量，或者标量）的边界条件，通过一个 table 来定义边界随时间的变化行为，具体解释如下（假定时间步长等于0.001 s）：</p>
<ul>
<li>当 0.00 &lt;= t &lt;= 0.01 s 时，速度值为 (0   0   0.002);</li>
<li>当 t = 0.011 s 时，速度变为 (0.011   0   0.011);</li>
<li>0.011 &lt;= t &lt;= 0.100 之间，速度的每个分量均为线性变化的;</li>
<li>当 t &gt; 0.100 s 以后，速度保持  (0.10   0   0.100) 不变。</li>
</ul>
<p>除了通过 table 来定义随时间分段线性变化边界条件，还可以定义多项式变化的边界，比如：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type uniformFixedValue<span class="comment">;</span></span><br><span class="line">uniformValue polynomial</span><br><span class="line"><span class="list">(</span><br><span class="line">    <span class="list">(<span class="list">(<span class="number">1</span> <span class="number">0</span> <span class="number">0</span>)</span> <span class="list">(<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>)</span>)</span></span><br><span class="line">    <span class="list">(<span class="list">(<span class="number">2</span> <span class="number">2</span> <span class="number">0</span>)</span> <span class="list">(<span class="number">1</span> <span class="number">2</span> <span class="number">0</span>)</span>)</span></span><br><span class="line">    <span class="list">(<span class="list">(<span class="number">3</span> <span class="number">5</span> <span class="number">0</span>)</span> <span class="list">(<span class="number">2</span> <span class="number">4</span> <span class="number">0</span>)</span>)</span></span><br><span class="line">)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>以上这段定义的是这样一个边界：x 分量，$U_x=1+2\cdot t+3\cdot t^2$；y 分量，$U_y=2\cdot t^2+5\cdot t^4$; z 分量，$U_z=0$。<br>需要注意的是， <code>polynomial</code> 这种方式，目前测试在 2.3.x 以及以下版本不能使用，在最新的 3.0.x 版中可以使用。</p>
<p>此外，还有其他的一些定义方式，列举如下（参考<a href="http://www.geocities.jp/penguinitis2002/study/OpenFOAM/time_varying_bc.html" target="_blank" rel="external">这个网站</a>）：</p>
<h5 id="固定值">固定值</h5><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">inlet</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="title">type</span> uniformFixedValue; </span><br><span class="line">    <span class="title">uniformValue</span> constant (<span class="number">10</span> <span class="number">0</span> <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式与 <code>fixedValue</code> 效果是一样的。</p>
<h5 id="tableFile">tableFile</h5><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">inlet</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="title">type</span> uniformFixedValue; </span><br><span class="line">    <span class="title">uniformValue</span> tableFile; </span><br><span class="line">    <span class="title">tableFileCoeffs</span></span><br><span class="line">    &#123; </span><br><span class="line">	<span class="title">fileName</span> <span class="string">"<span class="variable">$FOAM_CASE</span>/velocity"</span> </span><br><span class="line">	outOfBounds clamp; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个跟 <code>table</code> 那种类似，只不过将上面 <code>table</code> 的内容写到一个文件里了（这里是 <code>velocity</code> 文件）。 <code>velocity</code> 文件的格式为<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(</span><br><span class="line">    <span class="list">(<span class="keyword">0</span>   <span class="list">(<span class="keyword">0</span> <span class="number">0</span> <span class="number">0</span>)</span>)</span></span><br><span class="line">    <span class="list">(<span class="keyword">0.01</span> <span class="list">(<span class="keyword">10</span> <span class="number">0</span> <span class="number">0</span>)</span>)</span></span><br><span class="line">)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p> outOfBounds 的可选项及其含义有：</p>
<ul>
<li>clamp：当实际时间超过 tableFile 里的最大时间（比如上述示例文件里，最大时间为0.01s）以后，保持 tableFile 最大时间定义的那个值（对上述示例文件，为(10 0 0)）不变；</li>
<li>repeat：重复前面的变化模式，比如上上述示例中，0 &lt; t &lt; 0.01 时，$U_x=1000\cdot t$，当 t 超过0.01 时，计算方法为 $U_x = 1000\cdot (t-0.01)$；</li>
<li>error：t &gt; 0.01 时，报错退出；</li>
<li>warn：给出警告，但是程序继续运行，边界值计算方法同 clamp。</li>
</ul>
<h5 id="csvFile">csvFile</h5><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">inlet</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="title">type</span> uniformFixedValue; </span><br><span class="line">    <span class="title">uniformValue</span> csvFile; </span><br><span class="line">    <span class="title">csvFileCoeffs</span> </span><br><span class="line">    &#123; </span><br><span class="line">	<span class="title">fileName</span> <span class="string">"<span class="variable">$FOAM_CASE</span>/velocity.csv"</span> </span><br><span class="line">	outOfBounds clamp; </span><br><span class="line">	<span class="title">nHeaderLine</span> <span class="number">1</span>; </span><br><span class="line">	<span class="title">mergeSeparators</span> <span class="built_in">no</span>; </span><br><span class="line">	<span class="title">separator</span> <span class="string">","</span>;</span><br><span class="line">	<span class="title">refColumn</span> <span class="number">0</span>; </span><br><span class="line">	<span class="title">componentColumns</span> (<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式是通过一个 <code>csv</code> 格式的文件来定义分段函数，文件格式为<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">time</span>,velocity-x,velocity-y,velocity-z</span><br><span class="line"><span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line"><span class="number">0.01</span>,<span class="number">10</span>,<span class="number">0</span>,<span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<h4 id="2-_flowRateInletVelocity">2. flowRateInletVelocity</h4><p>这个边界条件指定的是界面上的体积流量或者质量流量，并根据流量来反推速度。速度的方向为<strong>垂直边界并指向区域内部</strong>。一般的用法如下：<br><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">myPatch</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="class"><span class="keyword">type</span>        <span class="title">flowRateInletVelocity</span>;</span></span><br><span class="line">      volumetricFlowRate  <span class="number">0.2</span>; <span class="comment">// 体积流量</span></span><br><span class="line">      value       uniform (<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  myPatch</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="class"><span class="keyword">type</span>                <span class="title">flowRateInletVelocity</span>;</span></span><br><span class="line">      massFlowRate        <span class="number">0.2</span>; <span class="comment">// 质量流量</span></span><br><span class="line">      rho                 rho; <span class="comment">//要指定密度场的名字</span></span><br><span class="line">      rhoInlet            <span class="number">1.0</span>; <span class="comment">//如果上述指定的密度场不存在，则使用这里指定的值作为边界上的密度</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>类似的，前面 <code>uniformFixedValue</code> 边界里的那些类型，<code>table</code>， <code>tableFile</code>  <code>csvFile</code>， <code>polynomial</code> 也都可以使用，而且格式是类似的，这里就不重复了，更多细节可以参考<a href="http://www.geocities.jp/penguinitis2002/study/OpenFOAM/time_varying_bc.html" target="_blank" rel="external">这个页面</a> </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这一篇里介绍OpenFOAM自带的两个简单的随时间变化的边界条件： <code>uniformFixedValue</code> 和 <code>flowRateInletVelocity</code> 。</p>]]>
    
    </summary>
    
      <category term="Boundary conditions" scheme="http://xiaopingqiu.github.io/tags/Boundary-conditions/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/tags/OpenFOAM/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[swak4Foam 如何用于名字形如 alpha.water 的场？]]></title>
    <link href="http://xiaopingqiu.github.io/2015/11/25/swak4Foam-alpha-water/"/>
    <id>http://xiaopingqiu.github.io/2015/11/25/swak4Foam-alpha-water/</id>
    <published>2015-11-25T12:33:10.000Z</published>
    <updated>2016-03-14T03:00:46.003Z</updated>
    <content type="html"><![CDATA[<p>swak4Foam 的 <code>groovyBC</code> 边界条件提供了一种很灵活的用表达式定义边界条件的方法。但是，从 OpenFOAM-2.3 开始，两相流求解器如 <code>interFoam</code> 和 <code>twoPhaseEulerFoam</code> 开始采用类似于 <code>alpha.water</code> 的场，这种场名默认情况下 <code>groovyBC</code> 是无法正确识别的，因为 <code>.</code> 在 swak4Foam 表达式中有特殊的作用。<br>所幸的是，开发人员也早就意识到这个问题了，并给出了解决方案，那就是用 <code>aliases</code>。这个东西真是不知道就很难，知道了就很简单，下面举一个我实际用过的例子：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">solid_inlet_left</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title">type</span>               groovyBC;</span><br><span class="line">        <span class="title">valueExpression</span>    <span class="string">"-inVel*normal()"</span></span><br><span class="line">        value              uniform (<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>);</span><br><span class="line">        <span class="title">variables</span> (</span><br><span class="line">            <span class="string">"A=sum(area());"</span></span><br><span class="line">            <span class="string">"outFlow&#123;outlet_left&#125;=sum(Uparticles&amp;normal()*area()*alphaparticles);"</span></span><br><span class="line">            <span class="string">"myFlow=outFlow/alphaparticles;"</span></span><br><span class="line">            <span class="string">"inVel=myFlow/A;"</span></span><br><span class="line">            );</span><br><span class="line">        <span class="title">aliases</span> &#123;</span><br><span class="line">            <span class="title">Uparticles</span>            U.particles;</span><br><span class="line">            <span class="title">alphaparticles</span>        alpha.particles;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我想我应该不用再解释什么。</p>
<p>主要参考<a href="http://sourceforge.net/p/openfoam-extend/ticketsswak4foam/210/" target="_blank" rel="external">这个网页</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>swak4Foam 的 <code>groovyBC</code> 边界条件提供了一种很灵活的用表达式定义边界条件的方法。但是，从 OpenFOAM-2.3 开始，两相流求解器如 <code>interFoam</code> 和 <code>twoPhaseEulerFoa]]>
    </summary>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/tags/OpenFOAM/"/>
    
      <category term="TIL" scheme="http://xiaopingqiu.github.io/tags/TIL/"/>
    
      <category term="groovyBC" scheme="http://xiaopingqiu.github.io/tags/groovyBC/"/>
    
      <category term="swak4Foam" scheme="http://xiaopingqiu.github.io/categories/swak4Foam/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenFOAM 中的单相流湍流模型之一]]></title>
    <link href="http://xiaopingqiu.github.io/2015/11/25/OpenFOAM-singlePhase-turbulenceModel/"/>
    <id>http://xiaopingqiu.github.io/2015/11/25/OpenFOAM-singlePhase-turbulenceModel/</id>
    <published>2015-11-25T11:13:58.000Z</published>
    <updated>2016-03-12T08:11:29.843Z</updated>
    <content type="html"><![CDATA[<p>相信有不少 OpenFOAM 用户有添加湍流模型的需求，我自己最早用 OpenFOAM 完成的一项工作就是在其中添加了一些单相流的湍流模型，并进行了一些计算。这里将我对单相湍流模型代码框架的理解记录下来，供大家参考。本系列将包含三篇，第一篇介绍湍流模型类的继承派生关系，第二篇具体分析几个 OpenFOAM 中带的湍流模型，并给出修改或增加新模型的方法，第三篇分析湍流模型的运行时选择机制（Run Time Selection）的原理。</p>
<a id="more"></a>
<h4 id="1-_湍流模型类的继承派生关系">1. 湍流模型类的继承派生关系</h4><p>这一部分是最简单的，只要有一点<code>C++</code>的知识，看一下湍流模型的代码头文件的类声明部分，就能理解。OpenFOAM 里的单相湍流模型包含两大类，<code>RAS</code> 和 <code>LES</code>，下面将分别分析。</p>
<p>OpenFOAM 单相流湍流模型的代码在 <code>src/turbulenceModels</code> 目录下，目录结构如下：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">Allwmake</span>  compressible  derivedFvPatchFields  incompressible  LES</span><br></pre></td></tr></table></figure></p>
<p>其中， <code>compressible</code> 和 <code>incompressible</code> 分别是可压缩和不可压缩湍流模型的代码， <code>derivedFvPatchFields</code> 是两个湍流相关的边界条件的代码， <code>LES</code> 是大涡模拟的两个相关的类（ <code>LESdeltas</code> 和 <code>LESfilters</code> ），具体在后面会介绍。这里我主要关心不可压缩湍流模型。<br>进入<code>incompressible</code>，目录结构为：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span> cd  incompressible</span><br><span class="line"><span class="variable">$ </span> ls</span><br><span class="line"><span class="constant">Allwmake </span> <span class="constant">LES </span> <span class="constant">RAS </span> turbulenceModel</span><br></pre></td></tr></table></figure></p>
<p>这里， 目录<code>turbulenceModel</code> 里是基类 <code>turbulenceModel</code> 相关的代码， <code>RAS</code> 和 <code>LES</code> ，顾名思义，分别是雷诺时均和大涡模拟湍流模型的代码。</p>
<h5 id="1-1_基类_turbulenceModel">1.1 基类 <code>turbulenceModel</code></h5><p>首先看基类 <code>turbulenceModel</code> ，这里我挑着我觉得重要的部分代码列出来：</p>
<p>先看头文件 turbulenceModel.H：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Foam</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// incompressible 命名空间，注意这个是很重要的，作用是将类隔离开。比如，可压和不可压都有kEpsilon模型，这两个模型的类名是一样的。要区分这两个类，靠的就是这个命名空间。可压的是 compressible::kEpsilon, 而不可压的则是 incompressible::kEpsilon</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">incompressible</span> </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">turbulenceModel</span> <span class="comment">//定义一个 turbulenceModel 类，继承自 regIOobject 类</span></span><br><span class="line">:</span><br><span class="line">    <span class="title">public</span> <span class="title">regIOobject</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据成员</span></span><br><span class="line">        <span class="keyword">const</span> Time&amp; runTime_;</span><br><span class="line">        <span class="keyword">const</span> fvMesh&amp; mesh_;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> volVectorField&amp; U_;</span><br><span class="line">        <span class="keyword">const</span> surfaceScalarField&amp; phi_;</span><br><span class="line"></span><br><span class="line">        transportModel&amp; transportModel_; <span class="comment">// 输运模型，涉及到分子粘度的设置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Near wall distance boundary field</span></span><br><span class="line">        nearWallDist y_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">//- Runtime type information</span></span><br><span class="line">    TypeName(<span class="string">"turbulenceModel"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Declare run-time New selection table 这个跟运行时选择有关，具体以后会涉及</span></span><br><span class="line"></span><br><span class="line">        declareRunTimeNewSelectionTable</span><br><span class="line">        (</span><br><span class="line">            autoPtr,</span><br><span class="line">            turbulenceModel,</span><br><span class="line">            turbulenceModel,</span><br><span class="line">            (</span><br><span class="line">                <span class="keyword">const</span> volVectorField&amp; U,</span><br><span class="line">                <span class="keyword">const</span> surfaceScalarField&amp; phi,</span><br><span class="line">                transportModel&amp; transport,</span><br><span class="line">                <span class="keyword">const</span> word&amp; turbulenceModelName</span><br><span class="line">            ),</span><br><span class="line">            (U, phi, transport, turbulenceModelName)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Constructors  构造函数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Construct from components</span></span><br><span class="line">        turbulenceModel</span><br><span class="line">        (</span><br><span class="line">            <span class="keyword">const</span> volVectorField&amp; U,</span><br><span class="line">            <span class="keyword">const</span> surfaceScalarField&amp; phi,</span><br><span class="line">            transportModel&amp; transport,</span><br><span class="line">            <span class="keyword">const</span> word&amp; turbulenceModelName = typeName</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Selectors // 这个也是跟运行时选择机制有关，涉及到具体湍流模型的选择过程</span></span><br><span class="line">        <span class="comment">//- Return a reference to the selected turbulence model</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> autoPtr&lt;turbulenceModel&gt; <span class="title">New</span></span><br><span class="line">        <span class="params">(</span><br><span class="line">            <span class="keyword">const</span> volVectorField&amp; U,</span><br><span class="line">            <span class="keyword">const</span> surfaceScalarField&amp; phi,</span><br><span class="line">            transportModel&amp; transport,</span><br><span class="line">            <span class="keyword">const</span> word&amp; turbulenceModelName = typeName</span><br><span class="line">        )</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Member Functions</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Const access to the coefficients dictionary</span></span><br><span class="line">        <span class="keyword">virtual</span> <span class="keyword">const</span> dictionary&amp; coeffDict() <span class="keyword">const</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Helper function to return the nam eof the turbulence G field</span></span><br><span class="line">        <span class="function">inline word <span class="title">GName</span><span class="params">()</span> <span class="keyword">const</span></span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> word(type() + <span class="string">":G"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Access function to velocity field</span></span><br><span class="line">        inline <span class="keyword">const</span> volVectorField&amp; U() <span class="keyword">const</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> U_;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Access function to flux field</span></span><br><span class="line">        inline <span class="keyword">const</span> surfaceScalarField&amp; phi() <span class="keyword">const</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> phi_;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Access function to incompressible transport model</span></span><br><span class="line">        inline transportModel&amp; transport() <span class="keyword">const</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> transportModel_;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Return the near wall distances</span></span><br><span class="line">        <span class="keyword">const</span> nearWallDist&amp; y() <span class="keyword">const</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> y_;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Return the laminar viscosity</span></span><br><span class="line">	<span class="comment">// 分子粘度，注意这里的返回值是输运模型类对象的 nu 函数的返回值。</span></span><br><span class="line">	<span class="comment">// 具体来说，如果是牛顿流体，那么这个返回值就是我们在transportProperties里设置的粘度；</span></span><br><span class="line">	<span class="comment">// 如果是非牛顿流体，那么粘度是根据具体的非牛顿流体模型计算得到的。</span></span><br><span class="line">        <span class="function">inline tmp&lt;volScalarField&gt; <span class="title">nu</span><span class="params">()</span> <span class="keyword">const</span> </span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> transportModel_.nu();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下形如 "virtual <span class="label">xxxx () const = 0" 的函数，都是纯虚函数，这是很重要的一部分。</span></span></span><br><span class="line">    <span class="comment">// 当一个类中有纯虚函数时，这个类就被称作抽象类，抽象类本身不能建立对象，一般都是作为接口类来使用。</span></span><br><span class="line">    <span class="comment">// 这里的turbulenceModel类就是接口类，“接口类”三个字的具体含义后面会解释。</span></span><br><span class="line">        <span class="comment">//- Return the turbulence viscosity</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> tmp&lt;volScalarField&gt; <span class="title">nut</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//- Return the effective viscosity</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> tmp&lt;volScalarField&gt; <span class="title">nuEff</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//- Return the turbulence kinetic energy</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> tmp&lt;volScalarField&gt; <span class="title">k</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//- Return the turbulence kinetic energy dissipation rate</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> tmp&lt;volScalarField&gt; <span class="title">epsilon</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//- Return the Reynolds stress tensor</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> tmp&lt;volSymmTensorField&gt; <span class="title">R</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//- Return the effective stress tensor including the laminar stress</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> tmp&lt;volSymmTensorField&gt; <span class="title">devReff</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//- Return the source term for the momentum equation</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> tmp&lt;fvVectorMatrix&gt; <span class="title">divDevReff</span><span class="params">(volVectorField&amp; U)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//- Return the source term for the momentum equation</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> tmp&lt;fvVectorMatrix&gt; <span class="title">divDevRhoReff</span></span><br><span class="line">        <span class="params">(</span><br><span class="line">            <span class="keyword">const</span> volScalarField&amp; rho,</span><br><span class="line">            volVectorField&amp; U</span><br><span class="line">        )</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//- Solve the turbulence equations and correct the turbulence viscosity</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">correct</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Read LESProperties or RASProperties dictionary</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">read</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>再来看 turbulenceModel.C，重点关注构造函数和 New 函数<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">namespace Foam</span><br><span class="line">&#123;</span><br><span class="line">namespace incompressible</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">// <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> Static Data Members <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> </span><br><span class="line"></span><br><span class="line">//这句与运行时选择机制有关，后面再说</span><br><span class="line">defineRunTimeSelectionTable(turbulenceModel, turbulenceModel);</span><br><span class="line"></span><br><span class="line">//构造函数的定义。构造函数包括四个参数，其中最后一个<span class="string">"turbulenceModelName"</span>是带缺省参数的，所以，只需要提供三个参数。</span><br><span class="line">turbulenceModel::turbulenceModel</span><br><span class="line">(</span><br><span class="line">    const volVectorField&amp; U,</span><br><span class="line">    const surfaceScalarField&amp; phi,</span><br><span class="line">    transportModel&amp; transport,</span><br><span class="line">    const word&amp; turbulenceModelName</span><br><span class="line">)</span><br><span class="line">//  这里往下一段叫做成员初始化列表，用于对当前类以及其基类成员进行初始化</span><br><span class="line">:</span><br><span class="line">    regIOobject</span><br><span class="line">    (</span><br><span class="line">        IOobject</span><br><span class="line">        (</span><br><span class="line">            turbulenceModelName,</span><br><span class="line">            U.time().constant(),</span><br><span class="line">            U.db(),</span><br><span class="line">            IOobject::NO_READ,</span><br><span class="line">            IOobject::NO_WRITE</span><br><span class="line">        )</span><br><span class="line">    ),</span><br><span class="line">    runTime_(U.time()),</span><br><span class="line">    mesh_(U.mesh()),</span><br><span class="line"></span><br><span class="line">    U_(U),</span><br><span class="line">    phi_(phi),</span><br><span class="line">    transportModel_(transport), // 输运模型从构造函数的参数中读取</span><br><span class="line">    y_(mesh_)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> Selectors <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> //</span><br><span class="line"></span><br><span class="line">这个函数，起着选择具体湍流模型的作用，后面我会结合求解器代码仔细说说这个函数。更详细的机制，将在结合运行时选择机制来解释。</span><br><span class="line">autoPtr<span class="variable">&lt;turbulenceModel&gt;</span> turbulenceModel::New</span><br><span class="line">(</span><br><span class="line">    const volVectorField&amp; U,</span><br><span class="line">    const surfaceScalarField&amp; phi,</span><br><span class="line">    transportModel&amp; transport,</span><br><span class="line">    const word&amp; turbulenceModelName</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    // 注意这里了，算例中的<span class="string">"turbulenceProperties"</span> 文件即由这段代码来读取。</span><br><span class="line">    // 需要从<span class="string">"turbulenceProperties"</span> 文件中查找一个关键字<span class="string">"simulationType"</span>，</span><br><span class="line">    // 然后将<span class="string">"simulationType"</span>对应的值赋值给变量<span class="string">"modelType"</span>（对于单相流，modelType 只可能是 <span class="string">"RAS"</span> 或者 <span class="string">"LES"</span>）。</span><br><span class="line">    const word modelType</span><br><span class="line">    (</span><br><span class="line">        IOdictionary</span><br><span class="line">        (</span><br><span class="line">            IOobject</span><br><span class="line">            (</span><br><span class="line">                <span class="string">"turbulenceProperties"</span>,</span><br><span class="line">                U.time().constant(),</span><br><span class="line">                U.db(),</span><br><span class="line">                IOobject::MUST_READ_IF_MODIFIED,</span><br><span class="line">                IOobject::NO_WRITE,</span><br><span class="line">                false</span><br><span class="line">            )</span><br><span class="line">        ).lookup(<span class="string">"simulationType"</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    Info<span class="variable">&lt;&lt; "Selecting turbulence model type " &lt;&lt; modelType &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    turbulenceModelConstructorTable::iterator cstrIter =</span><br><span class="line">        turbulenceModelConstructorTablePtr_-&gt;</span>find(modelType);</span><br><span class="line"></span><br><span class="line">    if (cstrIter == turbulenceModelConstructorTablePtr_-&gt;end())</span><br><span class="line">    &#123;</span><br><span class="line">        FatalErrorIn</span><br><span class="line">        (</span><br><span class="line">            <span class="string">"turbulenceModel::New(const volVectorField&amp;, "</span></span><br><span class="line">            <span class="string">"const surfaceScalarField&amp;, transportModel&amp;, const word&amp;)"</span></span><br><span class="line">        )   <span class="variable">&lt;&lt; "Unknown turbulenceModel type "</span><br><span class="line">            &lt;&lt; modelType &lt;&lt; nl &lt;&lt; nl</span><br><span class="line">            &lt;&lt; "Valid turbulenceModel types:" &lt;&lt; endl</span><br><span class="line">            &lt;&lt; turbulenceModelConstructorTablePtr_-&gt;</span>sortedToc()</span><br><span class="line">            <span class="variable">&lt;&lt; exit(FatalError);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return autoPtr&lt;turbulenceModel&gt;</span></span><br><span class="line">    (</span><br><span class="line">        cstrIter()(U, phi, transport, turbulenceModelName)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> Member Functions  <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> //</span><br><span class="line"></span><br><span class="line">void turbulenceModel::correct()</span><br><span class="line">&#123;</span><br><span class="line">    transportModel_.correct();</span><br><span class="line"></span><br><span class="line">    if (mesh_.changing())</span><br><span class="line">    &#123;</span><br><span class="line">        y_.correct();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> //</span><br><span class="line"></span><br><span class="line">&#125; // End namespace incompressible</span><br><span class="line">&#125; // End namespace Foam</span><br></pre></td></tr></table></figure></p>
<p>从基类 <code>turbulenceModel</code> 以下，就要花开两朵，各表一枝了。先来看 <code>RAS</code> 类的湍流模型。</p>
<h5 id="1-2_RAS_模型">1.2 RAS 模型</h5><p>我们从头文件 RASModel.H 看起<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Foam</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">namespace</span> incompressible</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------------------------------------------------------------------------*\</span><br><span class="line">                           Class RASModel Declaration</span><br><span class="line">\*---------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> RASModel</span><br><span class="line">:</span><br><span class="line">    <span class="keyword">public</span> turbulenceModel, <span class="comment">// RASModel 类是前面讲的turbulenceModel类的派生类</span></span><br><span class="line">    <span class="keyword">public</span> IOdictionary <span class="comment">// 同时也继承 IOdictionary 类</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 两个开关变量，类似于 C++ 中的bool变量，其值要么是true，要么是false。</span></span><br><span class="line">	<span class="comment">// 只是这里将 true 换成 on，false 换成 off 也是一样的。</span></span><br><span class="line">        Switch turbulence_;</span><br><span class="line">        Switch printCoeffs_;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Model coefficients dictionary</span></span><br><span class="line">        dictionary coeffDict_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Lower limit of k</span></span><br><span class="line">        dimensionedScalar kMin_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Lower limit of epsilon</span></span><br><span class="line">        dimensionedScalar epsilonMin_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Lower limit for omega</span></span><br><span class="line">        dimensionedScalar omegaMin_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Protected Member Functions</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Print model coefficients</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">printCoeffs</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Private Member Functions</span></span><br><span class="line">        <span class="comment">//- Disallow default bitwise copy construct</span></span><br><span class="line">        RASModel(<span class="keyword">const</span> RASModel&amp;);</span><br><span class="line">        <span class="comment">//- Disallow default bitwise assignment</span></span><br><span class="line">        <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> RASModel&amp;);</span><br><span class="line">        </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">//- Runtime type information</span></span><br><span class="line">    TypeName(<span class="string">"RASModel"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里也涉及到 运行时选择机制，以后一起讲。</span></span><br><span class="line">        declareRunTimeSelectionTable</span><br><span class="line">        (</span><br><span class="line">            autoPtr,</span><br><span class="line">            RASModel,</span><br><span class="line">            dictionary,</span><br><span class="line">            (</span><br><span class="line">                <span class="keyword">const</span> volVectorField&amp; U,</span><br><span class="line">                <span class="keyword">const</span> surfaceScalarField&amp; phi,</span><br><span class="line">                transportModel&amp; transport,</span><br><span class="line">                <span class="keyword">const</span> word&amp; turbulenceModelName</span><br><span class="line">            ),</span><br><span class="line">            (U, phi, transport, turbulenceModelName)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">        RASModel</span><br><span class="line">        (</span><br><span class="line">            <span class="keyword">const</span> word&amp; type,</span><br><span class="line">            <span class="keyword">const</span> volVectorField&amp; U,</span><br><span class="line">            <span class="keyword">const</span> surfaceScalarField&amp; phi,</span><br><span class="line">            transportModel&amp; transport,</span><br><span class="line">            <span class="keyword">const</span> word&amp; turbulenceModelName = turbulenceModel::typeName</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Return a reference to the selected RAS model 这个函数作为运行时选择机制里的选择器。</span></span><br><span class="line">        <span class="keyword">static</span> autoPtr&lt;RASModel&gt; New</span><br><span class="line">        (</span><br><span class="line">            <span class="keyword">const</span> volVectorField&amp; U,</span><br><span class="line">            <span class="keyword">const</span> surfaceScalarField&amp; phi,</span><br><span class="line">            transportModel&amp; transport,</span><br><span class="line">            <span class="keyword">const</span> word&amp; turbulenceModelName = turbulenceModel::typeName</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Member Functions</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Access</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注意，一下这些成员函数，是将来 RASModel 类的派生类们可能会用到的，这里一起定义了，</span></span><br><span class="line">	    <span class="comment">// 后面的派生类将可以直接继承这些函数，这样达到了代码重复利用的作用。</span></span><br><span class="line">            <span class="comment">//- Return the lower allowable limit for k (default: SMALL)</span></span><br><span class="line">            <span class="keyword">const</span> dimensionedScalar&amp; kMin() <span class="keyword">const</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> kMin_;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//- Return the lower allowable limit for epsilon (default: SMALL)</span></span><br><span class="line">            <span class="keyword">const</span> dimensionedScalar&amp; epsilonMin() <span class="keyword">const</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> epsilonMin_;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//- Return the lower allowable limit for omega (default: SMALL)</span></span><br><span class="line">            <span class="keyword">const</span> dimensionedScalar&amp; omegaMin() <span class="keyword">const</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> omegaMin_;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//- Allow kMin to be changed</span></span><br><span class="line">            dimensionedScalar&amp; kMin()</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> kMin_;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//- Allow epsilonMin to be changed</span></span><br><span class="line">            dimensionedScalar&amp; epsilonMin()</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> epsilonMin_;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//- Allow omegaMin to be changed</span></span><br><span class="line">            dimensionedScalar&amp; omegaMin()</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> omegaMin_;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//- Const access to the coefficients dictionary</span></span><br><span class="line">            <span class="keyword">virtual</span> <span class="keyword">const</span> dictionary&amp; coeffDict() <span class="keyword">const</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> coeffDict_;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Return the effective viscosity</span></span><br><span class="line">	<span class="comment">// 这个函数很重要，默认情况下，雷诺时均湍流模型中，有效粘度等于湍流粘度加层流粘度，即nut + nu。</span></span><br><span class="line">	<span class="comment">// 这里的 nut 和 nu 两个函数在基类 turbulenceModel 声明了，请往前翻以证实这一点。</span></span><br><span class="line">        <span class="keyword">virtual</span> tmp&lt;volScalarField&gt; nuEff() <span class="keyword">const</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> tmp&lt;volScalarField&gt;</span><br><span class="line">            (</span><br><span class="line">                <span class="keyword">new</span> volScalarField(<span class="string">"nuEff"</span>, nut() + nu())</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Solve the turbulence equations and correct the turbulence viscosity</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">correct</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Read RASProperties dictionary</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// End namespace incompressible</span></span><br><span class="line">&#125; <span class="comment">// End namespace Foam</span></span><br></pre></td></tr></table></figure></p>
<p>再来看 <code>RASModel.C</code>，这里跟 <code>turbulenceModel.C</code> 类似，重点关注构造函数和 选择器（Selector）函数。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line">namespace Foam</span><br><span class="line">&#123;</span><br><span class="line">namespace incompressible</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">defineTypeNameAndDebug(RASModel, <span class="number">0</span>);</span><br><span class="line">defineRunTimeSelectionTable(RASModel, dictionary);</span><br><span class="line">addToRunTimeSelectionTable(turbulenceModel, RASModel, turbulenceModel);</span><br><span class="line"></span><br><span class="line"><span class="comment">// * * * * * * * * * * * * * Protected Member Functions  * * * * * * * * * * //</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> RASModel::printCoeffs()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (printCoeffs_)</span><br><span class="line">    &#123;</span><br><span class="line">        Info&lt;&lt; type() &lt;&lt; <span class="string">"Coeffs"</span> &lt;&lt; coeffDict_ &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">RASModel::RASModel</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> word&amp; type,</span><br><span class="line">    <span class="keyword">const</span> volVectorField&amp; U,</span><br><span class="line">    <span class="keyword">const</span> surfaceScalarField&amp; phi,</span><br><span class="line">    transportModel&amp; transport,</span><br><span class="line">    <span class="keyword">const</span> word&amp; turbulenceModelName</span><br><span class="line">)</span><br><span class="line">:</span><br><span class="line">类似的，这里也是使用成员初始化列表来初始化当前类及其父类的数据成员</span><br><span class="line"></span><br><span class="line">    // 这一句是传递参数给父类 turbulenceModel，注意这里传给父类构造函数的参数要与父类中的构造函数的参数表一致哦</span><br><span class="line">    turbulenceModel(U, phi, transport, turbulenceModelName), </span><br><span class="line">    </span><br><span class="line"> //这里是建立一个IOobject来初始化另一个父类IOdictionary，注意这里建立的是一个名为“RASProperties”的IO对象，这个文件相信用过 OpenFOAM 湍流模拟的一定很熟悉吧</span><br><span class="line">    IOdictionary</span><br><span class="line">    (</span><br><span class="line">        IOobject</span><br><span class="line">        (</span><br><span class="line">            <span class="string">"RASProperties"</span>,</span><br><span class="line">            U.time().constant(), // 这里表示文件的位置是在constant文件夹下</span><br><span class="line">            U.db(),</span><br><span class="line">            IOobject::MUST_READ_IF_MODIFIED, //这里的意思是，如果修改了，则需要重新读取，所以，如果你在算例运行时修改了这个文件，你的修改会即时生效的</span><br><span class="line">            IOobject::NO_WRITE</span><br><span class="line">        )</span><br><span class="line">    ),</span><br><span class="line">    </span><br><span class="line">  // 查找“turbulence” 关键字，并用其对应的值来初始化变量“turbulnce_”。</span><br><span class="line">    turbulence_(lookup(<span class="string">"turbulence"</span>)),</span><br><span class="line">    // 同上，区别是这里是带缺省参数的，也就是说如果找不到“printCoeffs” 就用缺省值“<span class="keyword">false</span>”</span><br><span class="line">    printCoeffs_(lookupOrDefault&lt;Switch&gt;(<span class="string">"printCoeffs"</span>, <span class="keyword">false</span>)), </span><br><span class="line">    </span><br><span class="line">    // 这里是读取模型参数字典来初始化变量“coeffDict_”。注意，这里的 type 是啥？这个要等到进一步看一个具体的湍流模型类时才能明了。 </span><br><span class="line">    // 另外，注意这里的 `lookup` ， `lookupOrDefault` 和 `subOrEmptyDict` 三个函数都是继承自 IOdictionary 类的函数。</span><br><span class="line">    coeffDict_(subOrEmptyDict(type + <span class="string">"Coeffs"</span>)), </span><br><span class="line"></span><br><span class="line">    kMin_(<span class="string">"kMin"</span>, sqr(dimVelocity), SMALL),</span><br><span class="line">    epsilonMin_(<span class="string">"epsilonMin"</span>, kMin_.dimensions()/dimTime, SMALL),</span><br><span class="line">    omegaMin_(<span class="string">"omegaMin"</span>, dimless/dimTime, SMALL)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里是从 RASProperties 里读取kMin等的值，注意如果 RASProperties 里不设置那就使用上面初始化的值“SMALL”。</span></span><br><span class="line">    <span class="comment">// 注意这里的“*this”代表的是 RASModel 类本身，但是readIfPresent函数的参数应该是 dictionary 类，由于RASModel 类继承自 IODictionary 类，所以，这里其实隐含了一个派生类指针向基类指针的转换</span></span><br><span class="line">    kMin_.readIfPresent(*<span class="keyword">this</span>);  </span><br><span class="line">    epsilonMin_.readIfPresent(*<span class="keyword">this</span>);</span><br><span class="line">    omegaMin_.readIfPresent(*<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Force the construction of the mesh deltaCoeffs which may be needed</span></span><br><span class="line">    <span class="comment">// for the construction of the derived models and BCs</span></span><br><span class="line">    mesh_.deltaCoeffs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//这个也是跟运行时选择有关，以后会细说</span></span><br><span class="line">autoPtr&lt;RASModel&gt; RASModel::New</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> volVectorField&amp; U,</span><br><span class="line">    <span class="keyword">const</span> surfaceScalarField&amp; phi,</span><br><span class="line">    transportModel&amp; transport,</span><br><span class="line">    <span class="keyword">const</span> word&amp; turbulenceModelName</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// get model name, but do not register the dictionary</span></span><br><span class="line">    <span class="comment">// otherwise it is registered in the database twice</span></span><br><span class="line">    <span class="keyword">const</span> word modelType</span><br><span class="line">    (</span><br><span class="line">        IOdictionary</span><br><span class="line">        (</span><br><span class="line">            IOobject</span><br><span class="line">            (</span><br><span class="line">                <span class="string">"RASProperties"</span>,</span><br><span class="line">                U.time().constant(),</span><br><span class="line">                U.db(),</span><br><span class="line">                IOobject::MUST_READ_IF_MODIFIED,</span><br><span class="line">                IOobject::NO_WRITE,</span><br><span class="line">                <span class="keyword">false</span></span><br><span class="line">            )</span><br><span class="line">        ).lookup(<span class="string">"RASModel"</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    Info&lt;&lt; <span class="string">"Selecting RAS turbulence model "</span> &lt;&lt; modelType &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    dictionaryConstructorTable::iterator cstrIter =</span><br><span class="line">        dictionaryConstructorTablePtr_-&gt;find(modelType);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cstrIter == dictionaryConstructorTablePtr_-&gt;end())</span><br><span class="line">    &#123;</span><br><span class="line">        FatalErrorIn</span><br><span class="line">        (</span><br><span class="line">            <span class="string">"RASModel::New"</span></span><br><span class="line">            <span class="string">"("</span></span><br><span class="line">                <span class="string">"const volVectorField&amp;, "</span></span><br><span class="line">                <span class="string">"const surfaceScalarField&amp;, "</span></span><br><span class="line">                <span class="string">"transportModel&amp;, "</span></span><br><span class="line">                <span class="string">"const word&amp;"</span></span><br><span class="line">            <span class="string">")"</span></span><br><span class="line">        )   &lt;&lt; <span class="string">"Unknown RASModel type "</span></span><br><span class="line">            &lt;&lt; modelType &lt;&lt; nl &lt;&lt; nl</span><br><span class="line">            &lt;&lt; <span class="string">"Valid RASModel types:"</span> &lt;&lt; endl</span><br><span class="line">            &lt;&lt; dictionaryConstructorTablePtr_-&gt;sortedToc()</span><br><span class="line">            &lt;&lt; exit(FatalError);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> autoPtr&lt;RASModel&gt;</span><br><span class="line">    (</span><br><span class="line">        cstrIter()(U, phi, transport, turbulenceModelName)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// * * * * * * * * * * * * * * * Member Functions  * * * * * * * * * * * * * //</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> RASModel::correct()</span><br><span class="line">&#123;</span><br><span class="line">    turbulenceModel::correct();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool RASModel::read()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//if (regIOobject::read())</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bit of trickery : we are both IOdictionary ('RASProperties') and</span></span><br><span class="line">    <span class="comment">// an regIOobject from the turbulenceModel level. Problem is to distinguish</span></span><br><span class="line">    <span class="comment">// between the two - we only want to reread the IOdictionary.</span></span><br><span class="line"></span><br><span class="line">    bool ok = IOdictionary::readData</span><br><span class="line">    (</span><br><span class="line">        IOdictionary::readStream</span><br><span class="line">        (</span><br><span class="line">            IOdictionary::type()</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">    IOdictionary::close();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ok)</span><br><span class="line">    &#123;</span><br><span class="line">        lookup(<span class="string">"turbulence"</span>) &gt;&gt; turbulence_;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">const</span> dictionary* dictPtr = subDictPtr(type() + <span class="string">"Coeffs"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            coeffDict_ &lt;&lt;= *dictPtr;</span><br><span class="line">        &#125;</span><br><span class="line">        kMin_.readIfPresent(*<span class="keyword">this</span>);</span><br><span class="line">        epsilonMin_.readIfPresent(*<span class="keyword">this</span>);</span><br><span class="line">        omegaMin_.readIfPresent(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// End namespace incompressible</span></span><br><span class="line">&#125; <span class="comment">// End namespace Foam</span></span><br></pre></td></tr></table></figure></p>
<h5 id="1-3_LES_模型">1.3 LES 模型</h5><p>LESModel 类的结构与 RASModel 非常接近，所以这里就简单提一下区别之处。</p>
<ul>
<li>delta_ 成员<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">autoPtr</span>&lt;<span class="rule"><span class="attribute">Foam</span>:<span class="value">:LESdelta&gt; delta_</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这个成员是 LESdelta 类的对象，定义滤波尺度。这个类的定义在 <code>src/turbulenceModels/LES/LESdeltas</code> ，当中定义了几个可选的 delta 模型</p>
<ul>
<li>亚格子粘度和应力</li>
</ul>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//- Return the SGS viscosity. 亚格子粘度</span></span><br><span class="line">       <span class="function"><span class="keyword">virtual</span> tmp&lt;volScalarField&gt; <span class="title">nuSgs</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//- Return the effective viscosity</span></span><br><span class="line">       <span class="function"><span class="keyword">virtual</span> tmp&lt;volScalarField&gt; <span class="title">nuEff</span><span class="params">()</span> <span class="keyword">const</span> <span class="comment">//有效粘度等于亚格子粘度与分子粘度之和</span></span><br><span class="line">       </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> tmp&lt;volScalarField&gt;</span><br><span class="line">           (</span><br><span class="line">               <span class="keyword">new</span> volScalarField(<span class="string">"nuEff"</span>, nuSgs() + nu())</span><br><span class="line">           );</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//- Return the sub-grid stress tensor. // 亚格子应力</span></span><br><span class="line">       <span class="function"><span class="keyword">virtual</span> tmp&lt;volSymmTensorField&gt; <span class="title">B</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>LESModel.C 的结构与 RASModel.C 几乎一样，所以这里就不重复了。</p>
<p>前面提到，基类 turbulenceModel 里声明了很多纯虚函数，所以，turbulenceModel 类是抽象类，不能直接创建对象。注意这里的 RASModel 类和 LESModel 类由于继承了 turbulenceModel 类的纯虚函数，所以这两个依然是抽象类。这一点在后面解析具体湍流模型类的时候还会提到，这里先提个醒。</p>
<h5 id="1-4_继承派生关系">1.4 继承派生关系</h5><p>前面看完了基类 turbulenceModel，RASModel 以及 LESModel，可以看出这三个类的继承派生关系为：</p>
<p><img src="/image/turbulenceModel/RAS_LES.png" alt="RAS 和 LES 与 turbulenceModel 的继承关系"></p>
<p>下面继续看具体湍流模型类与基类的继承关系。<br>先看雷诺时均类湍流模型：<br>位于 <code>src/turbulenceModels/incompressible/RAS</code> 目录下的都是雷诺时均类的湍流模型，这个类型的继承关系很简单：所有具体湍流模型类都继承自 RASModel 类，关系示意图如下：</p>
<p><img src="/image/turbulenceModel/RAS.png" alt="RAS 类湍流模型的继承关系"></p>
<p>位于 <code>src/turbulenceModels/incompressible/LES</code> 目录下的是大涡模拟类型的湍流模型，这类湍流模型的继承关系比雷诺时均类的要复杂一点，但是也不难捋清，过程我就不详述了，下面给出我整理的继承关系图：</p>
<p><img src="/image/turbulenceModel/LES.png" alt="LES 类湍流模型的继承关系"></p>
<p>上图中，虚线框里的是抽象类，实线框里的是具体的可以调用的湍流模型类。</p>
<h5 id="1-5_求解器中湍流模型的调用">1.5 求解器中湍流模型的调用</h5><p>最后简单提一下求解器中调用湍流模型的接口。以 <code>pisoFoam</code> 求解器为例：<br>纵观 <code>pisoFoam</code> 的代码，跟湍流模型有关的共有三处，第一处是在 createField.H 的最后面，创建一个智能指针<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">autoPtr</span>&lt;<span class="rule"><span class="attribute">incompressible</span>:<span class="value">:turbulenceModel&gt; turbulence</span><br><span class="line">    (</span><br><span class="line">        incompressible::turbulenceModel::<span class="function">New</span>(U, phi, laminarTransport)</span><br><span class="line">    )</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>注意，这个指针的类型是 <code>incompressible::turbulenceModel</code> ，也就是说，创建的是基类的指针。<br>第二处位于 <code>UEqn</code> 中，<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ turbulence-&gt;<span class="function"><span class="title">divDevReff</span><span class="params">(U)</span></span></span><br></pre></td></tr></table></figure></p>
<p>从这里可以看出，这是用指针 <code>turbulence</code> 调用成员函数 <code>divDevReff</code><br>第三处在压力修正之后<br><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">turbulence-&gt;correct<span class="literal">()</span>;</span><br></pre></td></tr></table></figure></p>
<p>这里是调用成员函数 <code>correct</code> 。<br>这简单的几行代码，就完成了湍流模型的调用。这里先大致说一下调用的原理和过程，详细的留待后面跟运行时选择机制一起说。<br>首先，注意刚才提到的智能指针 <code>turbulence</code> 的类型是 <code>incompressible::turbulenceModel</code> ，是基类类型的。这里就不得不说一下 C++ <strong>虚函数</strong>的作用了。还记得上面提到的基类 <code>turbulenceModel</code> 中声明的那些<strong>纯虚函数</strong>吧，如果你往上翻翻，你会发现， <code>divDevReff</code> 和 <code>correct</code> 在基类 <code>turbulenceModel</code> 中都被声明为<strong>纯虚函数</strong>。这里只要把握两点，就能理解湍流模型的调用原理：</p>
<ol>
<li>基类类型的指针可以指向派生类的对象；</li>
<li>在基类中声明的纯虚函数可以在派生类中进行定义，当基类类型指针指向派生类对象以后，用这个指针调用成员函数时，实际调用的是指针指向的派生类中定义的函数。</li>
</ol>
<p>把握这两点，然后再去理解湍流模型的调用过程：<br>首先是调用 <code>incompressible::turbulenceModel::New</code> 函数来初始化指针 <code>turbulence</code> ，查看上面 <code>turbulenceModel</code> 类中 <code>New</code> 函数的定义，可以知道，函数要先从“turbulenceProperties” 文件里 <code>simulationType</code>　关键字，从而决定是调用 <code>RAS</code> 模型还是 <code>LES</code> 模型。如果用户设定的是 <code>RAS</code> ，那么 <code>turbulenceModel</code> 类的 <code>New</code> 函数将返回一个指向 <code>RASModel</code> 类的指针，这个指针将继续调用 <code>RASModel</code> 类的 <code>New</code> 函数，并在这个函数中读取 <code>RASProperties</code> 文件，查找关键字 <code>RASModel</code> ，从而决定具体调用的湍流模型。假设用户指定的是 <code>kEpsilon</code> 那么最终 createField.H 中定义的指针 <code>turbulence</code> 将指向一个 <code>kEpsilon</code> 类的对象，由此， <code>turbulence-&gt;divDevReff(U)</code> 和 <code>turbulence-&gt;correct()</code> 都将分别调用定义在 <code>kEpsilon</code> 类中的成员函数 <code>divDevReff</code> 和 <code>correct</code>。<br>一个简单的湍流模型调用示意图如下：</p>
<p><img src="/image/turbulenceModel/call.png" alt="湍流模型调用示意图"></p>
<p>以上是 RAS 类型模型的调用，LES 类型的基本上差不多，但是，从上面的继承关系图也能看出，LES 模型类的结构更复杂一点。根本原因在于，LES 模型不像 RAS 模型那样都是同一的对湍流粘度 <code>nut</code> 建模，而是有一部分是对亚格子粘度 <code>nuSgs</code> 建模（这一部分湍流模型均继承自 <code>GenEddyVisc</code> ），还有另一部分是直接对亚格子应力 <code>B</code> 建模（这一部分湍流模型均继承自 <code>GenSGSStress</code> ），此外，分离涡模型（Detached eddy model， DESModel）也放在这个目录下，而且还有一个直接继承自 <code>LESModel</code> 的模型 <code>kOmegaSSTSAS</code> （这个模型与 <code>LESModel</code> 的关系就跟 <code>kEpsilon</code> 与 <code>RASModel</code> 的关系一样）。虽然有这么多种类型，但是调用过程其实跟 RAS 类型的是差不多的。如果从字典文件“turbulenceProperties” 里读到的 <code>simulationType</code> 是 <code>LES</code> 的话，那么将继续从字典文件 <code>LESProperties</code> 里读取具体的 LES 模型。上面总结的那张继承关系图中，所有的实线框中的模型都可以选择。但是，具体的模型需要具体的设置，比如，需要设置滤波尺度 <code>delta</code> 模型，还可能需要设置 <code>filter</code> 模型，具体的要求可以去具体的湍流模型类的代码中去看。如果你了解一点你需要使用的湍流模型的基本理论，能写出模型的方程，那要看懂这个湍流模型在 OpenFOAM 中实现的代码是很容易的。</p>
<p>上述关于调用过程的叙述，只是我的理解，其实不严谨，但大致原理应该是这样。计划中这个系列将写三篇，我将在第三篇中叙述运行时选择机制，到时候还会深入说说这个调用过程。</p>
<p>P.S：本系列在筹划时，OpenFOAM-3.0 版本还没发布。随着 3.0 版本的发布，本系列里对湍流模型的描述已经“过时”了，因为在 3.0 版中，湍流模型类进行了重新模板化，将单相湍流和多相湍流模型整合在一起了，所以这里的描述只适用于 3.0 以下的版本。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>相信有不少 OpenFOAM 用户有添加湍流模型的需求，我自己最早用 OpenFOAM 完成的一项工作就是在其中添加了一些单相流的湍流模型，并进行了一些计算。这里将我对单相湍流模型代码框架的理解记录下来，供大家参考。本系列将包含三篇，第一篇介绍湍流模型类的继承派生关系，第二篇具体分析几个 OpenFOAM 中带的湍流模型，并给出修改或增加新模型的方法，第三篇分析湍流模型的运行时选择机制（Run Time Selection）的原理。</p>]]>
    
    </summary>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="turbulence model" scheme="http://xiaopingqiu.github.io/tags/turbulence-model/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[blockMesh 的新功能：multi/sectional grading in a block]]></title>
    <link href="http://xiaopingqiu.github.io/2015/10/06/blockMesh-multi-sectional-grading/"/>
    <id>http://xiaopingqiu.github.io/2015/10/06/blockMesh-multi-sectional-grading/</id>
    <published>2015-10-06T12:24:52.000Z</published>
    <updated>2015-11-03T13:38:21.454Z</updated>
    <content type="html"><![CDATA[<p>从 OpenFOAM-2.3.x 的 “<a href="https://github.com/OpenFOAM/OpenFOAM-2.3.x/commit/cf370883644ec59782be375041b2434eb3e2c4ed" target="_blank" rel="external">commit cf370883644ec59782be375041b2434eb3e2c4ed</a>“ 开始，<code>blockMesh</code> 有了一项新功能：multi/sectional grading in a block。这项功能说起来很简单即可以在同一个block里面设置多个方向的大小渐变网格。举个例子，假设你想画一个简单的二维槽道流网格，你希望两边靠近壁面处的网格更密一点，而中心的网格稀疏一点。以前版本的 <code>blockMesh</code> 由于只支持让网格大小在某一个方向上渐变（通过设置 simpleGrading），要实现上述网格，你需要将整个槽道分成两个block，然后分别设置 simpleGrading。现在有了 “multi/sectional grading”以后，只需要一个block，并设置好simpleGrading便可实现了。下面解释一下新版 <code>blockMesh</code> 具体设置，并以一个二维方腔流例子来说明。</p>
<a id="more"></a>
<p>先来解释一下参数的含义，下面是我设置的一个二维方腔流算例的 blockMeshDict 文件的部分：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">vertices</span><br><span class="line"><span class="list">(</span><br><span class="line">    <span class="list">(<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>)</span></span><br><span class="line">    <span class="list">(<span class="number">1</span> <span class="number">0</span> <span class="number">0</span>)</span></span><br><span class="line">    <span class="list">(<span class="number">1</span> <span class="number">1</span> <span class="number">0</span>)</span></span><br><span class="line">    <span class="list">(<span class="number">0</span> <span class="number">1</span> <span class="number">0</span>)</span></span><br><span class="line">    <span class="list">(<span class="number">0</span> <span class="number">0</span> <span class="number">0.1</span>)</span></span><br><span class="line">    <span class="list">(<span class="number">1</span> <span class="number">0</span> <span class="number">0.1</span>)</span></span><br><span class="line">    <span class="list">(<span class="number">1</span> <span class="number">1</span> <span class="number">0.1</span>)</span></span><br><span class="line">    <span class="list">(<span class="number">0</span> <span class="number">1</span> <span class="number">0.1</span>)</span></span><br><span class="line">)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">blocks</span><br><span class="line"><span class="list">(</span><br><span class="line">    <span class="keyword">hex</span> <span class="list">(<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>)</span> <span class="list">(<span class="number">100</span> <span class="number">100</span> <span class="number">1</span>)</span></span><br><span class="line">    simpleGrading</span><br><span class="line">    <span class="list">(</span><br><span class="line">      <span class="list">(<span class="list">(<span class="number">0.5</span> <span class="number">0.5</span> <span class="number">2</span>)</span>  <span class="list">(<span class="number">0.5</span> <span class="number">0.5</span> <span class="number">0.5</span>)</span>)</span></span><br><span class="line">      <span class="list">(<span class="list">(<span class="number">0.5</span> <span class="number">0.5</span> <span class="number">2</span>)</span>  <span class="list">(<span class="number">0.5</span> <span class="number">0.5</span> <span class="number">0.5</span>)</span>)</span></span><br><span class="line">      <span class="number">1</span></span><br><span class="line">    )</span></span><br><span class="line">)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>跟前面版本的差别在于 simpleGrading 部分的参数更多了。下面解释一下多出来的参数的含义。首先，注意 simpleGrading 的参数仍然是分成三段，分别代表x，y，z方向的网格渐变设置。其中，x方向的渐变设置参数又分作两段：”(0.5 0.5 2)”和”(0.5 0.5 0.5)”，每一段均代表一个子 block，这个子 block 的网格参数由三个数字来确定。以”(0.5 0.5 2)” 为例，第一个”0.5” 表示该子 block 的尺度是总 block 的尺度的0.5倍；第二个”0.5”表示在这个子block里划分的网格总数占整个block的网格总数的一半；”2” 代表着网格渐变因子，这个跟以前的 blockMesh 的 simpleGrading 参数的含义一样。</p>
<p>了解了参数的含义，便可以推知上述 blockMeshDict 文件对应的网格了：二维方腔，x和y方向上各分为两个子 block，子 block 的尺度都是整个 block 的一半，且子 block 的网格渐变因子分别为 “2” 和 “0.5”。得到的网格如下：</p>
<p><img src="/image/blockMesh/mesh_whole.png" alt="整体"></p>
<p>右上角局部放大图如下：<br><img src="/image/blockMesh/mesh_local.png" alt="右上角局部放大"></p>
<p>上述描述中有一个不是很严谨的地方，用下面这个例子来说明一下：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">blocks</span><br><span class="line"><span class="list">(</span><br><span class="line">    <span class="keyword">hex</span> <span class="list">(<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>)</span> <span class="list">(<span class="number">20</span> <span class="number">60</span> <span class="number">20</span>)</span></span><br><span class="line">    simpleGrading</span><br><span class="line">    <span class="list">(</span><br><span class="line">        <span class="number">1</span></span><br><span class="line">        <span class="list">(<span class="list">(<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>)</span> <span class="list">(<span class="number">6</span> <span class="number">4</span> <span class="number">1</span>)</span> <span class="list">(<span class="number">2</span> <span class="number">3</span> <span class="number">0.25</span>)</span>)</span></span><br><span class="line">        <span class="number">1</span></span><br><span class="line">    )</span></span><br><span class="line">)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>按照上文的描述，这个网格将在y方向上划分成3个子 block，其中第一个子 block 的尺度是整个 block 的2倍…等等，2倍？这怎么可能？实际情况是，blockMesh 会自动对参数进行归一化，第一个子 block 的尺度将是整个 block 的 2/(2+6+2)=0.2 倍，其余的依此类推。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>从 OpenFOAM-2.3.x 的 “<a href="https://github.com/OpenFOAM/OpenFOAM-2.3.x/commit/cf370883644ec59782be375041b2434eb3e2c4ed">commit cf370883644ec59782be375041b2434eb3e2c4ed</a>“ 开始，<code>blockMesh</code> 有了一项新功能：multi/sectional grading in a block。这项功能说起来很简单即可以在同一个block里面设置多个方向的大小渐变网格。举个例子，假设你想画一个简单的二维槽道流网格，你希望两边靠近壁面处的网格更密一点，而中心的网格稀疏一点。以前版本的 <code>blockMesh</code> 由于只支持让网格大小在某一个方向上渐变（通过设置 simpleGrading），要实现上述网格，你需要将整个槽道分成两个block，然后分别设置 simpleGrading。现在有了 “multi/sectional grading”以后，只需要一个block，并设置好simpleGrading便可实现了。下面解释一下新版 <code>blockMesh</code> 具体设置，并以一个二维方腔流例子来说明。</p>]]>
    
    </summary>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/tags/OpenFOAM/"/>
    
      <category term="Preprocessing" scheme="http://xiaopingqiu.github.io/tags/Preprocessing/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenFOAM-2.3.x 中的 twoPhaseEulerFoam 解析之 TurbulenceModel]]></title>
    <link href="http://xiaopingqiu.github.io/2015/09/19/TFM-TurbulenceModel/"/>
    <id>http://xiaopingqiu.github.io/2015/09/19/TFM-TurbulenceModel/</id>
    <published>2015-09-19T04:38:20.000Z</published>
    <updated>2015-09-25T09:15:31.359Z</updated>
    <content type="html"><![CDATA[<p>在 <code>kineticTheoryModel</code> 类的解读时前面提到过， <code>kineticTheoryModel</code> 使用了跟湍流模型一样的接口。这一篇，就来看一下 <code>twoPhaseEulerFoam</code> 中的湍流模型。  </p>
<a id="more"></a>
<p>OpenFOAM-2.3.x 中的<code>twoPhaseEulerFoam</code> 流体相可以调用 RAS 和 LES 湍流模型，固相可以使用两种计算固相应力的“湍流模型”。<br>湍流模型的调用是通过 phaseModel 来进行的，具体的过程放到最后来讲，这里先说一下最重要的 <code>divDevRhoReff</code> 函数的形式，主要有三种类型：用于固相的 <code>phasePressure</code> 和  <code>kineticTheoryModel</code> 以及用于流体相的 RAS 模型或 LES 模型，以 <code>kEpsilon</code> 模型为例。此外，在”pEqn.H”里，还需要用到 <code>pPrime()</code> 函数，这个函数主要是在处理颗粒相的压力时有意义，所以，在 <code>phasePressure</code> 和 <code>kineticTheoryModel</code> 两个模型中，这个函数也需要关注一下。</p>
<h5 id="1_phasePressure">1  phasePressure</h5><p> 很显然，这个是用于固相的，只考虑所谓固相压力，所以理论上， <code>divDevRhoReff</code>函数应该是对固相动量方程没有贡献的，实际上也正是如此，其定义如下：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="constant">Foam:</span><span class="symbol">:tmp&lt;Foam</span><span class="symbol">:</span><span class="symbol">:fvVectorMatrix&gt;</span></span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:RASModels</span><span class="symbol">:</span><span class="symbol">:phasePressureModel</span><span class="symbol">:</span><span class="symbol">:divDevRhoReff</span></span><br><span class="line">(</span><br><span class="line">    volVectorField&amp; <span class="constant">U</span></span><br><span class="line">) const</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> tmp&lt;fvVectorMatrix&gt;</span><br><span class="line">    (</span><br><span class="line">        new fvVectorMatrix</span><br><span class="line">        (</span><br><span class="line">            <span class="constant">U,</span></span><br><span class="line">            this-&gt;rho<span class="constant">_</span>.dimensions()*dimensionSet(<span class="number">0</span>, <span class="number">4</span>, -<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>经测验，这一项对 fvVectorMatrix 的贡献是零。</p>
 <figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="constant">Foam:</span><span class="symbol">:tmp&lt;Foam</span><span class="symbol">:</span><span class="symbol">:volScalarField&gt;</span></span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:RASModels</span><span class="symbol">:</span><span class="symbol">:phasePressureModel</span><span class="symbol">:</span><span class="symbol">:pPrime</span>() const</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        g0<span class="constant">_</span></span><br><span class="line">       *min</span><br><span class="line">        (</span><br><span class="line">            exp(preAlphaExp<span class="constant">_</span>*(this-&gt;alpha<span class="constant">_</span> - alphaMax<span class="constant">_</span>)),</span><br><span class="line">            expMax<span class="constant">_</span></span><br><span class="line">        );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:tmp&lt;Foam</span><span class="symbol">:</span><span class="symbol">:surfaceScalarField&gt;</span></span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:RASModels</span><span class="symbol">:</span><span class="symbol">:phasePressureModel</span><span class="symbol">:</span><span class="symbol">:pPrimef</span>() const</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        g0<span class="constant">_</span></span><br><span class="line">       *min</span><br><span class="line">        (</span><br><span class="line">            exp(preAlphaExp<span class="constant">_</span>*(<span class="symbol">fvc:</span><span class="symbol">:interpolate</span>(this-&gt;alpha<span class="constant">_</span>) - alphaMax<span class="constant">_</span>)),</span><br><span class="line">            expMax<span class="constant">_</span></span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>phasePressure</code> 模型计算的“固相压力”为<br>$$<br>pPrime = g0\cdot \mathrm{min}(e^{preAlphaExp\cdot (\varepsilon_s - \varepsilon_{s,max})},expMax)<br>$$<br>注意这里的$g0$ 与 <code>radialModel</code> 中的$g_0$ 不是一个概念！</p>
<h5 id="2_kineticTheory">2  kineticTheory</h5><p>KTGF 模型， 代码如下：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">  <span class="constant">Foam:</span><span class="symbol">:tmp&lt;Foam</span><span class="symbol">:</span><span class="symbol">:fvVectorMatrix&gt;</span></span><br><span class="line">  <span class="constant">Foam:</span><span class="symbol">:RASModels</span><span class="symbol">:</span><span class="symbol">:kineticTheoryModel</span><span class="symbol">:</span><span class="symbol">:divDevRhoReff</span></span><br><span class="line">  (</span><br><span class="line">     volVectorField&amp; <span class="constant">U</span></span><br><span class="line">  ) const</span><br><span class="line">  &#123;</span><br><span class="line">     <span class="keyword">return</span></span><br><span class="line">     (</span><br><span class="line">       - <span class="symbol">fvm:</span><span class="symbol">:laplacian</span>(this-&gt;rho<span class="constant">_</span>*this-&gt;nut<span class="constant">_</span>, <span class="constant">U)</span></span><br><span class="line">       - <span class="symbol">fvc:</span><span class="symbol">:div</span></span><br><span class="line">         (</span><br><span class="line">             (this-&gt;rho<span class="constant">_</span>*this-&gt;nut<span class="constant">_</span>)*dev2(<span class="constant">T(</span><span class="symbol">fvc:</span><span class="symbol">:grad</span>(<span class="constant">U)</span>))</span><br><span class="line">           + ((this-&gt;rho<span class="constant">_</span>*lambda<span class="constant">_</span>)*<span class="symbol">fvc:</span><span class="symbol">:div</span>(this-&gt;phi<span class="constant">_</span>))</span><br><span class="line">            *dimensioned&lt;symmTensor&gt;(<span class="string">"I"</span>, dimless, <span class="symbol">symmTensor:</span><span class="symbol">:I</span>)</span><br><span class="line">         )</span><br><span class="line">     );</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:tmp&lt;Foam</span><span class="symbol">:</span><span class="symbol">:volScalarField&gt;</span></span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:RASModels</span><span class="symbol">:</span><span class="symbol">:kineticTheoryModel</span><span class="symbol">:</span><span class="symbol">:pPrime</span>() const</span><br><span class="line">&#123;</span><br><span class="line">    <span class="regexp">//</span> <span class="constant">Local </span>references</span><br><span class="line">    const volScalarField&amp; alpha = this-&gt;alpha<span class="constant">_</span>;</span><br><span class="line">    const volScalarField&amp; rho = phase<span class="constant">_</span>.rho();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    (</span><br><span class="line">        <span class="constant">Theta_</span></span><br><span class="line">       *granularPressureModel<span class="constant">_</span>-&gt;granularPressureCoeffPrime</span><br><span class="line">        (</span><br><span class="line">            alpha,</span><br><span class="line">            radialModel<span class="constant">_</span>-&gt;g<span class="number">0</span>(alpha, alphaMinFriction<span class="constant">_</span>, alphaMax<span class="constant">_</span>),</span><br><span class="line">            radialModel<span class="constant">_</span>-&gt;g0prime(alpha, alphaMinFriction<span class="constant">_</span>, alphaMax<span class="constant">_</span>),</span><br><span class="line">            rho,</span><br><span class="line">            e<span class="constant">_</span></span><br><span class="line">        )</span><br><span class="line">     +  frictionalStressModel<span class="constant">_</span>-&gt;frictionalPressurePrime</span><br><span class="line">        (</span><br><span class="line">            alpha,</span><br><span class="line">            alphaMinFriction<span class="constant">_</span>,</span><br><span class="line">            alphaMax<span class="constant">_</span></span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:tmp&lt;Foam</span><span class="symbol">:</span><span class="symbol">:surfaceScalarField&gt;</span></span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:RASModels</span><span class="symbol">:</span><span class="symbol">:kineticTheoryModel</span><span class="symbol">:</span><span class="symbol">:pPrimef</span>() const</span><br><span class="line">&#123;</span><br><span class="line">    <span class="regexp">//</span> <span class="constant">Local </span>references</span><br><span class="line">    const volScalarField&amp; alpha = this-&gt;alpha<span class="constant">_</span>;</span><br><span class="line">    const volScalarField&amp; rho = phase<span class="constant">_</span>.rho();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="symbol">fvc:</span><span class="symbol">:interpolate</span></span><br><span class="line">    (</span><br><span class="line">        <span class="constant">Theta_</span></span><br><span class="line">       *granularPressureModel<span class="constant">_</span>-&gt;granularPressureCoeffPrime</span><br><span class="line">        (</span><br><span class="line">            alpha,</span><br><span class="line">            radialModel<span class="constant">_</span>-&gt;g<span class="number">0</span>(alpha, alphaMinFriction<span class="constant">_</span>, alphaMax<span class="constant">_</span>),</span><br><span class="line">            radialModel<span class="constant">_</span>-&gt;g0prime(alpha, alphaMinFriction<span class="constant">_</span>, alphaMax<span class="constant">_</span>),</span><br><span class="line">            rho,</span><br><span class="line">            e<span class="constant">_</span></span><br><span class="line">        )</span><br><span class="line">     +  frictionalStressModel<span class="constant">_</span>-&gt;frictionalPressurePrime</span><br><span class="line">        (</span><br><span class="line">            alpha,</span><br><span class="line">            alphaMinFriction<span class="constant">_</span>,</span><br><span class="line">            alphaMax<span class="constant">_</span></span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这一部分详细的公式已在 <code>kineticTheoryModel</code> 解读部分分析了，不再赘述。</p>
<h5 id="3_kEpsilon_(OpenFOAM-2-3-x/src/TurbulenceModels/turbulenceModels/RAS/kEpsilon)">3  kEpsilon (<code>OpenFOAM-2.3.x/src/TurbulenceModels/turbulenceModels/RAS/kEpsilon</code>)</h5><p>这个代表的是RAS湍流模型。（其实还有 LES 模型，只是 RAS 与 LES 的 <code>divDevRhoReff</code>函数形式应该是一样的），函数所在代码路径为：<code>OpenFOAM-2.3.x/src/TurbulenceModels/turbulenceModels/eddyViscosity/eddyViscosity.C</code></p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class <span class="constant">BasicTurbulenceModel&gt;</span></span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:tmp&lt;Foam</span><span class="symbol">:</span><span class="symbol">:fvVectorMatrix&gt;</span></span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:eddyViscosity&lt;BasicTurbulenceModel&gt;</span><span class="symbol">:</span><span class="symbol">:divDevRhoReff</span></span><br><span class="line">(</span><br><span class="line">    volVectorField&amp; <span class="constant">U</span></span><br><span class="line">) const</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    (</span><br><span class="line">      - <span class="symbol">fvm:</span><span class="symbol">:laplacian</span>(this-&gt;alpha<span class="constant">_</span>*this-&gt;rho<span class="constant">_</span>*this-&gt;nuEff(), <span class="constant">U)</span></span><br><span class="line">      - <span class="symbol">fvc:</span><span class="symbol">:div</span>((this-&gt;alpha<span class="constant">_</span>*this-&gt;rho<span class="constant">_</span>*this-&gt;nuEff())*dev2(<span class="constant">T(</span><span class="symbol">fvc:</span><span class="symbol">:grad</span>(<span class="constant">U)</span>)))</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>kEpsilon</code> 类中没有重新定义 <code>pPrime()</code> 函数，而是直接继承 <code>PhaseCompressibleTurbulenceModel</code> 类中的定义，返回零，这里就不列出代码了。</p>
<h4 id="湍流模型的调用">湍流模型的调用</h4><p>湍流模型的调用过程，值得看一下，重点是看一下湍流模型类的继承派生关系，以 <code>kineticTheoryModel</code> 为例。<br><code>kineticTheoryModel</code> 类的声明和构造函数部分如下：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> kineticTheoryModel</span><br><span class="line">:</span><br><span class="line">    public eddyViscosity</span><br><span class="line">    &lt;</span><br><span class="line">        RASModel&lt;PhaseCompressibleTurbulenceModel&lt;phaseModel&gt; &gt;</span><br><span class="line">    &gt;</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foam::RASModels::kineticTheoryModel::kineticTheoryModel</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; <span class="keyword">alpha</span>,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; rho,</span><br><span class="line">    <span class="keyword">const</span> volVectorField&amp; <span class="keyword">U</span>,</span><br><span class="line">    <span class="keyword">const</span> surfaceScalarField&amp; alphaRhoPhi,</span><br><span class="line">    <span class="keyword">const</span> surfaceScalarField&amp; phi,</span><br><span class="line">    <span class="keyword">const</span> transportModel&amp; phase,</span><br><span class="line">    <span class="keyword">const</span> word&amp; propertiesName,</span><br><span class="line">    <span class="keyword">const</span> word&amp; <span class="keyword">type</span></span><br><span class="line">)</span><br><span class="line">:</span><br><span class="line">    eddyViscosity&lt;RASModel&lt;PhaseCompressibleTurbulenceModel&lt;phaseModel&gt; &gt; &gt;</span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">type</span>,</span><br><span class="line">        <span class="keyword">alpha</span>,</span><br><span class="line">        rho,</span><br><span class="line">        <span class="keyword">U</span>,</span><br><span class="line">        alphaRhoPhi,</span><br><span class="line">        phi,</span><br><span class="line">        phase,</span><br><span class="line">        propertiesName</span><br><span class="line">    ),</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure></p>
<p>可见， <code>kineticTheoryModel</code> 类继承自 <code>eddyViscosity</code> 类，并且用 <code>RASModel&lt;PhaseCompressibleTurbulenceModel&lt;phaseModel&gt; &gt;</code> 来实例化<code>eddyViscosity</code> 类中的模板参数。</p>
<p>再来看<code>eddyViscosity</code> 类：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> BasicTurbulenceModel&gt;</span><br><span class="line"><span class="keyword">class</span> eddyViscosity</span><br><span class="line">:</span><br><span class="line">    <span class="keyword">public</span> BasicTurbulenceModel</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// Protected data</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">// Fields</span></span><br><span class="line">        volScalarField nut_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Protected Member Functions</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">correctNut</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> BasicTurbulenceModel&gt;</span><br><span class="line">Foam::eddyViscosity&lt;BasicTurbulenceModel&gt;::eddyViscosity</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> word&amp; modelName,</span><br><span class="line">    <span class="keyword">const</span> alphaField&amp; alpha,</span><br><span class="line">    <span class="keyword">const</span> rhoField&amp; rho,</span><br><span class="line">    <span class="keyword">const</span> volVectorField&amp; U,</span><br><span class="line">    <span class="keyword">const</span> surfaceScalarField&amp; alphaRhoPhi,</span><br><span class="line">    <span class="keyword">const</span> surfaceScalarField&amp; phi,</span><br><span class="line">    <span class="keyword">const</span> transportModel&amp; transport,</span><br><span class="line">    <span class="keyword">const</span> word&amp; propertiesName</span><br><span class="line">)</span><br><span class="line">:</span><br><span class="line">    BasicTurbulenceModel</span><br><span class="line">    (</span><br><span class="line">        modelName,</span><br><span class="line">        alpha,</span><br><span class="line">        rho,</span><br><span class="line">        U,</span><br><span class="line">        alphaRhoPhi,</span><br><span class="line">        phi,</span><br><span class="line">        transport,</span><br><span class="line">        propertiesName</span><br><span class="line">    ),</span><br><span class="line"></span><br><span class="line">    nut_</span><br><span class="line">    (</span><br><span class="line">        IOobject</span><br><span class="line">        (</span><br><span class="line">            IOobject::groupName(<span class="string">"nut"</span>, U.group()),</span><br><span class="line">            <span class="keyword">this</span>-&gt;runTime_.timeName(),</span><br><span class="line">            <span class="keyword">this</span>-&gt;mesh_,</span><br><span class="line">            IOobject::MUST_READ,</span><br><span class="line">            IOobject::AUTO_WRITE</span><br><span class="line">        ),</span><br><span class="line">        <span class="keyword">this</span>-&gt;mesh_</span><br><span class="line">    )</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，这里有意思的来了， <code>eddyViscosity</code> 类继承自其模板参数代表的类，具体继承自哪个类，要等模板实例化了才知道。这种用法我还是头一次接触。根据上面 <code>kineticTheoryModel</code> 类的构造函数，可知 <code>eddyViscosity</code> 类在当前分析的情况下，将继承自 <code>RASModel&lt;PhaseCompressibleTurbulenceModel&lt;phaseModel&gt; &gt;</code> 。</p>
<p>继续看 <code>RASModel</code> 类的定义：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">template&lt;<span class="keyword">class</span> BasicTurbulenceModel&gt;</span><br><span class="line"><span class="keyword">class</span> RASModel</span><br><span class="line">:</span><br><span class="line">    public BasicTurbulenceModel</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Protected data</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//- RAS coefficients dictionary</span></span><br><span class="line">        dictionary RASDict_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Turbulence on/off flag</span></span><br><span class="line">        Switch turbulence_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Flag to print the model coeffs at run-time</span></span><br><span class="line">        Switch printCoeffs_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Model coefficients dictionary</span></span><br><span class="line">        dictionary coeffDict_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Lower limit of k</span></span><br><span class="line">        dimensionedScalar kMin_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Lower limit of epsilon</span></span><br><span class="line">        dimensionedScalar epsilonMin_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Lower limit for omega</span></span><br><span class="line">        dimensionedScalar omegaMin_;</span><br><span class="line">      </span><br><span class="line">       ......</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// constructor</span></span><br><span class="line">template&lt;<span class="keyword">class</span> BasicTurbulenceModel&gt;</span><br><span class="line">Foam::RASModel&lt;BasicTurbulenceModel&gt;::RASModel</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> word&amp; <span class="keyword">type</span>,</span><br><span class="line">    <span class="keyword">const</span> alphaField&amp; <span class="keyword">alpha</span>,</span><br><span class="line">    <span class="keyword">const</span> rhoField&amp; rho,</span><br><span class="line">    <span class="keyword">const</span> volVectorField&amp; <span class="keyword">U</span>,</span><br><span class="line">    <span class="keyword">const</span> surfaceScalarField&amp; alphaRhoPhi,</span><br><span class="line">    <span class="keyword">const</span> surfaceScalarField&amp; phi,</span><br><span class="line">    <span class="keyword">const</span> transportModel&amp; transport,</span><br><span class="line">    <span class="keyword">const</span> word&amp; propertiesName</span><br><span class="line">)</span><br><span class="line">:</span><br><span class="line">    BasicTurbulenceModel</span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">alpha</span>,</span><br><span class="line">        rho,</span><br><span class="line">        <span class="keyword">U</span>,</span><br><span class="line">        alphaRhoPhi,</span><br><span class="line">        phi,</span><br><span class="line">        transport,</span><br><span class="line">        propertiesName</span><br><span class="line">    ),</span><br><span class="line"></span><br><span class="line">    RASDict_(this-&gt;subOrEmptyDict(<span class="string">"RAS"</span>)),</span><br><span class="line">    turbulence_(RASDict_.<span class="keyword">lookup</span>(<span class="string">"turbulence"</span>)),</span><br><span class="line">    printCoeffs_(RASDict_.lookupOrDefault&lt;Switch&gt;(<span class="string">"printCoeffs"</span>, false)),</span><br><span class="line">    coeffDict_(RASDict_.subOrEmptyDict(<span class="keyword">type</span> + <span class="string">"Coeffs"</span>)),</span><br><span class="line"></span><br><span class="line">    kMin_</span><br><span class="line">    (</span><br><span class="line">        dimensioned&lt;<span class="keyword">scalar</span>&gt;::lookupOrAddToDict</span><br><span class="line">        (</span><br><span class="line">            <span class="string">"kMin"</span>,</span><br><span class="line">            RASDict_,</span><br><span class="line">            SMALL,</span><br><span class="line">            sqr(dimVelocity)</span><br><span class="line">        )</span><br><span class="line">    ),</span><br><span class="line"></span><br><span class="line">    epsilonMin_</span><br><span class="line">    (</span><br><span class="line">        dimensioned&lt;<span class="keyword">scalar</span>&gt;::lookupOrAddToDict</span><br><span class="line">        (</span><br><span class="line">            <span class="string">"epsilonMin"</span>,</span><br><span class="line">            RASDict_,</span><br><span class="line">            SMALL,</span><br><span class="line">            kMin_.dimensions()/dimTime</span><br><span class="line">        )</span><br><span class="line">    ),</span><br><span class="line"></span><br><span class="line">    omegaMin_</span><br><span class="line">    (</span><br><span class="line">        dimensioned&lt;<span class="keyword">scalar</span>&gt;::lookupOrAddToDict</span><br><span class="line">        (</span><br><span class="line">            <span class="string">"omegaMin"</span>,</span><br><span class="line">            RASDict_,</span><br><span class="line">            SMALL,</span><br><span class="line">            dimless/dimTime</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Force the construction of the mesh deltaCoeffs which may be needed</span></span><br><span class="line">    <span class="comment">// for the construction of the derived models and BCs</span></span><br><span class="line">    this-&gt;mesh_.deltaCoeffs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>RASModel</code> 类也是继承自模板参数代表的类，在这里分析的情况下，模板参数将实例化为 <code>PhaseCompressibleTurbulenceModel&lt;phaseModel&gt;</code> ，所以， <code>RASModel</code> 类也将继承自 <code>PhaseCompressibleTurbulenceModel&lt;phaseModel&gt;</code>。</p>
<p><code>PhaseCompressibleTurbulenceModel</code> 类定义如下：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">TransportModel</span>&gt;</span><br><span class="line">class <span class="type">PhaseCompressibleTurbulenceModel</span></span><br><span class="line">:</span><br><span class="line">    public <span class="type">TurbulenceModel</span></span><br><span class="line">    &lt;</span><br><span class="line">        volScalarField,</span><br><span class="line">        volScalarField,</span><br><span class="line">        compressibleTurbulenceModel,</span><br><span class="line">        <span class="type">TransportModel</span></span><br><span class="line">    &gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    typedef volScalarField alphaField;</span><br><span class="line">    typedef volScalarField rhoField;</span><br><span class="line">    typedef <span class="type">TransportModel</span> transportModel;</span><br><span class="line">    ......</span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;class <span class="type">TransportModel</span>&gt;</span><br><span class="line"><span class="type">Foam</span>::<span class="type">PhaseCompressibleTurbulenceModel</span>&lt;<span class="type">TransportModel</span>&gt;::</span><br><span class="line"><span class="type">PhaseCompressibleTurbulenceModel</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; alpha,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; rho,</span><br><span class="line">    <span class="keyword">const</span> volVectorField&amp; U,</span><br><span class="line">    <span class="keyword">const</span> surfaceScalarField&amp; alphaRhoPhi,</span><br><span class="line">    <span class="keyword">const</span> surfaceScalarField&amp; phi,</span><br><span class="line">    <span class="keyword">const</span> transportModel&amp; transport,</span><br><span class="line">    <span class="keyword">const</span> word&amp; propertiesName</span><br><span class="line">)</span><br><span class="line">:</span><br><span class="line">    <span class="type">TurbulenceModel</span></span><br><span class="line">    &lt;</span><br><span class="line">        volScalarField,</span><br><span class="line">        volScalarField,</span><br><span class="line">        compressibleTurbulenceModel,</span><br><span class="line">        transportModel</span><br><span class="line">    &gt;</span><br><span class="line">    (</span><br><span class="line">        alpha,</span><br><span class="line">        rho,</span><br><span class="line">        U,</span><br><span class="line">        alphaRhoPhi,</span><br><span class="line">        phi,</span><br><span class="line">        transport,</span><br><span class="line">        propertiesName</span><br><span class="line">    )</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>可见， <code>PhaseCompressibleTurbulenceModel</code> 类继承自 <code>TurbulenceModel</code> 类，并且要注意给 <code>TurbulenceModel</code> 的模板代入的实例化参数。</p>
<p>继续深入，来看 <code>TurbulenceModel</code> 的定义，<br><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">template</span><br><span class="line">&lt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Alpha</span>,</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Rho</span>,</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">BasicTurbulenceModel</span>,</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TransportModel</span></span></span><br><span class="line">&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TurbulenceModel</span></span></span><br><span class="line">:</span><br><span class="line">    <span class="keyword">public</span> BasicTurbulenceModel</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    typedef Alpha alphaField;</span><br><span class="line">    typedef Rho rhoField;</span><br><span class="line">    typedef TransportModel transportModel;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line"></span><br><span class="line">    // Protected data</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> alphaField&amp; alpha_;</span><br><span class="line">        <span class="keyword">const</span> transportModel&amp; transport_;</span><br><span class="line">        ......</span><br><span class="line">        ......</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template</span><br><span class="line">&lt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Alpha</span>,</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Rho</span>,</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">BasicTurbulenceModel</span>,</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TransportModel</span></span></span><br><span class="line">&gt;</span><br><span class="line">Foam::TurbulenceModel&lt;Alpha, Rho, BasicTurbulenceModel, TransportModel&gt;::</span><br><span class="line">TurbulenceModel</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> alphaField&amp; alpha,</span><br><span class="line">    <span class="keyword">const</span> rhoField&amp; rho,</span><br><span class="line">    <span class="keyword">const</span> volVectorField&amp; U,</span><br><span class="line">    <span class="keyword">const</span> surfaceScalarField&amp; alphaRhoPhi,</span><br><span class="line">    <span class="keyword">const</span> surfaceScalarField&amp; phi,</span><br><span class="line">    <span class="keyword">const</span> transportModel&amp; transport,</span><br><span class="line">    <span class="keyword">const</span> word&amp; propertiesName</span><br><span class="line">)</span><br><span class="line">:</span><br><span class="line">    BasicTurbulenceModel</span><br><span class="line">    (</span><br><span class="line">        rho,</span><br><span class="line">        U,</span><br><span class="line">        alphaRhoPhi,</span><br><span class="line">        phi,</span><br><span class="line">        propertiesName</span><br><span class="line">    ),</span><br><span class="line">    alpha_(alpha),</span><br><span class="line">    transport_(transport)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p> <code>TurbulenceModel</code> 继承自模板的第三个参数对应的类，从 <code>PhaseCompressibleTurbulenceModel</code> 的定义可知，这里是 <code>compressibleTurbulenceModel</code> 。此外，还要注意这个类有一个数据成员是 <code>alpha_</code>，在派生类的某些地方会调用这个数据成员。</p>
<p>接着再看， <code>compressibleTurbulenceModel</code>，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> compressibleTurbulenceModel</span><br><span class="line">:</span><br><span class="line">    <span class="keyword">public</span> turbulenceModel</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Protected data</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> volScalarField&amp; rho_;</span><br><span class="line">    ......</span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Foam::compressibleTurbulenceModel::compressibleTurbulenceModel</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; rho,</span><br><span class="line">    <span class="keyword">const</span> volVectorField&amp; U,</span><br><span class="line">    <span class="keyword">const</span> surfaceScalarField&amp; alphaRhoPhi,</span><br><span class="line">    <span class="keyword">const</span> surfaceScalarField&amp; phi,</span><br><span class="line">    <span class="keyword">const</span> word&amp; propertiesName</span><br><span class="line">)</span><br><span class="line">:</span><br><span class="line">    turbulenceModel</span><br><span class="line">    (</span><br><span class="line">        U,</span><br><span class="line">        alphaRhoPhi,</span><br><span class="line">        phi,</span><br><span class="line">        propertiesName</span><br><span class="line">    ),</span><br><span class="line">    rho_(rho)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个类继承自 <code>turbulenceModel</code> ，并且有一个数据成员 <code>rho_</code> 。</p>
<p>最底层的是 <code>turbulenceModel</code> 类了，其定义如下：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> turbulenceModel</span><br><span class="line">:</span><br><span class="line">    public IOdictionary</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Protected data</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> Time&amp; runTime_;</span><br><span class="line">        <span class="keyword">const</span> fvMesh&amp; mesh_;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> volVectorField&amp; U_;</span><br><span class="line">        <span class="keyword">const</span> surfaceScalarField&amp; alphaRhoPhi_;</span><br><span class="line">        <span class="keyword">const</span> surfaceScalarField&amp; phi_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Near wall distance boundary field</span></span><br><span class="line">        nearWallDist y_;</span><br><span class="line">        ......</span><br><span class="line">        ......</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Foam::turbulenceModel::turbulenceModel</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> volVectorField&amp; <span class="keyword">U</span>,</span><br><span class="line">    <span class="keyword">const</span> surfaceScalarField&amp; alphaRhoPhi,</span><br><span class="line">    <span class="keyword">const</span> surfaceScalarField&amp; phi,</span><br><span class="line">    <span class="keyword">const</span> word&amp; propertiesName</span><br><span class="line">)</span><br><span class="line">:</span><br><span class="line">    IOdictionary</span><br><span class="line">    (</span><br><span class="line">        IOobject</span><br><span class="line">        (</span><br><span class="line">            IOobject::groupName(propertiesName, <span class="keyword">U</span>.<span class="literal">group</span>()),</span><br><span class="line">            <span class="keyword">U</span>.time().constant(),</span><br><span class="line">            <span class="keyword">U</span>.<span class="keyword">db</span>(),</span><br><span class="line">            IOobject::MUST_READ_IF_MODIFIED,</span><br><span class="line">            IOobject::NO_WRITE</span><br><span class="line">        )</span><br><span class="line">    ),</span><br><span class="line"></span><br><span class="line">    runTime_(<span class="keyword">U</span>.time()),</span><br><span class="line">    mesh_(<span class="keyword">U</span>.mesh()),</span><br><span class="line">    U_(<span class="keyword">U</span>),</span><br><span class="line">    alphaRhoPhi_(alphaRhoPhi),</span><br><span class="line">    phi_(phi),</span><br><span class="line">    y_(mesh_)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个类里定义了数据成员 <code>U_</code>，在 <code>kineticTheoryModel</code> 类中用到了。 </p>
<p>总结一下，湍流模型的继承派生关系如下图（看大图请右键点击图片，选“在新标签页中打开”）：</p>
<p><img src="/image/TFM/turbulenceModel.png" alt=""></p>
<p>像上面这种“类继承其模板参数所代表的类”的用法，在 OpenFOAM 中使用很普遍，最近在看的 thermodynamics 相关的代码里也大量使用了这种模式。不知道这是不是一种 C++ 的 design pattern？这方面我的理解还很浅显。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在 <code>kineticTheoryModel</code> 类的解读时前面提到过， <code>kineticTheoryModel</code> 使用了跟湍流模型一样的接口。这一篇，就来看一下 <code>twoPhaseEulerFoam</code> 中的湍流模型。  </p>]]>
    
    </summary>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/tags/OpenFOAM/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenFOAM-2.3.x 中的 twoPhaseEulerFoam 解析之 kineticTheoryModel 的子模型]]></title>
    <link href="http://xiaopingqiu.github.io/2015/09/19/kineticTheoryModelSubModels/"/>
    <id>http://xiaopingqiu.github.io/2015/09/19/kineticTheoryModelSubModels/</id>
    <published>2015-09-19T03:45:35.000Z</published>
    <updated>2015-11-26T13:38:11.789Z</updated>
    <content type="html"><![CDATA[<p>上一篇博文解读了 <code>kineticTheoryModel</code>  其中提到需要调用子模型来完成其功能，这里将 OpenFOAM 中 <code>kineticTheoryModel</code> 模型的子模型罗列如下。</p>
<a id="more"></a>
<h4 id="1-_viscosityModel">1. viscosityModel</h4><p>viscosityModel 的作用是根据颗粒温度 <code>Theta</code> 来计算固相粘度。<br>基类代码如下，核心是那个返回固相粘度的 <code>nu</code> 函数。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Foam</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">kineticTheoryModels</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------------------------------------------------------------------------*\</span><br><span class="line">                           Class viscosityModel Declaration</span><br><span class="line">\*---------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">viscosityModel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Private member functions</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Disallow default bitwise copy construct</span></span><br><span class="line">        viscosityModel(<span class="keyword">const</span> viscosityModel&amp;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Disallow default bitwise assignment</span></span><br><span class="line">        <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> viscosityModel&amp;);</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Protected data</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> dictionary&amp; dict_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">//- Runtime type information</span></span><br><span class="line">    TypeName(<span class="string">"viscosityModel"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Declare runtime constructor selection table</span></span><br><span class="line">    declareRunTimeSelectionTable</span><br><span class="line">    (</span><br><span class="line">        autoPtr,</span><br><span class="line">        viscosityModel,</span><br><span class="line">        dictionary,</span><br><span class="line">        (</span><br><span class="line">            <span class="keyword">const</span> dictionary&amp; dict</span><br><span class="line">        ),</span><br><span class="line">        (dict)</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// Constructors</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Construct from components</span></span><br><span class="line">        viscosityModel(<span class="keyword">const</span> dictionary&amp; dict);</span><br><span class="line">    <span class="comment">// Selectors</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> autoPtr&lt;viscosityModel&gt; <span class="title">New</span></span><br><span class="line">        <span class="params">(</span><br><span class="line">            <span class="keyword">const</span> dictionary&amp; dict</span><br><span class="line">        )</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//- Destructor</span></span><br><span class="line">    <span class="keyword">virtual</span> ~viscosityModel();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Member Functions</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> tmp&lt;volScalarField&gt; <span class="title">nu</span></span><br><span class="line">        <span class="params">(</span><br><span class="line">            <span class="keyword">const</span> volScalarField&amp; alpha1,</span><br><span class="line">            <span class="keyword">const</span> volScalarField&amp; Theta,</span><br><span class="line">            <span class="keyword">const</span> volScalarField&amp; g0,</span><br><span class="line">            <span class="keyword">const</span> volScalarField&amp; rho1,</span><br><span class="line">            <span class="keyword">const</span> volScalarField&amp; da,</span><br><span class="line">            <span class="keyword">const</span> dimensionedScalar&amp; e</span><br><span class="line">        )</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">read</span><span class="params">()</span></span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>2.3.x 版自带四种固相粘度模型，分别如下：</p>
<h5 id="1-1_none">1.1 none</h5><p>顾名思义，这个模型计算的固相粘度值为零。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意这里的 kineticTheoryModels 不是类名，而是命名空间</span></span><br><span class="line">Foam::tmp&lt;Foam::volScalarField&gt; Foam::kineticTheoryModels::noneViscosity::nu </span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; alpha1,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; Theta,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; g0,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; rho1,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; da,</span><br><span class="line">    <span class="keyword">const</span> dimensionedScalar&amp; e</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> dimensionedScalar</span><br><span class="line">    (</span><br><span class="line">        <span class="string">"0"</span>,</span><br><span class="line">        dimensionSet(<span class="number">0</span>, <span class="number">2</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">        <span class="number">0.0</span></span><br><span class="line">    )*alpha1; <span class="comment">// 返回 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="1-2_Syamlal_模型">1.2 Syamlal 模型</h5><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Foam<span class="type-annotation">::</span>tmp&lt;Foam<span class="type-annotation">::</span>volScalarField&gt;</span><br><span class="line">Foam<span class="type-annotation">::</span>kineticTheoryModels<span class="type-annotation">::</span>viscosityModels<span class="type-annotation">::</span>Syamlal<span class="type-annotation">::</span>nu</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; alpha1,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; Theta,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; g0,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; rho1,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; da,</span><br><span class="line">    <span class="keyword">const</span> dimensionedScalar&amp; <span class="literal">e</span></span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> scalar sqrtPi = sqrt(constant<span class="type-annotation">::</span>mathematical<span class="type-annotation">::</span><span class="literal">pi</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> da*sqrt(Theta)*</span><br><span class="line">    (</span><br><span class="line">        (<span class="number">4.0</span>/<span class="number">5.0</span>)*sqr(alpha1)*g0*(<span class="number">1.0</span> + <span class="literal">e</span>)/sqrtPi</span><br><span class="line">      + (<span class="number">1.0</span>/<span class="number">15.0</span>)*sqrtPi*g0*(<span class="number">1.0</span> + <span class="literal">e</span>)*(<span class="number">3.0</span>*<span class="literal">e</span> - <span class="number">1.0</span>)*sqr(alpha1)/(<span class="number">3.0</span> - <span class="literal">e</span>)</span><br><span class="line">      + (<span class="number">1.0</span>/<span class="number">6.0</span>)*alpha1*sqrtPi/(<span class="number">3.0</span> - <span class="literal">e</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>公式为<br>$$<br>\nu_s = d_p \sqrt{\Theta}\left[ \frac{4}{5}\varepsilon_s^2 g_0  \frac{(1+e)}{\sqrt{\pi}} + \frac{1}{15} \sqrt{\pi} \cdot g_0 \varepsilon_s^2\frac{(1+e)(3e-1)}{\sqrt{\pi}} + \frac{1}{6}\varepsilon_s \frac{\sqrt{\pi}}{3-e}\right ]<br>$$<br>其中$g_0$是由 径向分布模型计算得到的。</p>
<h5 id="1-3_HrenyaSinclair_模型">1.3  HrenyaSinclair 模型</h5><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">//- Characteristic length of geometry</span><br><span class="line">        dimensionedScalar L_; // 新定义的一个变量，</span><br><span class="line">        </span><br><span class="line"> // 构造函数       </span><br><span class="line">Foam<span class="type-annotation">::</span>kineticTheoryModels<span class="type-annotation">::</span>viscosityModels<span class="type-annotation">::</span>HrenyaSinclair<span class="type-annotation">::</span>HrenyaSinclair</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> dictionary&amp; dict</span><br><span class="line">)</span><br><span class="line">:</span><br><span class="line">    viscosityModel(dict),</span><br><span class="line">    coeffDict_(dict.subDict(typeName + <span class="string">"Coeffs"</span>)),</span><br><span class="line">    L_(<span class="string">"L"</span>, dimensionSet(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), coeffDict_.lookup(<span class="string">"L"</span>)) // 从外部读取 L_ 的值</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">Foam<span class="type-annotation">::</span>tmp&lt;Foam<span class="type-annotation">::</span>volScalarField&gt;</span><br><span class="line">Foam<span class="type-annotation">::</span>kineticTheoryModels<span class="type-annotation">::</span>viscosityModels<span class="type-annotation">::</span>HrenyaSinclair<span class="type-annotation">::</span>nu</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; alpha1,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; Theta,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; g0,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; rho1,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; da,</span><br><span class="line">    <span class="keyword">const</span> dimensionedScalar&amp; <span class="literal">e</span></span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> scalar sqrtPi = sqrt(constant<span class="type-annotation">::</span>mathematical<span class="type-annotation">::</span><span class="literal">pi</span>);</span><br><span class="line"></span><br><span class="line">    volScalarField lamda</span><br><span class="line">    (</span><br><span class="line">        scalar(<span class="number">1</span>) + da/(<span class="number">6.0</span>*sqrt(<span class="number">2.0</span>)*(alpha1 + scalar(<span class="number">1.0e-5</span>)))/L_</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> da*sqrt(Theta)*</span><br><span class="line">    (</span><br><span class="line">        (<span class="number">4.0</span>/<span class="number">5.0</span>)*sqr(alpha1)*g0*(<span class="number">1.0</span> + <span class="literal">e</span>)/sqrtPi</span><br><span class="line">      + (<span class="number">1.0</span>/<span class="number">15.0</span>)*sqrtPi*g0*(<span class="number">1.0</span> + <span class="literal">e</span>)*(<span class="number">3.0</span>*<span class="literal">e</span> - <span class="number">1</span>)*sqr(alpha1)/(<span class="number">3.0</span>-<span class="literal">e</span>)</span><br><span class="line">      + (<span class="number">1.0</span>/<span class="number">6.0</span>)*sqrtPi*alpha1*(<span class="number">0.5</span>*lamda + <span class="number">0.25</span>*(<span class="number">3.0</span>*<span class="literal">e</span> - <span class="number">1.0</span>))</span><br><span class="line">       /(<span class="number">0.5</span>*(<span class="number">3.0</span> - <span class="literal">e</span>)*lamda)</span><br><span class="line">      + (<span class="number">10</span>/<span class="number">96.0</span>)*sqrtPi/((<span class="number">1.0</span> + <span class="literal">e</span>)*<span class="number">0.5</span>*(<span class="number">3.0</span> - <span class="literal">e</span>)*g0*lamda)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>公式如下<br>$$<br>\begin{aligned}<br>\nu_s = &amp; d_p \sqrt{\Theta} \, [ \frac{4}{5} \varepsilon_s \cdot g_0 \frac{1+e}{\sqrt{\pi}} + \frac{1}{15}\sqrt{\pi} \cdot g_0 \varepsilon_s^2 \frac{(1+e)(3e-1)}{3-e} \\<br> + &amp; \frac{1}{6} \sqrt{\pi} \cdot \frac{0.5\lambda +  0.25(3e-1)}{0.5(3-e)\lambda} \varepsilon_s + \frac{10}{96}\sqrt{\pi}\cdot \frac{1}{0.5(1+e)(3-e)g_0\cdot \lambda}  ]<br>\end{aligned}<br>$$<br>其中<br>$$<br>\lambda = 1+\frac{d_p}{6\sqrt{2}\cdot \varepsilon_s}\cdot \frac{1}{L}<br>$$</p>
<h5 id="1-4_Gidaspow_模型">1.4 Gidaspow 模型</h5><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Foam<span class="type-annotation">::</span>tmp&lt;Foam<span class="type-annotation">::</span>volScalarField&gt;</span><br><span class="line">Foam<span class="type-annotation">::</span>kineticTheoryModels<span class="type-annotation">::</span>viscosityModels<span class="type-annotation">::</span>Gidaspow<span class="type-annotation">::</span>nu</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; alpha1,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; Theta,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; g0,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; rho1,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; da,</span><br><span class="line">    <span class="keyword">const</span> dimensionedScalar&amp; <span class="literal">e</span></span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> scalar sqrtPi = sqrt(constant<span class="type-annotation">::</span>mathematical<span class="type-annotation">::</span><span class="literal">pi</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> da*sqrt(Theta)*</span><br><span class="line">    (</span><br><span class="line">        (<span class="number">4.0</span>/<span class="number">5.0</span>)*sqr(alpha1)*g0*(<span class="number">1.0</span> + <span class="literal">e</span>)/sqrtPi</span><br><span class="line">      + (<span class="number">1.0</span>/<span class="number">15.0</span>)*sqrtPi*g0*(<span class="number">1.0</span> + <span class="literal">e</span>)*sqr(alpha1)</span><br><span class="line">      + (<span class="number">1.0</span>/<span class="number">6.0</span>)*sqrtPi*alpha1</span><br><span class="line">      + (<span class="number">10.0</span>/<span class="number">96.0</span>)*sqrtPi/((<span class="number">1.0</span> + <span class="literal">e</span>)*g0)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$$<br>\nu_s = d_p\sqrt{\Theta}\left [ \frac{4}{5} \varepsilon_s^2 g_0\cdot \frac{(1+e)}{\sqrt{\pi}}  + \frac{1}{15} \sqrt{\pi}\cdot g_0(1+e)\varepsilon_s^2 + \frac{1}{6} \sqrt{\pi}\cdot \varepsilon_s^2 + \frac{10}{96} \frac{\sqrt{\pi}}{(1+e)g_0}\right ]<br>$$</p>
<h4 id="2-_radialModel">2. radialModel</h4><p>这个类的作用是计算径向分布函数 <code>g0</code> </p>
<p>有三种 radialModel 可以选择：</p>
<h5 id="2-1_SinclairJackson">2.1 SinclairJackson</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Foam::tmp&lt;Foam::volScalarField&gt;</span><br><span class="line">Foam::kineticTheoryModels::radialModels::SinclairJackson::g0</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; alpha,</span><br><span class="line">    <span class="keyword">const</span> dimensionedScalar&amp; alphaMinFriction,</span><br><span class="line">    <span class="keyword">const</span> dimensionedScalar&amp; alphaMax</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span>/(<span class="number">1.0</span> - cbrt(min(alpha, alphaMinFriction)/alphaMax));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Foam::tmp&lt;Foam::volScalarField&gt;</span><br><span class="line">Foam::kineticTheoryModels::radialModels::SinclairJackson::g0prime</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; alpha,</span><br><span class="line">    <span class="keyword">const</span> dimensionedScalar&amp; alphaMinFriction,</span><br><span class="line">    <span class="keyword">const</span> dimensionedScalar&amp; alphaMax</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">volScalarField <span class="title">aByaMax</span></span><br><span class="line">    <span class="params">(</span><br><span class="line">        cbrt(min(max(alpha, scalar(1e-3)</span>), alphaMinFriction)/alphaMax)</span><br><span class="line">    )</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span>/(<span class="number">3</span>*alphaMax))/sqr(aByaMax - sqr(aByaMax));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$$<br>g_0 = \frac{1}{1-\sqrt[3]{\frac{min(\varepsilon_s, \varepsilon_{s,min})}{\varepsilon_{s,max}}}}<br>$$</p>
<p> <code>g0Prime</code> 为 <code>g0</code> 对  <code>alpha</code> 的导数 </p>
<p>$$<br>g_{0Prime} = \frac{\partial g_0}{\partial \varepsilon_s} = \frac{\frac{1}{3\cdot \varepsilon_{s,max}}}{(aByaMax-aByaMax^2)^2}<br>$$</p>
<p>其中</p>
<p>$$<br>aByaMax=\sqrt[3]{\frac{min(\varepsilon_s,\varepsilon_{s,min})}{\varepsilon_{s,max}}}<br>$$</p>
<h5 id="2-2_LunSavage">2.2 LunSavage</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Foam::tmp&lt;Foam::volScalarField&gt;</span><br><span class="line">Foam::kineticTheoryModels::radialModels::LunSavage::g0</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; alpha,</span><br><span class="line">    <span class="keyword">const</span> dimensionedScalar&amp; alphaMinFriction,</span><br><span class="line">    <span class="keyword">const</span> dimensionedScalar&amp; alphaMax</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">1.0</span> - alpha/alphaMax, -<span class="number">2.5</span>*alphaMax);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Foam::tmp&lt;Foam::volScalarField&gt;</span><br><span class="line">Foam::kineticTheoryModels::radialModels::LunSavage::g0prime</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; alpha,</span><br><span class="line">    <span class="keyword">const</span> dimensionedScalar&amp; alphaMinFriction,</span><br><span class="line">    <span class="keyword">const</span> dimensionedScalar&amp; alphaMax</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2.5</span>*<span class="built_in">pow</span>(<span class="number">1.0</span> - alpha/alphaMax, -<span class="number">2.5</span>*alphaMax - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$$<br>g_0 = \left( 1-\frac{\varepsilon_s}{\varepsilon_{s,max}}\right)^{-2.5\,\varepsilon_{s,max}}<br>$$</p>
<h5 id="2-3_CarnahanStarling_模型">2.3 CarnahanStarling 模型</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Foam::tmp&lt;Foam::volScalarField&gt;</span><br><span class="line">Foam::kineticTheoryModels::radialModels::CarnahanStarling::g0</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; alpha,</span><br><span class="line">    <span class="keyword">const</span> dimensionedScalar&amp; alphaMinFriction,</span><br><span class="line">    <span class="keyword">const</span> dimensionedScalar&amp; alphaMax</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        <span class="number">1.0</span>/(<span class="number">1.0</span> - alpha)</span><br><span class="line">      + <span class="number">3.0</span>*alpha/(<span class="number">2.0</span>*sqr(<span class="number">1.0</span> - alpha))</span><br><span class="line">      + sqr(alpha)/(<span class="number">2.0</span>*pow3(<span class="number">1.0</span> - alpha));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Foam::tmp&lt;Foam::volScalarField&gt;</span><br><span class="line">Foam::kineticTheoryModels::radialModels::CarnahanStarling::g0prime</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; alpha,</span><br><span class="line">    <span class="keyword">const</span> dimensionedScalar&amp; alphaMinFriction,</span><br><span class="line">    <span class="keyword">const</span> dimensionedScalar&amp; alphaMax</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        <span class="number">2.5</span>/sqr(<span class="number">1.0</span> - alpha)</span><br><span class="line">      + <span class="number">4.0</span>*alpha/pow3(<span class="number">1.0</span> - alpha)</span><br><span class="line">      + <span class="number">1.5</span>*sqr(alpha)/pow4(<span class="number">1.0</span> - alpha);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$$<br>g_0 = \frac{1}{1-\varepsilon_s} + \frac{3\varepsilon_s}{2(1-\varepsilon_s)^2} + \frac{\varepsilon_s^2}{2(1-\varepsilon_s)^3}<br>$$</p>
<h4 id="3-_granularPressureModel">3. granularPressureModel</h4><p>顾名思义，这个类是用来计算固相压力的。</p>
<p>OpenFOAM 内置两种固相压力模型：</p>
<h5 id="3-1_Lun_模型">3.1 Lun 模型</h5><p><code>granularPressureCoeff</code> 返回的是固相压力的系数，这个返回值乘以颗粒温度 <code>Theta</code> 才是固相压力。<br><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Foam<span class="type-annotation">::</span>tmp&lt;Foam<span class="type-annotation">::</span>volScalarField&gt;</span><br><span class="line">Foam<span class="type-annotation">::</span>kineticTheoryModels<span class="type-annotation">::</span>granularPressureModels<span class="type-annotation">::</span>Lun<span class="type-annotation">::</span>granularPressureCoeff</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; alpha1,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; g0,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; rho1,</span><br><span class="line">    <span class="keyword">const</span> dimensionedScalar&amp; <span class="literal">e</span></span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rho1*alpha1*(<span class="number">1.0</span> + <span class="number">2.0</span>*(<span class="number">1.0</span> + <span class="literal">e</span>)*alpha1*g0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Foam<span class="type-annotation">::</span>tmp&lt;Foam<span class="type-annotation">::</span>volScalarField&gt;</span><br><span class="line">Foam<span class="type-annotation">::</span>kineticTheoryModels<span class="type-annotation">::</span>granularPressureModels<span class="type-annotation">::</span>Lun<span class="type-annotation">::</span></span><br><span class="line">granularPressureCoeffPrime</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; alpha1,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; g0,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; g0prime,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; rho1,</span><br><span class="line">    <span class="keyword">const</span> dimensionedScalar&amp; <span class="literal">e</span></span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> rho1*(<span class="number">1.0</span> + alpha1*(<span class="number">1.0</span> + <span class="literal">e</span>)*(<span class="number">4.0</span>*g0 + <span class="number">2.0</span>*g0prime*alpha1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>$$<br>P_{s,coeff} = \rho\varepsilon_s[1+2(1+e)\varepsilon_sg_0]<br>$$</p>
<p><code>granularPressureCoeffPrime</code> 函数计算的是 $\partial P_{s,coeff}/\partial \varepsilon_s$ 。</p>
<h5 id="3-2_SyamlalRogersOBrien_模型">3.2 SyamlalRogersOBrien 模型</h5><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Foam<span class="type-annotation">::</span>tmp&lt;Foam<span class="type-annotation">::</span>volScalarField&gt;</span><br><span class="line">Foam<span class="type-annotation">::</span>kineticTheoryModels<span class="type-annotation">::</span>granularPressureModels<span class="type-annotation">::</span>SyamlalRogersOBrien<span class="type-annotation">::</span></span><br><span class="line">granularPressureCoeff</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; alpha1,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; g0,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; rho1,</span><br><span class="line">    <span class="keyword">const</span> dimensionedScalar&amp; <span class="literal">e</span></span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2.0</span>*rho1*(<span class="number">1.0</span> + <span class="literal">e</span>)*sqr(alpha1)*g0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Foam<span class="type-annotation">::</span>tmp&lt;Foam<span class="type-annotation">::</span>volScalarField&gt;</span><br><span class="line">Foam<span class="type-annotation">::</span>kineticTheoryModels<span class="type-annotation">::</span>granularPressureModels<span class="type-annotation">::</span>SyamlalRogersOBrien<span class="type-annotation">::</span></span><br><span class="line">granularPressureCoeffPrime</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; alpha1,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; g0,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; g0prime,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; rho1,</span><br><span class="line">    <span class="keyword">const</span> dimensionedScalar&amp; <span class="literal">e</span></span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> rho1*alpha1*(<span class="number">1.0</span> + <span class="literal">e</span>)*(<span class="number">4.0</span>*g0 + <span class="number">2.0</span>*g0prime*alpha1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$$<br>P_{s,coeff} = 2\rho(1+e)\varepsilon_s^2\cdot g_0<br>$$</p>
<h4 id="4-_frictionalStressModel">4. frictionalStressModel</h4><p>在稠密气固两相流中，当固相体积分率大于某个值时，单纯考虑跟颗粒温度关联的固相压力和固相粘性还不够，还需要考虑所谓的摩擦应力。这个类就是用来计算摩擦应力的。</p>
<p>有两种模型可选：</p>
<h5 id="4-1_Schaeffer_模型">4.1 Schaeffer 模型</h5><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">Foam::kineticTheoryModels::frictionalStressModels::Schaeffer::Schaeffer</span><br><span class="line">(</span><br><span class="line">    const dictionary&amp; dict</span><br><span class="line">)</span><br><span class="line">:</span><br><span class="line">    frictionalStressModel(dict),</span><br><span class="line">    coeffDict_(dict.subDict(typeName + <span class="string">"Coeffs"</span>)),</span><br><span class="line">    phi_(<span class="string">"phi"</span>, dimless, coeffDict_.lookup(<span class="string">"phi"</span>))</span><br><span class="line">&#123;</span><br><span class="line">    phi_ <span class="keyword">*</span>= constant::mathematical::pi/180.0; </span><br><span class="line">    // 这个phi_是一个角度，从外部读取，在外部设置的时候，按角度的单位来设置，这里是将角度转换成弧度。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> Destructor  <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> //</span><br><span class="line"></span><br><span class="line">Foam::kineticTheoryModels::frictionalStressModels::Schaeffer::~Schaeffer()</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> Member Functions  <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> //</span><br><span class="line"></span><br><span class="line">Foam::tmp<span class="variable">&lt;Foam::volScalarField&gt;</span></span><br><span class="line">Foam::kineticTheoryModels::frictionalStressModels::Schaeffer::</span><br><span class="line">frictionalPressure</span><br><span class="line">(</span><br><span class="line">    const volScalarField&amp; alpha1,</span><br><span class="line">    const dimensionedScalar&amp; alphaMinFriction,</span><br><span class="line">    const dimensionedScalar&amp; alphaMax</span><br><span class="line">) const</span><br><span class="line">&#123;</span><br><span class="line">    return</span><br><span class="line">        dimensionedScalar(<span class="string">"1e24"</span>, dimensionSet(1, -1, -2, 0, 0), 1e24)</span><br><span class="line">       <span class="keyword">*</span>pow(Foam::max(alpha1 - alphaMinFriction, scalar(0)), 10.0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foam::tmp<span class="variable">&lt;Foam::volScalarField&gt;</span></span><br><span class="line">Foam::kineticTheoryModels::frictionalStressModels::Schaeffer::</span><br><span class="line">frictionalPressurePrime</span><br><span class="line">(</span><br><span class="line">    const volScalarField&amp; alpha1,</span><br><span class="line">    const dimensionedScalar&amp; alphaMinFriction,</span><br><span class="line">    const dimensionedScalar&amp; alphaMax</span><br><span class="line">) const</span><br><span class="line">&#123;</span><br><span class="line">    return</span><br><span class="line">        dimensionedScalar(<span class="string">"1e25"</span>, dimensionSet(1, -1, -2, 0, 0), 1e25)</span><br><span class="line">       <span class="keyword">*</span>pow(Foam::max(alpha1 - alphaMinFriction, scalar(0)), 9.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$$<br>P_{f} = 10^{24}\cdot max(\varepsilon_s-\varepsilon_{s,friMin},0)^{10}<br>$$<br> 同前面一样，<code>frictionalPressurePrime</code> 是  <code>frictionalPressure</code> 对固相体积分率的导数。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">Foam::tmp&lt;Foam::volScalarField&gt;</span><br><span class="line">Foam::kineticTheoryModels::frictionalStressModels::Schaeffer::nu</span><br><span class="line">(</span><br><span class="line">    const volScalarField&amp; alpha1,</span><br><span class="line">    const dimensionedScalar&amp; alphaMax,</span><br><span class="line">    const volScalarField&amp; pf,</span><br><span class="line">    const volSymmTensorField&amp; D</span><br><span class="line">) const</span><br><span class="line">&#123;</span><br><span class="line">    const <span class="keyword">scalar</span> I2Dsmall = <span class="number">1.0</span>e-<span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">    <span class="regexp">//</span> Creating nu assuming it should be <span class="number">0</span> on the boundary which may <span class="keyword">not</span> be</span><br><span class="line">    // true</span><br><span class="line">    tmp&lt;volScalarField&gt; tnu</span><br><span class="line">    (</span><br><span class="line">        new volScalarField</span><br><span class="line">        (</span><br><span class="line">            IOobject</span><br><span class="line">            (</span><br><span class="line">                <span class="string">"Schaeffer:nu"</span>,</span><br><span class="line">                alpha1.mesh().<span class="keyword">time</span>().timeName(),</span><br><span class="line">                alpha1.mesh(),</span><br><span class="line">                IOobject::NO_READ,</span><br><span class="line">                IOobject::NO_WRITE,</span><br><span class="line">                false</span><br><span class="line">            ),</span><br><span class="line">            alpha1.mesh(),</span><br><span class="line">            dimensionedScalar(<span class="string">"nu"</span>, dimensionSet(<span class="number">0</span>, <span class="number">2</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">0</span>.<span class="number">0</span>)</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    volScalarField&amp; nuf = tnu();</span><br><span class="line"></span><br><span class="line">    forAll (D, celli)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (alpha1[celli] &gt; alphaMax.value() - <span class="number">5</span>e-<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nuf[celli] =</span><br><span class="line">                <span class="number">0</span>.<span class="number">5</span>*pf[celli]*<span class="keyword">sin</span>(phi<span class="number">_</span>.value())</span><br><span class="line">               /(</span><br><span class="line">                    <span class="keyword">sqrt</span>(<span class="number">1.0</span>/<span class="number">6.0</span>*(<span class="keyword">s</span><span class="string">qr(D[celli].xx()</span> - D[celli].yy())</span><br><span class="line">                  + <span class="keyword">s</span><span class="string">qr(D[celli].yy()</span> - D[celli].zz())</span><br><span class="line">                  + <span class="keyword">s</span><span class="string">qr(D[celli].zz()</span> - D[celli].xx()))</span><br><span class="line">                  + <span class="keyword">s</span><span class="string">qr(D[celli].xy()</span>) + <span class="keyword">s</span><span class="string">qr(D[celli].xz()</span>)</span><br><span class="line">                  + <span class="keyword">s</span><span class="string">qr(D[celli].yz()</span>)) + I2Dsmall</span><br><span class="line">                );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Correct coupled BCs</span><br><span class="line">    nuf.correctBoundaryConditions();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tnu;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$$<br>\nu_f = \left \{ \begin{aligned}<br> &amp; 0 ,  &amp;\varepsilon_s \le \varepsilon_{s,max} \\<br>&amp; \frac{0.5p_f sin\phi}{\sqrt{I_{2d}}}, &amp; \varepsilon_s > \varepsilon_{s,max}<br>\end{aligned} \right .<br>$$</p>
<p>其中，$p_f$ 代表的是上面的 <code>frictionalPressure</code><br>$$<br>D = \frac{1}{2}(\nabla U + \nabla U^T)<br>$$</p>
<p>$$<br>\sqrt{I_{2D}} = \frac{1}{6}[(D_{11}-D_{22})^2 + (D_{22}-D_{33})^2 + (D_{33}-D_{11})^2] + D_{12}^2 + D_{13}^2 + D_{23}^2<br>$$</p>
<h5 id="4-2_JohnsonJackson_模型">4.2 JohnsonJackson 模型</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> JohnsonJackson</span><br><span class="line">:</span><br><span class="line">    <span class="keyword">public</span> frictionalStressModel</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Private data</span></span><br><span class="line"></span><br><span class="line">        dictionary coeffDict_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Material constant for frictional normal stress</span></span><br><span class="line">        dimensionedScalar Fr_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Material constant for frictional normal stress</span></span><br><span class="line">        dimensionedScalar eta_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Material constant for frictional normal stress</span></span><br><span class="line">        dimensionedScalar p_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Angle of internal friction</span></span><br><span class="line">        dimensionedScalar phi_;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">Foam::kineticTheoryModels::frictionalStressModels::JohnsonJackson::</span><br><span class="line">JohnsonJackson</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> dictionary&amp; dict</span><br><span class="line">)</span><br><span class="line">:</span><br><span class="line">    frictionalStressModel(dict),</span><br><span class="line">    coeffDict_(dict.subDict(typeName + <span class="string">"Coeffs"</span>)),</span><br><span class="line">    Fr_(<span class="string">"Fr"</span>, dimensionSet(<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>), coeffDict_.lookup(<span class="string">"Fr"</span>)),</span><br><span class="line">    eta_(<span class="string">"eta"</span>, dimless, coeffDict_.lookup(<span class="string">"eta"</span>)),</span><br><span class="line">    p_(<span class="string">"p"</span>, dimless, coeffDict_.lookup(<span class="string">"p"</span>)),</span><br><span class="line">    phi_(<span class="string">"phi"</span>, dimless, coeffDict_.lookup(<span class="string">"phi"</span>))</span><br><span class="line">&#123;</span><br><span class="line">    phi_ *= constant::mathematical::pi/<span class="number">180.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// * * * * * * * * * * * * * * * Member Functions  * * * * * * * * * * * * * //</span></span><br><span class="line"></span><br><span class="line">Foam::tmp&lt;Foam::volScalarField&gt;</span><br><span class="line">Foam::kineticTheoryModels::frictionalStressModels::JohnsonJackson::</span><br><span class="line">frictionalPressure</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; alpha1,</span><br><span class="line">    <span class="keyword">const</span> dimensionedScalar&amp; alphaMinFriction,</span><br><span class="line">    <span class="keyword">const</span> dimensionedScalar&amp; alphaMax</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        Fr_*<span class="built_in">pow</span>(max(alpha1 - alphaMinFriction, scalar(<span class="number">0</span>)), eta_)</span><br><span class="line">       /<span class="built_in">pow</span>(max(alphaMax - alpha1, scalar(<span class="number">5.0e-2</span>)), p_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Foam::tmp&lt;Foam::volScalarField&gt;</span><br><span class="line">Foam::kineticTheoryModels::frictionalStressModels::JohnsonJackson::</span><br><span class="line">frictionalPressurePrime</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; alpha1,</span><br><span class="line">    <span class="keyword">const</span> dimensionedScalar&amp; alphaMinFriction,</span><br><span class="line">    <span class="keyword">const</span> dimensionedScalar&amp; alphaMax</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Fr_*</span><br><span class="line">    (</span><br><span class="line">        eta_*<span class="built_in">pow</span>(max(alpha1 - alphaMinFriction, scalar(<span class="number">0</span>)), eta_ - <span class="number">1.0</span>)</span><br><span class="line">       *(alphaMax-alpha1)</span><br><span class="line">      + p_*<span class="built_in">pow</span>(max(alpha1 - alphaMinFriction, scalar(<span class="number">0</span>)), eta_)</span><br><span class="line">    )/<span class="built_in">pow</span>(max(alphaMax - alpha1, scalar(<span class="number">5.0e-2</span>)), p_ + <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Foam::tmp&lt;Foam::volScalarField&gt;</span><br><span class="line">Foam::kineticTheoryModels::frictionalStressModels::JohnsonJackson::nu</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; alpha1,</span><br><span class="line">    <span class="keyword">const</span> dimensionedScalar&amp; alphaMax,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; pf,</span><br><span class="line">    <span class="keyword">const</span> volSymmTensorField&amp; D</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> dimensionedScalar(<span class="string">"0.5"</span>, dimTime, <span class="number">0.5</span>)*pf*<span class="built_in">sin</span>(phi_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个模型的特点是需要设置一些跟材料有关的参数。<br>$$<br>P_{f} = F_r \frac{max(\varepsilon_s-\varepsilon_{s,friMin},0)^{\eta}}{max(\varepsilon_{s,max}-\varepsilon_{s},0)^{p}}<br>$$</p>
<p>$$<br>\nu_f = 0.5\cdot p_fsin\phi<br>$$<br>一些材料的物性参数建议值可参见”Derivation, Implementation and Validation of Computer Simulation Models for Gas-Solids Fluidized Beds” Table-3.5。</p>
<h4 id="5-_conductivityModel">5. conductivityModel</h4><p>这个类的作用是计算 颗粒温度方程中的颗粒温度传导系数，只有在使用偏微分方程求解颗粒温度是才会用到。</p>
<p>有三种可选：</p>
<h5 id="5-1_Syamlal_模型">5.1 Syamlal 模型</h5><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Foam<span class="type-annotation">::</span>tmp&lt;Foam<span class="type-annotation">::</span>volScalarField&gt;</span><br><span class="line">Foam<span class="type-annotation">::</span>kineticTheoryModels<span class="type-annotation">::</span>conductivityModels<span class="type-annotation">::</span>Syamlal<span class="type-annotation">::</span>kappa</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; alpha1,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; Theta,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; g0,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; rho1,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; da,</span><br><span class="line">    <span class="keyword">const</span> dimensionedScalar&amp; <span class="literal">e</span></span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> scalar sqrtPi = sqrt(constant<span class="type-annotation">::</span>mathematical<span class="type-annotation">::</span><span class="literal">pi</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rho1*da*sqrt(Theta)*</span><br><span class="line">    (</span><br><span class="line">        <span class="number">2.0</span>*sqr(alpha1)*g0*(<span class="number">1.0</span> + <span class="literal">e</span>)/sqrtPi</span><br><span class="line">      + (<span class="number">9.0</span>/<span class="number">8.0</span>)*sqrtPi*g0*<span class="number">0.25</span>*sqr(<span class="number">1.0</span> + <span class="literal">e</span>)*(<span class="number">2.0</span>*<span class="literal">e</span> - <span class="number">1.0</span>)*sqr(alpha1)</span><br><span class="line">       /(<span class="number">49.0</span>/<span class="number">16.0</span> - <span class="number">33.0</span>*<span class="literal">e</span>/<span class="number">16.0</span>)</span><br><span class="line">      + (<span class="number">15.0</span>/<span class="number">32.0</span>)*sqrtPi*alpha1/(<span class="number">49.0</span>/<span class="number">16.0</span> - <span class="number">33.0</span>*<span class="literal">e</span>/<span class="number">16.0</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$$<br>\kappa = \rho d_p \sqrt{\Theta}\left [ 2 \varepsilon_s^2 g_0 \frac{1+e}{\sqrt{\pi}} + \frac{\frac{9}{8} \sqrt{\pi}g_0 \cdot 0.25(1+e)^2(2e-1)\varepsilon_s^2}{49/16-33e/16} + \frac{\frac{15}{32}\sqrt{\pi} \cdot \varepsilon_s }{49/16-33e/16} \right ]<br>$$</p>
<h5 id="5-2_HrenyaSinclair_模型">5.2 HrenyaSinclair 模型</h5><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">Foam::kineticTheoryModels::conductivityModels::HrenyaSinclair::HrenyaSinclair</span><br><span class="line">(</span><br><span class="line">    const dictionary&amp; dict</span><br><span class="line">)</span><br><span class="line">:</span><br><span class="line">    conductivityModel(dict),</span><br><span class="line">    coeffDict_(dict.subDict(typeName + <span class="string">"Coeffs"</span>)),</span><br><span class="line">    L_(<span class="string">"L"</span>, dimensionSet(0, 1, 0, 0, 0), coeffDict_.lookup(<span class="string">"L"</span>))</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> Destructor  <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> //</span><br><span class="line"></span><br><span class="line">Foam::kineticTheoryModels::conductivityModels::HrenyaSinclair::</span><br><span class="line">~HrenyaSinclair()</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> Member Functions  <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> //</span><br><span class="line"></span><br><span class="line">Foam::tmp<span class="variable">&lt;Foam::volScalarField&gt;</span></span><br><span class="line">Foam::kineticTheoryModels::conductivityModels::HrenyaSinclair::kappa</span><br><span class="line">(</span><br><span class="line">    const volScalarField&amp; alpha1,</span><br><span class="line">    const volScalarField&amp; Theta,</span><br><span class="line">    const volScalarField&amp; g0,</span><br><span class="line">    const volScalarField&amp; rho1,</span><br><span class="line">    const volScalarField&amp; da,</span><br><span class="line">    const dimensionedScalar&amp; e</span><br><span class="line">) const</span><br><span class="line">&#123;</span><br><span class="line">    const scalar sqrtPi = sqrt(constant::mathematical::pi);</span><br><span class="line"></span><br><span class="line">    volScalarField lamda</span><br><span class="line">    (</span><br><span class="line">        scalar(1) + da/(6.0<span class="keyword">*</span>sqrt(2.0)<span class="keyword">*</span>(alpha1 + scalar(1.0e-5)))/L_</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    return rho1<span class="keyword">*</span>da<span class="keyword">*</span>sqrt(Theta)<span class="keyword">*</span></span><br><span class="line">    (</span><br><span class="line">        2.0<span class="keyword">*</span>sqr(alpha1)<span class="keyword">*</span>g0<span class="keyword">*</span>(1.0 + e)/sqrtPi</span><br><span class="line">      + (9.0/8.0)<span class="keyword">*</span>sqrtPi<span class="keyword">*</span>g0<span class="keyword">*</span>0.25<span class="keyword">*</span>sqr(1.0 + e)<span class="keyword">*</span>(2.0<span class="keyword">*</span>e - 1.0)<span class="keyword">*</span>sqr(alpha1)</span><br><span class="line">       /(49.0/16.0 - 33.0<span class="keyword">*</span>e/16.0)</span><br><span class="line">      + (15.0/16.0)<span class="keyword">*</span>sqrtPi<span class="keyword">*</span>alpha1<span class="keyword">*</span>(0.5<span class="keyword">*</span>sqr(e) + 0.25<span class="keyword">*</span>e - 0.75 + lamda)</span><br><span class="line">       /((49.0/16.0 - 33.0<span class="keyword">*</span>e/16.0)<span class="keyword">*</span>lamda)</span><br><span class="line">      + (25.0/64.0)<span class="keyword">*</span>sqrtPi</span><br><span class="line">       /((1.0 + e)<span class="keyword">*</span>(49.0/16.0 - 33.0<span class="keyword">*</span>e/16.0)<span class="keyword">*</span>lamda<span class="keyword">*</span>g0)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个模型需要输入一个特征长度 L。<br>$$<br>\begin{aligned} \kappa = \ &amp; \rho d_p \sqrt{\Theta} \, [  2\varepsilon_s^2 g_0 \frac{1+e}{\sqrt{\pi}} + \frac{\frac{9}{8} \sqrt{\pi}g_0 \cdot 0.25(1+e)^2(2e-1)\varepsilon_s^2}{49/16-33e/16} \\<br>\ + &amp;\frac{\frac{15}{16}\sqrt{\pi} \varepsilon_s \cdot (0.5e^2+0.25e-0.75+\lambda) }{(49/16-33e/16)\lambda} + \frac{\frac{25}{64}\sqrt{\pi}}{(1+e)(49/16-33e/16)\lambda g_0}<br>  ] \end{aligned}<br>$$</p>
<p>其中<br>$$<br>\lambda = 1+\frac{d_p}{6\sqrt{2}\varepsilon_s L}<br>$$</p>
<h5 id="5-3_Gidaspow_模型">5.3 Gidaspow 模型</h5><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Foam<span class="type-annotation">::</span>tmp&lt;Foam<span class="type-annotation">::</span>volScalarField&gt;</span><br><span class="line">Foam<span class="type-annotation">::</span>kineticTheoryModels<span class="type-annotation">::</span>conductivityModels<span class="type-annotation">::</span>Gidaspow<span class="type-annotation">::</span>kappa</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; alpha1,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; Theta,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; g0,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; rho1,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; da,</span><br><span class="line">    <span class="keyword">const</span> dimensionedScalar&amp; <span class="literal">e</span></span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> scalar sqrtPi = sqrt(constant<span class="type-annotation">::</span>mathematical<span class="type-annotation">::</span><span class="literal">pi</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rho1*da*sqrt(Theta)*</span><br><span class="line">    (</span><br><span class="line">        <span class="number">2.0</span>*sqr(alpha1)*g0*(<span class="number">1.0</span> + <span class="literal">e</span>)/sqrtPi</span><br><span class="line">      + (<span class="number">9.0</span>/<span class="number">8.0</span>)*sqrtPi*g0*<span class="number">0.5</span>*(<span class="number">1.0</span> + <span class="literal">e</span>)*sqr(alpha1)</span><br><span class="line">      + (<span class="number">15.0</span>/<span class="number">16.0</span>)*sqrtPi*alpha1</span><br><span class="line">      + (<span class="number">25.0</span>/<span class="number">64.0</span>)*sqrtPi/((<span class="number">1.0</span> + <span class="literal">e</span>)*g0)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$$<br>\kappa =  \rho d_p \sqrt{\Theta}\left [  2 \varepsilon_s^2 g_0 \frac{1+e}{\sqrt{\pi}}  + \frac{9}{8}\sqrt{\pi}g_0\cdot 0.5(1+e)\varepsilon_s^2  + \frac{15}{16}\sqrt{\pi} \varepsilon_s +\frac{25}{64}\frac{\sqrt{\pi}}{(1+e)g_0}\right ]<br>$$</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>上一篇博文解读了 <code>kineticTheoryModel</code>  其中提到需要调用子模型来完成其功能，这里将 OpenFOAM 中 <code>kineticTheoryModel</code> 模型的子模型罗列如下。</p>]]>
    
    </summary>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/tags/OpenFOAM/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenFOAM-2.3.x 中的 twoPhaseEulerFoam 解析之 kineticTheoryModel]]></title>
    <link href="http://xiaopingqiu.github.io/2015/09/19/kineticTheoryModel/"/>
    <id>http://xiaopingqiu.github.io/2015/09/19/kineticTheoryModel/</id>
    <published>2015-09-19T02:26:09.000Z</published>
    <updated>2015-09-25T09:14:38.738Z</updated>
    <content type="html"><![CDATA[<p>OpenFOAM 中双流体模型的 kineticTheoryModel 是以 “ <em>Derivation, implementation, and validation of computer simulation models for gas-solid fluidized beds</em>, B.G.M. van Wachem, Ph.D. Thesis, Delft University of Technology, Amsterdam, 2000. “ 为蓝本来设计的，下面分析这个类的代码。需要注意的是，这个类需要调用一些别的类（如 viscosityModel 等，后面会一一分析）来完成其功能。</p>
<a id="more"></a>
<h4 id="1-_头文件_kineticTheoryModel-H">1. 头文件 kineticTheoryModel.H</h4><p>头文件中要注意的是 kineticTheoryModel 类的继承关系，以及六个子类的智能指针作为 kineticTheoryModel 类的数据成员。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class kineticTheoryModel</span><br><span class="line">:</span><br><span class="line">    <span class="keyword">public</span> eddyViscosity</span><br><span class="line">    <span class="subst">&lt;</span></span><br><span class="line">        RASModel<span class="subst">&lt;</span>PhaseCompressibleTurbulenceModel<span class="subst">&lt;</span>phaseModel<span class="subst">&gt;</span> <span class="subst">&gt;</span></span><br><span class="line">    <span class="subst">&gt;</span> <span class="comment">// 继承自湍流类，所以这里 kineticTheoryModel 跟湍流类使用同样的接口</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Private data</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Input Fields</span></span><br><span class="line">            const phaseModel<span class="subst">&amp;</span> phase_;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// Sub-models </span></span><br><span class="line">	<span class="comment">// 下面五个 sub models 是kineticTheoryModel类为了实现其功能需要调用的类。</span></span><br><span class="line">	<span class="comment">//子类的智能指针定义为当前类的数据成员。注意这里的 "kineticTheoryModels" 是 namespace。</span></span><br><span class="line">        </span><br><span class="line">            <span class="comment">//- Run-time selected viscosity model</span></span><br><span class="line">            autoPtr<span class="subst">&lt;</span>kineticTheoryModels<span class="tag">::viscosityModel</span><span class="subst">&gt;</span> viscosityModel_;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//- Run-time selected conductivity model</span></span><br><span class="line">            autoPtr<span class="subst">&lt;</span>kineticTheoryModels<span class="tag">::conductivityModel</span><span class="subst">&gt;</span> conductivityModel_;</span><br><span class="line">            <span class="comment">//- Run-time selected radial distribution model</span></span><br><span class="line">            autoPtr<span class="subst">&lt;</span>kineticTheoryModels<span class="tag">::radialModel</span><span class="subst">&gt;</span> radialModel_;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//- Run-time selected granular pressure model</span></span><br><span class="line">            autoPtr<span class="subst">&lt;</span>kineticTheoryModels<span class="tag">::granularPressureModel</span><span class="subst">&gt;</span></span><br><span class="line">                granularPressureModel_;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//- Run-time selected frictional stress model</span></span><br><span class="line">            autoPtr<span class="subst">&lt;</span>kineticTheoryModels<span class="tag">::frictionalStressModel</span><span class="subst">&gt;</span></span><br><span class="line">                frictionalStressModel_;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">...</span><span class="attribute">...</span></span><br><span class="line">  <span class="attribute">...</span><span class="attribute">...</span></span><br></pre></td></tr></table></figure>
<h4 id="2-_构造函数">2. 构造函数</h4><p>注意这里向基类传递的参数，这里的湍流类的继承关系比较复杂，比单相湍流复杂很多，后面会有具体的分析<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">Foam::RASModels::kineticTheoryModel::kineticTheoryModel</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; alpha,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; rho,</span><br><span class="line">    <span class="keyword">const</span> volVectorField&amp; U,</span><br><span class="line">    <span class="keyword">const</span> surfaceScalarField&amp; alphaRhoPhi,</span><br><span class="line">    <span class="keyword">const</span> surfaceScalarField&amp; phi,</span><br><span class="line">    <span class="keyword">const</span> transportModel&amp; phase,</span><br><span class="line">    <span class="keyword">const</span> word&amp; propertiesName,</span><br><span class="line">    <span class="keyword">const</span> word&amp; type</span><br><span class="line">)</span><br><span class="line">:</span><br><span class="line">    eddyViscosity&lt;RASModel&lt;PhaseCompressibleTurbulenceModel&lt;phaseModel&gt; &gt; &gt;</span><br><span class="line">    (</span><br><span class="line">        type,</span><br><span class="line">        alpha,</span><br><span class="line">        rho,</span><br><span class="line">        U,</span><br><span class="line">        alphaRhoPhi,</span><br><span class="line">        phi,</span><br><span class="line">        phase,</span><br><span class="line">        propertiesName</span><br><span class="line">    ),</span><br><span class="line"></span><br><span class="line">    phase_(phase),</span><br><span class="line"></span><br><span class="line">    viscosityModel_</span><br><span class="line">    (</span><br><span class="line">        kineticTheoryModels::viscosityModel::New</span><br><span class="line">        (</span><br><span class="line">            <span class="keyword">this</span>-&gt;coeffDict_ <span class="comment">// coeffDict_ 是 RASModel的成员</span></span><br><span class="line">        )</span><br><span class="line">    ),</span><br><span class="line">    conductivityModel_</span><br><span class="line">    (</span><br><span class="line">        kineticTheoryModels::conductivityModel::New</span><br><span class="line">        (</span><br><span class="line">            <span class="keyword">this</span>-&gt;coeffDict_</span><br><span class="line">        )</span><br><span class="line">    ),</span><br><span class="line">    radialModel_</span><br><span class="line">    (</span><br><span class="line">        kineticTheoryModels::radialModel::New</span><br><span class="line">        (</span><br><span class="line">            <span class="keyword">this</span>-&gt;coeffDict_</span><br><span class="line">        )</span><br><span class="line">    ),</span><br><span class="line">    granularPressureModel_</span><br><span class="line">    (</span><br><span class="line">        kineticTheoryModels::granularPressureModel::New</span><br><span class="line">        (</span><br><span class="line">            <span class="keyword">this</span>-&gt;coeffDict_</span><br><span class="line">        )</span><br><span class="line">    ),</span><br><span class="line">    frictionalStressModel_</span><br><span class="line">    (</span><br><span class="line">        kineticTheoryModels::frictionalStressModel::New</span><br><span class="line">        (</span><br><span class="line">            <span class="keyword">this</span>-&gt;coeffDict_</span><br><span class="line">        )</span><br><span class="line">    ),</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">......</span><br></pre></td></tr></table></figure></p>
<h4 id="3-_主要成员函数">3. 主要成员函数</h4><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> Member Functions  <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> //</span><br><span class="line"></span><br><span class="line">Foam::tmp<span class="variable">&lt;Foam::volScalarField&gt;</span></span><br><span class="line">Foam::RASModels::kineticTheoryModel::k() const</span><br><span class="line">&#123;</span><br><span class="line">    // notImplemented 是 Error.H中定义的一个函数，用于提示某个模型或函数没有实现。</span><br><span class="line">    notImplemented(<span class="string">"kineticTheoryModel::k()"</span>); </span><br><span class="line">    return nut_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Foam::tmp<span class="variable">&lt;Foam::volScalarField&gt;</span></span><br><span class="line">Foam::RASModels::kineticTheoryModel::epsilon() const</span><br><span class="line">&#123;</span><br><span class="line">    notImplemented(<span class="string">"kineticTheoryModel::epsilon()"</span>);</span><br><span class="line">    return nut_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <code>k</code> 和  <code>epsilon</code> 是两个从基类继承下来的函数，这两个函数在基类中是纯虚函数，所以虽然 kineticTheoryModel 用不到它们，但是还是需要进行定义，否则 kineticTheoryModel 类就将是一个虚基类，从而无法创建对象了。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="constant">Foam:</span><span class="symbol">:tmp&lt;Foam</span><span class="symbol">:</span><span class="symbol">:volSymmTensorField&gt;</span></span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:RASModels</span><span class="symbol">:</span><span class="symbol">:kineticTheoryModel</span><span class="symbol">:</span><span class="symbol">:R</span>() const</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> tmp&lt;volSymmTensorField&gt;</span><br><span class="line">    (</span><br><span class="line">        new volSymmTensorField</span><br><span class="line">        (</span><br><span class="line">            <span class="constant">IOobject</span></span><br><span class="line">            (</span><br><span class="line">                <span class="constant">IOobject:</span><span class="symbol">:groupName</span>(<span class="string">"R"</span>, this-&gt;<span class="constant">U_.</span>group()),</span><br><span class="line">                this-&gt;runTime<span class="constant">_</span>.timeName(),</span><br><span class="line">                this-&gt;mesh<span class="constant">_</span>,</span><br><span class="line">                <span class="constant">IOobject:</span><span class="symbol">:NO_READ</span>,</span><br><span class="line">                <span class="constant">IOobject:</span><span class="symbol">:NO_WRITE</span></span><br><span class="line">            ),</span><br><span class="line">          - (this-&gt;nut<span class="constant">_</span>)*dev(twoSymm(<span class="symbol">fvc:</span><span class="symbol">:grad</span>(this-&gt;<span class="constant">U_)</span>))</span><br><span class="line">          - (lambda<span class="constant">_</span>*<span class="symbol">fvc:</span><span class="symbol">:div</span>(this-&gt;phi<span class="constant">_</span>))*<span class="symbol">symmTensor:</span><span class="symbol">:I</span></span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>R 函数返回所谓的雷诺应力，其实跟单相湍流类的 R 函数返回值有点差别：<br>$$<br>-\nu_t[\nabla U + \nabla U^T-\frac{2}{3}(\nabla \cdot U)\cdot \mathrm{I}] - \lambda(\nabla \cdot U)\cdot \mathrm{I}<br>$$<br>这里的 R 与下面的 devRoReff 函数返回值只相差一个 rho。<br>而单相湍流模型的 R 则为：<br>$$<br>\frac{2}{3}k\cdot \mathrm{I}- \nu_t (\nabla U + \nabla U^T)<br>$$</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:tmp&lt;Foam</span><span class="symbol">:</span><span class="symbol">:volScalarField&gt;</span></span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:RASModels</span><span class="symbol">:</span><span class="symbol">:kineticTheoryModel</span><span class="symbol">:</span><span class="symbol">:pPrime</span>() const</span><br><span class="line">&#123;</span><br><span class="line">    <span class="regexp">//</span> <span class="constant">Local </span>references</span><br><span class="line">    const volScalarField&amp; alpha = this-&gt;alpha<span class="constant">_</span>;</span><br><span class="line">    const volScalarField&amp; rho = phase<span class="constant">_</span>.rho();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    (</span><br><span class="line">        <span class="constant">Theta_</span></span><br><span class="line">       *granularPressureModel<span class="constant">_</span>-&gt;granularPressureCoeffPrime</span><br><span class="line">        (</span><br><span class="line">            alpha,</span><br><span class="line">            radialModel<span class="constant">_</span>-&gt;g<span class="number">0</span>(alpha, alphaMinFriction<span class="constant">_</span>, alphaMax<span class="constant">_</span>),</span><br><span class="line">            radialModel<span class="constant">_</span>-&gt;g0prime(alpha, alphaMinFriction<span class="constant">_</span>, alphaMax<span class="constant">_</span>),</span><br><span class="line">            rho,</span><br><span class="line">            e<span class="constant">_</span></span><br><span class="line">        )</span><br><span class="line">     +  frictionalStressModel<span class="constant">_</span>-&gt;frictionalPressurePrime</span><br><span class="line">        (</span><br><span class="line">            alpha,</span><br><span class="line">            alphaMinFriction<span class="constant">_</span>,</span><br><span class="line">            alphaMax<span class="constant">_</span></span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:tmp&lt;Foam</span><span class="symbol">:</span><span class="symbol">:surfaceScalarField&gt;</span></span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:RASModels</span><span class="symbol">:</span><span class="symbol">:kineticTheoryModel</span><span class="symbol">:</span><span class="symbol">:pPrimef</span>() const</span><br><span class="line">&#123;</span><br><span class="line">    <span class="regexp">//</span> <span class="constant">Local </span>references</span><br><span class="line">    const volScalarField&amp; alpha = this-&gt;alpha<span class="constant">_</span>;</span><br><span class="line">    const volScalarField&amp; rho = phase<span class="constant">_</span>.rho();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="symbol">fvc:</span><span class="symbol">:interpolate</span></span><br><span class="line">    (</span><br><span class="line">        <span class="constant">Theta_</span></span><br><span class="line">       *granularPressureModel<span class="constant">_</span>-&gt;granularPressureCoeffPrime</span><br><span class="line">        (</span><br><span class="line">            alpha,</span><br><span class="line">            radialModel<span class="constant">_</span>-&gt;g<span class="number">0</span>(alpha, alphaMinFriction<span class="constant">_</span>, alphaMax<span class="constant">_</span>),</span><br><span class="line">            radialModel<span class="constant">_</span>-&gt;g0prime(alpha, alphaMinFriction<span class="constant">_</span>, alphaMax<span class="constant">_</span>),</span><br><span class="line">            rho,</span><br><span class="line">            e<span class="constant">_</span></span><br><span class="line">        )</span><br><span class="line">     +  frictionalStressModel<span class="constant">_</span>-&gt;frictionalPressurePrime</span><br><span class="line">        (</span><br><span class="line">            alpha,</span><br><span class="line">            alphaMinFriction<span class="constant">_</span>,</span><br><span class="line">            alphaMax<span class="constant">_</span></span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>pPrime 和 pPrimef 两个函数，返回的是固相压力对固相孔隙率的导数（$\partial P_s/\partial \varepsilon_s$）。</p>
<p>两个在”UEqn.H” 被动量方程调用的函数<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="constant">Foam:</span><span class="symbol">:tmp&lt;Foam</span><span class="symbol">:</span><span class="symbol">:volSymmTensorField&gt;</span></span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:RASModels</span><span class="symbol">:</span><span class="symbol">:kineticTheoryModel</span><span class="symbol">:</span><span class="symbol">:devRhoReff</span>() const</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> tmp&lt;volSymmTensorField&gt;</span><br><span class="line">    (</span><br><span class="line">        new volSymmTensorField</span><br><span class="line">        (</span><br><span class="line">            <span class="constant">IOobject</span></span><br><span class="line">            (</span><br><span class="line">                <span class="constant">IOobject:</span><span class="symbol">:groupName</span>(<span class="string">"devRhoReff"</span>, this-&gt;<span class="constant">U_.</span>group()),</span><br><span class="line">                this-&gt;runTime<span class="constant">_</span>.timeName(),</span><br><span class="line">                this-&gt;mesh<span class="constant">_</span>,</span><br><span class="line">                <span class="constant">IOobject:</span><span class="symbol">:NO_READ</span>,</span><br><span class="line">                <span class="constant">IOobject:</span><span class="symbol">:NO_WRITE</span></span><br><span class="line">            ),</span><br><span class="line">          - (this-&gt;rho<span class="constant">_</span>*this-&gt;nut<span class="constant">_</span>)</span><br><span class="line">           *dev(twoSymm(<span class="symbol">fvc:</span><span class="symbol">:grad</span>(this-&gt;<span class="constant">U_)</span>))</span><br><span class="line">          - ((this-&gt;rho<span class="constant">_</span>*lambda<span class="constant">_</span>)*<span class="symbol">fvc:</span><span class="symbol">:div</span>(this-&gt;phi<span class="constant">_</span>))*<span class="symbol">symmTensor:</span><span class="symbol">:I</span></span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:tmp&lt;Foam</span><span class="symbol">:</span><span class="symbol">:fvVectorMatrix&gt;</span></span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:RASModels</span><span class="symbol">:</span><span class="symbol">:kineticTheoryModel</span><span class="symbol">:</span><span class="symbol">:divDevRhoReff</span></span><br><span class="line">(</span><br><span class="line">    volVectorField&amp; <span class="constant">U</span></span><br><span class="line">) const</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    (</span><br><span class="line">      - <span class="symbol">fvm:</span><span class="symbol">:laplacian</span>(this-&gt;rho<span class="constant">_</span>*this-&gt;nut<span class="constant">_</span>, <span class="constant">U)</span></span><br><span class="line">      - <span class="symbol">fvc:</span><span class="symbol">:div</span></span><br><span class="line">        (</span><br><span class="line">            (this-&gt;rho<span class="constant">_</span>*this-&gt;nut<span class="constant">_</span>)*dev2(<span class="constant">T(</span><span class="symbol">fvc:</span><span class="symbol">:grad</span>(<span class="constant">U)</span>))</span><br><span class="line">          + ((this-&gt;rho<span class="constant">_</span>*lambda<span class="constant">_</span>)*<span class="symbol">fvc:</span><span class="symbol">:div</span>(this-&gt;phi<span class="constant">_</span>))</span><br><span class="line">           *dimensioned&lt;symmTensor&gt;(<span class="string">"I"</span>, dimless, <span class="symbol">symmTensor:</span><span class="symbol">:I</span>)</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对应的公式分别为：<br><strong>devRhoReff</strong><br>$$<br>- \rho  \nu_t \cdot dev(\nabla U + \nabla U^T) - \rho \lambda(\nabla \cdot U)\cdot  \mathrm{I} \\<br> = - \rho  \nu_t(\nabla U + \nabla U^T) +  \rho  \nu_t \frac{2}{3}(\nabla \cdot U)\cdot \mathrm{I} - \rho \lambda (\nabla \cdot U)\cdot  \mathrm{I}<br>$$</p>
<p><strong>divDevRhoReff</strong><br>$$<br>\ - \nabla \cdot (\rho \nu_t \nabla U) - \nabla \cdot \left [\rho \nu_t \nabla U^T\ - \rho \nu_t \frac{2}{3}(\nabla \cdot U)\cdot \mathrm{I} \right ] + \rho \lambda (\nabla \cdot U) \cdot \mathrm{I} )<br>$$</p>
<p> <code>correct</code>是计算颗粒温度 <code>Theta</code> 的函数，这是 kineticTheoryModel 类最重要的部分。<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br></pre></td><td class="code"><pre><span class="line">void Foam::RASModels::kineticTheoryModel::correct()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Local references</span></span><br><span class="line">    volScalarField <span class="keyword">alpha</span>(<span class="literal">max</span>(this-&gt;alpha_, <span class="literal">scalar</span>(0)));</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; rho = phase_.rho();</span><br><span class="line">    <span class="keyword">const</span> surfaceScalarField&amp; alphaRhoPhi = this-&gt;alphaRhoPhi_;</span><br><span class="line">    <span class="keyword">const</span> volVectorField&amp; <span class="keyword">U</span> = this-&gt;U_; <span class="comment">// 当前相的速度</span></span><br><span class="line">    <span class="keyword">const</span> volVectorField&amp; Uc_ = phase_.fluid().otherPhase(phase_).<span class="keyword">U</span>(); <span class="comment">// 另一相的速度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">scalar</span> sqrtPi = <span class="literal">sqrt</span>(constant::mathematical::pi);</span><br><span class="line">    dimensionedScalar ThetaSmall(<span class="string">"ThetaSmall"</span>, Theta_.dimensions(), 1.0e-6);</span><br><span class="line">    dimensionedScalar ThetaSmallSqrt(<span class="literal">sqrt</span>(ThetaSmall));</span><br><span class="line"></span><br><span class="line">    tmp&lt;volScalarField&gt; tda(phase_.<span class="literal">d</span>()); <span class="comment">// 颗粒直径</span></span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; da = tda();</span><br><span class="line"></span><br><span class="line">    tmp&lt;volTensorField&gt; tgradU(fvc::grad(this-&gt;U_));</span><br><span class="line">    <span class="keyword">const</span> volTensorField&amp; gradU(tgradU());</span><br><span class="line">    volSymmTensorField <span class="literal">D</span>(symm(gradU));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Calculating the radial distribution function </span></span><br><span class="line">    <span class="comment">// 调用 radialModel 类 来计算径向分布函数</span></span><br><span class="line">    gs0_ = radialModel_-&gt;g0(<span class="keyword">alpha</span>, alphaMinFriction_, alphaMax_);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!equilibrium_) <span class="comment">// 如果 equilibrium_ = off ，那么将用这个偏微分方程来计算颗粒温度，否则将改用一个代数方程，见下文</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Particle viscosity (Table 3.2, p.47)</span></span><br><span class="line">	<span class="comment">// 调用viscosityModel 来更新颗粒相的粘度</span></span><br><span class="line">        nut_ = viscosityModel_-&gt;nu(<span class="keyword">alpha</span>, Theta_, gs0_, rho, da, e_);</span><br><span class="line"></span><br><span class="line">        volScalarField ThetaSqrt(<span class="literal">sqrt</span>(Theta_));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Bulk viscosity  p. 45 (Lun et al. 1984). </span></span><br><span class="line">        lambda_ = (4.0/3.0)*sqr(<span class="keyword">alpha</span>)*da*gs0_*(1.0 + e_)*ThetaSqrt/sqrtPi;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Stress tensor, Definitions, Table 3.1, p. 43</span></span><br><span class="line">        volSymmTensorField tau <span class="comment">// 颗粒应力</span></span><br><span class="line">        (</span><br><span class="line">            rho*(2.0*nut_*<span class="keyword">D</span> + (lambda_ - (2.0/3.0)*nut_)*tr(<span class="keyword">D</span>)*I)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Dissipation (Eq. 3.24, p.50)</span></span><br><span class="line">        volScalarField gammaCoeff <span class="comment">//颗粒动能耗散项</span></span><br><span class="line">        (</span><br><span class="line">            12.0*(1.0 - sqr(e_))</span><br><span class="line"><span class="comment">           *max(sqr(alpha), residualAlpha_)</span></span><br><span class="line"><span class="comment">           *rho*gs0_*(1.0/da)*ThetaSqrt/sqrtPi</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Drag // 调用曳力模型计算曳力系数</span></span><br><span class="line">        volScalarField beta(phase_.fluid().drag(phase_).K());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Eq. 3.25, p. 50 Js = J1 - J2</span></span><br><span class="line">        volScalarField J1(3.0*beta);</span><br><span class="line">        volScalarField J2</span><br><span class="line">        (</span><br><span class="line">            0.25*sqr(beta)*da*magSqr(<span class="keyword">U</span> - Uc_)</span><br><span class="line">           /(</span><br><span class="line">               <span class="literal">max</span>(<span class="keyword">alpha</span>, residualAlpha_)*rho</span><br><span class="line"><span class="comment">              *sqrtPi*(ThetaSqrt + ThetaSmallSqrt)</span></span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// particle pressure - coefficient in front of Theta (Eq. 3.22, p. 45)</span></span><br><span class="line">        volScalarField PsCoeff</span><br><span class="line">        (</span><br><span class="line">            granularPressureModel_-&gt;granularPressureCoeff</span><br><span class="line">            (</span><br><span class="line">                <span class="keyword">alpha</span>,</span><br><span class="line">                gs0_,</span><br><span class="line">                rho,</span><br><span class="line">                e_</span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 'thermal' conductivity (Table 3.3, p. 49)</span></span><br><span class="line">	<span class="comment">// 调用 conductivityModel 计算颗粒脉动能量的传导系数</span></span><br><span class="line">        kappa_ = conductivityModel_-&gt;<span class="keyword">kappa</span>(<span class="keyword">alpha</span>, Theta_, gs0_, rho, da, e_);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Construct the granular temperature equation (Eq. 3.20, p. 44)</span></span><br><span class="line">        <span class="comment">// NB. note that there are two typos in Eq. 3.20:</span></span><br><span class="line">        <span class="comment">//     Ps should be without grad</span></span><br><span class="line">        <span class="comment">//     the laplacian has the wrong sign</span></span><br><span class="line">	<span class="comment">// 构建颗粒温度方程，注意，开头提到的文献里的颗粒温度方程有两处 typo，</span></span><br><span class="line">	<span class="comment">//下面的代码修复了这两处错误，后文会给出正确的公式。</span></span><br><span class="line">        fvScalarMatrix ThetaEqn</span><br><span class="line">        (</span><br><span class="line">            1.5*</span><br><span class="line">            (</span><br><span class="line">                fvm::ddt(<span class="keyword">alpha</span>, rho, Theta_)</span><br><span class="line">              + fvm::div(alphaRhoPhi, Theta_)</span><br><span class="line">              - fvc::Sp(fvc::ddt(<span class="keyword">alpha</span>, rho) + fvc::div(alphaRhoPhi), Theta_)</span><br><span class="line">            )</span><br><span class="line">          - fvm::laplacian(kappa_, Theta_, <span class="string">"laplacian(kappa,Theta)"</span>)</span><br><span class="line">         ==</span><br><span class="line">            fvm::SuSp(-((PsCoeff*I) &amp;&amp; gradU), Theta_)</span><br><span class="line">          + (tau &amp;&amp; gradU)</span><br><span class="line">          + fvm::Sp(-gammaCoeff, Theta_)</span><br><span class="line">          + fvm::Sp(-J1, Theta_)</span><br><span class="line">          + fvm::Sp(J2/(Theta_ + ThetaSmall), Theta_)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        ThetaEqn.relax();</span><br><span class="line">        ThetaEqn.solve();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 如果 equilibrium = on， 将使用一个代数方程来计算颗粒温度。</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Equilibrium =&gt; dissipation == production</span></span><br><span class="line">        <span class="comment">// Eq. 4.14, p.82</span></span><br><span class="line">        volScalarField K1(2.0*(1.0 + e_)*rho*gs0_);</span><br><span class="line">        volScalarField K3</span><br><span class="line">        (</span><br><span class="line">            0.5*da*rho*</span><br><span class="line">            (</span><br><span class="line">                (sqrtPi/(3.0*(3.0 - e_)))</span><br><span class="line"><span class="comment">               *(1.0 + 0.4*(1.0 + e_)*(3.0*e_ - 1.0)*alpha*gs0_)</span></span><br><span class="line">               +1.6*<span class="keyword">alpha</span>*gs0_*(1.0 + e_)/sqrtPi</span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        volScalarField K2</span><br><span class="line">        (</span><br><span class="line">            4.0*da*rho*(1.0 + e_)*<span class="keyword">alpha</span>*gs0_/(3.0*sqrtPi) - 2.0*K3/3.0</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        volScalarField K4(12.0*(1.0 - sqr(e_))*rho*gs0_/(da*sqrtPi));</span><br><span class="line"></span><br><span class="line">        volScalarField trD</span><br><span class="line">        (</span><br><span class="line">            <span class="keyword">alpha</span>/(<span class="keyword">alpha</span> + residualAlpha_)</span><br><span class="line"><span class="comment">           *fvc::div(this-&gt;phi_)</span></span><br><span class="line">        );</span><br><span class="line">        volScalarField tr2D(sqr(trD));</span><br><span class="line">        volScalarField trD2(tr(<span class="keyword">D</span> &amp; <span class="keyword">D</span>));</span><br><span class="line"></span><br><span class="line">        volScalarField t1(K1*<span class="keyword">alpha</span> + rho);</span><br><span class="line">        volScalarField l1(-t1*trD);</span><br><span class="line">        volScalarField l2(sqr(t1)*tr2D);</span><br><span class="line">        volScalarField l3</span><br><span class="line">        (</span><br><span class="line">            4.0</span><br><span class="line"><span class="comment">           *K4</span></span><br><span class="line"><span class="comment">           *alpha</span></span><br><span class="line"><span class="comment">           *(2.0*K3*trD2 + K2*tr2D)</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        Theta_ = sqr</span><br><span class="line">        (</span><br><span class="line">            (l1 + <span class="literal">sqrt</span>(l2 + l3))</span><br><span class="line">           /(2.0*<span class="literal">max</span>(<span class="keyword">alpha</span>, residualAlpha_)*K4)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        kappa_ = conductivityModel_-&gt;<span class="keyword">kappa</span>(<span class="keyword">alpha</span>, Theta_, gs0_, rho, da, e_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 限定 颗粒温度的上下限。</span></span><br><span class="line">  <span class="comment">// max 和 min 函数的定义，没有找到。经验证， max 的作用是让小于0的归零， min 是让大于100的等于100。</span></span><br><span class="line">    Theta_.<span class="literal">max</span>(0);</span><br><span class="line">    Theta_.<span class="literal">min</span>(100);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">	<span class="comment">//利用先得到的颗粒温度更新颗粒相的粘度</span></span><br><span class="line">        <span class="comment">// particle viscosity (Table 3.2, p.47)</span></span><br><span class="line">        nut_ = viscosityModel_-&gt;nu(<span class="keyword">alpha</span>, Theta_, gs0_, rho, da, e_);</span><br><span class="line"></span><br><span class="line">        volScalarField ThetaSqrt(<span class="literal">sqrt</span>(Theta_));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Bulk viscosity  p. 45 (Lun et al. 1984).</span></span><br><span class="line">        lambda_ = (4.0/3.0)*sqr(<span class="keyword">alpha</span>)*da*gs0_*(1.0 + e_)*ThetaSqrt/sqrtPi;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Frictional pressure // 计算由于颗粒之间的摩擦作用产生的一个等效的颗粒相压力作用。</span></span><br><span class="line">        volScalarField pf</span><br><span class="line">        (</span><br><span class="line">            frictionalStressModel_-&gt;frictionalPressure</span><br><span class="line">            (</span><br><span class="line">                <span class="keyword">alpha</span>,</span><br><span class="line">                alphaMinFriction_,</span><br><span class="line">                alphaMax_</span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add frictional shear viscosity, Eq. 3.30, p. 52</span></span><br><span class="line">       <span class="comment">// 将颗粒摩擦产生的颗粒相粘度加到由颗粒温度计算得到的颗粒相粘度中，作为总的颗粒相粘度</span></span><br><span class="line">        nut_ += frictionalStressModel_-&gt;nu </span><br><span class="line">        (</span><br><span class="line">            <span class="keyword">alpha</span>,</span><br><span class="line">            alphaMax_,</span><br><span class="line">            pf/rho,</span><br><span class="line">            <span class="literal">D</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Limit viscosity</span></span><br><span class="line">	<span class="comment">// 限定颗粒相粘度的上限</span></span><br><span class="line">        nut_.<span class="literal">min</span>(100);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (debug)</span><br><span class="line">    &#123;</span><br><span class="line">        Info&lt;&lt; typeName &lt;&lt; ':' &lt;&lt; <span class="keyword">nl</span></span><br><span class="line">            &lt;&lt; <span class="string">"    max(Theta) = "</span> &lt;&lt; <span class="literal">max</span>(Theta_).value() &lt;&lt; <span class="keyword">nl</span></span><br><span class="line">            &lt;&lt; <span class="string">"    max(nut) = "</span> &lt;&lt; <span class="literal">max</span>(nut_).value() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里重点关注一下 <code>ThetaEqn</code> 的写法。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">fvScalarMatrix</span> <span class="tag">ThetaEqn</span></span><br><span class="line">  (</span><br><span class="line">      1<span class="class">.5</span>*</span><br><span class="line">      (</span><br><span class="line">          <span class="rule"><span class="attribute">fvm</span>:<span class="value">:<span class="function">ddt</span>(alpha, rho, Theta_)</span><br><span class="line">        + fvm::<span class="function">div</span>(alphaRhoPhi, Theta_)</span><br><span class="line">        - fvc::<span class="function">Sp</span>(fvc::<span class="function">ddt</span>(alpha, rho) + fvc::<span class="function">div</span>(alphaRhoPhi), Theta_)</span><br><span class="line">      )</span><br><span class="line">    - fvm::<span class="function">laplacian</span>(kappa_, Theta_, <span class="string">"laplacian(kappa,Theta)"</span>)</span><br><span class="line">   ==</span><br><span class="line">      fvm::<span class="function">SuSp</span>(<span class="function">-</span>((PsCoeff*I) &amp;&amp; gradU), Theta_)</span><br><span class="line">    + (tau &amp;&amp; gradU)</span><br><span class="line">    + fvm::<span class="function">Sp</span>(-gammaCoeff, Theta_)</span><br><span class="line">    + fvm::<span class="function">Sp</span>(-J1, Theta_)</span><br><span class="line">    + fvm::<span class="function">Sp</span>(J2/(Theta_ + ThetaSmall), Theta_)</span><br><span class="line"> )</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>对应的偏微分方程是，<br>$$<br>\frac{3}{2}\left [ \frac{\partial }{\partial t}(\varepsilon_s \rho_s \Theta)+ \nabla \cdot (\varepsilon_s \rho_s \Theta U_s) \right ] = (-P_s \mathrm{I} + \tau_s):\nabla U_s + \nabla \cdot (\kappa_s \nabla \Theta) - \gamma_s - J_s<br>$$<br>下面将公式与代码一一对应。代码里跟公式相比，多了一项<br>$$<br>-\Theta\frac{\partial }{\partial t}(\varepsilon_s \rho_s) - \Theta \nabla \cdot (\varepsilon_s \rho_s U_s)<br>$$<br>这样，相当于代码对应的前两项是<br>$$<br>\varepsilon_s \rho_s \frac{\partial \Theta}{\partial t} + \varepsilon_s \rho_s U_s \cdot \nabla \Theta<br>$$<br>这样做的目的仍不是很明确。</p>
<p>Laplacian 项不需多言，剩下的几项，全都当作了源项来处理。<br>$(-P_s \mathrm{I} + \tau_s)\:\nabla U_s$ 拆开成了两项，分别对应 <code>fvm::SuSp(-((PsCoeff*I) &amp;&amp; gradU), Theta_)</code> 和 <code>(tau &amp;&amp; gradU)</code> 。第一项，由于$P_s$是$\Theta$ 的函数，所以，在固相压力类中，返回的值是固相压力系数（固相压力除以颗粒温度），在这里将$\Theta$进行了隐式处理。而由于$\tau$与$\nabla U_s$与$\Theta$无关，所以就只当成一般的源项了。</p>
<p>$\gamma$项的处理与颗粒压力类似，也是只定义 <code>gammaCoeff</code> ，然后将$\Theta$作隐式处理。由于实际上$\gamma$的表达式<br>$$<br>\gamma = \frac{12(1-e^2)\varepsilon_s^2\rho g_0}{d_p \sqrt{\pi}} \Theta^{3/2}<br>$$<br>这里有关于$\Theta$的非线性项，程序里实际上是对$\Theta$作了部分隐式处理，从 <code>gammaCoeff</code>的定义可以看出来：<br>$$<br>\gamma_{Coeff} = \frac{12(1-e^2)\varepsilon_s^2\rho g_0}{d_p } \sqrt{\frac{\Theta}{\pi}}<br>$$</p>
<p>颗粒温度方程中的$J_s$ 也分成了两项来处理，$J_s = J_1 - J_2$<br>$J_1$的处理很简单，在公式里，$J_1 = 3\beta \Theta$，而在代码当中，变量 <code>J1</code> 定义为 <code>3*beta</code>，而 <code>Theta</code> 则作隐式处理。   </p>
<p>$J_2$也人为作了隐式处理，文献中$J_2$的表达式为<br>$$<br>J_2 = \frac{\beta^2 d_p |U_g-U_s|^2}{4\varepsilon_s\rho\sqrt{\pi \Theta}}<br>$$</p>
<p>程序里则将$J_2$除以$\Theta$以后作为系数，以实现对$\Theta$进行隐式处理。<br>注意这里要说明一下”Sp”和”SuSp”的区别，这个在”Programmer’s Guide”里有说明，此外这个<a href="https://openfoamwiki.net/index.php/HowTo_Adding_a_new_transport_equation" target="_blank" rel="external">网页</a>里也有说明。可是，为什么固相压力项要用”SuSp”，这个也暂时不明白。</p>
<p>计算颗粒温度的代数方程的具体公式这里不写了，可以参考文献。</p>
<p>最后，上面提到的由于颗粒摩擦作用产生的颗粒压力和颗粒粘度，只在颗粒体积分率很大的区域才需要启用，算例中需要设定一个值，对于颗粒相体积分率大于一个设定值时， <code>alphaMinFriction</code>，只有颗粒相体积分率超过这个值时，才会启用由于颗粒相摩擦而产生的压力和粘度。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>OpenFOAM 中双流体模型的 kineticTheoryModel 是以 “ <em>Derivation, implementation, and validation of computer simulation models for gas-solid fluidized beds</em>, B.G.M. van Wachem, Ph.D. Thesis, Delft University of Technology, Amsterdam, 2000. “ 为蓝本来设计的，下面分析这个类的代码。需要注意的是，这个类需要调用一些别的类（如 viscosityModel 等，后面会一一分析）来完成其功能。</p>]]>
    
    </summary>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/tags/OpenFOAM/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++ 中派生类引用与基类引用的隐式转换]]></title>
    <link href="http://xiaopingqiu.github.io/2015/09/13/CPP-conversion-Of-derived-class-reference-to-base-class-type/"/>
    <id>http://xiaopingqiu.github.io/2015/09/13/CPP-conversion-Of-derived-class-reference-to-base-class-type/</id>
    <published>2015-09-13T09:03:35.000Z</published>
    <updated>2015-09-13T13:19:36.361Z</updated>
    <content type="html"><![CDATA[<p>在读 OpenFOAM 代码过程中，有一类应用初看之下觉得很费解，比如 OpenFOAM-2.3.x 的 <code>twoPhaseEulerFoam</code>，createFields.H 有这么一段：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">phaseModel&amp; <span class="variable">phase1 =</span> fluid.phase1();</span><br><span class="line">phaseModel&amp; <span class="variable">phase2 =</span> fluid.phase2();</span><br><span class="line"></span><br><span class="line">volScalarField&amp; <span class="variable">alpha1 =</span> phase1;</span><br><span class="line">volScalarField&amp; <span class="variable">alpha2 =</span> phase2;</span><br></pre></td></tr></table></figure></p>
<p>乍看之下，感觉有点奇怪：怎么能将 phaseModel 类的引用直接赋值给 volScalarField 类的引用呢？后来查看了一下 phaseModel 类的定义，发现原来 phaseModel 类是 volScalarField 类的派生，由此上面代码就好理解了，无非是将派生类引用赋值给基类引用而已。</p>
<a id="more"></a>
<p>但是，下面代码，虽然深究下去发现原理类似，但是乍看上去却更加费解：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="constant">Foam:</span><span class="symbol">:tmp&lt;Foam</span><span class="symbol">:</span><span class="symbol">:volVectorField&gt;</span> <span class="constant">Foam:</span><span class="symbol">:twoPhaseSystem</span><span class="symbol">:</span><span class="symbol">:U</span>() const</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> phase1<span class="constant">_</span>*phase1<span class="constant">_</span>.<span class="constant">U(</span>) + phase2<span class="constant">_</span>*phase2<span class="constant">_</span>.<span class="constant">U(</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:tmp&lt;Foam</span><span class="symbol">:</span><span class="symbol">:surfaceScalarField&gt;</span> <span class="constant">Foam:</span><span class="symbol">:twoPhaseSystem</span><span class="symbol">:</span><span class="symbol">:calcPhi</span>() const</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        <span class="symbol">fvc:</span><span class="symbol">:interpolate</span>(phase1<span class="constant">_</span>)*phase1<span class="constant">_</span>.phi()</span><br><span class="line">      + <span class="symbol">fvc:</span><span class="symbol">:interpolate</span>(phase2<span class="constant">_</span>)*phase2<span class="constant">_</span>.phi();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里将 <code>phase1_</code> 直接与 <code>phase1_.U()</code>（或者 <code>phase1_.phi()</code>）相乘，怎么理解？从原理上讲，应该是 <code>phase1_</code> 的体积分率与其速度的乘积。<br>仔细看一下 phaseModel 类的构造函数，<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Foam::phaseModel::phaseModel</span><br><span class="line">(</span><br><span class="line">    const twoPhaseSystem&amp; fluid,</span><br><span class="line">    const dictionary&amp; phaseProperties,</span><br><span class="line">    const word&amp; phaseName</span><br><span class="line">)</span><br><span class="line">:</span><br><span class="line">    volScalarField</span><br><span class="line">    (</span><br><span class="line">        IOobject</span><br><span class="line">        (</span><br><span class="line">            IOobject::<span class="function"><span class="title">groupName</span><span class="params">(<span class="string">"alpha"</span>, phaseName)</span></span>, <span class="comment">// "alpha.particle" </span></span><br><span class="line">            fluid.<span class="function"><span class="title">mesh</span><span class="params">()</span></span>.<span class="function"><span class="title">time</span><span class="params">()</span></span>.<span class="function"><span class="title">timeName</span><span class="params">()</span></span>,</span><br><span class="line">            fluid.<span class="function"><span class="title">mesh</span><span class="params">()</span></span>,</span><br><span class="line">            IOobject::READ_IF_PRESENT,</span><br><span class="line">            IOobject::AUTO_WRITE</span><br><span class="line">        ),</span><br><span class="line">        fluid.<span class="function"><span class="title">mesh</span><span class="params">()</span></span>,</span><br><span class="line">        <span class="function"><span class="title">dimensionedScalar</span><span class="params">(<span class="string">"alpha"</span>, dimless, <span class="number">0</span>)</span></span></span><br><span class="line">    ),</span><br><span class="line">    ......</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure></p>
<p>原来是这样，读取 “alpha.phaseName” 数据文件构建了一个 IOobject 对象，并用该对象对一个临时的 volScalarField 对象进行了初始化，然后用成员初始化列表，将该临时 volScalarField 对象对基类 volScalarField 进行初始化。</p>
<p>这样一来，对于上面的情形， <code>phase1_ * phase1_.U()</code> ，实际上是进行了一个隐式转换，先将 <code>phase1_</code> 转换成基类 volScalarField 类型，由于上述 phaseModel 类的初始化设定，转换以后，<code>phase1_</code> 其实就相当于用 alpha 初始化过的那个 volScalarField 类的对象了。所以， <code>phase1_ * phase1_.U()</code> 其实相当于  <code>alpha.phaseName * phase1_.U()</code> ，是两个 volScalarField 类对象之间的乘法运算。 </p>
<p>在 <code>twoPhaseEulerFoam</code>的代码里，类似的用法还有很多，这里不能一一举例，当看到某处费解的时候，不妨想想是否是上面提到的情形。</p>
<p>为了便于理解这个原理，我这里写了一个简单的 c++ 测试小程序<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        A(<span class="keyword">int</span> a);</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">A::A(<span class="keyword">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> A::print()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"base class:"</span>&lt;&lt;<span class="string">"a="</span>&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> B : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> b;</span><br><span class="line">        B(<span class="keyword">int</span> a, <span class="keyword">int</span> b);</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">B::B(<span class="keyword">int</span> a, <span class="keyword">int</span> b):A(a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> B::print()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Derived class:"</span>&lt;&lt;<span class="string">"a="</span>&lt;&lt;a&lt;&lt;<span class="string">",b="</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_test</span><span class="params">( A&amp; obja)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    obja.print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">operator</span>*(A&amp; a, A&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a.a * b.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">2</span>,b=<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">A <span class="title">obj1</span><span class="params">(a)</span></span>;</span><br><span class="line">    obj1.print();</span><br><span class="line"></span><br><span class="line">    <span class="function">B <span class="title">obj2</span><span class="params">(a+b,b)</span></span>;</span><br><span class="line">    obj2.print();</span><br><span class="line"></span><br><span class="line">    A&amp; obj3 = obj2;</span><br><span class="line">    obj3.print();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"obj3.a="</span>&lt;&lt;obj3.a&lt;&lt;endl;</span><br><span class="line">   <span class="comment">// cout&lt;&lt;"obj3.b="&lt;&lt;obj3.b&lt;&lt;endl; Error! class A has no member named 'b'.</span></span><br><span class="line"></span><br><span class="line">    print_test(obj1);</span><br><span class="line">    print_test(obj2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"obj1 * obj2 :"</span>&lt;&lt; obj1 * obj2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出如下：</p>
<pre><code>base <span class="class"><span class="keyword">class</span>:<span class="typename">a=2</span></span>
Derived <span class="class"><span class="keyword">class</span>:<span class="typename">a=6</span>,<span class="typename">b=4</span></span>
base <span class="class"><span class="keyword">class</span>:<span class="typename">a=6</span></span>
obj3.a=<span class="number">6</span>
base <span class="class"><span class="keyword">class</span>:<span class="typename">a=2</span></span>
base <span class="class"><span class="keyword">class</span>:<span class="typename">a=6</span></span>
obj1 * obj2 :<span class="number">12</span>
</code></pre><p>可以将上述程序中派生类对象赋值给基类的规律简单小结如下：</p>
<ul>
<li>当将基类的引用指向派生类的对象时，用该引用只能调用派生类从基类继承而来的成员。像上面程序中，obj3.a 输出的是 对象 obj2 的成员 a，但是 obj3 无法调用成员b。</li>
<li>当一个函数需要的参数是基类的引用时，可以直接将派生类的对象传递给该函数，像上面的 <code>print_test</code> 函数和重载的 <code>*</code> 运算符那样。此事相当于作了一个隐式的将派生类对象赋值给基类引用。  </li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>在读 OpenFOAM 代码过程中，有一类应用初看之下觉得很费解，比如 OpenFOAM-2.3.x 的 <code>twoPhaseEulerFoam</code>，createFields.H 有这么一段：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">phaseModel&amp; <span class="variable">phase1 =</span> fluid.phase1();</span><br><span class="line">phaseModel&amp; <span class="variable">phase2 =</span> fluid.phase2();</span><br><span class="line"></span><br><span class="line">volScalarField&amp; <span class="variable">alpha1 =</span> phase1;</span><br><span class="line">volScalarField&amp; <span class="variable">alpha2 =</span> phase2;</span><br></pre></td></tr></table></figure></p>
<p>乍看之下，感觉有点奇怪：怎么能将 phaseModel 类的引用直接赋值给 volScalarField 类的引用呢？后来查看了一下 phaseModel 类的定义，发现原来 phaseModel 类是 volScalarField 类的派生，由此上面代码就好理解了，无非是将派生类引用赋值给基类引用而已。</p>]]>
    
    </summary>
    
      <category term="C++" scheme="http://xiaopingqiu.github.io/tags/C/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/tags/OpenFOAM/"/>
    
      <category term="C++" scheme="http://xiaopingqiu.github.io/categories/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在 CentOS 上安装 OpenFOAM ]]></title>
    <link href="http://xiaopingqiu.github.io/2015/09/13/OpenFOAM-install-centOS/"/>
    <id>http://xiaopingqiu.github.io/2015/09/13/OpenFOAM-install-centOS/</id>
    <published>2015-09-13T05:23:06.000Z</published>
    <updated>2015-09-13T07:57:31.626Z</updated>
    <content type="html"><![CDATA[<p>本篇记录我在 CentOS 上编译安装 OpenFOAM 的过程。我需要在不能联网且没有 root 权限的集群上使用OpenFOAM ，最早的时候，我使用的是 <a href="http://sourceforge.net/projects/centfoam/" target="_blank" rel="external">centFOAM project</a> 提供的 64bit CentOS 安装包，这个很方便，把压缩包下载，解压，然后配置一下环境变量就可以了。但是后来 centFOAM 好像不再更新了，所以我只好尝试着自己编译。</p>
<p>由于集群上缺少一些 OpenFOAM 依赖的包，要是一个一个去下载源码编译以补齐那些依赖的包，实在很费劲，所以我采取了另一种尝试：在虚拟机里安装跟集群上一样的系统，然后在虚拟机里编译好 OpenFOAM ，再拷贝到集群上去用（据信 cenoFOAM project 提供的安装包也是在虚拟机编译好的，而且在 cfd-online 论坛上也见有人推荐这么做）。我尝试过在 CentOS 5.4 ，CentOS 6.3 以及 Scientific Linux 6.5 上安装过 OpenFOAM-2.3.x，都成功了，过程大同小异。下面是我的安装过程的一个简要记录。</p>
<a id="more"></a>
<h3 id="1_CentOS_6-3">1 CentOS 6.3</h3><p>首先，你需要一个虚拟机软件，我使用的是 VirtualBox，然后在虚拟机里安装一个64 bit 的CentOS 6.3（镜像可以去<a href="http://vault.centos.org/" target="_blank" rel="external">官网</a>下载）。注意，要想在 VirtualBox安装 64 bit的虚拟机，你的主系统也必须是 64 bit，而且，还要求你的 CPU 支持并开启了虚拟化技术，见<a href="http://rickie622.blog.163.com/blog/static/2123881120113473224536/" target="_blank" rel="external">这个链接</a>。然后，安装虚拟机的过程中，CentOS 6.3 会让你选择以哪种方式安装系统，我选择的是 “Software Development Workstation”，因为这种方式安装的包最全。以下是我在虚拟机里编译安装 OpenFOAM-2.3.x 的过程。</p>
<h4 id="1-0_补充一些依赖包">1.0 补充一些依赖包</h4><p>确保你的虚拟机可以联网，然后运行以下命令补充一些包：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yum groupinstall 'Development Tools</span><br><span class="line"></span><br><span class="line">yum <span class="keyword">install</span> glibc-devel.i686</span><br><span class="line"></span><br><span class="line">yum <span class="keyword">install</span> zlib.x86_64</span><br><span class="line">yum <span class="keyword">install</span> zlib-devel.x86_64</span><br></pre></td></tr></table></figure></p>
<h4 id="1-1_下载需要的源码包。">1.1 下载需要的源码包。</h4><p>需要的源码包包括：OpenFOAM-2.3.x ，ThirdParty-2.3.x，这两个可以在OpenFOAM的官网找到，其中 OpenFOAM-2.3.x 可以用 git 从<a href="https://github.com/OpenFOAM/OpenFOAM-2.3.x" target="_blank" rel="external">这里</a>克隆一份；gcc-4.8.2, mpfr-3.1.2, gmp-5.1.2, mpc-1.0.1, boost-1.55.0, 这些可以OpenFOAM的 github 仓库里<a href="https://github.com/OpenFOAM/ThirdParty-2.3.x" target="_blank" rel="external">找到链接</a>。因为有移植到集群上的需要，所以我这里需要自己编译gcc 和openmpi，这样，就不需要依赖集群系统上的 gcc 和 openmpi 了。</p>
<h4 id="1-2_将源码包解压到合适的位置">1.2 将源码包解压到合适的位置</h4><p>建议在虚拟里，创建一个普通用户（假设为 user），不要用root用户来编译，以下操作都假定是以user用户的身份在进行。在 $HOME 下创建一个目录 OpenFOAM，然后将OpenFOAM-2.3.x 以及 ThirdParty-2.3.x 拷贝到该目录下（如果需要的话，先解压）。然后，解压 gcc-4.8.2，mpfr-3.1.2, gmp-5.1.2, mpc-1.0.1, boost-1.55.0, 并拷贝到 <code>$HOME/ThirdParty-2.3.x</code> 下，并将 boost-1.55.0 重命名为 boost-system。</p>
<h4 id="1-3_编译前的配置和检查">1.3 编译前的配置和检查</h4><p>打开<code>$HOME/OpenFOAM/OpenFOAM-2.3.x/etc/config/settings.sh</code> 文件，跳到<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">case <span class="string">"<span class="subst">$&#123;foamCompiler&#125;</span>"</span> <span class="keyword">in</span></span><br><span class="line">OpenFOAM | ThirdParty)</span><br><span class="line">    case <span class="string">"$WM_COMPILER"</span> <span class="keyword">in</span></span><br><span class="line">    Gcc | Gcc++<span class="number">0</span>x | Gcc48 | Gcc48++<span class="number">0</span>x)</span><br><span class="line">        <span class="variable">gcc_version=</span>gcc-<span class="number">4.8</span>.<span class="number">2</span></span><br><span class="line">        <span class="variable">gmp_version=</span>gmp-<span class="number">5.1</span>.<span class="number">2</span></span><br><span class="line">        <span class="variable">mpfr_version=</span>mpfr-<span class="number">3.1</span>.<span class="number">2</span></span><br><span class="line">        <span class="variable">mpc_version=</span>mpc-<span class="number">1.0</span>.<span class="number">1</span></span><br><span class="line">        ;;</span><br></pre></td></tr></table></figure></p>
<p>检查一下你下载的软件包版本跟这里的设置是否一样，如果不一致，可以直接修改这个文件以使这里的设置和你下载的版本一致。<br>此外，还需要跳到<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">OPENMPI)</span><br><span class="line">    <span class="built_in">export</span> FOAM_MPI=openmpi-<span class="number">1.6</span>.<span class="number">5</span></span><br><span class="line">    <span class="comment"># optional configuration tweaks:</span></span><br><span class="line">    _foamSource `<span class="variable">$WM_PROJECT_DIR</span>/bin/foamEtcFile config/openmpi.sh`</span><br><span class="line"></span><br><span class="line">    <span class="built_in">export</span> MPI_ARCH_PATH=<span class="variable">$WM_THIRD_PARTY_DIR</span>/platforms/<span class="variable">$WM_ARCH</span><span class="variable">$WM_COMPILER</span>/<span class="variable">$FOAM_MPI</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Tell OpenMPI where to find its install directory</span></span><br><span class="line">    <span class="built_in">export</span> OPAL_PREFIX=<span class="variable">$MPI_ARCH_PATH</span></span><br><span class="line"></span><br><span class="line">    _foamAddPath    <span class="variable">$MPI_ARCH_PATH</span>/bin</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 64-bit on OpenSuSE 12.1 uses lib64 others use lib</span></span><br><span class="line">    _foamAddLib     <span class="variable">$MPI_ARCH_PATH</span>/lib<span class="variable">$WM_COMPILER_LIB_ARCH</span></span><br><span class="line">    _foamAddLib     <span class="variable">$MPI_ARCH_PATH</span>/lib</span><br><span class="line"></span><br><span class="line">    _foamAddMan     <span class="variable">$MPI_ARCH_PATH</span>/share/man</span><br><span class="line">    ;;</span><br></pre></td></tr></table></figure></p>
<p>看看你的 ThirdParty-2.3.x 下的 openmpi 的版本是否跟这里的一样（上面的设置是 openmpi-1.6.5），如果不一样，也需要修改这个文件。</p>
<p>然后，打开<code>$HOME/OpenFOAM/OpenFOAM-2.3.x/etc/bashrc</code> 文件，设置<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foamCompiler=ThirdParty</span><br><span class="line"><span class="keyword">export</span> WM_<span class="built_in">MPLIB</span>=OPEN<span class="built_in">MPI</span></span><br></pre></td></tr></table></figure></p>
<p>接着，打开<code>~/.bashrc</code> 文件，在最后一行输入”source $HOME/OpenFOAM/OpenFOAM-2.3.x/etc/bashrc”，保存后，在终端里运行一下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure></p>
<p>来加载跟OpenFOAM相关的环境变量。</p>
<p>最后，还需要检查一下 ThirdParty-2.3.x 目录下的那些编译辅助脚本，看看设置是否正确。需要检查的脚本有 <code>makeGcc</code>， <code>makeCGAL</code>， <code>makeCmake</code>，主要的检查项目仍然是看脚本里设置的软件包版本和实际下载的是否一致。比如，打开脚本 <code>makeGcc</code> ，有这么一段配置<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="setting">gmpPACKAGE=<span class="value">gmp-<span class="number">5.1</span>.<span class="number">2</span></span></span></span><br><span class="line"><span class="setting">mpfrPACKAGE=<span class="value">mpfr-<span class="number">3.1</span>.<span class="number">2</span></span></span></span><br><span class="line"><span class="setting">mpcPACKAGE=<span class="value">mpc-<span class="number">1.0</span>.<span class="number">1</span></span></span></span><br><span class="line"><span class="setting">gccPACKAGE=<span class="value">gcc-<span class="number">4.8</span>.<span class="number">2</span></span></span></span><br></pre></td></tr></table></figure></p>
<p>需要保证这里的设置与 ThirdParty-2.3.x 目录下实际的源码包的版本一致。</p>
<h4 id="1-4_编译过程">1.4 编译过程</h4><p>上面的配置完成以后，就可以开始编译了。按如下顺序进行编译：</p>
<ul>
<li>gcc<br>运行 ThirdParty-2.3.x 下的脚本 <code>makeGcc</code> 即可。<br>这一步完成以后，在终端里输入 <code>gcc -v</code> ，看看返回的版本是否是下载的那个版本。如若不然，重新运行一下 <code>source ~/.bashrc</code> ，再看看 gcc 的版本是否正常。要是不对的话，那就得检查一下 gcc 的编译过程是否出错了。gcc 的编译成功是前提，要是这一步没有成功，下面的也就无法进行了。 </li>
<li>CGAL<br>运行 <code>makeCGAL</code> 即可，boost 和 CGAL 的编译包括在这一步。<br>完成以后，也同样需要检查一下是否编译成功。检查的办法是，看看 <code>ThirdParty-2.3.x/platforms/linux64Gcc</code> 下是否有 <code>CGAL-4.3</code> 和 <code>boost-system</code>，然后看看这两个目录下是否都有 <code>lib</code> 和 <code>bin</code> 目录。如果没有，那就是编译出问题了，需要检查一下。 </li>
<li>Cmake<br>运行 makeCmake<br>同样的，编译完以后需要检查是否成功。</li>
<li>ThirdParty的其他包<br>运行 ThirdParty-2.3.x 下面的 <code>Allwmake</code> ，这一步包括了openmpi 以及 Scotch 的编译。<br>正常的话，这一步编译完以后，应该就可以有 <code>mpirun</code> 以及  <code>mpicc</code> 等命令了。请运行 <code>which mpirun</code> 来检查编译是否成功。  </li>
<li>编译OpenFOAM-2.3.x<br>到 <code>$HOME/OpenFOAM/OpenFOAM-2.3.x</code> 下去运行 <code>Allwmake</code>，进行 OpenFOAM 的编译。  </li>
</ul>
<p>建议将编译过程的输出保留下来，万一编译失败，可以根据编译过程的报错来找原因。比如，上面说的 “运行 makeGcc” ，在终端里可以这样操作<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./makeGcc &gt; <span class="built_in">log</span>_gcc <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp;</span><br></pre></td></tr></table></figure></p>
<p>这样，便会将编译 gcc 过程中的正常输出信息和报错信息都输出到文件 “log_gcc” 里面。此外，后来我发现，其实运行 ThirdParty-2.3.x 下面的 <code>Allwmake</code> 时，其实也包括了”CGAL”的编译，所以其实 <code>makeCGAL</code> 不需要单独拿出来作为一步。</p>
<h4 id="1-5_测试">1.5 测试</h4><p>编译结束以后，需要测试一下编译是否成功。建议至少运行一个串行算例，一个并行算例来检验 OpenFOAM 编译是否成功。最简单的是将 interFoam 求解器的 dambreak 算例串行运行一次，并行运行一次。</p>
<h4 id="1-6_移植到集群">1.6 移植到集群</h4><p>如果上述编译一切正常，那就可以考虑将编译好的OpenFOAM移植到集群了。移植之前，为了减少需要拷贝的文件的数量，可以将一些不需要的源码和编译过程产生的中间文件删除。比如，ThirdParty-2.3.x 目录下的 gcc， mpfr，gmp，mpc以及 boost 的源码包都删除（openmpi-1.6.5 的源码建议保留），因为有用的是文件其实都在 platforms 目录下，只要保证这个目录完好就可以了。然后，建议将 <code>$HOME/OpenFOAM</code> 整个目录打包，再拷贝到集群上去。打包的目的有两个，一是减小文件的空间占用，另外一个更重要的原因是，OpenFOAM 的编译过程中会产生很多重要的软链接，如果不打包，这些软链接容易在拷贝的过程中损坏（比如，假如你用U盘拷贝 OpenFOAM 这个目录，那软链接几乎肯定会损坏）。 </p>
<p>将压缩包拷贝到集群，在你的 $HOME 下解压。建议你在集群上也创建跟在虚拟上一样的目录结构，即在<code>$HOME</code>下创建目录 <code>OpenFOAM</code>，然后将 OpenFOAM-2.3.x 和 ThirdParty-2.3.x 拷贝到<code>OpenFOAM</code>目录下，这样，就不再需要去修改OpenFOAM的安装路径这个环境变量了。万一你没法做到这一点，那么，你需要修改 <code>OpenFOAM-2.3.x/etc/bashrc</code> 文件，将 <code>foamInstall=$HOME/$WM_PROJECT</code> 修改成你的实际路径（这里 <code>$HOME/$WM_PROJECT=$HOME/OpenFOAM</code>）。</p>
<p>然后，类似的，打开<code>~/.bashrc</code> 文件，在最后一行输入”source $HOME/OpenFOAM/OpenFOAM-2.3.x/etc/bashrc”，保存后，在终端里运行一下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure></p>
<p>一切正常的话，移植工作就完成了。</p>
<p>当然，也需要测试一下移植是否成功，同样可以通过运行 dambreak算例来测试。我曾经遇到的问题是，串行可以运行，但是并行出问题了。对于这种情况，解决办法是，到 <code>OpenFOAM/OpenFOAM-2.3.x/src/Pstream</code> 目录下， <code>dummy</code> 和 <code>mpi</code> 下运行  <code>wclean</code>，然后，运行 <code>Pstream</code> 下面的  <code>Allwmake</code> ，重新编译 <code>dummy</code> 和 <code>mpi</code> 。如果这样编译了仍然不能并行，那么还可以再试试重新编译openmpi，具体做法是，删除 <code>ThirdParty-2.3.x/platforms/linux64GccDPOpt/lib/openmpi-1.6.5</code> 以及 <code>ThirdParty-2.3.x/platforms/linux64Gcc/openmpi-1.6.5</code>，然后重新运行ThirdParty-2.3.x 下的  <code>Allwmake</code>，编译完以后在重新编译一下 <code>dummy</code> 和 <code>mpi</code>。一般情况下，可以编译成功，因为编译需要的东西其实都在 ThirdParty-2.3.x 下面包含了，不需要依赖系统的什么包，这也是自己上面自己手动编译 gcc 等这些包带来的好处。这样处理以后，就可以正常并行运行了。</p>
<h3 id="2-_CentOS_5-4">2. CentOS 5.4</h3><p>CentOS 5.4 上的编译和移植过程几乎和上面是一样的，只有几个细节不同，比如，安装依赖包的时候，<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="keyword">install</span> glibc-devel.i686</span><br></pre></td></tr></table></figure></p>
<p>应该是<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="keyword">install</span> glibc-devel.i386</span><br></pre></td></tr></table></figure></p>
<p>其他的差别，在我印象中是没有了。</p>
<p>最后，有必要提一下一个诡异的失败经历，这个问题我至今也不知道是什么原因导致的。<br>有一次在移植到集群的时候，重新编以 openmpi 的过程中遇到如下报错：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CDPATH=<span class="string">"$&#123;ZSH_VERSION+.&#125;:"</span> &amp;&amp; cd . &amp;&amp; <span class="regexp">/bin/</span>sh <span class="regexp">/storage02.mnt/</span>home<span class="regexp">/lmu/</span>OpenFOAM<span class="regexp">/ThirdParty-2.3.x/</span>openmpi-<span class="number">1.6</span>.<span class="number">5</span><span class="regexp">/config/mi</span>ssing --run aclocal-<span class="number">1.11</span> -I config</span><br></pre></td></tr></table></figure></p>
<p>导致 openmpi 无法编译。<br>但是，将OpenFOAM拷贝到另一个目录（不再是 <code>$HOME/OpenFOAM</code> ），再重新尝试，却成功了。</p>
<p>另一次，是在 Scientific Linux 上，也是重新编译 openmpi 的时候遇到了一样的报错，后来解决的办法是，弃用ThirdParty下的 openmpi，改启用系统的openmpi（虽然版本老一点），具体设置是将” export WM_MPLIB=OPENMPI” 改为 “ export WM_MPLIB=SYSTEMOPENMPI”，改完以后也能成功并行运行。</p>
<p>本篇博文，由于是写在我编译 OpenFOAM 好几个月之后，当时也没有详细记录编译过程，所以肯定有细节遗漏或者错误的地方。而且，在不同的系统上，也可能遇到我这里没有提到的问题，本篇博文仅仅是给有需要的人做一个参考。要是你编译过程中遇到某个问题在看了本文后得到了解决，那我的目的就达到了。有问题 ，欢迎来OpenFOAM开源计算千人群讨论交流。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本篇记录我在 CentOS 上编译安装 OpenFOAM 的过程。我需要在不能联网且没有 root 权限的集群上使用OpenFOAM ，最早的时候，我使用的是 <a href="http://sourceforge.net/projects/centfoam/">centFOAM project</a> 提供的 64bit CentOS 安装包，这个很方便，把压缩包下载，解压，然后配置一下环境变量就可以了。但是后来 centFOAM 好像不再更新了，所以我只好尝试着自己编译。</p>
<p>由于集群上缺少一些 OpenFOAM 依赖的包，要是一个一个去下载源码编译以补齐那些依赖的包，实在很费劲，所以我采取了另一种尝试：在虚拟机里安装跟集群上一样的系统，然后在虚拟机里编译好 OpenFOAM ，再拷贝到集群上去用（据信 cenoFOAM project 提供的安装包也是在虚拟机编译好的，而且在 cfd-online 论坛上也见有人推荐这么做）。我尝试过在 CentOS 5.4 ，CentOS 6.3 以及 Scientific Linux 6.5 上安装过 OpenFOAM-2.3.x，都成功了，过程大同小异。下面是我的安装过程的一个简要记录。</p>]]>
    
    </summary>
    
      <category term="CentOS" scheme="http://xiaopingqiu.github.io/tags/CentOS/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/tags/OpenFOAM/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenFOAM-2.3.x 中的 twoPhaseEulerFoam 解析之曳力模型的调用过程]]></title>
    <link href="http://xiaopingqiu.github.io/2015/09/07/twoPhaseEulerFoam23x-twoPhaseSystem/"/>
    <id>http://xiaopingqiu.github.io/2015/09/07/twoPhaseEulerFoam23x-twoPhaseSystem/</id>
    <published>2015-09-07T14:27:47.000Z</published>
    <updated>2015-09-25T09:06:26.746Z</updated>
    <content type="html"><![CDATA[<p>前面有三篇博文对 OpenFOAM-2.1.x 中的 <code>twoPhaseEulerFoam</code> 求解器进行了解读，然而 OpenFOAM-2.3.x 中，这个求解器的代码有了很大的变化。本文将以一个曳力模型的调用过程为例，介绍 OpenFOAM-2.3.x 中 <code>twoPhaseEulerFoam</code> 是如何调用相间作用力模型的。后续还将对 OpenFOAM-2.3.x 中的 <code>twoPhaseEulerFoam</code> 的其他方面进行解读。</p>
<a id="more"></a>
<p>主程序中(“ UEqn.H “)，dragCoeff 定义为：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volScalarField dragCoeff<span class="list">(<span class="keyword">fluid</span>.dragCoeff<span class="list">()</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>其中，<code>fluid</code> 为 <code>twoPhaseSystem</code> 类的对象，所以，要去找  <code>twoPhaseSystem</code> 类的成员函数 <code>dragCoeff()</code>。<br>在源文件 <code>twoPhaseSystem.C</code> 中找到如下定义：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="constant">Foam:</span><span class="symbol">:tmp&lt;Foam</span><span class="symbol">:</span><span class="symbol">:volScalarField&gt;</span> <span class="constant">Foam:</span><span class="symbol">:twoPhaseSystem</span><span class="symbol">:</span><span class="symbol">:dragCoeff</span>() const</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> drag<span class="constant">_</span>-&gt;<span class="constant">K(</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而  <code>drag_</code> 的定义为<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">autoPtr<span class="tag">&lt;<span class="title">BlendedInterfacialModel</span>&lt;<span class="attribute">dragModel</span>&gt;</span> &gt; drag_;</span></span><br></pre></td></tr></table></figure></p>
<p>所以，需要找到类 <code>BlendedInterfacialModel&lt;dragModel&gt;</code> 的成员函数 <code>K()</code>的定义。<br>在源文件 <code>BlendedInterfacialModel.C</code> 中，找到如下定义：<br><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">template&lt;<span class="keyword">class</span> modelType&gt;</span><br><span class="line"><span class="type">Foam</span>::tmp&lt;<span class="type">Foam</span>::volScalarField&gt;</span><br><span class="line"><span class="type">Foam</span>::<span class="type">BlendedInterfacialModel</span>&lt;modelType&gt;::<span class="type">K</span><span class="literal">()</span> const</span><br><span class="line">&#123;</span><br><span class="line">    tmp&lt;volScalarField&gt; f1, f2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (model_.valid<span class="literal">()</span> || model1In2_.valid<span class="literal">()</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        f1 = blending_.f1(pair1In2_.dispersed<span class="literal">()</span>, pair2In1_.dispersed<span class="literal">()</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (model_.valid<span class="literal">()</span> || model2In1_.valid<span class="literal">()</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        f2 = blending_.f2(pair1In2_.dispersed<span class="literal">()</span>, pair2In1_.dispersed<span class="literal">()</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tmp&lt;volScalarField&gt; x</span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">new</span> volScalarField</span><br><span class="line">        (</span><br><span class="line">            <span class="type">IOobject</span></span><br><span class="line">            (</span><br><span class="line">                modelType::typeName + <span class="string">"Coeff"</span>,</span><br><span class="line">                pair_.phase1<span class="literal">()</span>.mesh<span class="literal">()</span>.time<span class="literal">()</span>.timeName<span class="literal">()</span>,</span><br><span class="line">                pair_.phase1<span class="literal">()</span>.mesh<span class="literal">()</span></span><br><span class="line">            ),</span><br><span class="line">            pair_.phase1<span class="literal">()</span>.mesh<span class="literal">()</span>,</span><br><span class="line">            dimensionedScalar(<span class="string">"zero"</span>, modelType::dimK, <span class="number">0</span>)</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (model_.valid<span class="literal">()</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x<span class="literal">()</span> += model_-&gt;<span class="type">K</span><span class="literal">()</span>*(f1<span class="literal">()</span> - f2<span class="literal">()</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (model1In2_.valid<span class="literal">()</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x<span class="literal">()</span> += model1In2_-&gt;<span class="type">K</span><span class="literal">()</span>*(<span class="number">1</span> - f1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (model2In1_.valid<span class="literal">()</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x<span class="literal">()</span> += model2In1_-&gt;<span class="type">K</span><span class="literal">()</span>*f2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (model_.valid<span class="literal">()</span> || model1In2_.valid<span class="literal">()</span> || model2In1_.valid<span class="literal">()</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        correctFixedFluxBCs(x<span class="literal">()</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于曳力模型，上述成员函数的  <code>modelType</code> 可以实例化为 <code>dragModel</code>，要理解该函数的行为，有三点需要清楚： <code>pair_</code>，  <code>pair1In2_</code>， <code>pair2In1_</code> 的定义； <code>model_</code>， <code>model1In2_</code>，  <code>model2In1_</code> 的定义； <code>blendingMethod</code> 类的成员函数  <code>f1</code> 与 <code>f2</code> 的定义。下面一一解释：</p>
<h4 id="1-_pair_，_pair1In2_，_pair2In1__的定义">1.  <code>pair_</code>，  <code>pair1In2_</code>， <code>pair2In1_</code> 的定义</h4><p>这三个是 <code>BlendedInterfacialModel</code> 类的数据成员，回到 <code>twoPhaseSystem</code> 类中去看 <code>drag_</code> 的初始化，<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">drag_.<span class="keyword">set</span></span><br><span class="line">   (</span><br><span class="line">       <span class="keyword">new</span> BlendedInterfacialModel&lt;dragModel&gt;</span><br><span class="line">       (</span><br><span class="line">           lookup(<span class="string">"drag"</span>),</span><br><span class="line">           (</span><br><span class="line">               blendingMethods_.found(<span class="string">"drag"</span>)</span><br><span class="line">             ? blendingMethods_[<span class="string">"drag"</span>]</span><br><span class="line">             : blendingMethods_[<span class="string">"default"</span>]</span><br><span class="line">           ),</span><br><span class="line">           pair_,</span><br><span class="line">           pair1In2_,</span><br><span class="line">           pair2In1_</span><br><span class="line">       )</span><br><span class="line">   );</span><br></pre></td></tr></table></figure></p>
<p>可知，<code>BlendedInterfacialModel</code> 类中的 <code>pair_</code>，  <code>pair1In2_</code>， <code>pair2In1_</code> 是将 <code>twoPhaseSystem</code> 类的数据成员传递过去来实现初始化的，所以，真正要看懂的是<code>twoPhaseSystem</code>类中数据成员<code>pair_</code>，  <code>pair1In2_</code>， <code>pair2In1_</code> 的初始化，见如下代码：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">pair_.<span class="keyword">set</span></span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">new</span> phasePair</span><br><span class="line">        (</span><br><span class="line">            phase1_,</span><br><span class="line">            phase2_,</span><br><span class="line">            g,</span><br><span class="line">            sigmaTable</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">    pair1In2_.<span class="keyword">set</span></span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">new</span> orderedPhasePair</span><br><span class="line">        (</span><br><span class="line">            phase1_,</span><br><span class="line">            phase2_,</span><br><span class="line">            g,</span><br><span class="line">            sigmaTable,</span><br><span class="line">            aspectRatioTable</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">    pair2In1_.<span class="keyword">set</span></span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">new</span> orderedPhasePair</span><br><span class="line">        (</span><br><span class="line">            phase2_,</span><br><span class="line">            phase1_,</span><br><span class="line">            g,</span><br><span class="line">            sigmaTable,</span><br><span class="line">            aspectRatioTable</span><br><span class="line">        )</span><br><span class="line">    );</span><br></pre></td></tr></table></figure></p>
<p>可见，<code>pair_</code> 是  <code>phasePair</code> 类的指针，  <code>pair1In2_</code> 与 <code>pair2In1_</code> 是  <code>orderedPhasePair</code> 类的指针。<br>其中<code>phase1_</code> 和  <code>phase2_</code> 是通过从文件”phaseProperties”里读取内容来初始化的：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">phase1_</span><br><span class="line">    (</span><br><span class="line"><span class="comment">        *this, </span></span><br><span class="line"><span class="comment">        *this,</span></span><br><span class="line">        wordList(<span class="keyword">lookup</span>(<span class="string">"phases"</span>))[0]</span><br><span class="line">    ),</span><br><span class="line">    phase2_</span><br><span class="line">    (</span><br><span class="line"><span class="comment">        *this,</span></span><br><span class="line"><span class="comment">        *this,</span></span><br><span class="line">        wordList(<span class="keyword">lookup</span>(<span class="string">"phases"</span>))[1]</span><br><span class="line">    ),</span><br></pre></td></tr></table></figure></p>
<p>举例说，假设”phaseProperties” 文件里有以下内容：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">phases <span class="list">(<span class="keyword">particles</span> air)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>则， <code>phase1_</code> = “particles”， <code>phase2_</code> = “air” 。</p>
<p>根据 <code>phasePair</code> 类中的定义，成员函数 <code>dispersed()</code> 总是返回对象的<code>phase1</code>（也就是 <code>phasePair</code> 或者  <code>orderedPhasePair</code> 类的构造函数的第一个参数），所以，对于 “particles air” 体系，<code>pair1In2_.dispersed() = phase1_.name() = &quot;particles&quot;</code>， 而 <code>pair2In1_.dispersed() = phase2_.name() = &quot;air&quot;</code>。</p>
<h4 id="2-_model_，_model1In2_，_model2In1__的定义">2. <code>model_</code>， <code>model1In2_</code>，  <code>model2In1_</code> 的定义</h4><p>这三个是 <code>BlendedInterfacialModel</code> 类的数据成员，定义和初始化如下：<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">autoPtr&lt;modelType&gt; model_;</span><br><span class="line">autoPtr&lt;modelType&gt; model<span class="number">1</span>I<span class="label">n2</span>_;</span><br><span class="line">autoPtr&lt;modelType&gt; model<span class="number">2</span>I<span class="label">n1</span>_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="comment">(modelTable.found(pair_)</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        model_.set</span><br><span class="line">        <span class="comment">(</span><br><span class="line">            modelType::New</span><br><span class="line">            (</span><br><span class="line">                modelTable[pair_],</span><br><span class="line">                pair_</span><br><span class="line">            )</span>.ptr<span class="comment">()</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="comment">(modelTable.found(pair1In2_)</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        model<span class="number">1</span>I<span class="label">n2</span>_.set</span><br><span class="line">        <span class="comment">(</span><br><span class="line">            modelType::New</span><br><span class="line">            (</span><br><span class="line">                modelTable[pair1In2_],</span><br><span class="line">                pair1In2_</span><br><span class="line">            )</span>.ptr<span class="comment">()</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="comment">(modelTable.found(pair2In1_)</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        model<span class="number">2</span>I<span class="label">n1</span>_.set</span><br><span class="line">        <span class="comment">(</span><br><span class="line">            modelType::New</span><br><span class="line">            (</span><br><span class="line">                modelTable[pair2In1_],</span><br><span class="line">                pair2In1_</span><br><span class="line">            )</span>.ptr<span class="comment">()</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，这里讨论的是曳力模型的调用，所以，如前所述，<code>modelType</code> 可以实例化为 <code>dragModel</code>。<br><code>modelTable</code> 是 <code>phasePair::dictTable</code> 类型的引用，本质上是一个 HashTable（ <code>HashTable&lt;dictionary, phasePairKey, phasePairKey::hash&gt;</code> ），其 key 是 <code>phasePairKey</code> 类型的对象，value 是 <code>dictionary</code> 类的对象。 <code>found</code> 函数通过查找 <code>modelTable</code> 对象中是否存在某个 key 来决定返回值是 true 还是 false。</p>
<p>这里要分头说，一边是 <code>modelTable</code> 的初始化，另一边是 <code>pair_</code>， <code>pair2In1_</code>， <code>pair2In1_</code>  如何与 <code>phasePairKey</code> 类进行对比。</p>
<p>从 <code>twoPhaseSystem</code> 类中对 <code>drag_</code> 的初始化可知， <code>modelTable</code> 的初始化是由 <code>lookup(&quot;drag&quot;)</code> 来完成的。<code>lookup</code> 函数的作用是读取”phaseProperties” 文件的内容来实现对一个 HashTable 的初始化（具体过程将会在后续解读中涉及）。举例说，以下 “phaseProperties” 的内容<br><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">drag</span><br><span class="line">(</span><br><span class="line">    (particles <span class="keyword">in</span> air)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">type</span>            <span class="title">GidaspowErgunWenYu</span>;</span></span><br><span class="line">        residualAlpha   <span class="number">1e-6</span>;</span><br><span class="line">        residualRe      <span class="number">1e-3</span>;</span><br><span class="line">        swarmCorrection</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="class"><span class="keyword">type</span>        <span class="title">none</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>将利用 <code>(particles in air)</code> 来初始化一个 <code>phasePairKey</code> 对象（利用 <code>phasePairKey</code>类中的空白构造函数和重载的 <code>&gt;&gt;</code> 符号）。成员<code>ordeded_</code> 的值取决于 “in” 或 “and” ，若形如 “particles in air “，<code>ordeded_ = true</code>，若形如 “particles and air “， 则 <code>ordeded_ = false</code>。 则剩余内容将用于初始化一个 <code>dictionary</code> 对象。</p>
<p>而另一方面，<code>phasePair</code> 是 <code>phasePairKey</code>的派生类， <code>orderedPhasePair</code> 则是<code>phasePair</code> 的派生类，所以，将 <code>pair_</code> ，<code>pair1In2_</code> 以及 <code>pair2In1_</code> 作为 <code>found</code> 函数的参数，隐含了将派生类的引用转换成基类引用。 <code>phasePair</code>类默认 <code>ordered_ = false</code>， 而 <code>orderedPhasePair</code> 类则默认<code>ordered_ = true</code>。<code>pair_</code> ，<code>pair1In2_</code> 以及 <code>pair2In1_</code> 与 <code>modelTable_</code> 的 key 进行比较，比较的是对应的 <code>phase1</code>，<code>phase2</code> 和 <code>ordered_</code> 三个成员的值是否相等，只有三者都一样时， <code>found</code> 函数才返回 <code>true</code> 。   所以，对于上面提到的设置，即<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">phases <span class="list">(<span class="keyword">particles</span> air)</span><span class="comment">;</span></span><br><span class="line">drag</span><br><span class="line"><span class="list">(</span><br><span class="line">    <span class="list">(<span class="keyword">particles</span> in air)</span></span><br><span class="line">    .......</span><br><span class="line">)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>只有<code>modelTable.found(pair1In2_)</code>的值为<code>true</code>。同样，也就只有 <code>model1In2_.valid()</code> 为 <code>true</code> （即 <code>model1In2_</code> 指针不为空。）  </p>
<h4 id="3-_blendingMethod_类的成员函数_f1_与_f2">3. <code>blendingMethod</code> 类的成员函数  <code>f1</code> 与 <code>f2</code></h4><p>这两个函数的实现在不同的 <code>blendingMethods</code>中不一样，以最简单的 <code>noBlending</code> 类型为例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">Foam::tmp&lt;Foam::volScalarField&gt; Foam::blendingMethods::noBlending::f1</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> phaseModel&amp; phase1,</span><br><span class="line">    <span class="keyword">const</span> phaseModel&amp; phase2</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> fvMesh&amp; mesh(phase1.mesh());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        tmp&lt;volScalarField&gt;</span><br><span class="line">        (</span><br><span class="line">            <span class="keyword">new</span> volScalarField</span><br><span class="line">            (</span><br><span class="line">                IOobject</span><br><span class="line">                (</span><br><span class="line">                    <span class="string">"f"</span>,</span><br><span class="line">                    mesh.time().timeName(),</span><br><span class="line">                    mesh</span><br><span class="line">                ),</span><br><span class="line">                mesh,</span><br><span class="line">                dimensionedScalar</span><br><span class="line">                (</span><br><span class="line">                    <span class="string">"f"</span>,</span><br><span class="line">                    dimless,</span><br><span class="line">                    phase2.name() != continuousPhase_</span><br><span class="line">                ) <span class="comment">// 如果 phase2 就是 continuousPhase，那么 f1 = 0；否则 f1 = 1</span></span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foam::tmp&lt;Foam::volScalarField&gt; Foam::blendingMethods::noBlending::f2</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> phaseModel&amp; phase1,</span><br><span class="line">    <span class="keyword">const</span> phaseModel&amp; phase2</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> fvMesh&amp; mesh(phase1.mesh());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        tmp&lt;volScalarField&gt;</span><br><span class="line">        (</span><br><span class="line">            <span class="keyword">new</span> volScalarField</span><br><span class="line">            (</span><br><span class="line">                IOobject</span><br><span class="line">                (</span><br><span class="line">                    <span class="string">"f"</span>,</span><br><span class="line">                    mesh.time().timeName(),</span><br><span class="line">                    mesh</span><br><span class="line">                ),</span><br><span class="line">                mesh,</span><br><span class="line">                dimensionedScalar</span><br><span class="line">                (</span><br><span class="line">                    <span class="string">"f"</span>,</span><br><span class="line">                    dimless,</span><br><span class="line">                    phase1.name() == continuousPhase_</span><br><span class="line">                ) <span class="comment">// 如果 phase1 是 continuousPhase，那么 f2 = 1，否则 f2 = 0。</span></span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再回头看 <code>BlendedInterfacialModel</code> 类的成员函数 <code>K()</code>，<br><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (model_.valid<span class="literal">()</span> || model1In2_.valid<span class="literal">()</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       f1 = blending_.f1(pair1In2_.dispersed<span class="literal">()</span>, pair2In1_.dispersed<span class="literal">()</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (model_.valid<span class="literal">()</span> || model2In1_.valid<span class="literal">()</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       f2 = blending_.f2(pair1In2_.dispersed<span class="literal">()</span>, pair2In1_.dispersed<span class="literal">()</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>根据上面的 “phaseProperties” 的设置，可知 <code>pair1In2_.dispersed() = &quot;particles&quot;</code>，  <code>pair2In1_.dispersed() = &quot;air&quot;</code>，而  <code>continuousPhase_</code> 是从 “phaseProperties” 的 “blending” 子字典里读取的，这里<code>continuousPhase_ = &quot;air&quot;</code>，于是，可以得到 <code>f1 = 0</code>， <code>f2 = 1</code>。再看 <code>K()</code> 的返回值，可知，最终有效的返回值是<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="comment">(model1In2_.valid()</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       x<span class="comment">()</span> += model<span class="number">1</span>I<span class="label">n2</span>_-&gt;K<span class="comment">()</span>*<span class="comment">(1 - f1)</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>即，最终 <code>K()</code> 函数的返回值是 <code>model1In2_-&gt;K()</code> 。而<code>model1In2_-&gt;K()</code>的值就取决于具体调用的曳力模型了，举例说，假如调用的是 Ergun 曳力模型，则 <code>K()</code> 最终返回的值，也就是 “UEqn.H” 中的 <code>dragCoeff</code> 的值是<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="rule"><span class="attribute">Foam</span>:<span class="value">:tmp&lt;Foam::volScalarField&gt; Foam::dragModel::<span class="function">K</span>() const</span><br><span class="line">&#123;</span><br><span class="line">    return</span><br><span class="line">        <span class="number">0.75</span></span><br><span class="line">       *<span class="function">CdRe</span>()</span><br><span class="line">       *<span class="function">max</span>(pair_.<span class="function">dispersed</span>(), residualAlpha_)</span><br><span class="line">       *swarmCorrection_-&gt;<span class="function">Cs</span>()</span><br><span class="line">       *pair_.<span class="function">continuous</span>().<span class="function">rho</span>()</span><br><span class="line">       *pair_.<span class="function">continuous</span>().<span class="function">nu</span>()</span><br><span class="line">       /<span class="function">sqr</span>(pair_.<span class="function">dispersed</span>().<span class="function">d</span>())</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中 <code>CdRe()</code> 的定义为<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="rule"><span class="attribute">Foam</span>:<span class="value">:tmp&lt;Foam::volScalarField&gt; Foam::dragModels::Ergun::<span class="function">CdRe</span>() const</span><br><span class="line">&#123;</span><br><span class="line">    return</span><br><span class="line">        (<span class="number">4</span>/<span class="number">3</span>)</span><br><span class="line">       *(</span><br><span class="line">            <span class="number">150</span></span><br><span class="line">           *<span class="function">max</span>(<span class="function">scalar</span>(<span class="number">1</span>) - pair_.<span class="function">continuous</span>(), residualAlpha_)</span><br><span class="line">           /<span class="function">max</span>(pair_.<span class="function">continuous</span>(), residualAlpha_)</span><br><span class="line">          + <span class="number">1.75</span></span><br><span class="line">           *pair_.<span class="function">Re</span>()</span><br><span class="line">        )</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意所有曳力模型的 <code>K()</code>函数形式是一样的，不同曳力模型的区别在于 <code>CdRe()</code> 的实现不一样。<br>此外，virtualMass，  heatTransfer，lift，wallLubrication，turbulentDispersion 这些子模型的调用也都是经过类似的过程进行的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前面有三篇博文对 OpenFOAM-2.1.x 中的 <code>twoPhaseEulerFoam</code> 求解器进行了解读，然而 OpenFOAM-2.3.x 中，这个求解器的代码有了很大的变化。本文将以一个曳力模型的调用过程为例，介绍 OpenFOAM-2.3.x 中 <code>twoPhaseEulerFoam</code> 是如何调用相间作用力模型的。后续还将对 OpenFOAM-2.3.x 中的 <code>twoPhaseEulerFoam</code> 的其他方面进行解读。</p>]]>
    
    </summary>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/tags/OpenFOAM/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
</feed>