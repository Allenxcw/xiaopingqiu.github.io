<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Giskard's CFD Learning Tricks]]></title>
  <subtitle><![CDATA[CFD and Scientific Computing]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://xiaopingqiu.github.io/"/>
  <updated>2015-11-25T12:46:34.806Z</updated>
  <id>http://xiaopingqiu.github.io/</id>
  
  <author>
    <name><![CDATA[Giskard Q.]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[swak4Foam 如何用于名字形如 alpha.water 的场？]]></title>
    <link href="http://xiaopingqiu.github.io/2015/11/25/swak4Foam-alpha-water/"/>
    <id>http://xiaopingqiu.github.io/2015/11/25/swak4Foam-alpha-water/</id>
    <published>2015-11-25T12:33:10.000Z</published>
    <updated>2015-11-25T12:46:34.806Z</updated>
    <content type="html"><![CDATA[<p>swak4Foam 的 <code>groovyBC</code> 边界条件提供了一种很灵活的用表达式定义边界条件的方法。但是，从 OpenFOAM-2.3 开始，两相流求解器如 <code>interFoam</code> 和 <code>twoPhaseEulerFoam</code> 开始采用类似于 <code>alpha.water</code> 的场，这种场名默认情况下 <code>groovyBC</code> 是无法正确识别的，因为 <code>.</code> 在 swak4Foam 表达式中有特殊的作用。<br>所幸的是，开发人员也早就意识到这个问题了，并给出了解决方案，那就是用 <code>aliases</code>。这个东西真是不知道就很难，知道了就很简单，下面举一个我实际用过的例子：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">solid_inlet_left</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title">type</span>               groovyBC;</span><br><span class="line">        <span class="title">valueExpression</span>    <span class="string">"-inVel*normal()"</span></span><br><span class="line">        value              uniform (<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>);</span><br><span class="line">        <span class="title">variables</span> (</span><br><span class="line">            <span class="string">"A=sum(area());"</span></span><br><span class="line">            <span class="string">"outFlow&#123;outlet_left&#125;=sum(Uparticles&amp;normal()*area()*alphaparticles);"</span></span><br><span class="line">            <span class="string">"myFlow=outFlow/alphaparticles;"</span></span><br><span class="line">            <span class="string">"inVel=myFlow/A;"</span></span><br><span class="line">            );</span><br><span class="line">        <span class="title">aliases</span> &#123;</span><br><span class="line">            <span class="title">Uparticles</span>            U.particles;</span><br><span class="line">            <span class="title">alphaparticles</span>        alpha.particles;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我想我应该不用再解释什么。</p>
<p>主要参考<a href="http://sourceforge.net/p/openfoam-extend/ticketsswak4foam/210/" target="_blank" rel="external">这个网页</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>swak4Foam 的 <code>groovyBC</code> 边界条件提供了一种很灵活的用表达式定义边界条件的方法。但是，从 OpenFOAM-2.3 开始，两相流求解器如 <code>interFoam</code> 和 <code>twoPhaseEulerFoa]]>
    </summary>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/tags/OpenFOAM/"/>
    
      <category term="TIL" scheme="http://xiaopingqiu.github.io/tags/TIL/"/>
    
      <category term="groovyBC" scheme="http://xiaopingqiu.github.io/tags/groovyBC/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
      <category term="swak4Foam" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/swak4Foam/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenFOAM 中的单相流湍流模型之一]]></title>
    <link href="http://xiaopingqiu.github.io/2015/11/25/OpenFOAM-singlePhase-turbulenceModel/"/>
    <id>http://xiaopingqiu.github.io/2015/11/25/OpenFOAM-singlePhase-turbulenceModel/</id>
    <published>2015-11-25T11:13:58.000Z</published>
    <updated>2015-11-25T12:14:31.405Z</updated>
    <content type="html"><![CDATA[<p>相信有不少 OpenFOAM 用户有添加湍流模型的需求，我自己最早用 OpenFOAM 完成的一项工作就是在其中添加了一些单相流的湍流模型，并进行了一些计算。这里将我对单相湍流模型代码框架的理解记录下来，供大家参考。本系列将包含三篇，第一篇介绍湍流模型类的继承派生关系，第二篇具体分析几个 OpenFOAM 中带的湍流模型，并给出修改或增加新模型的方法，第三篇分析湍流模型的运行时选择机制（Run Time Selection）的原理。</p>
<a id="more"></a>
<h4 id="1-_湍流模型类的继承派生关系">1. 湍流模型类的继承派生关系</h4><p>这一部分是最简单的，只要有一点<code>C++</code>的知识，看一下湍流模型的代码头文件的类声明部分，就能理解。OpenFOAM 里的单相湍流模型包含两大类，<code>RAS</code> 和 <code>LES</code>，下面将分别分析。</p>
<p>OpenFOAM 单相流湍流模型的代码在 <code>src/turbulenceModels</code> 目录下，目录结构如下：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">Allwmake</span>  compressible  derivedFvPatchFields  incompressible  LES</span><br></pre></td></tr></table></figure></p>
<p>其中， <code>compressible</code> 和 <code>incompressible</code> 分别是可压缩和不可压缩湍流模型的代码， <code>derivedFvPatchFields</code> 是两个湍流相关的边界条件的代码， <code>LES</code> 是大涡模拟的两个相关的类（ <code>LESdeltas</code> 和 <code>LESfilters</code> ），具体在后面会介绍。这里我主要关心不可压缩湍流模型。<br>进入<code>incompressible</code>，目录结构为：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span> cd  incompressible</span><br><span class="line"><span class="variable">$ </span> ls</span><br><span class="line"><span class="constant">Allwmake </span> <span class="constant">LES </span> <span class="constant">RAS </span> turbulenceModel</span><br></pre></td></tr></table></figure></p>
<p>这里， 目录<code>turbulenceModel</code> 里是基类 <code>turbulenceModel</code> 相关的代码， <code>RAS</code> 和 <code>LES</code> ，顾名思义，分别是雷诺时均和大涡模拟湍流模型的代码。</p>
<h5 id="1-1_基类_turbulenceModel">1.1 基类 <code>turbulenceModel</code></h5><p>首先看基类 <code>turbulenceModel</code> ，这里我挑着我觉得重要的部分代码列出来：</p>
<p>先看头文件 turbulenceModel.H：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Foam</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// incompressible 命名空间，注意这个是很重要的，作用是将类隔离开。比如，可压和不可压都有kEpsilon模型，这两个模型的类名是一样的。要区分这两个类，靠的就是这个命名空间。可压的是 compressible::kEpsilon, 而不可压的则是 incompressible::kEpsilon</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">incompressible</span> </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">turbulenceModel</span> <span class="comment">//定义一个 turbulenceModel 类，继承自 regIOobject 类</span></span><br><span class="line">:</span><br><span class="line">    <span class="title">public</span> <span class="title">regIOobject</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据成员</span></span><br><span class="line">        <span class="keyword">const</span> Time&amp; runTime_;</span><br><span class="line">        <span class="keyword">const</span> fvMesh&amp; mesh_;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> volVectorField&amp; U_;</span><br><span class="line">        <span class="keyword">const</span> surfaceScalarField&amp; phi_;</span><br><span class="line"></span><br><span class="line">        transportModel&amp; transportModel_; <span class="comment">// 输运模型，涉及到分子粘度的设置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Near wall distance boundary field</span></span><br><span class="line">        nearWallDist y_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">//- Runtime type information</span></span><br><span class="line">    TypeName(<span class="string">"turbulenceModel"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Declare run-time New selection table 这个跟运行时选择有关，具体以后会涉及</span></span><br><span class="line"></span><br><span class="line">        declareRunTimeNewSelectionTable</span><br><span class="line">        (</span><br><span class="line">            autoPtr,</span><br><span class="line">            turbulenceModel,</span><br><span class="line">            turbulenceModel,</span><br><span class="line">            (</span><br><span class="line">                <span class="keyword">const</span> volVectorField&amp; U,</span><br><span class="line">                <span class="keyword">const</span> surfaceScalarField&amp; phi,</span><br><span class="line">                transportModel&amp; transport,</span><br><span class="line">                <span class="keyword">const</span> word&amp; turbulenceModelName</span><br><span class="line">            ),</span><br><span class="line">            (U, phi, transport, turbulenceModelName)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Constructors  构造函数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Construct from components</span></span><br><span class="line">        turbulenceModel</span><br><span class="line">        (</span><br><span class="line">            <span class="keyword">const</span> volVectorField&amp; U,</span><br><span class="line">            <span class="keyword">const</span> surfaceScalarField&amp; phi,</span><br><span class="line">            transportModel&amp; transport,</span><br><span class="line">            <span class="keyword">const</span> word&amp; turbulenceModelName = typeName</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Selectors // 这个也是跟运行时选择机制有关，涉及到具体湍流模型的选择过程</span></span><br><span class="line">        <span class="comment">//- Return a reference to the selected turbulence model</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> autoPtr&lt;turbulenceModel&gt; <span class="title">New</span></span><br><span class="line">        <span class="params">(</span><br><span class="line">            <span class="keyword">const</span> volVectorField&amp; U,</span><br><span class="line">            <span class="keyword">const</span> surfaceScalarField&amp; phi,</span><br><span class="line">            transportModel&amp; transport,</span><br><span class="line">            <span class="keyword">const</span> word&amp; turbulenceModelName = typeName</span><br><span class="line">        )</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Member Functions</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Const access to the coefficients dictionary</span></span><br><span class="line">        <span class="keyword">virtual</span> <span class="keyword">const</span> dictionary&amp; coeffDict() <span class="keyword">const</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Helper function to return the nam eof the turbulence G field</span></span><br><span class="line">        <span class="function">inline word <span class="title">GName</span><span class="params">()</span> <span class="keyword">const</span></span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> word(type() + <span class="string">":G"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Access function to velocity field</span></span><br><span class="line">        inline <span class="keyword">const</span> volVectorField&amp; U() <span class="keyword">const</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> U_;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Access function to flux field</span></span><br><span class="line">        inline <span class="keyword">const</span> surfaceScalarField&amp; phi() <span class="keyword">const</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> phi_;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Access function to incompressible transport model</span></span><br><span class="line">        inline transportModel&amp; transport() <span class="keyword">const</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> transportModel_;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Return the near wall distances</span></span><br><span class="line">        <span class="keyword">const</span> nearWallDist&amp; y() <span class="keyword">const</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> y_;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Return the laminar viscosity</span></span><br><span class="line">	<span class="comment">// 分子粘度，注意这里的返回值是输运模型类对象的 nu 函数的返回值。</span></span><br><span class="line">	<span class="comment">// 具体来说，如果是牛顿流体，那么这个返回值就是我们在transportProperties里设置的粘度；</span></span><br><span class="line">	<span class="comment">// 如果是非牛顿流体，那么粘度是根据具体的非牛顿流体模型计算得到的。</span></span><br><span class="line">        <span class="function">inline tmp&lt;volScalarField&gt; <span class="title">nu</span><span class="params">()</span> <span class="keyword">const</span> </span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> transportModel_.nu();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下形如 "virtual <span class="label">xxxx () const = 0" 的函数，都是纯虚函数，这是很重要的一部分。</span></span></span><br><span class="line">    <span class="comment">// 当一个类中有纯虚函数时，这个类就被称作抽象类，抽象类本身不能建立对象，一般都是作为接口类来使用。</span></span><br><span class="line">    <span class="comment">// 这里的turbulenceModel类就是接口类，“接口类”三个字的具体含义后面会解释。</span></span><br><span class="line">        <span class="comment">//- Return the turbulence viscosity</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> tmp&lt;volScalarField&gt; <span class="title">nut</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//- Return the effective viscosity</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> tmp&lt;volScalarField&gt; <span class="title">nuEff</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//- Return the turbulence kinetic energy</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> tmp&lt;volScalarField&gt; <span class="title">k</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//- Return the turbulence kinetic energy dissipation rate</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> tmp&lt;volScalarField&gt; <span class="title">epsilon</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//- Return the Reynolds stress tensor</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> tmp&lt;volSymmTensorField&gt; <span class="title">R</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//- Return the effective stress tensor including the laminar stress</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> tmp&lt;volSymmTensorField&gt; <span class="title">devReff</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//- Return the source term for the momentum equation</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> tmp&lt;fvVectorMatrix&gt; <span class="title">divDevReff</span><span class="params">(volVectorField&amp; U)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//- Return the source term for the momentum equation</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> tmp&lt;fvVectorMatrix&gt; <span class="title">divDevRhoReff</span></span><br><span class="line">        <span class="params">(</span><br><span class="line">            <span class="keyword">const</span> volScalarField&amp; rho,</span><br><span class="line">            volVectorField&amp; U</span><br><span class="line">        )</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//- Solve the turbulence equations and correct the turbulence viscosity</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">correct</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Read LESProperties or RASProperties dictionary</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">read</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>再来看 turbulenceModel.C，重点关注构造函数和 New 函数<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">namespace Foam</span><br><span class="line">&#123;</span><br><span class="line">namespace incompressible</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">// <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> Static Data Members <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> </span><br><span class="line"></span><br><span class="line">//这句与运行时选择机制有关，后面再说</span><br><span class="line">defineRunTimeSelectionTable(turbulenceModel, turbulenceModel);</span><br><span class="line"></span><br><span class="line">//构造函数的定义。构造函数包括四个参数，其中最后一个<span class="string">"turbulenceModelName"</span>是带缺省参数的，所以，只需要提供三个参数。</span><br><span class="line">turbulenceModel::turbulenceModel</span><br><span class="line">(</span><br><span class="line">    const volVectorField&amp; U,</span><br><span class="line">    const surfaceScalarField&amp; phi,</span><br><span class="line">    transportModel&amp; transport,</span><br><span class="line">    const word&amp; turbulenceModelName</span><br><span class="line">)</span><br><span class="line">//  这里往下一段叫做成员初始化列表，用于对当前类以及其基类成员进行初始化</span><br><span class="line">:</span><br><span class="line">    regIOobject</span><br><span class="line">    (</span><br><span class="line">        IOobject</span><br><span class="line">        (</span><br><span class="line">            turbulenceModelName,</span><br><span class="line">            U.time().constant(),</span><br><span class="line">            U.db(),</span><br><span class="line">            IOobject::NO_READ,</span><br><span class="line">            IOobject::NO_WRITE</span><br><span class="line">        )</span><br><span class="line">    ),</span><br><span class="line">    runTime_(U.time()),</span><br><span class="line">    mesh_(U.mesh()),</span><br><span class="line"></span><br><span class="line">    U_(U),</span><br><span class="line">    phi_(phi),</span><br><span class="line">    transportModel_(transport), // 输运模型从构造函数的参数中读取</span><br><span class="line">    y_(mesh_)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> Selectors <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> //</span><br><span class="line"></span><br><span class="line">这个函数，起着选择具体湍流模型的作用，后面我会结合求解器代码仔细说说这个函数。更详细的机制，将在结合运行时选择机制来解释。</span><br><span class="line">autoPtr<span class="variable">&lt;turbulenceModel&gt;</span> turbulenceModel::New</span><br><span class="line">(</span><br><span class="line">    const volVectorField&amp; U,</span><br><span class="line">    const surfaceScalarField&amp; phi,</span><br><span class="line">    transportModel&amp; transport,</span><br><span class="line">    const word&amp; turbulenceModelName</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    // 注意这里了，算例中的<span class="string">"turbulenceProperties"</span> 文件即由这段代码来读取。</span><br><span class="line">    // 需要从<span class="string">"turbulenceProperties"</span> 文件中查找一个关键字<span class="string">"simulationType"</span>，</span><br><span class="line">    // 然后将<span class="string">"simulationType"</span>对应的值赋值给变量<span class="string">"modelType"</span>（对于单相流，modelType 只可能是 <span class="string">"RAS"</span> 或者 <span class="string">"LES"</span>）。</span><br><span class="line">    const word modelType</span><br><span class="line">    (</span><br><span class="line">        IOdictionary</span><br><span class="line">        (</span><br><span class="line">            IOobject</span><br><span class="line">            (</span><br><span class="line">                <span class="string">"turbulenceProperties"</span>,</span><br><span class="line">                U.time().constant(),</span><br><span class="line">                U.db(),</span><br><span class="line">                IOobject::MUST_READ_IF_MODIFIED,</span><br><span class="line">                IOobject::NO_WRITE,</span><br><span class="line">                false</span><br><span class="line">            )</span><br><span class="line">        ).lookup(<span class="string">"simulationType"</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    Info<span class="variable">&lt;&lt; "Selecting turbulence model type " &lt;&lt; modelType &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    turbulenceModelConstructorTable::iterator cstrIter =</span><br><span class="line">        turbulenceModelConstructorTablePtr_-&gt;</span>find(modelType);</span><br><span class="line"></span><br><span class="line">    if (cstrIter == turbulenceModelConstructorTablePtr_-&gt;end())</span><br><span class="line">    &#123;</span><br><span class="line">        FatalErrorIn</span><br><span class="line">        (</span><br><span class="line">            <span class="string">"turbulenceModel::New(const volVectorField&amp;, "</span></span><br><span class="line">            <span class="string">"const surfaceScalarField&amp;, transportModel&amp;, const word&amp;)"</span></span><br><span class="line">        )   <span class="variable">&lt;&lt; "Unknown turbulenceModel type "</span><br><span class="line">            &lt;&lt; modelType &lt;&lt; nl &lt;&lt; nl</span><br><span class="line">            &lt;&lt; "Valid turbulenceModel types:" &lt;&lt; endl</span><br><span class="line">            &lt;&lt; turbulenceModelConstructorTablePtr_-&gt;</span>sortedToc()</span><br><span class="line">            <span class="variable">&lt;&lt; exit(FatalError);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return autoPtr&lt;turbulenceModel&gt;</span></span><br><span class="line">    (</span><br><span class="line">        cstrIter()(U, phi, transport, turbulenceModelName)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> Member Functions  <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> //</span><br><span class="line"></span><br><span class="line">void turbulenceModel::correct()</span><br><span class="line">&#123;</span><br><span class="line">    transportModel_.correct();</span><br><span class="line"></span><br><span class="line">    if (mesh_.changing())</span><br><span class="line">    &#123;</span><br><span class="line">        y_.correct();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> //</span><br><span class="line"></span><br><span class="line">&#125; // End namespace incompressible</span><br><span class="line">&#125; // End namespace Foam</span><br></pre></td></tr></table></figure></p>
<p>从基类 <code>turbulenceModel</code> 以下，就要花开两朵，各表一枝了。先来看 <code>RAS</code> 类的湍流模型。</p>
<h5 id="1-2_RAS_模型">1.2 RAS 模型</h5><p>我们从头文件 RASModel.H 看起<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Foam</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">namespace</span> incompressible</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------------------------------------------------------------------------*\</span><br><span class="line">                           Class RASModel Declaration</span><br><span class="line">\*---------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> RASModel</span><br><span class="line">:</span><br><span class="line">    <span class="keyword">public</span> turbulenceModel, <span class="comment">// RASModel 类是前面讲的turbulenceModel类的派生类</span></span><br><span class="line">    <span class="keyword">public</span> IOdictionary <span class="comment">// 同时也继承 IOdictionary 类</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 两个开关变量，类似于 C++ 中的bool变量，其值要么是true，要么是false。</span></span><br><span class="line">	<span class="comment">// 只是这里将 true 换成 on，false 换成 off 也是一样的。</span></span><br><span class="line">        Switch turbulence_;</span><br><span class="line">        Switch printCoeffs_;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Model coefficients dictionary</span></span><br><span class="line">        dictionary coeffDict_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Lower limit of k</span></span><br><span class="line">        dimensionedScalar kMin_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Lower limit of epsilon</span></span><br><span class="line">        dimensionedScalar epsilonMin_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Lower limit for omega</span></span><br><span class="line">        dimensionedScalar omegaMin_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Protected Member Functions</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Print model coefficients</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">printCoeffs</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Private Member Functions</span></span><br><span class="line">        <span class="comment">//- Disallow default bitwise copy construct</span></span><br><span class="line">        RASModel(<span class="keyword">const</span> RASModel&amp;);</span><br><span class="line">        <span class="comment">//- Disallow default bitwise assignment</span></span><br><span class="line">        <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> RASModel&amp;);</span><br><span class="line">        </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">//- Runtime type information</span></span><br><span class="line">    TypeName(<span class="string">"RASModel"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里也涉及到 运行时选择机制，以后一起讲。</span></span><br><span class="line">        declareRunTimeSelectionTable</span><br><span class="line">        (</span><br><span class="line">            autoPtr,</span><br><span class="line">            RASModel,</span><br><span class="line">            dictionary,</span><br><span class="line">            (</span><br><span class="line">                <span class="keyword">const</span> volVectorField&amp; U,</span><br><span class="line">                <span class="keyword">const</span> surfaceScalarField&amp; phi,</span><br><span class="line">                transportModel&amp; transport,</span><br><span class="line">                <span class="keyword">const</span> word&amp; turbulenceModelName</span><br><span class="line">            ),</span><br><span class="line">            (U, phi, transport, turbulenceModelName)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">        RASModel</span><br><span class="line">        (</span><br><span class="line">            <span class="keyword">const</span> word&amp; type,</span><br><span class="line">            <span class="keyword">const</span> volVectorField&amp; U,</span><br><span class="line">            <span class="keyword">const</span> surfaceScalarField&amp; phi,</span><br><span class="line">            transportModel&amp; transport,</span><br><span class="line">            <span class="keyword">const</span> word&amp; turbulenceModelName = turbulenceModel::typeName</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Return a reference to the selected RAS model 这个函数作为运行时选择机制里的选择器。</span></span><br><span class="line">        <span class="keyword">static</span> autoPtr&lt;RASModel&gt; New</span><br><span class="line">        (</span><br><span class="line">            <span class="keyword">const</span> volVectorField&amp; U,</span><br><span class="line">            <span class="keyword">const</span> surfaceScalarField&amp; phi,</span><br><span class="line">            transportModel&amp; transport,</span><br><span class="line">            <span class="keyword">const</span> word&amp; turbulenceModelName = turbulenceModel::typeName</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Member Functions</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Access</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注意，一下这些成员函数，是将来 RASModel 类的派生类们可能会用到的，这里一起定义了，</span></span><br><span class="line">	    <span class="comment">// 后面的派生类将可以直接继承这些函数，这样达到了代码重复利用的作用。</span></span><br><span class="line">            <span class="comment">//- Return the lower allowable limit for k (default: SMALL)</span></span><br><span class="line">            <span class="keyword">const</span> dimensionedScalar&amp; kMin() <span class="keyword">const</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> kMin_;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//- Return the lower allowable limit for epsilon (default: SMALL)</span></span><br><span class="line">            <span class="keyword">const</span> dimensionedScalar&amp; epsilonMin() <span class="keyword">const</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> epsilonMin_;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//- Return the lower allowable limit for omega (default: SMALL)</span></span><br><span class="line">            <span class="keyword">const</span> dimensionedScalar&amp; omegaMin() <span class="keyword">const</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> omegaMin_;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//- Allow kMin to be changed</span></span><br><span class="line">            dimensionedScalar&amp; kMin()</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> kMin_;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//- Allow epsilonMin to be changed</span></span><br><span class="line">            dimensionedScalar&amp; epsilonMin()</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> epsilonMin_;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//- Allow omegaMin to be changed</span></span><br><span class="line">            dimensionedScalar&amp; omegaMin()</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> omegaMin_;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//- Const access to the coefficients dictionary</span></span><br><span class="line">            <span class="keyword">virtual</span> <span class="keyword">const</span> dictionary&amp; coeffDict() <span class="keyword">const</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> coeffDict_;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Return the effective viscosity</span></span><br><span class="line">	<span class="comment">// 这个函数很重要，默认情况下，雷诺时均湍流模型中，有效粘度等于湍流粘度加层流粘度，即nut + nu。</span></span><br><span class="line">	<span class="comment">// 这里的 nut 和 nu 两个函数在基类 turbulenceModel 声明了，请往前翻以证实这一点。</span></span><br><span class="line">        <span class="keyword">virtual</span> tmp&lt;volScalarField&gt; nuEff() <span class="keyword">const</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> tmp&lt;volScalarField&gt;</span><br><span class="line">            (</span><br><span class="line">                <span class="keyword">new</span> volScalarField(<span class="string">"nuEff"</span>, nut() + nu())</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Solve the turbulence equations and correct the turbulence viscosity</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">correct</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Read RASProperties dictionary</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// End namespace incompressible</span></span><br><span class="line">&#125; <span class="comment">// End namespace Foam</span></span><br></pre></td></tr></table></figure></p>
<p>再来看 <code>RASModel.C</code>，这里跟 <code>turbulenceModel.C</code> 类似，重点关注构造函数和 选择器（Selector）函数。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line">namespace Foam</span><br><span class="line">&#123;</span><br><span class="line">namespace incompressible</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">defineTypeNameAndDebug(RASModel, <span class="number">0</span>);</span><br><span class="line">defineRunTimeSelectionTable(RASModel, dictionary);</span><br><span class="line">addToRunTimeSelectionTable(turbulenceModel, RASModel, turbulenceModel);</span><br><span class="line"></span><br><span class="line"><span class="comment">// * * * * * * * * * * * * * Protected Member Functions  * * * * * * * * * * //</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> RASModel::printCoeffs()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (printCoeffs_)</span><br><span class="line">    &#123;</span><br><span class="line">        Info&lt;&lt; type() &lt;&lt; <span class="string">"Coeffs"</span> &lt;&lt; coeffDict_ &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">RASModel::RASModel</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> word&amp; type,</span><br><span class="line">    <span class="keyword">const</span> volVectorField&amp; U,</span><br><span class="line">    <span class="keyword">const</span> surfaceScalarField&amp; phi,</span><br><span class="line">    transportModel&amp; transport,</span><br><span class="line">    <span class="keyword">const</span> word&amp; turbulenceModelName</span><br><span class="line">)</span><br><span class="line">:</span><br><span class="line">类似的，这里也是使用成员初始化列表来初始化当前类及其父类的数据成员</span><br><span class="line"></span><br><span class="line">    // 这一句是传递参数给父类 turbulenceModel，注意这里传给父类构造函数的参数要与父类中的构造函数的参数表一致哦</span><br><span class="line">    turbulenceModel(U, phi, transport, turbulenceModelName), </span><br><span class="line">    </span><br><span class="line"> //这里是建立一个IOobject来初始化另一个父类IOdictionary，注意这里建立的是一个名为“RASProperties”的IO对象，这个文件相信用过 OpenFOAM 湍流模拟的一定很熟悉吧</span><br><span class="line">    IOdictionary</span><br><span class="line">    (</span><br><span class="line">        IOobject</span><br><span class="line">        (</span><br><span class="line">            <span class="string">"RASProperties"</span>,</span><br><span class="line">            U.time().constant(), // 这里表示文件的位置是在constant文件夹下</span><br><span class="line">            U.db(),</span><br><span class="line">            IOobject::MUST_READ_IF_MODIFIED, //这里的意思是，如果修改了，则需要重新读取，所以，如果你在算例运行时修改了这个文件，你的修改会即时生效的</span><br><span class="line">            IOobject::NO_WRITE</span><br><span class="line">        )</span><br><span class="line">    ),</span><br><span class="line">    </span><br><span class="line">  // 查找“turbulence” 关键字，并用其对应的值来初始化变量“turbulnce_”。</span><br><span class="line">    turbulence_(lookup(<span class="string">"turbulence"</span>)),</span><br><span class="line">    // 同上，区别是这里是带缺省参数的，也就是说如果找不到“printCoeffs” 就用缺省值“<span class="keyword">false</span>”</span><br><span class="line">    printCoeffs_(lookupOrDefault&lt;Switch&gt;(<span class="string">"printCoeffs"</span>, <span class="keyword">false</span>)), </span><br><span class="line">    </span><br><span class="line">    // 这里是读取模型参数字典来初始化变量“coeffDict_”。注意，这里的 type 是啥？这个要等到进一步看一个具体的湍流模型类时才能明了。 </span><br><span class="line">    // 另外，注意这里的 `lookup` ， `lookupOrDefault` 和 `subOrEmptyDict` 三个函数都是继承自 IOdictionary 类的函数。</span><br><span class="line">    coeffDict_(subOrEmptyDict(type + <span class="string">"Coeffs"</span>)), </span><br><span class="line"></span><br><span class="line">    kMin_(<span class="string">"kMin"</span>, sqr(dimVelocity), SMALL),</span><br><span class="line">    epsilonMin_(<span class="string">"epsilonMin"</span>, kMin_.dimensions()/dimTime, SMALL),</span><br><span class="line">    omegaMin_(<span class="string">"omegaMin"</span>, dimless/dimTime, SMALL)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里是从 RASProperties 里读取kMin等的值，注意如果 RASProperties 里不设置那就使用上面初始化的值“SMALL”。</span></span><br><span class="line">    <span class="comment">// 注意这里的“*this”代表的是 RASModel 类本身，但是readIfPresent函数的参数应该是 dictionary 类，由于RASModel 类继承自 IODictionary 类，所以，这里其实隐含了一个派生类指针向基类指针的转换</span></span><br><span class="line">    kMin_.readIfPresent(*<span class="keyword">this</span>);  </span><br><span class="line">    epsilonMin_.readIfPresent(*<span class="keyword">this</span>);</span><br><span class="line">    omegaMin_.readIfPresent(*<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Force the construction of the mesh deltaCoeffs which may be needed</span></span><br><span class="line">    <span class="comment">// for the construction of the derived models and BCs</span></span><br><span class="line">    mesh_.deltaCoeffs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//这个也是跟运行时选择有关，以后会细说</span></span><br><span class="line">autoPtr&lt;RASModel&gt; RASModel::New</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> volVectorField&amp; U,</span><br><span class="line">    <span class="keyword">const</span> surfaceScalarField&amp; phi,</span><br><span class="line">    transportModel&amp; transport,</span><br><span class="line">    <span class="keyword">const</span> word&amp; turbulenceModelName</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// get model name, but do not register the dictionary</span></span><br><span class="line">    <span class="comment">// otherwise it is registered in the database twice</span></span><br><span class="line">    <span class="keyword">const</span> word modelType</span><br><span class="line">    (</span><br><span class="line">        IOdictionary</span><br><span class="line">        (</span><br><span class="line">            IOobject</span><br><span class="line">            (</span><br><span class="line">                <span class="string">"RASProperties"</span>,</span><br><span class="line">                U.time().constant(),</span><br><span class="line">                U.db(),</span><br><span class="line">                IOobject::MUST_READ_IF_MODIFIED,</span><br><span class="line">                IOobject::NO_WRITE,</span><br><span class="line">                <span class="keyword">false</span></span><br><span class="line">            )</span><br><span class="line">        ).lookup(<span class="string">"RASModel"</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    Info&lt;&lt; <span class="string">"Selecting RAS turbulence model "</span> &lt;&lt; modelType &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    dictionaryConstructorTable::iterator cstrIter =</span><br><span class="line">        dictionaryConstructorTablePtr_-&gt;find(modelType);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cstrIter == dictionaryConstructorTablePtr_-&gt;end())</span><br><span class="line">    &#123;</span><br><span class="line">        FatalErrorIn</span><br><span class="line">        (</span><br><span class="line">            <span class="string">"RASModel::New"</span></span><br><span class="line">            <span class="string">"("</span></span><br><span class="line">                <span class="string">"const volVectorField&amp;, "</span></span><br><span class="line">                <span class="string">"const surfaceScalarField&amp;, "</span></span><br><span class="line">                <span class="string">"transportModel&amp;, "</span></span><br><span class="line">                <span class="string">"const word&amp;"</span></span><br><span class="line">            <span class="string">")"</span></span><br><span class="line">        )   &lt;&lt; <span class="string">"Unknown RASModel type "</span></span><br><span class="line">            &lt;&lt; modelType &lt;&lt; nl &lt;&lt; nl</span><br><span class="line">            &lt;&lt; <span class="string">"Valid RASModel types:"</span> &lt;&lt; endl</span><br><span class="line">            &lt;&lt; dictionaryConstructorTablePtr_-&gt;sortedToc()</span><br><span class="line">            &lt;&lt; exit(FatalError);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> autoPtr&lt;RASModel&gt;</span><br><span class="line">    (</span><br><span class="line">        cstrIter()(U, phi, transport, turbulenceModelName)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// * * * * * * * * * * * * * * * Member Functions  * * * * * * * * * * * * * //</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> RASModel::correct()</span><br><span class="line">&#123;</span><br><span class="line">    turbulenceModel::correct();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool RASModel::read()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//if (regIOobject::read())</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bit of trickery : we are both IOdictionary ('RASProperties') and</span></span><br><span class="line">    <span class="comment">// an regIOobject from the turbulenceModel level. Problem is to distinguish</span></span><br><span class="line">    <span class="comment">// between the two - we only want to reread the IOdictionary.</span></span><br><span class="line"></span><br><span class="line">    bool ok = IOdictionary::readData</span><br><span class="line">    (</span><br><span class="line">        IOdictionary::readStream</span><br><span class="line">        (</span><br><span class="line">            IOdictionary::type()</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">    IOdictionary::close();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ok)</span><br><span class="line">    &#123;</span><br><span class="line">        lookup(<span class="string">"turbulence"</span>) &gt;&gt; turbulence_;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">const</span> dictionary* dictPtr = subDictPtr(type() + <span class="string">"Coeffs"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            coeffDict_ &lt;&lt;= *dictPtr;</span><br><span class="line">        &#125;</span><br><span class="line">        kMin_.readIfPresent(*<span class="keyword">this</span>);</span><br><span class="line">        epsilonMin_.readIfPresent(*<span class="keyword">this</span>);</span><br><span class="line">        omegaMin_.readIfPresent(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// End namespace incompressible</span></span><br><span class="line">&#125; <span class="comment">// End namespace Foam</span></span><br></pre></td></tr></table></figure></p>
<h5 id="1-3_LES_模型">1.3 LES 模型</h5><p>LESModel 类的结构与 RASModel 非常接近，所以这里就简单提一下区别之处。</p>
<ul>
<li>delta_ 成员<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">autoPtr</span>&lt;<span class="rule"><span class="attribute">Foam</span>:<span class="value">:LESdelta&gt; delta_</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这个成员是 LESdelta 类的对象，定义滤波尺度。这个类的定义在 <code>src/turbulenceModels/LES/LESdeltas</code> ，当中定义了几个可选的 delta 模型</p>
<ul>
<li>亚格子粘度和应力</li>
</ul>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//- Return the SGS viscosity. 亚格子粘度</span></span><br><span class="line">       <span class="function"><span class="keyword">virtual</span> tmp&lt;volScalarField&gt; <span class="title">nuSgs</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//- Return the effective viscosity</span></span><br><span class="line">       <span class="function"><span class="keyword">virtual</span> tmp&lt;volScalarField&gt; <span class="title">nuEff</span><span class="params">()</span> <span class="keyword">const</span> <span class="comment">//有效粘度等于亚格子粘度与分子粘度之和</span></span><br><span class="line">       </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> tmp&lt;volScalarField&gt;</span><br><span class="line">           (</span><br><span class="line">               <span class="keyword">new</span> volScalarField(<span class="string">"nuEff"</span>, nuSgs() + nu())</span><br><span class="line">           );</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//- Return the sub-grid stress tensor. // 亚格子应力</span></span><br><span class="line">       <span class="function"><span class="keyword">virtual</span> tmp&lt;volSymmTensorField&gt; <span class="title">B</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>LESModel.C 的结构与 RASModel.C 几乎一样，所以这里就不重复了。</p>
<p>前面提到，基类 turbulenceModel 里声明了很多纯虚函数，所以，turbulenceModel 类是抽象类，不能直接创建对象。注意这里的 RASModel 类和 LESModel 类由于继承了 turbulenceModel 类的纯虚函数，所以这两个依然是抽象类。这一点在后面解析具体湍流模型类的时候还会提到，这里先提个醒。</p>
<h5 id="1-4_继承派生关系">1.4 继承派生关系</h5><p>前面看完了基类 turbulenceModel，RASModel 以及 LESModel，可以看出这三个类的继承派生关系为：</p>
<p><img src="/image/turbulenceModel/RAS_LES.png" alt="RAS 和 LES 与 turbulenceModel 的继承关系"></p>
<p>下面继续看具体湍流模型类与基类的继承关系。<br>先看雷诺时均类湍流模型：<br>位于 <code>src/turbulenceModels/incompressible/RAS</code> 目录下的都是雷诺时均类的湍流模型，这个类型的继承关系很简单：所有具体湍流模型类都继承自 RASModel 类，关系示意图如下：</p>
<p><img src="/image/turbulenceModel/RAS.png" alt="RAS 类湍流模型的继承关系"></p>
<p>位于 <code>src/turbulenceModels/incompressible/LES</code> 目录下的是大涡模拟类型的湍流模型，这类湍流模型的继承关系比雷诺时均类的要复杂一点，但是也不难捋清，过程我就不详述了，下面给出我整理的继承关系图：</p>
<p><img src="/image/turbulenceModel/LES.png" alt="LES 类湍流模型的继承关系"></p>
<p>上图中，虚线框里的是抽象类，实线框里的是具体的可以调用的湍流模型类。</p>
<h5 id="1-5_求解器中湍流模型的调用">1.5 求解器中湍流模型的调用</h5><p>最后简单提一下求解器中调用湍流模型的接口。以 <code>pisoFoam</code> 求解器为例：<br>纵观 <code>pisoFoam</code> 的代码，跟湍流模型有关的共有三处，第一处是在 createField.H 的最后面，创建一个智能指针<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">autoPtr</span>&lt;<span class="rule"><span class="attribute">incompressible</span>:<span class="value">:turbulenceModel&gt; turbulence</span><br><span class="line">    (</span><br><span class="line">        incompressible::turbulenceModel::<span class="function">New</span>(U, phi, laminarTransport)</span><br><span class="line">    )</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>注意，这个指针的类型是 <code>incompressible::turbulenceModel</code> ，也就是说，创建的是基类的指针。<br>第二处位于 <code>UEqn</code> 中，<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ turbulence-&gt;<span class="function"><span class="title">divDevReff</span><span class="params">(U)</span></span></span><br></pre></td></tr></table></figure></p>
<p>从这里可以看出，这是用指针 <code>turbulence</code> 调用成员函数 <code>divDevReff</code><br>第三处在曳力修正之后<br><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">turbulence-&gt;correct<span class="literal">()</span>;</span><br></pre></td></tr></table></figure></p>
<p>这里是调用成员函数 <code>correct</code> 。<br>这简单的几行代码，就完成了湍流模型的调用。这里先大致说一下调用的原理和过程，详细的留待后面跟运行时选择机制一起说。<br>首先，注意刚才提到的智能指针 <code>turbulence</code> 的类型是 <code>incompressible::turbulenceModel</code> ，是基类类型的。这里就不得不说一下 C++ <strong>虚函数</strong>的作用了。还记得上面提到的基类 <code>turbulenceModel</code> 中声明的那些<strong>纯虚函数</strong>吧，如果你往上翻翻，你会发现， <code>divDevReff</code> 和 <code>correct</code> 在基类 <code>turbulenceModel</code> 中都被声明为<strong>纯虚函数</strong>。这里只要把握两点，就能理解湍流模型的调用原理：</p>
<ol>
<li>基类类型的指针可以指向派生类的对象；</li>
<li>在基类中声明的纯虚函数可以在派生类中进行定义，当基类类型指针指向派生类对象以后，用这个指针调用成员函数时，实际调用的是指针指向的派生类中定义的函数。</li>
</ol>
<p>把握这两点，然后再去理解湍流模型的调用过程：<br>首先是调用 <code>incompressible::turbulenceModel::New</code> 函数来初始化指针 <code>turbulence</code> ，查看上面 <code>turbulenceModel</code> 类中 <code>New</code> 函数的定义，可以知道，函数要先从“turbulenceProperties” 文件里 <code>simulationType</code>　关键字，从而决定是调用 <code>RAS</code> 模型还是 <code>LES</code> 模型。如果用户设定的是 <code>RAS</code> ，那么 <code>turbulenceModel</code> 类的 <code>New</code> 函数将返回一个指向 <code>RASModel</code> 类的指针，这个指针将继续调用 <code>RASModel</code> 类的 <code>New</code> 函数，并在这个函数中读取 <code>RASProperties</code> 文件，查找关键字 <code>RASModel</code> ，从而决定具体调用的湍流模型。假设用户指定的是 <code>kEpsilon</code> 那么最终 createField.H 中定义的指针 <code>turbulence</code> 将指向一个 <code>kEpsilon</code> 类的对象，由此， <code>turbulence-&gt;divDevReff(U)</code> 和 <code>turbulence-&gt;correct()</code> 都将分别调用定义在 <code>kEpsilon</code> 类中的成员函数 <code>divDevReff</code> 和 <code>correct</code>。<br>一个简单的湍流模型调用示意图如下：</p>
<p><img src="/image/turbulenceModel/call.png" alt="湍流模型调用示意图"></p>
<p>以上是 RAS 类型模型的调用，LES 类型的基本上差不多，但是，从上面的继承关系图也能看出，LES 模型类的结构更复杂一点。根本原因在于，LES 模型不像 RAS 模型那样都是同一的对湍流粘度 <code>nut</code> 建模，而是有一部分是对亚格子粘度 <code>nuSgs</code> 建模（这一部分湍流模型均继承自 <code>GenEddyVisc</code> ），还有另一部分是直接对亚格子应力 <code>B</code> 建模（这一部分湍流模型均继承自 <code>GenSGSStress</code> ），此外，分离涡模型（Detached eddy model， DESModel）也放在这个目录下，而且还有一个直接继承自 <code>LESModel</code> 的模型 <code>kOmegaSSTSAS</code> （这个模型与 <code>LESModel</code> 的关系就跟 <code>kEpsilon</code> 与 <code>RASModel</code> 的关系一样）。虽然有这么多种类型，但是调用过程其实跟 RAS 类型的是差不多的。如果从字典文件“turbulenceProperties” 里读到的 <code>simulationType</code> 是 <code>LES</code> 的话，那么将继续从字典文件 <code>LESProperties</code> 里读取具体的 LES 模型。上面总结的那张继承关系图中，所有的实线框中的模型都可以选择。但是，具体的模型需要具体的设置，比如，需要设置滤波尺度 <code>delta</code> 模型，还可能需要设置 <code>filter</code> 模型，具体的要求可以去具体的湍流模型类的代码中去看。如果你了解一点你需要使用的湍流模型的基本理论，能写出模型的方程，那要看懂这个湍流模型在 OpenFOAM 中实现的代码是很容易的。</p>
<p>上述关于调用过程的叙述，只是我的理解，其实不严谨，但大致原理应该是这样。计划中这个系列将写三篇，我将在第三篇中叙述运行时选择机制，到时候还会深入说说这个调用过程。</p>
<p>P.S：本系列在筹划时，OpenFOAM-3.0 版本还没发布。随着 3.0 版本的发布，本系列里对湍流模型的描述已经“过时”了，因为在 3.0 版中，湍流模型类进行了重新模板化，将单相湍流和多相湍流模型整合在一起了，所以这里的描述只适用于 3.0 以下的版本。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>相信有不少 OpenFOAM 用户有添加湍流模型的需求，我自己最早用 OpenFOAM 完成的一项工作就是在其中添加了一些单相流的湍流模型，并进行了一些计算。这里将我对单相湍流模型代码框架的理解记录下来，供大家参考。本系列将包含三篇，第一篇介绍湍流模型类的继承派生关系，第二篇具体分析几个 OpenFOAM 中带的湍流模型，并给出修改或增加新模型的方法，第三篇分析湍流模型的运行时选择机制（Run Time Selection）的原理。</p>]]>
    
    </summary>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/tags/OpenFOAM/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[blockMesh 的新功能：multi/sectional grading in a block]]></title>
    <link href="http://xiaopingqiu.github.io/2015/10/06/blockMesh-multi-sectional-grading/"/>
    <id>http://xiaopingqiu.github.io/2015/10/06/blockMesh-multi-sectional-grading/</id>
    <published>2015-10-06T12:24:52.000Z</published>
    <updated>2015-11-03T13:38:21.454Z</updated>
    <content type="html"><![CDATA[<p>从 OpenFOAM-2.3.x 的 “<a href="https://github.com/OpenFOAM/OpenFOAM-2.3.x/commit/cf370883644ec59782be375041b2434eb3e2c4ed" target="_blank" rel="external">commit cf370883644ec59782be375041b2434eb3e2c4ed</a>“ 开始，<code>blockMesh</code> 有了一项新功能：multi/sectional grading in a block。这项功能说起来很简单即可以在同一个block里面设置多个方向的大小渐变网格。举个例子，假设你想画一个简单的二维槽道流网格，你希望两边靠近壁面处的网格更密一点，而中心的网格稀疏一点。以前版本的 <code>blockMesh</code> 由于只支持让网格大小在某一个方向上渐变（通过设置 simpleGrading），要实现上述网格，你需要将整个槽道分成两个block，然后分别设置 simpleGrading。现在有了 “multi/sectional grading”以后，只需要一个block，并设置好simpleGrading便可实现了。下面解释一下新版 <code>blockMesh</code> 具体设置，并以一个二维方腔流例子来说明。</p>
<a id="more"></a>
<p>先来解释一下参数的含义，下面是我设置的一个二维方腔流算例的 blockMeshDict 文件的部分：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">vertices</span><br><span class="line"><span class="list">(</span><br><span class="line">    <span class="list">(<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>)</span></span><br><span class="line">    <span class="list">(<span class="number">1</span> <span class="number">0</span> <span class="number">0</span>)</span></span><br><span class="line">    <span class="list">(<span class="number">1</span> <span class="number">1</span> <span class="number">0</span>)</span></span><br><span class="line">    <span class="list">(<span class="number">0</span> <span class="number">1</span> <span class="number">0</span>)</span></span><br><span class="line">    <span class="list">(<span class="number">0</span> <span class="number">0</span> <span class="number">0.1</span>)</span></span><br><span class="line">    <span class="list">(<span class="number">1</span> <span class="number">0</span> <span class="number">0.1</span>)</span></span><br><span class="line">    <span class="list">(<span class="number">1</span> <span class="number">1</span> <span class="number">0.1</span>)</span></span><br><span class="line">    <span class="list">(<span class="number">0</span> <span class="number">1</span> <span class="number">0.1</span>)</span></span><br><span class="line">)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">blocks</span><br><span class="line"><span class="list">(</span><br><span class="line">    <span class="keyword">hex</span> <span class="list">(<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>)</span> <span class="list">(<span class="number">100</span> <span class="number">100</span> <span class="number">1</span>)</span></span><br><span class="line">    simpleGrading</span><br><span class="line">    <span class="list">(</span><br><span class="line">      <span class="list">(<span class="list">(<span class="number">0.5</span> <span class="number">0.5</span> <span class="number">2</span>)</span>  <span class="list">(<span class="number">0.5</span> <span class="number">0.5</span> <span class="number">0.5</span>)</span>)</span></span><br><span class="line">      <span class="list">(<span class="list">(<span class="number">0.5</span> <span class="number">0.5</span> <span class="number">2</span>)</span>  <span class="list">(<span class="number">0.5</span> <span class="number">0.5</span> <span class="number">0.5</span>)</span>)</span></span><br><span class="line">      <span class="number">1</span></span><br><span class="line">    )</span></span><br><span class="line">)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>跟前面版本的差别在于 simpleGrading 部分的参数更多了。下面解释一下多出来的参数的含义。首先，注意 simpleGrading 的参数仍然是分成三段，分别代表x，y，z方向的网格渐变设置。其中，x方向的渐变设置参数又分作两段：”(0.5 0.5 2)”和”(0.5 0.5 0.5)”，每一段均代表一个子 block，这个子 block 的网格参数由三个数字来确定。以”(0.5 0.5 2)” 为例，第一个”0.5” 表示该子 block 的尺度是总 block 的尺度的0.5倍；第二个”0.5”表示在这个子block里划分的网格总数占整个block的网格总数的一半；”2” 代表着网格渐变因子，这个跟以前的 blockMesh 的 simpleGrading 参数的含义一样。</p>
<p>了解了参数的含义，便可以推知上述 blockMeshDict 文件对应的网格了：二维方腔，x和y方向上各分为两个子 block，子 block 的尺度都是整个 block 的一半，且子 block 的网格渐变因子分别为 “2” 和 “0.5”。得到的网格如下：</p>
<p><img src="/image/blockMesh/mesh_whole.png" alt="整体"></p>
<p>右上角局部放大图如下：<br><img src="/image/blockMesh/mesh_local.png" alt="右上角局部放大"></p>
<p>上述描述中有一个不是很严谨的地方，用下面这个例子来说明一下：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">blocks</span><br><span class="line"><span class="list">(</span><br><span class="line">    <span class="keyword">hex</span> <span class="list">(<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>)</span> <span class="list">(<span class="number">20</span> <span class="number">60</span> <span class="number">20</span>)</span></span><br><span class="line">    simpleGrading</span><br><span class="line">    <span class="list">(</span><br><span class="line">        <span class="number">1</span></span><br><span class="line">        <span class="list">(<span class="list">(<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>)</span> <span class="list">(<span class="number">6</span> <span class="number">4</span> <span class="number">1</span>)</span> <span class="list">(<span class="number">2</span> <span class="number">3</span> <span class="number">0.25</span>)</span>)</span></span><br><span class="line">        <span class="number">1</span></span><br><span class="line">    )</span></span><br><span class="line">)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>按照上文的描述，这个网格将在y方向上划分成3个子 block，其中第一个子 block 的尺度是整个 block 的2倍…等等，2倍？这怎么可能？实际情况是，blockMesh 会自动对参数进行归一化，第一个子 block 的尺度将是整个 block 的 2/(2+6+2)=0.2 倍，其余的依此类推。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>从 OpenFOAM-2.3.x 的 “<a href="https://github.com/OpenFOAM/OpenFOAM-2.3.x/commit/cf370883644ec59782be375041b2434eb3e2c4ed">commit cf370883644ec59782be375041b2434eb3e2c4ed</a>“ 开始，<code>blockMesh</code> 有了一项新功能：multi/sectional grading in a block。这项功能说起来很简单即可以在同一个block里面设置多个方向的大小渐变网格。举个例子，假设你想画一个简单的二维槽道流网格，你希望两边靠近壁面处的网格更密一点，而中心的网格稀疏一点。以前版本的 <code>blockMesh</code> 由于只支持让网格大小在某一个方向上渐变（通过设置 simpleGrading），要实现上述网格，你需要将整个槽道分成两个block，然后分别设置 simpleGrading。现在有了 “multi/sectional grading”以后，只需要一个block，并设置好simpleGrading便可实现了。下面解释一下新版 <code>blockMesh</code> 具体设置，并以一个二维方腔流例子来说明。</p>]]>
    
    </summary>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/tags/OpenFOAM/"/>
    
      <category term="Preprocessing" scheme="http://xiaopingqiu.github.io/tags/Preprocessing/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenFOAM-2.3.x 中的 twoPhaseEulerFoam 解析之 TurbulenceModel]]></title>
    <link href="http://xiaopingqiu.github.io/2015/09/19/TFM-TurbulenceModel/"/>
    <id>http://xiaopingqiu.github.io/2015/09/19/TFM-TurbulenceModel/</id>
    <published>2015-09-19T04:38:20.000Z</published>
    <updated>2015-09-25T09:15:31.359Z</updated>
    <content type="html"><![CDATA[<p>在 <code>kineticTheoryModel</code> 类的解读时前面提到过， <code>kineticTheoryModel</code> 使用了跟湍流模型一样的接口。这一篇，就来看一下 <code>twoPhaseEulerFoam</code> 中的湍流模型。  </p>
<a id="more"></a>
<p>OpenFOAM-2.3.x 中的<code>twoPhaseEulerFoam</code> 流体相可以调用 RAS 和 LES 湍流模型，固相可以使用两种计算固相应力的“湍流模型”。<br>湍流模型的调用是通过 phaseModel 来进行的，具体的过程放到最后来讲，这里先说一下最重要的 <code>divDevRhoReff</code> 函数的形式，主要有三种类型：用于固相的 <code>phasePressure</code> 和  <code>kineticTheoryModel</code> 以及用于流体相的 RAS 模型或 LES 模型，以 <code>kEpsilon</code> 模型为例。此外，在”pEqn.H”里，还需要用到 <code>pPrime()</code> 函数，这个函数主要是在处理颗粒相的压力时有意义，所以，在 <code>phasePressure</code> 和 <code>kineticTheoryModel</code> 两个模型中，这个函数也需要关注一下。</p>
<h5 id="1_phasePressure">1  phasePressure</h5><p> 很显然，这个是用于固相的，只考虑所谓固相压力，所以理论上， <code>divDevRhoReff</code>函数应该是对固相动量方程没有贡献的，实际上也正是如此，其定义如下：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="constant">Foam:</span><span class="symbol">:tmp&lt;Foam</span><span class="symbol">:</span><span class="symbol">:fvVectorMatrix&gt;</span></span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:RASModels</span><span class="symbol">:</span><span class="symbol">:phasePressureModel</span><span class="symbol">:</span><span class="symbol">:divDevRhoReff</span></span><br><span class="line">(</span><br><span class="line">    volVectorField&amp; <span class="constant">U</span></span><br><span class="line">) const</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> tmp&lt;fvVectorMatrix&gt;</span><br><span class="line">    (</span><br><span class="line">        new fvVectorMatrix</span><br><span class="line">        (</span><br><span class="line">            <span class="constant">U,</span></span><br><span class="line">            this-&gt;rho<span class="constant">_</span>.dimensions()*dimensionSet(<span class="number">0</span>, <span class="number">4</span>, -<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>经测验，这一项对 fvVectorMatrix 的贡献是零。</p>
 <figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="constant">Foam:</span><span class="symbol">:tmp&lt;Foam</span><span class="symbol">:</span><span class="symbol">:volScalarField&gt;</span></span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:RASModels</span><span class="symbol">:</span><span class="symbol">:phasePressureModel</span><span class="symbol">:</span><span class="symbol">:pPrime</span>() const</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        g0<span class="constant">_</span></span><br><span class="line">       *min</span><br><span class="line">        (</span><br><span class="line">            exp(preAlphaExp<span class="constant">_</span>*(this-&gt;alpha<span class="constant">_</span> - alphaMax<span class="constant">_</span>)),</span><br><span class="line">            expMax<span class="constant">_</span></span><br><span class="line">        );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:tmp&lt;Foam</span><span class="symbol">:</span><span class="symbol">:surfaceScalarField&gt;</span></span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:RASModels</span><span class="symbol">:</span><span class="symbol">:phasePressureModel</span><span class="symbol">:</span><span class="symbol">:pPrimef</span>() const</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        g0<span class="constant">_</span></span><br><span class="line">       *min</span><br><span class="line">        (</span><br><span class="line">            exp(preAlphaExp<span class="constant">_</span>*(<span class="symbol">fvc:</span><span class="symbol">:interpolate</span>(this-&gt;alpha<span class="constant">_</span>) - alphaMax<span class="constant">_</span>)),</span><br><span class="line">            expMax<span class="constant">_</span></span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>phasePressure</code> 模型计算的“固相压力”为<br>$$<br>pPrime = g0\cdot \mathrm{min}(e^{preAlphaExp\cdot (\varepsilon_s - \varepsilon_{s,max})},expMax)<br>$$<br>注意这里的$g0$ 与 <code>radialModel</code> 中的$g_0$ 不是一个概念！</p>
<h5 id="2_kineticTheory">2  kineticTheory</h5><p>KTGF 模型， 代码如下：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">  <span class="constant">Foam:</span><span class="symbol">:tmp&lt;Foam</span><span class="symbol">:</span><span class="symbol">:fvVectorMatrix&gt;</span></span><br><span class="line">  <span class="constant">Foam:</span><span class="symbol">:RASModels</span><span class="symbol">:</span><span class="symbol">:kineticTheoryModel</span><span class="symbol">:</span><span class="symbol">:divDevRhoReff</span></span><br><span class="line">  (</span><br><span class="line">     volVectorField&amp; <span class="constant">U</span></span><br><span class="line">  ) const</span><br><span class="line">  &#123;</span><br><span class="line">     <span class="keyword">return</span></span><br><span class="line">     (</span><br><span class="line">       - <span class="symbol">fvm:</span><span class="symbol">:laplacian</span>(this-&gt;rho<span class="constant">_</span>*this-&gt;nut<span class="constant">_</span>, <span class="constant">U)</span></span><br><span class="line">       - <span class="symbol">fvc:</span><span class="symbol">:div</span></span><br><span class="line">         (</span><br><span class="line">             (this-&gt;rho<span class="constant">_</span>*this-&gt;nut<span class="constant">_</span>)*dev2(<span class="constant">T(</span><span class="symbol">fvc:</span><span class="symbol">:grad</span>(<span class="constant">U)</span>))</span><br><span class="line">           + ((this-&gt;rho<span class="constant">_</span>*lambda<span class="constant">_</span>)*<span class="symbol">fvc:</span><span class="symbol">:div</span>(this-&gt;phi<span class="constant">_</span>))</span><br><span class="line">            *dimensioned&lt;symmTensor&gt;(<span class="string">"I"</span>, dimless, <span class="symbol">symmTensor:</span><span class="symbol">:I</span>)</span><br><span class="line">         )</span><br><span class="line">     );</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:tmp&lt;Foam</span><span class="symbol">:</span><span class="symbol">:volScalarField&gt;</span></span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:RASModels</span><span class="symbol">:</span><span class="symbol">:kineticTheoryModel</span><span class="symbol">:</span><span class="symbol">:pPrime</span>() const</span><br><span class="line">&#123;</span><br><span class="line">    <span class="regexp">//</span> <span class="constant">Local </span>references</span><br><span class="line">    const volScalarField&amp; alpha = this-&gt;alpha<span class="constant">_</span>;</span><br><span class="line">    const volScalarField&amp; rho = phase<span class="constant">_</span>.rho();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    (</span><br><span class="line">        <span class="constant">Theta_</span></span><br><span class="line">       *granularPressureModel<span class="constant">_</span>-&gt;granularPressureCoeffPrime</span><br><span class="line">        (</span><br><span class="line">            alpha,</span><br><span class="line">            radialModel<span class="constant">_</span>-&gt;g<span class="number">0</span>(alpha, alphaMinFriction<span class="constant">_</span>, alphaMax<span class="constant">_</span>),</span><br><span class="line">            radialModel<span class="constant">_</span>-&gt;g0prime(alpha, alphaMinFriction<span class="constant">_</span>, alphaMax<span class="constant">_</span>),</span><br><span class="line">            rho,</span><br><span class="line">            e<span class="constant">_</span></span><br><span class="line">        )</span><br><span class="line">     +  frictionalStressModel<span class="constant">_</span>-&gt;frictionalPressurePrime</span><br><span class="line">        (</span><br><span class="line">            alpha,</span><br><span class="line">            alphaMinFriction<span class="constant">_</span>,</span><br><span class="line">            alphaMax<span class="constant">_</span></span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:tmp&lt;Foam</span><span class="symbol">:</span><span class="symbol">:surfaceScalarField&gt;</span></span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:RASModels</span><span class="symbol">:</span><span class="symbol">:kineticTheoryModel</span><span class="symbol">:</span><span class="symbol">:pPrimef</span>() const</span><br><span class="line">&#123;</span><br><span class="line">    <span class="regexp">//</span> <span class="constant">Local </span>references</span><br><span class="line">    const volScalarField&amp; alpha = this-&gt;alpha<span class="constant">_</span>;</span><br><span class="line">    const volScalarField&amp; rho = phase<span class="constant">_</span>.rho();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="symbol">fvc:</span><span class="symbol">:interpolate</span></span><br><span class="line">    (</span><br><span class="line">        <span class="constant">Theta_</span></span><br><span class="line">       *granularPressureModel<span class="constant">_</span>-&gt;granularPressureCoeffPrime</span><br><span class="line">        (</span><br><span class="line">            alpha,</span><br><span class="line">            radialModel<span class="constant">_</span>-&gt;g<span class="number">0</span>(alpha, alphaMinFriction<span class="constant">_</span>, alphaMax<span class="constant">_</span>),</span><br><span class="line">            radialModel<span class="constant">_</span>-&gt;g0prime(alpha, alphaMinFriction<span class="constant">_</span>, alphaMax<span class="constant">_</span>),</span><br><span class="line">            rho,</span><br><span class="line">            e<span class="constant">_</span></span><br><span class="line">        )</span><br><span class="line">     +  frictionalStressModel<span class="constant">_</span>-&gt;frictionalPressurePrime</span><br><span class="line">        (</span><br><span class="line">            alpha,</span><br><span class="line">            alphaMinFriction<span class="constant">_</span>,</span><br><span class="line">            alphaMax<span class="constant">_</span></span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这一部分详细的公式已在 <code>kineticTheoryModel</code> 解读部分分析了，不再赘述。</p>
<h5 id="3_kEpsilon_(OpenFOAM-2-3-x/src/TurbulenceModels/turbulenceModels/RAS/kEpsilon)">3  kEpsilon (<code>OpenFOAM-2.3.x/src/TurbulenceModels/turbulenceModels/RAS/kEpsilon</code>)</h5><p>这个代表的是RAS湍流模型。（其实还有 LES 模型，只是 RAS 与 LES 的 <code>divDevRhoReff</code>函数形式应该是一样的），函数所在代码路径为：<code>OpenFOAM-2.3.x/src/TurbulenceModels/turbulenceModels/eddyViscosity/eddyViscosity.C</code></p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class <span class="constant">BasicTurbulenceModel&gt;</span></span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:tmp&lt;Foam</span><span class="symbol">:</span><span class="symbol">:fvVectorMatrix&gt;</span></span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:eddyViscosity&lt;BasicTurbulenceModel&gt;</span><span class="symbol">:</span><span class="symbol">:divDevRhoReff</span></span><br><span class="line">(</span><br><span class="line">    volVectorField&amp; <span class="constant">U</span></span><br><span class="line">) const</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    (</span><br><span class="line">      - <span class="symbol">fvm:</span><span class="symbol">:laplacian</span>(this-&gt;alpha<span class="constant">_</span>*this-&gt;rho<span class="constant">_</span>*this-&gt;nuEff(), <span class="constant">U)</span></span><br><span class="line">      - <span class="symbol">fvc:</span><span class="symbol">:div</span>((this-&gt;alpha<span class="constant">_</span>*this-&gt;rho<span class="constant">_</span>*this-&gt;nuEff())*dev2(<span class="constant">T(</span><span class="symbol">fvc:</span><span class="symbol">:grad</span>(<span class="constant">U)</span>)))</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>kEpsilon</code> 类中没有重新定义 <code>pPrime()</code> 函数，而是直接继承 <code>PhaseCompressibleTurbulenceModel</code> 类中的定义，返回零，这里就不列出代码了。</p>
<h4 id="湍流模型的调用">湍流模型的调用</h4><p>湍流模型的调用过程，值得看一下，重点是看一下湍流模型类的继承派生关系，以 <code>kineticTheoryModel</code> 为例。<br><code>kineticTheoryModel</code> 类的声明和构造函数部分如下：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> kineticTheoryModel</span><br><span class="line">:</span><br><span class="line">    public eddyViscosity</span><br><span class="line">    &lt;</span><br><span class="line">        RASModel&lt;PhaseCompressibleTurbulenceModel&lt;phaseModel&gt; &gt;</span><br><span class="line">    &gt;</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foam::RASModels::kineticTheoryModel::kineticTheoryModel</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; <span class="keyword">alpha</span>,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; rho,</span><br><span class="line">    <span class="keyword">const</span> volVectorField&amp; <span class="keyword">U</span>,</span><br><span class="line">    <span class="keyword">const</span> surfaceScalarField&amp; alphaRhoPhi,</span><br><span class="line">    <span class="keyword">const</span> surfaceScalarField&amp; phi,</span><br><span class="line">    <span class="keyword">const</span> transportModel&amp; phase,</span><br><span class="line">    <span class="keyword">const</span> word&amp; propertiesName,</span><br><span class="line">    <span class="keyword">const</span> word&amp; <span class="keyword">type</span></span><br><span class="line">)</span><br><span class="line">:</span><br><span class="line">    eddyViscosity&lt;RASModel&lt;PhaseCompressibleTurbulenceModel&lt;phaseModel&gt; &gt; &gt;</span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">type</span>,</span><br><span class="line">        <span class="keyword">alpha</span>,</span><br><span class="line">        rho,</span><br><span class="line">        <span class="keyword">U</span>,</span><br><span class="line">        alphaRhoPhi,</span><br><span class="line">        phi,</span><br><span class="line">        phase,</span><br><span class="line">        propertiesName</span><br><span class="line">    ),</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure></p>
<p>可见， <code>kineticTheoryModel</code> 类继承自 <code>eddyViscosity</code> 类，并且用 <code>RASModel&lt;PhaseCompressibleTurbulenceModel&lt;phaseModel&gt; &gt;</code> 来实例化<code>eddyViscosity</code> 类中的模板参数。</p>
<p>再来看<code>eddyViscosity</code> 类：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> BasicTurbulenceModel&gt;</span><br><span class="line"><span class="keyword">class</span> eddyViscosity</span><br><span class="line">:</span><br><span class="line">    <span class="keyword">public</span> BasicTurbulenceModel</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// Protected data</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">// Fields</span></span><br><span class="line">        volScalarField nut_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Protected Member Functions</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">correctNut</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> BasicTurbulenceModel&gt;</span><br><span class="line">Foam::eddyViscosity&lt;BasicTurbulenceModel&gt;::eddyViscosity</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> word&amp; modelName,</span><br><span class="line">    <span class="keyword">const</span> alphaField&amp; alpha,</span><br><span class="line">    <span class="keyword">const</span> rhoField&amp; rho,</span><br><span class="line">    <span class="keyword">const</span> volVectorField&amp; U,</span><br><span class="line">    <span class="keyword">const</span> surfaceScalarField&amp; alphaRhoPhi,</span><br><span class="line">    <span class="keyword">const</span> surfaceScalarField&amp; phi,</span><br><span class="line">    <span class="keyword">const</span> transportModel&amp; transport,</span><br><span class="line">    <span class="keyword">const</span> word&amp; propertiesName</span><br><span class="line">)</span><br><span class="line">:</span><br><span class="line">    BasicTurbulenceModel</span><br><span class="line">    (</span><br><span class="line">        modelName,</span><br><span class="line">        alpha,</span><br><span class="line">        rho,</span><br><span class="line">        U,</span><br><span class="line">        alphaRhoPhi,</span><br><span class="line">        phi,</span><br><span class="line">        transport,</span><br><span class="line">        propertiesName</span><br><span class="line">    ),</span><br><span class="line"></span><br><span class="line">    nut_</span><br><span class="line">    (</span><br><span class="line">        IOobject</span><br><span class="line">        (</span><br><span class="line">            IOobject::groupName(<span class="string">"nut"</span>, U.group()),</span><br><span class="line">            <span class="keyword">this</span>-&gt;runTime_.timeName(),</span><br><span class="line">            <span class="keyword">this</span>-&gt;mesh_,</span><br><span class="line">            IOobject::MUST_READ,</span><br><span class="line">            IOobject::AUTO_WRITE</span><br><span class="line">        ),</span><br><span class="line">        <span class="keyword">this</span>-&gt;mesh_</span><br><span class="line">    )</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，这里有意思的来了， <code>eddyViscosity</code> 类继承自其模板参数代表的类，具体继承自哪个类，要等模板实例化了才知道。这种用法我还是头一次接触。根据上面 <code>kineticTheoryModel</code> 类的构造函数，可知 <code>eddyViscosity</code> 类在当前分析的情况下，将继承自 <code>RASModel&lt;PhaseCompressibleTurbulenceModel&lt;phaseModel&gt; &gt;</code> 。</p>
<p>继续看 <code>RASModel</code> 类的定义：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">template&lt;<span class="keyword">class</span> BasicTurbulenceModel&gt;</span><br><span class="line"><span class="keyword">class</span> RASModel</span><br><span class="line">:</span><br><span class="line">    public BasicTurbulenceModel</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Protected data</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//- RAS coefficients dictionary</span></span><br><span class="line">        dictionary RASDict_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Turbulence on/off flag</span></span><br><span class="line">        Switch turbulence_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Flag to print the model coeffs at run-time</span></span><br><span class="line">        Switch printCoeffs_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Model coefficients dictionary</span></span><br><span class="line">        dictionary coeffDict_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Lower limit of k</span></span><br><span class="line">        dimensionedScalar kMin_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Lower limit of epsilon</span></span><br><span class="line">        dimensionedScalar epsilonMin_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Lower limit for omega</span></span><br><span class="line">        dimensionedScalar omegaMin_;</span><br><span class="line">      </span><br><span class="line">       ......</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// constructor</span></span><br><span class="line">template&lt;<span class="keyword">class</span> BasicTurbulenceModel&gt;</span><br><span class="line">Foam::RASModel&lt;BasicTurbulenceModel&gt;::RASModel</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> word&amp; <span class="keyword">type</span>,</span><br><span class="line">    <span class="keyword">const</span> alphaField&amp; <span class="keyword">alpha</span>,</span><br><span class="line">    <span class="keyword">const</span> rhoField&amp; rho,</span><br><span class="line">    <span class="keyword">const</span> volVectorField&amp; <span class="keyword">U</span>,</span><br><span class="line">    <span class="keyword">const</span> surfaceScalarField&amp; alphaRhoPhi,</span><br><span class="line">    <span class="keyword">const</span> surfaceScalarField&amp; phi,</span><br><span class="line">    <span class="keyword">const</span> transportModel&amp; transport,</span><br><span class="line">    <span class="keyword">const</span> word&amp; propertiesName</span><br><span class="line">)</span><br><span class="line">:</span><br><span class="line">    BasicTurbulenceModel</span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">alpha</span>,</span><br><span class="line">        rho,</span><br><span class="line">        <span class="keyword">U</span>,</span><br><span class="line">        alphaRhoPhi,</span><br><span class="line">        phi,</span><br><span class="line">        transport,</span><br><span class="line">        propertiesName</span><br><span class="line">    ),</span><br><span class="line"></span><br><span class="line">    RASDict_(this-&gt;subOrEmptyDict(<span class="string">"RAS"</span>)),</span><br><span class="line">    turbulence_(RASDict_.<span class="keyword">lookup</span>(<span class="string">"turbulence"</span>)),</span><br><span class="line">    printCoeffs_(RASDict_.lookupOrDefault&lt;Switch&gt;(<span class="string">"printCoeffs"</span>, false)),</span><br><span class="line">    coeffDict_(RASDict_.subOrEmptyDict(<span class="keyword">type</span> + <span class="string">"Coeffs"</span>)),</span><br><span class="line"></span><br><span class="line">    kMin_</span><br><span class="line">    (</span><br><span class="line">        dimensioned&lt;<span class="keyword">scalar</span>&gt;::lookupOrAddToDict</span><br><span class="line">        (</span><br><span class="line">            <span class="string">"kMin"</span>,</span><br><span class="line">            RASDict_,</span><br><span class="line">            SMALL,</span><br><span class="line">            sqr(dimVelocity)</span><br><span class="line">        )</span><br><span class="line">    ),</span><br><span class="line"></span><br><span class="line">    epsilonMin_</span><br><span class="line">    (</span><br><span class="line">        dimensioned&lt;<span class="keyword">scalar</span>&gt;::lookupOrAddToDict</span><br><span class="line">        (</span><br><span class="line">            <span class="string">"epsilonMin"</span>,</span><br><span class="line">            RASDict_,</span><br><span class="line">            SMALL,</span><br><span class="line">            kMin_.dimensions()/dimTime</span><br><span class="line">        )</span><br><span class="line">    ),</span><br><span class="line"></span><br><span class="line">    omegaMin_</span><br><span class="line">    (</span><br><span class="line">        dimensioned&lt;<span class="keyword">scalar</span>&gt;::lookupOrAddToDict</span><br><span class="line">        (</span><br><span class="line">            <span class="string">"omegaMin"</span>,</span><br><span class="line">            RASDict_,</span><br><span class="line">            SMALL,</span><br><span class="line">            dimless/dimTime</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Force the construction of the mesh deltaCoeffs which may be needed</span></span><br><span class="line">    <span class="comment">// for the construction of the derived models and BCs</span></span><br><span class="line">    this-&gt;mesh_.deltaCoeffs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>RASModel</code> 类也是继承自模板参数代表的类，在这里分析的情况下，模板参数将实例化为 <code>PhaseCompressibleTurbulenceModel&lt;phaseModel&gt;</code> ，所以， <code>RASModel</code> 类也将继承自 <code>PhaseCompressibleTurbulenceModel&lt;phaseModel&gt;</code>。</p>
<p><code>PhaseCompressibleTurbulenceModel</code> 类定义如下：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class <span class="type">TransportModel</span>&gt;</span><br><span class="line">class <span class="type">PhaseCompressibleTurbulenceModel</span></span><br><span class="line">:</span><br><span class="line">    public <span class="type">TurbulenceModel</span></span><br><span class="line">    &lt;</span><br><span class="line">        volScalarField,</span><br><span class="line">        volScalarField,</span><br><span class="line">        compressibleTurbulenceModel,</span><br><span class="line">        <span class="type">TransportModel</span></span><br><span class="line">    &gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    typedef volScalarField alphaField;</span><br><span class="line">    typedef volScalarField rhoField;</span><br><span class="line">    typedef <span class="type">TransportModel</span> transportModel;</span><br><span class="line">    ......</span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;class <span class="type">TransportModel</span>&gt;</span><br><span class="line"><span class="type">Foam</span>::<span class="type">PhaseCompressibleTurbulenceModel</span>&lt;<span class="type">TransportModel</span>&gt;::</span><br><span class="line"><span class="type">PhaseCompressibleTurbulenceModel</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; alpha,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; rho,</span><br><span class="line">    <span class="keyword">const</span> volVectorField&amp; U,</span><br><span class="line">    <span class="keyword">const</span> surfaceScalarField&amp; alphaRhoPhi,</span><br><span class="line">    <span class="keyword">const</span> surfaceScalarField&amp; phi,</span><br><span class="line">    <span class="keyword">const</span> transportModel&amp; transport,</span><br><span class="line">    <span class="keyword">const</span> word&amp; propertiesName</span><br><span class="line">)</span><br><span class="line">:</span><br><span class="line">    <span class="type">TurbulenceModel</span></span><br><span class="line">    &lt;</span><br><span class="line">        volScalarField,</span><br><span class="line">        volScalarField,</span><br><span class="line">        compressibleTurbulenceModel,</span><br><span class="line">        transportModel</span><br><span class="line">    &gt;</span><br><span class="line">    (</span><br><span class="line">        alpha,</span><br><span class="line">        rho,</span><br><span class="line">        U,</span><br><span class="line">        alphaRhoPhi,</span><br><span class="line">        phi,</span><br><span class="line">        transport,</span><br><span class="line">        propertiesName</span><br><span class="line">    )</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>可见， <code>PhaseCompressibleTurbulenceModel</code> 类继承自 <code>TurbulenceModel</code> 类，并且要注意给 <code>TurbulenceModel</code> 的模板代入的实例化参数。</p>
<p>继续深入，来看 <code>TurbulenceModel</code> 的定义，<br><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">template</span><br><span class="line">&lt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Alpha</span>,</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Rho</span>,</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">BasicTurbulenceModel</span>,</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TransportModel</span></span></span><br><span class="line">&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TurbulenceModel</span></span></span><br><span class="line">:</span><br><span class="line">    <span class="keyword">public</span> BasicTurbulenceModel</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    typedef Alpha alphaField;</span><br><span class="line">    typedef Rho rhoField;</span><br><span class="line">    typedef TransportModel transportModel;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line"></span><br><span class="line">    // Protected data</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> alphaField&amp; alpha_;</span><br><span class="line">        <span class="keyword">const</span> transportModel&amp; transport_;</span><br><span class="line">        ......</span><br><span class="line">        ......</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template</span><br><span class="line">&lt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Alpha</span>,</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Rho</span>,</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">BasicTurbulenceModel</span>,</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TransportModel</span></span></span><br><span class="line">&gt;</span><br><span class="line">Foam::TurbulenceModel&lt;Alpha, Rho, BasicTurbulenceModel, TransportModel&gt;::</span><br><span class="line">TurbulenceModel</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> alphaField&amp; alpha,</span><br><span class="line">    <span class="keyword">const</span> rhoField&amp; rho,</span><br><span class="line">    <span class="keyword">const</span> volVectorField&amp; U,</span><br><span class="line">    <span class="keyword">const</span> surfaceScalarField&amp; alphaRhoPhi,</span><br><span class="line">    <span class="keyword">const</span> surfaceScalarField&amp; phi,</span><br><span class="line">    <span class="keyword">const</span> transportModel&amp; transport,</span><br><span class="line">    <span class="keyword">const</span> word&amp; propertiesName</span><br><span class="line">)</span><br><span class="line">:</span><br><span class="line">    BasicTurbulenceModel</span><br><span class="line">    (</span><br><span class="line">        rho,</span><br><span class="line">        U,</span><br><span class="line">        alphaRhoPhi,</span><br><span class="line">        phi,</span><br><span class="line">        propertiesName</span><br><span class="line">    ),</span><br><span class="line">    alpha_(alpha),</span><br><span class="line">    transport_(transport)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p> <code>TurbulenceModel</code> 继承自模板的第三个参数对应的类，从 <code>PhaseCompressibleTurbulenceModel</code> 的定义可知，这里是 <code>compressibleTurbulenceModel</code> 。此外，还要注意这个类有一个数据成员是 <code>alpha_</code>，在派生类的某些地方会调用这个数据成员。</p>
<p>接着再看， <code>compressibleTurbulenceModel</code>，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> compressibleTurbulenceModel</span><br><span class="line">:</span><br><span class="line">    <span class="keyword">public</span> turbulenceModel</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Protected data</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> volScalarField&amp; rho_;</span><br><span class="line">    ......</span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Foam::compressibleTurbulenceModel::compressibleTurbulenceModel</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; rho,</span><br><span class="line">    <span class="keyword">const</span> volVectorField&amp; U,</span><br><span class="line">    <span class="keyword">const</span> surfaceScalarField&amp; alphaRhoPhi,</span><br><span class="line">    <span class="keyword">const</span> surfaceScalarField&amp; phi,</span><br><span class="line">    <span class="keyword">const</span> word&amp; propertiesName</span><br><span class="line">)</span><br><span class="line">:</span><br><span class="line">    turbulenceModel</span><br><span class="line">    (</span><br><span class="line">        U,</span><br><span class="line">        alphaRhoPhi,</span><br><span class="line">        phi,</span><br><span class="line">        propertiesName</span><br><span class="line">    ),</span><br><span class="line">    rho_(rho)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个类继承自 <code>turbulenceModel</code> ，并且有一个数据成员 <code>rho_</code> 。</p>
<p>最底层的是 <code>turbulenceModel</code> 类了，其定义如下：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> turbulenceModel</span><br><span class="line">:</span><br><span class="line">    public IOdictionary</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Protected data</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> Time&amp; runTime_;</span><br><span class="line">        <span class="keyword">const</span> fvMesh&amp; mesh_;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> volVectorField&amp; U_;</span><br><span class="line">        <span class="keyword">const</span> surfaceScalarField&amp; alphaRhoPhi_;</span><br><span class="line">        <span class="keyword">const</span> surfaceScalarField&amp; phi_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Near wall distance boundary field</span></span><br><span class="line">        nearWallDist y_;</span><br><span class="line">        ......</span><br><span class="line">        ......</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Foam::turbulenceModel::turbulenceModel</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> volVectorField&amp; <span class="keyword">U</span>,</span><br><span class="line">    <span class="keyword">const</span> surfaceScalarField&amp; alphaRhoPhi,</span><br><span class="line">    <span class="keyword">const</span> surfaceScalarField&amp; phi,</span><br><span class="line">    <span class="keyword">const</span> word&amp; propertiesName</span><br><span class="line">)</span><br><span class="line">:</span><br><span class="line">    IOdictionary</span><br><span class="line">    (</span><br><span class="line">        IOobject</span><br><span class="line">        (</span><br><span class="line">            IOobject::groupName(propertiesName, <span class="keyword">U</span>.<span class="literal">group</span>()),</span><br><span class="line">            <span class="keyword">U</span>.time().constant(),</span><br><span class="line">            <span class="keyword">U</span>.<span class="keyword">db</span>(),</span><br><span class="line">            IOobject::MUST_READ_IF_MODIFIED,</span><br><span class="line">            IOobject::NO_WRITE</span><br><span class="line">        )</span><br><span class="line">    ),</span><br><span class="line"></span><br><span class="line">    runTime_(<span class="keyword">U</span>.time()),</span><br><span class="line">    mesh_(<span class="keyword">U</span>.mesh()),</span><br><span class="line">    U_(<span class="keyword">U</span>),</span><br><span class="line">    alphaRhoPhi_(alphaRhoPhi),</span><br><span class="line">    phi_(phi),</span><br><span class="line">    y_(mesh_)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个类里定义了数据成员 <code>U_</code>，在 <code>kineticTheoryModel</code> 类中用到了。 </p>
<p>总结一下，湍流模型的继承派生关系如下图（看大图请右键点击图片，选“在新标签页中打开”）：</p>
<p><img src="/image/TFM/turbulenceModel.png" alt=""></p>
<p>像上面这种“类继承其模板参数所代表的类”的用法，在 OpenFOAM 中使用很普遍，最近在看的 thermodynamics 相关的代码里也大量使用了这种模式。不知道这是不是一种 C++ 的 design pattern？这方面我的理解还很浅显。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在 <code>kineticTheoryModel</code> 类的解读时前面提到过， <code>kineticTheoryModel</code> 使用了跟湍流模型一样的接口。这一篇，就来看一下 <code>twoPhaseEulerFoam</code> 中的湍流模型。  </p>]]>
    
    </summary>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/tags/OpenFOAM/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenFOAM-2.3.x 中的 twoPhaseEulerFoam 解析之 kineticTheoryModel 的子模型]]></title>
    <link href="http://xiaopingqiu.github.io/2015/09/19/kineticTheoryModelSubModels/"/>
    <id>http://xiaopingqiu.github.io/2015/09/19/kineticTheoryModelSubModels/</id>
    <published>2015-09-19T03:45:35.000Z</published>
    <updated>2015-11-26T13:38:11.789Z</updated>
    <content type="html"><![CDATA[<p>上一篇博文解读了 <code>kineticTheoryModel</code>  其中提到需要调用子模型来完成其功能，这里将 OpenFOAM 中 <code>kineticTheoryModel</code> 模型的子模型罗列如下。</p>
<a id="more"></a>
<h4 id="1-_viscosityModel">1. viscosityModel</h4><p>viscosityModel 的作用是根据颗粒温度 <code>Theta</code> 来计算固相粘度。<br>基类代码如下，核心是那个返回固相粘度的 <code>nu</code> 函数。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Foam</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">kineticTheoryModels</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------------------------------------------------------------------------*\</span><br><span class="line">                           Class viscosityModel Declaration</span><br><span class="line">\*---------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">viscosityModel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Private member functions</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Disallow default bitwise copy construct</span></span><br><span class="line">        viscosityModel(<span class="keyword">const</span> viscosityModel&amp;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Disallow default bitwise assignment</span></span><br><span class="line">        <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> viscosityModel&amp;);</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Protected data</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> dictionary&amp; dict_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">//- Runtime type information</span></span><br><span class="line">    TypeName(<span class="string">"viscosityModel"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Declare runtime constructor selection table</span></span><br><span class="line">    declareRunTimeSelectionTable</span><br><span class="line">    (</span><br><span class="line">        autoPtr,</span><br><span class="line">        viscosityModel,</span><br><span class="line">        dictionary,</span><br><span class="line">        (</span><br><span class="line">            <span class="keyword">const</span> dictionary&amp; dict</span><br><span class="line">        ),</span><br><span class="line">        (dict)</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// Constructors</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Construct from components</span></span><br><span class="line">        viscosityModel(<span class="keyword">const</span> dictionary&amp; dict);</span><br><span class="line">    <span class="comment">// Selectors</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> autoPtr&lt;viscosityModel&gt; <span class="title">New</span></span><br><span class="line">        <span class="params">(</span><br><span class="line">            <span class="keyword">const</span> dictionary&amp; dict</span><br><span class="line">        )</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//- Destructor</span></span><br><span class="line">    <span class="keyword">virtual</span> ~viscosityModel();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Member Functions</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> tmp&lt;volScalarField&gt; <span class="title">nu</span></span><br><span class="line">        <span class="params">(</span><br><span class="line">            <span class="keyword">const</span> volScalarField&amp; alpha1,</span><br><span class="line">            <span class="keyword">const</span> volScalarField&amp; Theta,</span><br><span class="line">            <span class="keyword">const</span> volScalarField&amp; g0,</span><br><span class="line">            <span class="keyword">const</span> volScalarField&amp; rho1,</span><br><span class="line">            <span class="keyword">const</span> volScalarField&amp; da,</span><br><span class="line">            <span class="keyword">const</span> dimensionedScalar&amp; e</span><br><span class="line">        )</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">read</span><span class="params">()</span></span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>2.3.x 版自带四种固相粘度模型，分别如下：</p>
<h5 id="1-1_none">1.1 none</h5><p>顾名思义，这个模型计算的固相粘度值为零。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意这里的 kineticTheoryModels 不是类名，而是命名空间</span></span><br><span class="line">Foam::tmp&lt;Foam::volScalarField&gt; Foam::kineticTheoryModels::noneViscosity::nu </span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; alpha1,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; Theta,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; g0,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; rho1,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; da,</span><br><span class="line">    <span class="keyword">const</span> dimensionedScalar&amp; e</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> dimensionedScalar</span><br><span class="line">    (</span><br><span class="line">        <span class="string">"0"</span>,</span><br><span class="line">        dimensionSet(<span class="number">0</span>, <span class="number">2</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">        <span class="number">0.0</span></span><br><span class="line">    )*alpha1; <span class="comment">// 返回 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="1-2_Syamlal_模型">1.2 Syamlal 模型</h5><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Foam<span class="type-annotation">::</span>tmp&lt;Foam<span class="type-annotation">::</span>volScalarField&gt;</span><br><span class="line">Foam<span class="type-annotation">::</span>kineticTheoryModels<span class="type-annotation">::</span>viscosityModels<span class="type-annotation">::</span>Syamlal<span class="type-annotation">::</span>nu</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; alpha1,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; Theta,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; g0,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; rho1,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; da,</span><br><span class="line">    <span class="keyword">const</span> dimensionedScalar&amp; <span class="literal">e</span></span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> scalar sqrtPi = sqrt(constant<span class="type-annotation">::</span>mathematical<span class="type-annotation">::</span><span class="literal">pi</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> da*sqrt(Theta)*</span><br><span class="line">    (</span><br><span class="line">        (<span class="number">4.0</span>/<span class="number">5.0</span>)*sqr(alpha1)*g0*(<span class="number">1.0</span> + <span class="literal">e</span>)/sqrtPi</span><br><span class="line">      + (<span class="number">1.0</span>/<span class="number">15.0</span>)*sqrtPi*g0*(<span class="number">1.0</span> + <span class="literal">e</span>)*(<span class="number">3.0</span>*<span class="literal">e</span> - <span class="number">1.0</span>)*sqr(alpha1)/(<span class="number">3.0</span> - <span class="literal">e</span>)</span><br><span class="line">      + (<span class="number">1.0</span>/<span class="number">6.0</span>)*alpha1*sqrtPi/(<span class="number">3.0</span> - <span class="literal">e</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>公式为<br>$$<br>\nu_s = d_p \sqrt{\Theta}\left[ \frac{4}{5}\varepsilon_s^2 g_0  \frac{(1+e)}{\sqrt{\pi}} + \frac{1}{15} \sqrt{\pi} \cdot g_0 \varepsilon_s^2\frac{(1+e)(3e-1)}{\sqrt{\pi}} + \frac{1}{6}\varepsilon_s \frac{\sqrt{\pi}}{3-e}\right ]<br>$$<br>其中$g_0$是由 径向分布模型计算得到的。</p>
<h5 id="1-3_HrenyaSinclair_模型">1.3  HrenyaSinclair 模型</h5><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">//- Characteristic length of geometry</span><br><span class="line">        dimensionedScalar L_; // 新定义的一个变量，</span><br><span class="line">        </span><br><span class="line"> // 构造函数       </span><br><span class="line">Foam<span class="type-annotation">::</span>kineticTheoryModels<span class="type-annotation">::</span>viscosityModels<span class="type-annotation">::</span>HrenyaSinclair<span class="type-annotation">::</span>HrenyaSinclair</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> dictionary&amp; dict</span><br><span class="line">)</span><br><span class="line">:</span><br><span class="line">    viscosityModel(dict),</span><br><span class="line">    coeffDict_(dict.subDict(typeName + <span class="string">"Coeffs"</span>)),</span><br><span class="line">    L_(<span class="string">"L"</span>, dimensionSet(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), coeffDict_.lookup(<span class="string">"L"</span>)) // 从外部读取 L_ 的值</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">Foam<span class="type-annotation">::</span>tmp&lt;Foam<span class="type-annotation">::</span>volScalarField&gt;</span><br><span class="line">Foam<span class="type-annotation">::</span>kineticTheoryModels<span class="type-annotation">::</span>viscosityModels<span class="type-annotation">::</span>HrenyaSinclair<span class="type-annotation">::</span>nu</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; alpha1,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; Theta,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; g0,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; rho1,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; da,</span><br><span class="line">    <span class="keyword">const</span> dimensionedScalar&amp; <span class="literal">e</span></span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> scalar sqrtPi = sqrt(constant<span class="type-annotation">::</span>mathematical<span class="type-annotation">::</span><span class="literal">pi</span>);</span><br><span class="line"></span><br><span class="line">    volScalarField lamda</span><br><span class="line">    (</span><br><span class="line">        scalar(<span class="number">1</span>) + da/(<span class="number">6.0</span>*sqrt(<span class="number">2.0</span>)*(alpha1 + scalar(<span class="number">1.0e-5</span>)))/L_</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> da*sqrt(Theta)*</span><br><span class="line">    (</span><br><span class="line">        (<span class="number">4.0</span>/<span class="number">5.0</span>)*sqr(alpha1)*g0*(<span class="number">1.0</span> + <span class="literal">e</span>)/sqrtPi</span><br><span class="line">      + (<span class="number">1.0</span>/<span class="number">15.0</span>)*sqrtPi*g0*(<span class="number">1.0</span> + <span class="literal">e</span>)*(<span class="number">3.0</span>*<span class="literal">e</span> - <span class="number">1</span>)*sqr(alpha1)/(<span class="number">3.0</span>-<span class="literal">e</span>)</span><br><span class="line">      + (<span class="number">1.0</span>/<span class="number">6.0</span>)*sqrtPi*alpha1*(<span class="number">0.5</span>*lamda + <span class="number">0.25</span>*(<span class="number">3.0</span>*<span class="literal">e</span> - <span class="number">1.0</span>))</span><br><span class="line">       /(<span class="number">0.5</span>*(<span class="number">3.0</span> - <span class="literal">e</span>)*lamda)</span><br><span class="line">      + (<span class="number">10</span>/<span class="number">96.0</span>)*sqrtPi/((<span class="number">1.0</span> + <span class="literal">e</span>)*<span class="number">0.5</span>*(<span class="number">3.0</span> - <span class="literal">e</span>)*g0*lamda)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>公式如下<br>$$<br>\begin{aligned}<br>\nu_s = &amp; d_p \sqrt{\Theta} \, [ \frac{4}{5} \varepsilon_s \cdot g_0 \frac{1+e}{\sqrt{\pi}} + \frac{1}{15}\sqrt{\pi} \cdot g_0 \varepsilon_s^2 \frac{(1+e)(3e-1)}{3-e} \\<br> + &amp; \frac{1}{6} \sqrt{\pi} \cdot \frac{0.5\lambda +  0.25(3e-1)}{0.5(3-e)\lambda} \varepsilon_s + \frac{10}{96}\sqrt{\pi}\cdot \frac{1}{0.5(1+e)(3-e)g_0\cdot \lambda}  ]<br>\end{aligned}<br>$$<br>其中<br>$$<br>\lambda = 1+\frac{d_p}{6\sqrt{2}\cdot \varepsilon_s}\cdot \frac{1}{L}<br>$$</p>
<h5 id="1-4_Gidaspow_模型">1.4 Gidaspow 模型</h5><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Foam<span class="type-annotation">::</span>tmp&lt;Foam<span class="type-annotation">::</span>volScalarField&gt;</span><br><span class="line">Foam<span class="type-annotation">::</span>kineticTheoryModels<span class="type-annotation">::</span>viscosityModels<span class="type-annotation">::</span>Gidaspow<span class="type-annotation">::</span>nu</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; alpha1,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; Theta,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; g0,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; rho1,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; da,</span><br><span class="line">    <span class="keyword">const</span> dimensionedScalar&amp; <span class="literal">e</span></span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> scalar sqrtPi = sqrt(constant<span class="type-annotation">::</span>mathematical<span class="type-annotation">::</span><span class="literal">pi</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> da*sqrt(Theta)*</span><br><span class="line">    (</span><br><span class="line">        (<span class="number">4.0</span>/<span class="number">5.0</span>)*sqr(alpha1)*g0*(<span class="number">1.0</span> + <span class="literal">e</span>)/sqrtPi</span><br><span class="line">      + (<span class="number">1.0</span>/<span class="number">15.0</span>)*sqrtPi*g0*(<span class="number">1.0</span> + <span class="literal">e</span>)*sqr(alpha1)</span><br><span class="line">      + (<span class="number">1.0</span>/<span class="number">6.0</span>)*sqrtPi*alpha1</span><br><span class="line">      + (<span class="number">10.0</span>/<span class="number">96.0</span>)*sqrtPi/((<span class="number">1.0</span> + <span class="literal">e</span>)*g0)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$$<br>\nu_s = d_p\sqrt{\Theta}\left [ \frac{4}{5} \varepsilon_s^2 g_0\cdot \frac{(1+e)}{\sqrt{\pi}}  + \frac{1}{15} \sqrt{\pi}\cdot g_0(1+e)\varepsilon_s^2 + \frac{1}{6} \sqrt{\pi}\cdot \varepsilon_s^2 + \frac{10}{96} \frac{\sqrt{\pi}}{(1+e)g_0}\right ]<br>$$</p>
<h4 id="2-_radialModel">2. radialModel</h4><p>这个类的作用是计算径向分布函数 <code>g0</code> </p>
<p>有三种 radialModel 可以选择：</p>
<h5 id="2-1_SinclairJackson">2.1 SinclairJackson</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Foam::tmp&lt;Foam::volScalarField&gt;</span><br><span class="line">Foam::kineticTheoryModels::radialModels::SinclairJackson::g0</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; alpha,</span><br><span class="line">    <span class="keyword">const</span> dimensionedScalar&amp; alphaMinFriction,</span><br><span class="line">    <span class="keyword">const</span> dimensionedScalar&amp; alphaMax</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span>/(<span class="number">1.0</span> - cbrt(min(alpha, alphaMinFriction)/alphaMax));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Foam::tmp&lt;Foam::volScalarField&gt;</span><br><span class="line">Foam::kineticTheoryModels::radialModels::SinclairJackson::g0prime</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; alpha,</span><br><span class="line">    <span class="keyword">const</span> dimensionedScalar&amp; alphaMinFriction,</span><br><span class="line">    <span class="keyword">const</span> dimensionedScalar&amp; alphaMax</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">volScalarField <span class="title">aByaMax</span></span><br><span class="line">    <span class="params">(</span><br><span class="line">        cbrt(min(max(alpha, scalar(1e-3)</span>), alphaMinFriction)/alphaMax)</span><br><span class="line">    )</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span>/(<span class="number">3</span>*alphaMax))/sqr(aByaMax - sqr(aByaMax));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$$<br>g_0 = \frac{1}{1-\sqrt[3]{\frac{min(\varepsilon_s, \varepsilon_{s,min})}{\varepsilon_{s,max}}}}<br>$$</p>
<p> <code>g0Prime</code> 为 <code>g0</code> 对  <code>alpha</code> 的导数 </p>
<p>$$<br>g_{0Prime} = \frac{\partial g_0}{\partial \varepsilon_s} = \frac{\frac{1}{3\cdot \varepsilon_{s,max}}}{(aByaMax-aByaMax^2)^2}<br>$$</p>
<p>其中</p>
<p>$$<br>aByaMax=\sqrt[3]{\frac{min(\varepsilon_s,\varepsilon_{s,min})}{\varepsilon_{s,max}}}<br>$$</p>
<h5 id="2-2_LunSavage">2.2 LunSavage</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Foam::tmp&lt;Foam::volScalarField&gt;</span><br><span class="line">Foam::kineticTheoryModels::radialModels::LunSavage::g0</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; alpha,</span><br><span class="line">    <span class="keyword">const</span> dimensionedScalar&amp; alphaMinFriction,</span><br><span class="line">    <span class="keyword">const</span> dimensionedScalar&amp; alphaMax</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">1.0</span> - alpha/alphaMax, -<span class="number">2.5</span>*alphaMax);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Foam::tmp&lt;Foam::volScalarField&gt;</span><br><span class="line">Foam::kineticTheoryModels::radialModels::LunSavage::g0prime</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; alpha,</span><br><span class="line">    <span class="keyword">const</span> dimensionedScalar&amp; alphaMinFriction,</span><br><span class="line">    <span class="keyword">const</span> dimensionedScalar&amp; alphaMax</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2.5</span>*<span class="built_in">pow</span>(<span class="number">1.0</span> - alpha/alphaMax, -<span class="number">2.5</span>*alphaMax - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$$<br>g_0 = \left( 1-\frac{\varepsilon_s}{\varepsilon_{s,max}}\right)^{-2.5\,\varepsilon_{s,max}}<br>$$</p>
<h5 id="2-3_CarnahanStarling_模型">2.3 CarnahanStarling 模型</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Foam::tmp&lt;Foam::volScalarField&gt;</span><br><span class="line">Foam::kineticTheoryModels::radialModels::CarnahanStarling::g0</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; alpha,</span><br><span class="line">    <span class="keyword">const</span> dimensionedScalar&amp; alphaMinFriction,</span><br><span class="line">    <span class="keyword">const</span> dimensionedScalar&amp; alphaMax</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        <span class="number">1.0</span>/(<span class="number">1.0</span> - alpha)</span><br><span class="line">      + <span class="number">3.0</span>*alpha/(<span class="number">2.0</span>*sqr(<span class="number">1.0</span> - alpha))</span><br><span class="line">      + sqr(alpha)/(<span class="number">2.0</span>*pow3(<span class="number">1.0</span> - alpha));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Foam::tmp&lt;Foam::volScalarField&gt;</span><br><span class="line">Foam::kineticTheoryModels::radialModels::CarnahanStarling::g0prime</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; alpha,</span><br><span class="line">    <span class="keyword">const</span> dimensionedScalar&amp; alphaMinFriction,</span><br><span class="line">    <span class="keyword">const</span> dimensionedScalar&amp; alphaMax</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        <span class="number">2.5</span>/sqr(<span class="number">1.0</span> - alpha)</span><br><span class="line">      + <span class="number">4.0</span>*alpha/pow3(<span class="number">1.0</span> - alpha)</span><br><span class="line">      + <span class="number">1.5</span>*sqr(alpha)/pow4(<span class="number">1.0</span> - alpha);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$$<br>g_0 = \frac{1}{1-\varepsilon_s} + \frac{3\varepsilon_s}{2(1-\varepsilon_s)^2} + \frac{\varepsilon_s^2}{2(1-\varepsilon_s)^3}<br>$$</p>
<h4 id="3-_granularPressureModel">3. granularPressureModel</h4><p>顾名思义，这个类是用来计算固相压力的。</p>
<p>OpenFOAM 内置两种固相压力模型：</p>
<h5 id="3-1_Lun_模型">3.1 Lun 模型</h5><p><code>granularPressureCoeff</code> 返回的是固相压力的系数，这个返回值乘以颗粒温度 <code>Theta</code> 才是固相压力。<br><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Foam<span class="type-annotation">::</span>tmp&lt;Foam<span class="type-annotation">::</span>volScalarField&gt;</span><br><span class="line">Foam<span class="type-annotation">::</span>kineticTheoryModels<span class="type-annotation">::</span>granularPressureModels<span class="type-annotation">::</span>Lun<span class="type-annotation">::</span>granularPressureCoeff</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; alpha1,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; g0,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; rho1,</span><br><span class="line">    <span class="keyword">const</span> dimensionedScalar&amp; <span class="literal">e</span></span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rho1*alpha1*(<span class="number">1.0</span> + <span class="number">2.0</span>*(<span class="number">1.0</span> + <span class="literal">e</span>)*alpha1*g0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Foam<span class="type-annotation">::</span>tmp&lt;Foam<span class="type-annotation">::</span>volScalarField&gt;</span><br><span class="line">Foam<span class="type-annotation">::</span>kineticTheoryModels<span class="type-annotation">::</span>granularPressureModels<span class="type-annotation">::</span>Lun<span class="type-annotation">::</span></span><br><span class="line">granularPressureCoeffPrime</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; alpha1,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; g0,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; g0prime,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; rho1,</span><br><span class="line">    <span class="keyword">const</span> dimensionedScalar&amp; <span class="literal">e</span></span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> rho1*(<span class="number">1.0</span> + alpha1*(<span class="number">1.0</span> + <span class="literal">e</span>)*(<span class="number">4.0</span>*g0 + <span class="number">2.0</span>*g0prime*alpha1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>$$<br>P_{s,coeff} = \rho\varepsilon_s[1+2(1+e)\varepsilon_sg_0]<br>$$</p>
<p><code>granularPressureCoeffPrime</code> 函数计算的是 $\partial P_{s,coeff}/\partial \varepsilon_s$ 。</p>
<h5 id="3-2_SyamlalRogersOBrien_模型">3.2 SyamlalRogersOBrien 模型</h5><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Foam<span class="type-annotation">::</span>tmp&lt;Foam<span class="type-annotation">::</span>volScalarField&gt;</span><br><span class="line">Foam<span class="type-annotation">::</span>kineticTheoryModels<span class="type-annotation">::</span>granularPressureModels<span class="type-annotation">::</span>SyamlalRogersOBrien<span class="type-annotation">::</span></span><br><span class="line">granularPressureCoeff</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; alpha1,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; g0,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; rho1,</span><br><span class="line">    <span class="keyword">const</span> dimensionedScalar&amp; <span class="literal">e</span></span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2.0</span>*rho1*(<span class="number">1.0</span> + <span class="literal">e</span>)*sqr(alpha1)*g0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Foam<span class="type-annotation">::</span>tmp&lt;Foam<span class="type-annotation">::</span>volScalarField&gt;</span><br><span class="line">Foam<span class="type-annotation">::</span>kineticTheoryModels<span class="type-annotation">::</span>granularPressureModels<span class="type-annotation">::</span>SyamlalRogersOBrien<span class="type-annotation">::</span></span><br><span class="line">granularPressureCoeffPrime</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; alpha1,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; g0,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; g0prime,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; rho1,</span><br><span class="line">    <span class="keyword">const</span> dimensionedScalar&amp; <span class="literal">e</span></span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> rho1*alpha1*(<span class="number">1.0</span> + <span class="literal">e</span>)*(<span class="number">4.0</span>*g0 + <span class="number">2.0</span>*g0prime*alpha1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$$<br>P_{s,coeff} = 2\rho(1+e)\varepsilon_s^2\cdot g_0<br>$$</p>
<h4 id="4-_frictionalStressModel">4. frictionalStressModel</h4><p>在稠密气固两相流中，当固相体积分率大于某个值时，单纯考虑跟颗粒温度关联的固相压力和固相粘性还不够，还需要考虑所谓的摩擦应力。这个类就是用来计算摩擦应力的。</p>
<p>有两种模型可选：</p>
<h5 id="4-1_Schaeffer_模型">4.1 Schaeffer 模型</h5><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">Foam::kineticTheoryModels::frictionalStressModels::Schaeffer::Schaeffer</span><br><span class="line">(</span><br><span class="line">    const dictionary&amp; dict</span><br><span class="line">)</span><br><span class="line">:</span><br><span class="line">    frictionalStressModel(dict),</span><br><span class="line">    coeffDict_(dict.subDict(typeName + <span class="string">"Coeffs"</span>)),</span><br><span class="line">    phi_(<span class="string">"phi"</span>, dimless, coeffDict_.lookup(<span class="string">"phi"</span>))</span><br><span class="line">&#123;</span><br><span class="line">    phi_ <span class="keyword">*</span>= constant::mathematical::pi/180.0; </span><br><span class="line">    // 这个phi_是一个角度，从外部读取，在外部设置的时候，按角度的单位来设置，这里是将角度转换成弧度。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> Destructor  <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> //</span><br><span class="line"></span><br><span class="line">Foam::kineticTheoryModels::frictionalStressModels::Schaeffer::~Schaeffer()</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> Member Functions  <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> //</span><br><span class="line"></span><br><span class="line">Foam::tmp<span class="variable">&lt;Foam::volScalarField&gt;</span></span><br><span class="line">Foam::kineticTheoryModels::frictionalStressModels::Schaeffer::</span><br><span class="line">frictionalPressure</span><br><span class="line">(</span><br><span class="line">    const volScalarField&amp; alpha1,</span><br><span class="line">    const dimensionedScalar&amp; alphaMinFriction,</span><br><span class="line">    const dimensionedScalar&amp; alphaMax</span><br><span class="line">) const</span><br><span class="line">&#123;</span><br><span class="line">    return</span><br><span class="line">        dimensionedScalar(<span class="string">"1e24"</span>, dimensionSet(1, -1, -2, 0, 0), 1e24)</span><br><span class="line">       <span class="keyword">*</span>pow(Foam::max(alpha1 - alphaMinFriction, scalar(0)), 10.0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foam::tmp<span class="variable">&lt;Foam::volScalarField&gt;</span></span><br><span class="line">Foam::kineticTheoryModels::frictionalStressModels::Schaeffer::</span><br><span class="line">frictionalPressurePrime</span><br><span class="line">(</span><br><span class="line">    const volScalarField&amp; alpha1,</span><br><span class="line">    const dimensionedScalar&amp; alphaMinFriction,</span><br><span class="line">    const dimensionedScalar&amp; alphaMax</span><br><span class="line">) const</span><br><span class="line">&#123;</span><br><span class="line">    return</span><br><span class="line">        dimensionedScalar(<span class="string">"1e25"</span>, dimensionSet(1, -1, -2, 0, 0), 1e25)</span><br><span class="line">       <span class="keyword">*</span>pow(Foam::max(alpha1 - alphaMinFriction, scalar(0)), 9.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$$<br>P_{f} = 10^{24}\cdot max(\varepsilon_s-\varepsilon_{s,friMin},0)^{10}<br>$$<br> 同前面一样，<code>frictionalPressurePrime</code> 是  <code>frictionalPressure</code> 对固相体积分率的导数。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">Foam::tmp&lt;Foam::volScalarField&gt;</span><br><span class="line">Foam::kineticTheoryModels::frictionalStressModels::Schaeffer::nu</span><br><span class="line">(</span><br><span class="line">    const volScalarField&amp; alpha1,</span><br><span class="line">    const dimensionedScalar&amp; alphaMax,</span><br><span class="line">    const volScalarField&amp; pf,</span><br><span class="line">    const volSymmTensorField&amp; D</span><br><span class="line">) const</span><br><span class="line">&#123;</span><br><span class="line">    const <span class="keyword">scalar</span> I2Dsmall = <span class="number">1.0</span>e-<span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">    <span class="regexp">//</span> Creating nu assuming it should be <span class="number">0</span> on the boundary which may <span class="keyword">not</span> be</span><br><span class="line">    // true</span><br><span class="line">    tmp&lt;volScalarField&gt; tnu</span><br><span class="line">    (</span><br><span class="line">        new volScalarField</span><br><span class="line">        (</span><br><span class="line">            IOobject</span><br><span class="line">            (</span><br><span class="line">                <span class="string">"Schaeffer:nu"</span>,</span><br><span class="line">                alpha1.mesh().<span class="keyword">time</span>().timeName(),</span><br><span class="line">                alpha1.mesh(),</span><br><span class="line">                IOobject::NO_READ,</span><br><span class="line">                IOobject::NO_WRITE,</span><br><span class="line">                false</span><br><span class="line">            ),</span><br><span class="line">            alpha1.mesh(),</span><br><span class="line">            dimensionedScalar(<span class="string">"nu"</span>, dimensionSet(<span class="number">0</span>, <span class="number">2</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">0</span>.<span class="number">0</span>)</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    volScalarField&amp; nuf = tnu();</span><br><span class="line"></span><br><span class="line">    forAll (D, celli)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (alpha1[celli] &gt; alphaMax.value() - <span class="number">5</span>e-<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nuf[celli] =</span><br><span class="line">                <span class="number">0</span>.<span class="number">5</span>*pf[celli]*<span class="keyword">sin</span>(phi<span class="number">_</span>.value())</span><br><span class="line">               /(</span><br><span class="line">                    <span class="keyword">sqrt</span>(<span class="number">1.0</span>/<span class="number">6.0</span>*(<span class="keyword">s</span><span class="string">qr(D[celli].xx()</span> - D[celli].yy())</span><br><span class="line">                  + <span class="keyword">s</span><span class="string">qr(D[celli].yy()</span> - D[celli].zz())</span><br><span class="line">                  + <span class="keyword">s</span><span class="string">qr(D[celli].zz()</span> - D[celli].xx()))</span><br><span class="line">                  + <span class="keyword">s</span><span class="string">qr(D[celli].xy()</span>) + <span class="keyword">s</span><span class="string">qr(D[celli].xz()</span>)</span><br><span class="line">                  + <span class="keyword">s</span><span class="string">qr(D[celli].yz()</span>)) + I2Dsmall</span><br><span class="line">                );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Correct coupled BCs</span><br><span class="line">    nuf.correctBoundaryConditions();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tnu;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$$<br>\nu_f = \left \{ \begin{aligned}<br> &amp; 0 ,  &amp;\varepsilon_s \le \varepsilon_{s,max} \\<br>&amp; \frac{0.5p_f sin\phi}{\sqrt{I_{2d}}}, &amp; \varepsilon_s > \varepsilon_{s,max}<br>\end{aligned} \right .<br>$$</p>
<p>其中，$p_f$ 代表的是上面的 <code>frictionalPressure</code><br>$$<br>D = \frac{1}{2}(\nabla U + \nabla U^T)<br>$$</p>
<p>$$<br>\sqrt{I_{2D}} = \frac{1}{6}[(D_{11}-D_{22})^2 + (D_{22}-D_{33})^2 + (D_{33}-D_{11})^2] + D_{12}^2 + D_{13}^2 + D_{23}^2<br>$$</p>
<h5 id="4-2_JohnsonJackson_模型">4.2 JohnsonJackson 模型</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> JohnsonJackson</span><br><span class="line">:</span><br><span class="line">    <span class="keyword">public</span> frictionalStressModel</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Private data</span></span><br><span class="line"></span><br><span class="line">        dictionary coeffDict_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Material constant for frictional normal stress</span></span><br><span class="line">        dimensionedScalar Fr_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Material constant for frictional normal stress</span></span><br><span class="line">        dimensionedScalar eta_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Material constant for frictional normal stress</span></span><br><span class="line">        dimensionedScalar p_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Angle of internal friction</span></span><br><span class="line">        dimensionedScalar phi_;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">Foam::kineticTheoryModels::frictionalStressModels::JohnsonJackson::</span><br><span class="line">JohnsonJackson</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> dictionary&amp; dict</span><br><span class="line">)</span><br><span class="line">:</span><br><span class="line">    frictionalStressModel(dict),</span><br><span class="line">    coeffDict_(dict.subDict(typeName + <span class="string">"Coeffs"</span>)),</span><br><span class="line">    Fr_(<span class="string">"Fr"</span>, dimensionSet(<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>), coeffDict_.lookup(<span class="string">"Fr"</span>)),</span><br><span class="line">    eta_(<span class="string">"eta"</span>, dimless, coeffDict_.lookup(<span class="string">"eta"</span>)),</span><br><span class="line">    p_(<span class="string">"p"</span>, dimless, coeffDict_.lookup(<span class="string">"p"</span>)),</span><br><span class="line">    phi_(<span class="string">"phi"</span>, dimless, coeffDict_.lookup(<span class="string">"phi"</span>))</span><br><span class="line">&#123;</span><br><span class="line">    phi_ *= constant::mathematical::pi/<span class="number">180.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// * * * * * * * * * * * * * * * Member Functions  * * * * * * * * * * * * * //</span></span><br><span class="line"></span><br><span class="line">Foam::tmp&lt;Foam::volScalarField&gt;</span><br><span class="line">Foam::kineticTheoryModels::frictionalStressModels::JohnsonJackson::</span><br><span class="line">frictionalPressure</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; alpha1,</span><br><span class="line">    <span class="keyword">const</span> dimensionedScalar&amp; alphaMinFriction,</span><br><span class="line">    <span class="keyword">const</span> dimensionedScalar&amp; alphaMax</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        Fr_*<span class="built_in">pow</span>(max(alpha1 - alphaMinFriction, scalar(<span class="number">0</span>)), eta_)</span><br><span class="line">       /<span class="built_in">pow</span>(max(alphaMax - alpha1, scalar(<span class="number">5.0e-2</span>)), p_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Foam::tmp&lt;Foam::volScalarField&gt;</span><br><span class="line">Foam::kineticTheoryModels::frictionalStressModels::JohnsonJackson::</span><br><span class="line">frictionalPressurePrime</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; alpha1,</span><br><span class="line">    <span class="keyword">const</span> dimensionedScalar&amp; alphaMinFriction,</span><br><span class="line">    <span class="keyword">const</span> dimensionedScalar&amp; alphaMax</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Fr_*</span><br><span class="line">    (</span><br><span class="line">        eta_*<span class="built_in">pow</span>(max(alpha1 - alphaMinFriction, scalar(<span class="number">0</span>)), eta_ - <span class="number">1.0</span>)</span><br><span class="line">       *(alphaMax-alpha1)</span><br><span class="line">      + p_*<span class="built_in">pow</span>(max(alpha1 - alphaMinFriction, scalar(<span class="number">0</span>)), eta_)</span><br><span class="line">    )/<span class="built_in">pow</span>(max(alphaMax - alpha1, scalar(<span class="number">5.0e-2</span>)), p_ + <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Foam::tmp&lt;Foam::volScalarField&gt;</span><br><span class="line">Foam::kineticTheoryModels::frictionalStressModels::JohnsonJackson::nu</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; alpha1,</span><br><span class="line">    <span class="keyword">const</span> dimensionedScalar&amp; alphaMax,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; pf,</span><br><span class="line">    <span class="keyword">const</span> volSymmTensorField&amp; D</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> dimensionedScalar(<span class="string">"0.5"</span>, dimTime, <span class="number">0.5</span>)*pf*<span class="built_in">sin</span>(phi_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个模型的特点是需要设置一些跟材料有关的参数。<br>$$<br>P_{f} = F_r \frac{max(\varepsilon_s-\varepsilon_{s,friMin},0)^{\eta}}{max(\varepsilon_{s,max}-\varepsilon_{s},0)^{p}}<br>$$</p>
<p>$$<br>\nu_f = 0.5\cdot p_fsin\phi<br>$$<br>一些材料的物性参数建议值可参见”Derivation, Implementation and Validation of Computer Simulation Models for Gas-Solids Fluidized Beds” Table-3.5。</p>
<h4 id="5-_conductivityModel">5. conductivityModel</h4><p>这个类的作用是计算 颗粒温度方程中的颗粒温度传导系数，只有在使用偏微分方程求解颗粒温度是才会用到。</p>
<p>有三种可选：</p>
<h5 id="5-1_Syamlal_模型">5.1 Syamlal 模型</h5><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Foam<span class="type-annotation">::</span>tmp&lt;Foam<span class="type-annotation">::</span>volScalarField&gt;</span><br><span class="line">Foam<span class="type-annotation">::</span>kineticTheoryModels<span class="type-annotation">::</span>conductivityModels<span class="type-annotation">::</span>Syamlal<span class="type-annotation">::</span>kappa</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; alpha1,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; Theta,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; g0,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; rho1,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; da,</span><br><span class="line">    <span class="keyword">const</span> dimensionedScalar&amp; <span class="literal">e</span></span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> scalar sqrtPi = sqrt(constant<span class="type-annotation">::</span>mathematical<span class="type-annotation">::</span><span class="literal">pi</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rho1*da*sqrt(Theta)*</span><br><span class="line">    (</span><br><span class="line">        <span class="number">2.0</span>*sqr(alpha1)*g0*(<span class="number">1.0</span> + <span class="literal">e</span>)/sqrtPi</span><br><span class="line">      + (<span class="number">9.0</span>/<span class="number">8.0</span>)*sqrtPi*g0*<span class="number">0.25</span>*sqr(<span class="number">1.0</span> + <span class="literal">e</span>)*(<span class="number">2.0</span>*<span class="literal">e</span> - <span class="number">1.0</span>)*sqr(alpha1)</span><br><span class="line">       /(<span class="number">49.0</span>/<span class="number">16.0</span> - <span class="number">33.0</span>*<span class="literal">e</span>/<span class="number">16.0</span>)</span><br><span class="line">      + (<span class="number">15.0</span>/<span class="number">32.0</span>)*sqrtPi*alpha1/(<span class="number">49.0</span>/<span class="number">16.0</span> - <span class="number">33.0</span>*<span class="literal">e</span>/<span class="number">16.0</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$$<br>\kappa = \rho d_p \sqrt{\Theta}\left [ 2 \varepsilon_s^2 g_0 \frac{1+e}{\sqrt{\pi}} + \frac{\frac{9}{8} \sqrt{\pi}g_0 \cdot 0.25(1+e)^2(2e-1)\varepsilon_s^2}{49/16-33e/16} + \frac{\frac{15}{32}\sqrt{\pi} \cdot \varepsilon_s }{49/16-33e/16} \right ]<br>$$</p>
<h5 id="5-2_HrenyaSinclair_模型">5.2 HrenyaSinclair 模型</h5><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">Foam::kineticTheoryModels::conductivityModels::HrenyaSinclair::HrenyaSinclair</span><br><span class="line">(</span><br><span class="line">    const dictionary&amp; dict</span><br><span class="line">)</span><br><span class="line">:</span><br><span class="line">    conductivityModel(dict),</span><br><span class="line">    coeffDict_(dict.subDict(typeName + <span class="string">"Coeffs"</span>)),</span><br><span class="line">    L_(<span class="string">"L"</span>, dimensionSet(0, 1, 0, 0, 0), coeffDict_.lookup(<span class="string">"L"</span>))</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> Destructor  <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> //</span><br><span class="line"></span><br><span class="line">Foam::kineticTheoryModels::conductivityModels::HrenyaSinclair::</span><br><span class="line">~HrenyaSinclair()</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> Member Functions  <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> //</span><br><span class="line"></span><br><span class="line">Foam::tmp<span class="variable">&lt;Foam::volScalarField&gt;</span></span><br><span class="line">Foam::kineticTheoryModels::conductivityModels::HrenyaSinclair::kappa</span><br><span class="line">(</span><br><span class="line">    const volScalarField&amp; alpha1,</span><br><span class="line">    const volScalarField&amp; Theta,</span><br><span class="line">    const volScalarField&amp; g0,</span><br><span class="line">    const volScalarField&amp; rho1,</span><br><span class="line">    const volScalarField&amp; da,</span><br><span class="line">    const dimensionedScalar&amp; e</span><br><span class="line">) const</span><br><span class="line">&#123;</span><br><span class="line">    const scalar sqrtPi = sqrt(constant::mathematical::pi);</span><br><span class="line"></span><br><span class="line">    volScalarField lamda</span><br><span class="line">    (</span><br><span class="line">        scalar(1) + da/(6.0<span class="keyword">*</span>sqrt(2.0)<span class="keyword">*</span>(alpha1 + scalar(1.0e-5)))/L_</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    return rho1<span class="keyword">*</span>da<span class="keyword">*</span>sqrt(Theta)<span class="keyword">*</span></span><br><span class="line">    (</span><br><span class="line">        2.0<span class="keyword">*</span>sqr(alpha1)<span class="keyword">*</span>g0<span class="keyword">*</span>(1.0 + e)/sqrtPi</span><br><span class="line">      + (9.0/8.0)<span class="keyword">*</span>sqrtPi<span class="keyword">*</span>g0<span class="keyword">*</span>0.25<span class="keyword">*</span>sqr(1.0 + e)<span class="keyword">*</span>(2.0<span class="keyword">*</span>e - 1.0)<span class="keyword">*</span>sqr(alpha1)</span><br><span class="line">       /(49.0/16.0 - 33.0<span class="keyword">*</span>e/16.0)</span><br><span class="line">      + (15.0/16.0)<span class="keyword">*</span>sqrtPi<span class="keyword">*</span>alpha1<span class="keyword">*</span>(0.5<span class="keyword">*</span>sqr(e) + 0.25<span class="keyword">*</span>e - 0.75 + lamda)</span><br><span class="line">       /((49.0/16.0 - 33.0<span class="keyword">*</span>e/16.0)<span class="keyword">*</span>lamda)</span><br><span class="line">      + (25.0/64.0)<span class="keyword">*</span>sqrtPi</span><br><span class="line">       /((1.0 + e)<span class="keyword">*</span>(49.0/16.0 - 33.0<span class="keyword">*</span>e/16.0)<span class="keyword">*</span>lamda<span class="keyword">*</span>g0)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个模型需要输入一个特征长度 L。<br>$$<br>\begin{aligned} \kappa = \ &amp; \rho d_p \sqrt{\Theta} \, [  2\varepsilon_s^2 g_0 \frac{1+e}{\sqrt{\pi}} + \frac{\frac{9}{8} \sqrt{\pi}g_0 \cdot 0.25(1+e)^2(2e-1)\varepsilon_s^2}{49/16-33e/16} \\<br>\ + &amp;\frac{\frac{15}{16}\sqrt{\pi} \varepsilon_s \cdot (0.5e^2+0.25e-0.75+\lambda) }{(49/16-33e/16)\lambda} + \frac{\frac{25}{64}\sqrt{\pi}}{(1+e)(49/16-33e/16)\lambda g_0}<br>  ] \end{aligned}<br>$$</p>
<p>其中<br>$$<br>\lambda = 1+\frac{d_p}{6\sqrt{2}\varepsilon_s L}<br>$$</p>
<h5 id="5-3_Gidaspow_模型">5.3 Gidaspow 模型</h5><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Foam<span class="type-annotation">::</span>tmp&lt;Foam<span class="type-annotation">::</span>volScalarField&gt;</span><br><span class="line">Foam<span class="type-annotation">::</span>kineticTheoryModels<span class="type-annotation">::</span>conductivityModels<span class="type-annotation">::</span>Gidaspow<span class="type-annotation">::</span>kappa</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; alpha1,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; Theta,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; g0,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; rho1,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; da,</span><br><span class="line">    <span class="keyword">const</span> dimensionedScalar&amp; <span class="literal">e</span></span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> scalar sqrtPi = sqrt(constant<span class="type-annotation">::</span>mathematical<span class="type-annotation">::</span><span class="literal">pi</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rho1*da*sqrt(Theta)*</span><br><span class="line">    (</span><br><span class="line">        <span class="number">2.0</span>*sqr(alpha1)*g0*(<span class="number">1.0</span> + <span class="literal">e</span>)/sqrtPi</span><br><span class="line">      + (<span class="number">9.0</span>/<span class="number">8.0</span>)*sqrtPi*g0*<span class="number">0.5</span>*(<span class="number">1.0</span> + <span class="literal">e</span>)*sqr(alpha1)</span><br><span class="line">      + (<span class="number">15.0</span>/<span class="number">16.0</span>)*sqrtPi*alpha1</span><br><span class="line">      + (<span class="number">25.0</span>/<span class="number">64.0</span>)*sqrtPi/((<span class="number">1.0</span> + <span class="literal">e</span>)*g0)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$$<br>\kappa =  \rho d_p \sqrt{\Theta}\left [  2 \varepsilon_s^2 g_0 \frac{1+e}{\sqrt{\pi}}  + \frac{9}{8}\sqrt{\pi}g_0\cdot 0.5(1+e)\varepsilon_s^2  + \frac{15}{16}\sqrt{\pi} \varepsilon_s +\frac{25}{64}\frac{\sqrt{\pi}}{(1+e)g_0}\right ]<br>$$</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>上一篇博文解读了 <code>kineticTheoryModel</code>  其中提到需要调用子模型来完成其功能，这里将 OpenFOAM 中 <code>kineticTheoryModel</code> 模型的子模型罗列如下。</p>]]>
    
    </summary>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/tags/OpenFOAM/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenFOAM-2.3.x 中的 twoPhaseEulerFoam 解析之 kineticTheoryModel]]></title>
    <link href="http://xiaopingqiu.github.io/2015/09/19/kineticTheoryModel/"/>
    <id>http://xiaopingqiu.github.io/2015/09/19/kineticTheoryModel/</id>
    <published>2015-09-19T02:26:09.000Z</published>
    <updated>2015-09-25T09:14:38.738Z</updated>
    <content type="html"><![CDATA[<p>OpenFOAM 中双流体模型的 kineticTheoryModel 是以 “ <em>Derivation, implementation, and validation of computer simulation models for gas-solid fluidized beds</em>, B.G.M. van Wachem, Ph.D. Thesis, Delft University of Technology, Amsterdam, 2000. “ 为蓝本来设计的，下面分析这个类的代码。需要注意的是，这个类需要调用一些别的类（如 viscosityModel 等，后面会一一分析）来完成其功能。</p>
<a id="more"></a>
<h4 id="1-_头文件_kineticTheoryModel-H">1. 头文件 kineticTheoryModel.H</h4><p>头文件中要注意的是 kineticTheoryModel 类的继承关系，以及六个子类的智能指针作为 kineticTheoryModel 类的数据成员。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class kineticTheoryModel</span><br><span class="line">:</span><br><span class="line">    <span class="keyword">public</span> eddyViscosity</span><br><span class="line">    <span class="subst">&lt;</span></span><br><span class="line">        RASModel<span class="subst">&lt;</span>PhaseCompressibleTurbulenceModel<span class="subst">&lt;</span>phaseModel<span class="subst">&gt;</span> <span class="subst">&gt;</span></span><br><span class="line">    <span class="subst">&gt;</span> <span class="comment">// 继承自湍流类，所以这里 kineticTheoryModel 跟湍流类使用同样的接口</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Private data</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Input Fields</span></span><br><span class="line">            const phaseModel<span class="subst">&amp;</span> phase_;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// Sub-models </span></span><br><span class="line">	<span class="comment">// 下面五个 sub models 是kineticTheoryModel类为了实现其功能需要调用的类。</span></span><br><span class="line">	<span class="comment">//子类的智能指针定义为当前类的数据成员。注意这里的 "kineticTheoryModels" 是 namespace。</span></span><br><span class="line">        </span><br><span class="line">            <span class="comment">//- Run-time selected viscosity model</span></span><br><span class="line">            autoPtr<span class="subst">&lt;</span>kineticTheoryModels<span class="tag">::viscosityModel</span><span class="subst">&gt;</span> viscosityModel_;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//- Run-time selected conductivity model</span></span><br><span class="line">            autoPtr<span class="subst">&lt;</span>kineticTheoryModels<span class="tag">::conductivityModel</span><span class="subst">&gt;</span> conductivityModel_;</span><br><span class="line">            <span class="comment">//- Run-time selected radial distribution model</span></span><br><span class="line">            autoPtr<span class="subst">&lt;</span>kineticTheoryModels<span class="tag">::radialModel</span><span class="subst">&gt;</span> radialModel_;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//- Run-time selected granular pressure model</span></span><br><span class="line">            autoPtr<span class="subst">&lt;</span>kineticTheoryModels<span class="tag">::granularPressureModel</span><span class="subst">&gt;</span></span><br><span class="line">                granularPressureModel_;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//- Run-time selected frictional stress model</span></span><br><span class="line">            autoPtr<span class="subst">&lt;</span>kineticTheoryModels<span class="tag">::frictionalStressModel</span><span class="subst">&gt;</span></span><br><span class="line">                frictionalStressModel_;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">...</span><span class="attribute">...</span></span><br><span class="line">  <span class="attribute">...</span><span class="attribute">...</span></span><br></pre></td></tr></table></figure>
<h4 id="2-_构造函数">2. 构造函数</h4><p>注意这里向基类传递的参数，这里的湍流类的继承关系比较复杂，比单相湍流复杂很多，后面会有具体的分析<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">Foam::RASModels::kineticTheoryModel::kineticTheoryModel</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; alpha,</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; rho,</span><br><span class="line">    <span class="keyword">const</span> volVectorField&amp; U,</span><br><span class="line">    <span class="keyword">const</span> surfaceScalarField&amp; alphaRhoPhi,</span><br><span class="line">    <span class="keyword">const</span> surfaceScalarField&amp; phi,</span><br><span class="line">    <span class="keyword">const</span> transportModel&amp; phase,</span><br><span class="line">    <span class="keyword">const</span> word&amp; propertiesName,</span><br><span class="line">    <span class="keyword">const</span> word&amp; type</span><br><span class="line">)</span><br><span class="line">:</span><br><span class="line">    eddyViscosity&lt;RASModel&lt;PhaseCompressibleTurbulenceModel&lt;phaseModel&gt; &gt; &gt;</span><br><span class="line">    (</span><br><span class="line">        type,</span><br><span class="line">        alpha,</span><br><span class="line">        rho,</span><br><span class="line">        U,</span><br><span class="line">        alphaRhoPhi,</span><br><span class="line">        phi,</span><br><span class="line">        phase,</span><br><span class="line">        propertiesName</span><br><span class="line">    ),</span><br><span class="line"></span><br><span class="line">    phase_(phase),</span><br><span class="line"></span><br><span class="line">    viscosityModel_</span><br><span class="line">    (</span><br><span class="line">        kineticTheoryModels::viscosityModel::New</span><br><span class="line">        (</span><br><span class="line">            <span class="keyword">this</span>-&gt;coeffDict_ <span class="comment">// coeffDict_ 是 RASModel的成员</span></span><br><span class="line">        )</span><br><span class="line">    ),</span><br><span class="line">    conductivityModel_</span><br><span class="line">    (</span><br><span class="line">        kineticTheoryModels::conductivityModel::New</span><br><span class="line">        (</span><br><span class="line">            <span class="keyword">this</span>-&gt;coeffDict_</span><br><span class="line">        )</span><br><span class="line">    ),</span><br><span class="line">    radialModel_</span><br><span class="line">    (</span><br><span class="line">        kineticTheoryModels::radialModel::New</span><br><span class="line">        (</span><br><span class="line">            <span class="keyword">this</span>-&gt;coeffDict_</span><br><span class="line">        )</span><br><span class="line">    ),</span><br><span class="line">    granularPressureModel_</span><br><span class="line">    (</span><br><span class="line">        kineticTheoryModels::granularPressureModel::New</span><br><span class="line">        (</span><br><span class="line">            <span class="keyword">this</span>-&gt;coeffDict_</span><br><span class="line">        )</span><br><span class="line">    ),</span><br><span class="line">    frictionalStressModel_</span><br><span class="line">    (</span><br><span class="line">        kineticTheoryModels::frictionalStressModel::New</span><br><span class="line">        (</span><br><span class="line">            <span class="keyword">this</span>-&gt;coeffDict_</span><br><span class="line">        )</span><br><span class="line">    ),</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">......</span><br></pre></td></tr></table></figure></p>
<h4 id="3-_主要成员函数">3. 主要成员函数</h4><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> Member Functions  <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> //</span><br><span class="line"></span><br><span class="line">Foam::tmp<span class="variable">&lt;Foam::volScalarField&gt;</span></span><br><span class="line">Foam::RASModels::kineticTheoryModel::k() const</span><br><span class="line">&#123;</span><br><span class="line">    // notImplemented 是 Error.H中定义的一个函数，用于提示某个模型或函数没有实现。</span><br><span class="line">    notImplemented(<span class="string">"kineticTheoryModel::k()"</span>); </span><br><span class="line">    return nut_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Foam::tmp<span class="variable">&lt;Foam::volScalarField&gt;</span></span><br><span class="line">Foam::RASModels::kineticTheoryModel::epsilon() const</span><br><span class="line">&#123;</span><br><span class="line">    notImplemented(<span class="string">"kineticTheoryModel::epsilon()"</span>);</span><br><span class="line">    return nut_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <code>k</code> 和  <code>epsilon</code> 是两个从基类继承下来的函数，这两个函数在基类中是纯虚函数，所以虽然 kineticTheoryModel 用不到它们，但是还是需要进行定义，否则 kineticTheoryModel 类就将是一个虚基类，从而无法创建对象了。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="constant">Foam:</span><span class="symbol">:tmp&lt;Foam</span><span class="symbol">:</span><span class="symbol">:volSymmTensorField&gt;</span></span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:RASModels</span><span class="symbol">:</span><span class="symbol">:kineticTheoryModel</span><span class="symbol">:</span><span class="symbol">:R</span>() const</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> tmp&lt;volSymmTensorField&gt;</span><br><span class="line">    (</span><br><span class="line">        new volSymmTensorField</span><br><span class="line">        (</span><br><span class="line">            <span class="constant">IOobject</span></span><br><span class="line">            (</span><br><span class="line">                <span class="constant">IOobject:</span><span class="symbol">:groupName</span>(<span class="string">"R"</span>, this-&gt;<span class="constant">U_.</span>group()),</span><br><span class="line">                this-&gt;runTime<span class="constant">_</span>.timeName(),</span><br><span class="line">                this-&gt;mesh<span class="constant">_</span>,</span><br><span class="line">                <span class="constant">IOobject:</span><span class="symbol">:NO_READ</span>,</span><br><span class="line">                <span class="constant">IOobject:</span><span class="symbol">:NO_WRITE</span></span><br><span class="line">            ),</span><br><span class="line">          - (this-&gt;nut<span class="constant">_</span>)*dev(twoSymm(<span class="symbol">fvc:</span><span class="symbol">:grad</span>(this-&gt;<span class="constant">U_)</span>))</span><br><span class="line">          - (lambda<span class="constant">_</span>*<span class="symbol">fvc:</span><span class="symbol">:div</span>(this-&gt;phi<span class="constant">_</span>))*<span class="symbol">symmTensor:</span><span class="symbol">:I</span></span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>R 函数返回所谓的雷诺应力，其实跟单相湍流类的 R 函数返回值有点差别：<br>$$<br>-\nu_t[\nabla U + \nabla U^T-\frac{2}{3}(\nabla \cdot U)\cdot \mathrm{I}] - \lambda(\nabla \cdot U)\cdot \mathrm{I}<br>$$<br>这里的 R 与下面的 devRoReff 函数返回值只相差一个 rho。<br>而单相湍流模型的 R 则为：<br>$$<br>\frac{2}{3}k\cdot \mathrm{I}- \nu_t (\nabla U + \nabla U^T)<br>$$</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:tmp&lt;Foam</span><span class="symbol">:</span><span class="symbol">:volScalarField&gt;</span></span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:RASModels</span><span class="symbol">:</span><span class="symbol">:kineticTheoryModel</span><span class="symbol">:</span><span class="symbol">:pPrime</span>() const</span><br><span class="line">&#123;</span><br><span class="line">    <span class="regexp">//</span> <span class="constant">Local </span>references</span><br><span class="line">    const volScalarField&amp; alpha = this-&gt;alpha<span class="constant">_</span>;</span><br><span class="line">    const volScalarField&amp; rho = phase<span class="constant">_</span>.rho();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    (</span><br><span class="line">        <span class="constant">Theta_</span></span><br><span class="line">       *granularPressureModel<span class="constant">_</span>-&gt;granularPressureCoeffPrime</span><br><span class="line">        (</span><br><span class="line">            alpha,</span><br><span class="line">            radialModel<span class="constant">_</span>-&gt;g<span class="number">0</span>(alpha, alphaMinFriction<span class="constant">_</span>, alphaMax<span class="constant">_</span>),</span><br><span class="line">            radialModel<span class="constant">_</span>-&gt;g0prime(alpha, alphaMinFriction<span class="constant">_</span>, alphaMax<span class="constant">_</span>),</span><br><span class="line">            rho,</span><br><span class="line">            e<span class="constant">_</span></span><br><span class="line">        )</span><br><span class="line">     +  frictionalStressModel<span class="constant">_</span>-&gt;frictionalPressurePrime</span><br><span class="line">        (</span><br><span class="line">            alpha,</span><br><span class="line">            alphaMinFriction<span class="constant">_</span>,</span><br><span class="line">            alphaMax<span class="constant">_</span></span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:tmp&lt;Foam</span><span class="symbol">:</span><span class="symbol">:surfaceScalarField&gt;</span></span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:RASModels</span><span class="symbol">:</span><span class="symbol">:kineticTheoryModel</span><span class="symbol">:</span><span class="symbol">:pPrimef</span>() const</span><br><span class="line">&#123;</span><br><span class="line">    <span class="regexp">//</span> <span class="constant">Local </span>references</span><br><span class="line">    const volScalarField&amp; alpha = this-&gt;alpha<span class="constant">_</span>;</span><br><span class="line">    const volScalarField&amp; rho = phase<span class="constant">_</span>.rho();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="symbol">fvc:</span><span class="symbol">:interpolate</span></span><br><span class="line">    (</span><br><span class="line">        <span class="constant">Theta_</span></span><br><span class="line">       *granularPressureModel<span class="constant">_</span>-&gt;granularPressureCoeffPrime</span><br><span class="line">        (</span><br><span class="line">            alpha,</span><br><span class="line">            radialModel<span class="constant">_</span>-&gt;g<span class="number">0</span>(alpha, alphaMinFriction<span class="constant">_</span>, alphaMax<span class="constant">_</span>),</span><br><span class="line">            radialModel<span class="constant">_</span>-&gt;g0prime(alpha, alphaMinFriction<span class="constant">_</span>, alphaMax<span class="constant">_</span>),</span><br><span class="line">            rho,</span><br><span class="line">            e<span class="constant">_</span></span><br><span class="line">        )</span><br><span class="line">     +  frictionalStressModel<span class="constant">_</span>-&gt;frictionalPressurePrime</span><br><span class="line">        (</span><br><span class="line">            alpha,</span><br><span class="line">            alphaMinFriction<span class="constant">_</span>,</span><br><span class="line">            alphaMax<span class="constant">_</span></span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>pPrime 和 pPrimef 两个函数，返回的是固相压力对固相孔隙率的导数（$\partial P_s/\partial \varepsilon_s$）。</p>
<p>两个在”UEqn.H” 被动量方程调用的函数<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="constant">Foam:</span><span class="symbol">:tmp&lt;Foam</span><span class="symbol">:</span><span class="symbol">:volSymmTensorField&gt;</span></span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:RASModels</span><span class="symbol">:</span><span class="symbol">:kineticTheoryModel</span><span class="symbol">:</span><span class="symbol">:devRhoReff</span>() const</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> tmp&lt;volSymmTensorField&gt;</span><br><span class="line">    (</span><br><span class="line">        new volSymmTensorField</span><br><span class="line">        (</span><br><span class="line">            <span class="constant">IOobject</span></span><br><span class="line">            (</span><br><span class="line">                <span class="constant">IOobject:</span><span class="symbol">:groupName</span>(<span class="string">"devRhoReff"</span>, this-&gt;<span class="constant">U_.</span>group()),</span><br><span class="line">                this-&gt;runTime<span class="constant">_</span>.timeName(),</span><br><span class="line">                this-&gt;mesh<span class="constant">_</span>,</span><br><span class="line">                <span class="constant">IOobject:</span><span class="symbol">:NO_READ</span>,</span><br><span class="line">                <span class="constant">IOobject:</span><span class="symbol">:NO_WRITE</span></span><br><span class="line">            ),</span><br><span class="line">          - (this-&gt;rho<span class="constant">_</span>*this-&gt;nut<span class="constant">_</span>)</span><br><span class="line">           *dev(twoSymm(<span class="symbol">fvc:</span><span class="symbol">:grad</span>(this-&gt;<span class="constant">U_)</span>))</span><br><span class="line">          - ((this-&gt;rho<span class="constant">_</span>*lambda<span class="constant">_</span>)*<span class="symbol">fvc:</span><span class="symbol">:div</span>(this-&gt;phi<span class="constant">_</span>))*<span class="symbol">symmTensor:</span><span class="symbol">:I</span></span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:tmp&lt;Foam</span><span class="symbol">:</span><span class="symbol">:fvVectorMatrix&gt;</span></span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:RASModels</span><span class="symbol">:</span><span class="symbol">:kineticTheoryModel</span><span class="symbol">:</span><span class="symbol">:divDevRhoReff</span></span><br><span class="line">(</span><br><span class="line">    volVectorField&amp; <span class="constant">U</span></span><br><span class="line">) const</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    (</span><br><span class="line">      - <span class="symbol">fvm:</span><span class="symbol">:laplacian</span>(this-&gt;rho<span class="constant">_</span>*this-&gt;nut<span class="constant">_</span>, <span class="constant">U)</span></span><br><span class="line">      - <span class="symbol">fvc:</span><span class="symbol">:div</span></span><br><span class="line">        (</span><br><span class="line">            (this-&gt;rho<span class="constant">_</span>*this-&gt;nut<span class="constant">_</span>)*dev2(<span class="constant">T(</span><span class="symbol">fvc:</span><span class="symbol">:grad</span>(<span class="constant">U)</span>))</span><br><span class="line">          + ((this-&gt;rho<span class="constant">_</span>*lambda<span class="constant">_</span>)*<span class="symbol">fvc:</span><span class="symbol">:div</span>(this-&gt;phi<span class="constant">_</span>))</span><br><span class="line">           *dimensioned&lt;symmTensor&gt;(<span class="string">"I"</span>, dimless, <span class="symbol">symmTensor:</span><span class="symbol">:I</span>)</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对应的公式分别为：<br><strong>devRhoReff</strong><br>$$<br>- \rho  \nu_t \cdot dev(\nabla U + \nabla U^T) - \rho \lambda(\nabla \cdot U)\cdot  \mathrm{I} \\<br> = - \rho  \nu_t(\nabla U + \nabla U^T) +  \rho  \nu_t \frac{2}{3}(\nabla \cdot U)\cdot \mathrm{I} - \rho \lambda (\nabla \cdot U)\cdot  \mathrm{I}<br>$$</p>
<p><strong>divDevRhoReff</strong><br>$$<br>\ - \nabla \cdot (\rho \nu_t \nabla U) - \nabla \cdot \left [\rho \nu_t \nabla U^T\ - \rho \nu_t \frac{2}{3}(\nabla \cdot U)\cdot \mathrm{I} \right ] + \rho \lambda (\nabla \cdot U) \cdot \mathrm{I} )<br>$$</p>
<p> <code>correct</code>是计算颗粒温度 <code>Theta</code> 的函数，这是 kineticTheoryModel 类最重要的部分。<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br></pre></td><td class="code"><pre><span class="line">void Foam::RASModels::kineticTheoryModel::correct()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Local references</span></span><br><span class="line">    volScalarField <span class="keyword">alpha</span>(<span class="literal">max</span>(this-&gt;alpha_, <span class="literal">scalar</span>(0)));</span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; rho = phase_.rho();</span><br><span class="line">    <span class="keyword">const</span> surfaceScalarField&amp; alphaRhoPhi = this-&gt;alphaRhoPhi_;</span><br><span class="line">    <span class="keyword">const</span> volVectorField&amp; <span class="keyword">U</span> = this-&gt;U_; <span class="comment">// 当前相的速度</span></span><br><span class="line">    <span class="keyword">const</span> volVectorField&amp; Uc_ = phase_.fluid().otherPhase(phase_).<span class="keyword">U</span>(); <span class="comment">// 另一相的速度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">scalar</span> sqrtPi = <span class="literal">sqrt</span>(constant::mathematical::pi);</span><br><span class="line">    dimensionedScalar ThetaSmall(<span class="string">"ThetaSmall"</span>, Theta_.dimensions(), 1.0e-6);</span><br><span class="line">    dimensionedScalar ThetaSmallSqrt(<span class="literal">sqrt</span>(ThetaSmall));</span><br><span class="line"></span><br><span class="line">    tmp&lt;volScalarField&gt; tda(phase_.<span class="literal">d</span>()); <span class="comment">// 颗粒直径</span></span><br><span class="line">    <span class="keyword">const</span> volScalarField&amp; da = tda();</span><br><span class="line"></span><br><span class="line">    tmp&lt;volTensorField&gt; tgradU(fvc::grad(this-&gt;U_));</span><br><span class="line">    <span class="keyword">const</span> volTensorField&amp; gradU(tgradU());</span><br><span class="line">    volSymmTensorField <span class="literal">D</span>(symm(gradU));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Calculating the radial distribution function </span></span><br><span class="line">    <span class="comment">// 调用 radialModel 类 来计算径向分布函数</span></span><br><span class="line">    gs0_ = radialModel_-&gt;g0(<span class="keyword">alpha</span>, alphaMinFriction_, alphaMax_);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!equilibrium_) <span class="comment">// 如果 equilibrium_ = off ，那么将用这个偏微分方程来计算颗粒温度，否则将改用一个代数方程，见下文</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Particle viscosity (Table 3.2, p.47)</span></span><br><span class="line">	<span class="comment">// 调用viscosityModel 来更新颗粒相的粘度</span></span><br><span class="line">        nut_ = viscosityModel_-&gt;nu(<span class="keyword">alpha</span>, Theta_, gs0_, rho, da, e_);</span><br><span class="line"></span><br><span class="line">        volScalarField ThetaSqrt(<span class="literal">sqrt</span>(Theta_));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Bulk viscosity  p. 45 (Lun et al. 1984). </span></span><br><span class="line">        lambda_ = (4.0/3.0)*sqr(<span class="keyword">alpha</span>)*da*gs0_*(1.0 + e_)*ThetaSqrt/sqrtPi;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Stress tensor, Definitions, Table 3.1, p. 43</span></span><br><span class="line">        volSymmTensorField tau <span class="comment">// 颗粒应力</span></span><br><span class="line">        (</span><br><span class="line">            rho*(2.0*nut_*<span class="keyword">D</span> + (lambda_ - (2.0/3.0)*nut_)*tr(<span class="keyword">D</span>)*I)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Dissipation (Eq. 3.24, p.50)</span></span><br><span class="line">        volScalarField gammaCoeff <span class="comment">//颗粒动能耗散项</span></span><br><span class="line">        (</span><br><span class="line">            12.0*(1.0 - sqr(e_))</span><br><span class="line"><span class="comment">           *max(sqr(alpha), residualAlpha_)</span></span><br><span class="line"><span class="comment">           *rho*gs0_*(1.0/da)*ThetaSqrt/sqrtPi</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Drag // 调用曳力模型计算曳力系数</span></span><br><span class="line">        volScalarField beta(phase_.fluid().drag(phase_).K());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Eq. 3.25, p. 50 Js = J1 - J2</span></span><br><span class="line">        volScalarField J1(3.0*beta);</span><br><span class="line">        volScalarField J2</span><br><span class="line">        (</span><br><span class="line">            0.25*sqr(beta)*da*magSqr(<span class="keyword">U</span> - Uc_)</span><br><span class="line">           /(</span><br><span class="line">               <span class="literal">max</span>(<span class="keyword">alpha</span>, residualAlpha_)*rho</span><br><span class="line"><span class="comment">              *sqrtPi*(ThetaSqrt + ThetaSmallSqrt)</span></span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// particle pressure - coefficient in front of Theta (Eq. 3.22, p. 45)</span></span><br><span class="line">        volScalarField PsCoeff</span><br><span class="line">        (</span><br><span class="line">            granularPressureModel_-&gt;granularPressureCoeff</span><br><span class="line">            (</span><br><span class="line">                <span class="keyword">alpha</span>,</span><br><span class="line">                gs0_,</span><br><span class="line">                rho,</span><br><span class="line">                e_</span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 'thermal' conductivity (Table 3.3, p. 49)</span></span><br><span class="line">	<span class="comment">// 调用 conductivityModel 计算颗粒脉动能量的传导系数</span></span><br><span class="line">        kappa_ = conductivityModel_-&gt;<span class="keyword">kappa</span>(<span class="keyword">alpha</span>, Theta_, gs0_, rho, da, e_);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Construct the granular temperature equation (Eq. 3.20, p. 44)</span></span><br><span class="line">        <span class="comment">// NB. note that there are two typos in Eq. 3.20:</span></span><br><span class="line">        <span class="comment">//     Ps should be without grad</span></span><br><span class="line">        <span class="comment">//     the laplacian has the wrong sign</span></span><br><span class="line">	<span class="comment">// 构建颗粒温度方程，注意，开头提到的文献里的颗粒温度方程有两处 typo，</span></span><br><span class="line">	<span class="comment">//下面的代码修复了这两处错误，后文会给出正确的公式。</span></span><br><span class="line">        fvScalarMatrix ThetaEqn</span><br><span class="line">        (</span><br><span class="line">            1.5*</span><br><span class="line">            (</span><br><span class="line">                fvm::ddt(<span class="keyword">alpha</span>, rho, Theta_)</span><br><span class="line">              + fvm::div(alphaRhoPhi, Theta_)</span><br><span class="line">              - fvc::Sp(fvc::ddt(<span class="keyword">alpha</span>, rho) + fvc::div(alphaRhoPhi), Theta_)</span><br><span class="line">            )</span><br><span class="line">          - fvm::laplacian(kappa_, Theta_, <span class="string">"laplacian(kappa,Theta)"</span>)</span><br><span class="line">         ==</span><br><span class="line">            fvm::SuSp(-((PsCoeff*I) &amp;&amp; gradU), Theta_)</span><br><span class="line">          + (tau &amp;&amp; gradU)</span><br><span class="line">          + fvm::Sp(-gammaCoeff, Theta_)</span><br><span class="line">          + fvm::Sp(-J1, Theta_)</span><br><span class="line">          + fvm::Sp(J2/(Theta_ + ThetaSmall), Theta_)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        ThetaEqn.relax();</span><br><span class="line">        ThetaEqn.solve();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 如果 equilibrium = on， 将使用一个代数方程来计算颗粒温度。</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Equilibrium =&gt; dissipation == production</span></span><br><span class="line">        <span class="comment">// Eq. 4.14, p.82</span></span><br><span class="line">        volScalarField K1(2.0*(1.0 + e_)*rho*gs0_);</span><br><span class="line">        volScalarField K3</span><br><span class="line">        (</span><br><span class="line">            0.5*da*rho*</span><br><span class="line">            (</span><br><span class="line">                (sqrtPi/(3.0*(3.0 - e_)))</span><br><span class="line"><span class="comment">               *(1.0 + 0.4*(1.0 + e_)*(3.0*e_ - 1.0)*alpha*gs0_)</span></span><br><span class="line">               +1.6*<span class="keyword">alpha</span>*gs0_*(1.0 + e_)/sqrtPi</span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        volScalarField K2</span><br><span class="line">        (</span><br><span class="line">            4.0*da*rho*(1.0 + e_)*<span class="keyword">alpha</span>*gs0_/(3.0*sqrtPi) - 2.0*K3/3.0</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        volScalarField K4(12.0*(1.0 - sqr(e_))*rho*gs0_/(da*sqrtPi));</span><br><span class="line"></span><br><span class="line">        volScalarField trD</span><br><span class="line">        (</span><br><span class="line">            <span class="keyword">alpha</span>/(<span class="keyword">alpha</span> + residualAlpha_)</span><br><span class="line"><span class="comment">           *fvc::div(this-&gt;phi_)</span></span><br><span class="line">        );</span><br><span class="line">        volScalarField tr2D(sqr(trD));</span><br><span class="line">        volScalarField trD2(tr(<span class="keyword">D</span> &amp; <span class="keyword">D</span>));</span><br><span class="line"></span><br><span class="line">        volScalarField t1(K1*<span class="keyword">alpha</span> + rho);</span><br><span class="line">        volScalarField l1(-t1*trD);</span><br><span class="line">        volScalarField l2(sqr(t1)*tr2D);</span><br><span class="line">        volScalarField l3</span><br><span class="line">        (</span><br><span class="line">            4.0</span><br><span class="line"><span class="comment">           *K4</span></span><br><span class="line"><span class="comment">           *alpha</span></span><br><span class="line"><span class="comment">           *(2.0*K3*trD2 + K2*tr2D)</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        Theta_ = sqr</span><br><span class="line">        (</span><br><span class="line">            (l1 + <span class="literal">sqrt</span>(l2 + l3))</span><br><span class="line">           /(2.0*<span class="literal">max</span>(<span class="keyword">alpha</span>, residualAlpha_)*K4)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        kappa_ = conductivityModel_-&gt;<span class="keyword">kappa</span>(<span class="keyword">alpha</span>, Theta_, gs0_, rho, da, e_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 限定 颗粒温度的上下限。</span></span><br><span class="line">  <span class="comment">// max 和 min 函数的定义，没有找到。经验证， max 的作用是让小于0的归零， min 是让大于100的等于100。</span></span><br><span class="line">    Theta_.<span class="literal">max</span>(0);</span><br><span class="line">    Theta_.<span class="literal">min</span>(100);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">	<span class="comment">//利用先得到的颗粒温度更新颗粒相的粘度</span></span><br><span class="line">        <span class="comment">// particle viscosity (Table 3.2, p.47)</span></span><br><span class="line">        nut_ = viscosityModel_-&gt;nu(<span class="keyword">alpha</span>, Theta_, gs0_, rho, da, e_);</span><br><span class="line"></span><br><span class="line">        volScalarField ThetaSqrt(<span class="literal">sqrt</span>(Theta_));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Bulk viscosity  p. 45 (Lun et al. 1984).</span></span><br><span class="line">        lambda_ = (4.0/3.0)*sqr(<span class="keyword">alpha</span>)*da*gs0_*(1.0 + e_)*ThetaSqrt/sqrtPi;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Frictional pressure // 计算由于颗粒之间的摩擦作用产生的一个等效的颗粒相压力作用。</span></span><br><span class="line">        volScalarField pf</span><br><span class="line">        (</span><br><span class="line">            frictionalStressModel_-&gt;frictionalPressure</span><br><span class="line">            (</span><br><span class="line">                <span class="keyword">alpha</span>,</span><br><span class="line">                alphaMinFriction_,</span><br><span class="line">                alphaMax_</span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add frictional shear viscosity, Eq. 3.30, p. 52</span></span><br><span class="line">       <span class="comment">// 将颗粒摩擦产生的颗粒相粘度加到由颗粒温度计算得到的颗粒相粘度中，作为总的颗粒相粘度</span></span><br><span class="line">        nut_ += frictionalStressModel_-&gt;nu </span><br><span class="line">        (</span><br><span class="line">            <span class="keyword">alpha</span>,</span><br><span class="line">            alphaMax_,</span><br><span class="line">            pf/rho,</span><br><span class="line">            <span class="literal">D</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Limit viscosity</span></span><br><span class="line">	<span class="comment">// 限定颗粒相粘度的上限</span></span><br><span class="line">        nut_.<span class="literal">min</span>(100);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (debug)</span><br><span class="line">    &#123;</span><br><span class="line">        Info&lt;&lt; typeName &lt;&lt; ':' &lt;&lt; <span class="keyword">nl</span></span><br><span class="line">            &lt;&lt; <span class="string">"    max(Theta) = "</span> &lt;&lt; <span class="literal">max</span>(Theta_).value() &lt;&lt; <span class="keyword">nl</span></span><br><span class="line">            &lt;&lt; <span class="string">"    max(nut) = "</span> &lt;&lt; <span class="literal">max</span>(nut_).value() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里重点关注一下 <code>ThetaEqn</code> 的写法。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">fvScalarMatrix</span> <span class="tag">ThetaEqn</span></span><br><span class="line">  (</span><br><span class="line">      1<span class="class">.5</span>*</span><br><span class="line">      (</span><br><span class="line">          <span class="rule"><span class="attribute">fvm</span>:<span class="value">:<span class="function">ddt</span>(alpha, rho, Theta_)</span><br><span class="line">        + fvm::<span class="function">div</span>(alphaRhoPhi, Theta_)</span><br><span class="line">        - fvc::<span class="function">Sp</span>(fvc::<span class="function">ddt</span>(alpha, rho) + fvc::<span class="function">div</span>(alphaRhoPhi), Theta_)</span><br><span class="line">      )</span><br><span class="line">    - fvm::<span class="function">laplacian</span>(kappa_, Theta_, <span class="string">"laplacian(kappa,Theta)"</span>)</span><br><span class="line">   ==</span><br><span class="line">      fvm::<span class="function">SuSp</span>(<span class="function">-</span>((PsCoeff*I) &amp;&amp; gradU), Theta_)</span><br><span class="line">    + (tau &amp;&amp; gradU)</span><br><span class="line">    + fvm::<span class="function">Sp</span>(-gammaCoeff, Theta_)</span><br><span class="line">    + fvm::<span class="function">Sp</span>(-J1, Theta_)</span><br><span class="line">    + fvm::<span class="function">Sp</span>(J2/(Theta_ + ThetaSmall), Theta_)</span><br><span class="line"> )</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>对应的偏微分方程是，<br>$$<br>\frac{3}{2}\left [ \frac{\partial }{\partial t}(\varepsilon_s \rho_s \Theta)+ \nabla \cdot (\varepsilon_s \rho_s \Theta U_s) \right ] = (-P_s \mathrm{I} + \tau_s):\nabla U_s + \nabla \cdot (\kappa_s \nabla \Theta) - \gamma_s - J_s<br>$$<br>下面将公式与代码一一对应。代码里跟公式相比，多了一项<br>$$<br>-\Theta\frac{\partial }{\partial t}(\varepsilon_s \rho_s) - \Theta \nabla \cdot (\varepsilon_s \rho_s U_s)<br>$$<br>这样，相当于代码对应的前两项是<br>$$<br>\varepsilon_s \rho_s \frac{\partial \Theta}{\partial t} + \varepsilon_s \rho_s U_s \cdot \nabla \Theta<br>$$<br>这样做的目的仍不是很明确。</p>
<p>Laplacian 项不需多言，剩下的几项，全都当作了源项来处理。<br>$(-P_s \mathrm{I} + \tau_s)\:\nabla U_s$ 拆开成了两项，分别对应 <code>fvm::SuSp(-((PsCoeff*I) &amp;&amp; gradU), Theta_)</code> 和 <code>(tau &amp;&amp; gradU)</code> 。第一项，由于$P_s$是$\Theta$ 的函数，所以，在固相压力类中，返回的值是固相压力系数（固相压力除以颗粒温度），在这里将$\Theta$进行了隐式处理。而由于$\tau$与$\nabla U_s$与$\Theta$无关，所以就只当成一般的源项了。</p>
<p>$\gamma$项的处理与颗粒压力类似，也是只定义 <code>gammaCoeff</code> ，然后将$\Theta$作隐式处理。由于实际上$\gamma$的表达式<br>$$<br>\gamma = \frac{12(1-e^2)\varepsilon_s^2\rho g_0}{d_p \sqrt{\pi}} \Theta^{3/2}<br>$$<br>这里有关于$\Theta$的非线性项，程序里实际上是对$\Theta$作了部分隐式处理，从 <code>gammaCoeff</code>的定义可以看出来：<br>$$<br>\gamma_{Coeff} = \frac{12(1-e^2)\varepsilon_s^2\rho g_0}{d_p } \sqrt{\frac{\Theta}{\pi}}<br>$$</p>
<p>颗粒温度方程中的$J_s$ 也分成了两项来处理，$J_s = J_1 - J_2$<br>$J_1$的处理很简单，在公式里，$J_1 = 3\beta \Theta$，而在代码当中，变量 <code>J1</code> 定义为 <code>3*beta</code>，而 <code>Theta</code> 则作隐式处理。   </p>
<p>$J_2$也人为作了隐式处理，文献中$J_2$的表达式为<br>$$<br>J_2 = \frac{\beta^2 d_p |U_g-U_s|^2}{4\varepsilon_s\rho\sqrt{\pi \Theta}}<br>$$</p>
<p>程序里则将$J_2$除以$\Theta$以后作为系数，以实现对$\Theta$进行隐式处理。<br>注意这里要说明一下”Sp”和”SuSp”的区别，这个在”Programmer’s Guide”里有说明，此外这个<a href="https://openfoamwiki.net/index.php/HowTo_Adding_a_new_transport_equation" target="_blank" rel="external">网页</a>里也有说明。可是，为什么固相压力项要用”SuSp”，这个也暂时不明白。</p>
<p>计算颗粒温度的代数方程的具体公式这里不写了，可以参考文献。</p>
<p>最后，上面提到的由于颗粒摩擦作用产生的颗粒压力和颗粒粘度，只在颗粒体积分率很大的区域才需要启用，算例中需要设定一个值，对于颗粒相体积分率大于一个设定值时， <code>alphaMinFriction</code>，只有颗粒相体积分率超过这个值时，才会启用由于颗粒相摩擦而产生的压力和粘度。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>OpenFOAM 中双流体模型的 kineticTheoryModel 是以 “ <em>Derivation, implementation, and validation of computer simulation models for gas-solid fluidized beds</em>, B.G.M. van Wachem, Ph.D. Thesis, Delft University of Technology, Amsterdam, 2000. “ 为蓝本来设计的，下面分析这个类的代码。需要注意的是，这个类需要调用一些别的类（如 viscosityModel 等，后面会一一分析）来完成其功能。</p>]]>
    
    </summary>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/tags/OpenFOAM/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++ 中派生类引用与基类引用的隐式转换]]></title>
    <link href="http://xiaopingqiu.github.io/2015/09/13/CPP-conversion-Of-derived-class-reference-to-base-class-type/"/>
    <id>http://xiaopingqiu.github.io/2015/09/13/CPP-conversion-Of-derived-class-reference-to-base-class-type/</id>
    <published>2015-09-13T09:03:35.000Z</published>
    <updated>2015-09-13T13:19:36.361Z</updated>
    <content type="html"><![CDATA[<p>在读 OpenFOAM 代码过程中，有一类应用初看之下觉得很费解，比如 OpenFOAM-2.3.x 的 <code>twoPhaseEulerFoam</code>，createFields.H 有这么一段：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">phaseModel&amp; <span class="variable">phase1 =</span> fluid.phase1();</span><br><span class="line">phaseModel&amp; <span class="variable">phase2 =</span> fluid.phase2();</span><br><span class="line"></span><br><span class="line">volScalarField&amp; <span class="variable">alpha1 =</span> phase1;</span><br><span class="line">volScalarField&amp; <span class="variable">alpha2 =</span> phase2;</span><br></pre></td></tr></table></figure></p>
<p>乍看之下，感觉有点奇怪：怎么能将 phaseModel 类的引用直接赋值给 volScalarField 类的引用呢？后来查看了一下 phaseModel 类的定义，发现原来 phaseModel 类是 volScalarField 类的派生，由此上面代码就好理解了，无非是将派生类引用赋值给基类引用而已。</p>
<a id="more"></a>
<p>但是，下面代码，虽然深究下去发现原理类似，但是乍看上去却更加费解：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="constant">Foam:</span><span class="symbol">:tmp&lt;Foam</span><span class="symbol">:</span><span class="symbol">:volVectorField&gt;</span> <span class="constant">Foam:</span><span class="symbol">:twoPhaseSystem</span><span class="symbol">:</span><span class="symbol">:U</span>() const</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> phase1<span class="constant">_</span>*phase1<span class="constant">_</span>.<span class="constant">U(</span>) + phase2<span class="constant">_</span>*phase2<span class="constant">_</span>.<span class="constant">U(</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="constant">Foam:</span><span class="symbol">:tmp&lt;Foam</span><span class="symbol">:</span><span class="symbol">:surfaceScalarField&gt;</span> <span class="constant">Foam:</span><span class="symbol">:twoPhaseSystem</span><span class="symbol">:</span><span class="symbol">:calcPhi</span>() const</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        <span class="symbol">fvc:</span><span class="symbol">:interpolate</span>(phase1<span class="constant">_</span>)*phase1<span class="constant">_</span>.phi()</span><br><span class="line">      + <span class="symbol">fvc:</span><span class="symbol">:interpolate</span>(phase2<span class="constant">_</span>)*phase2<span class="constant">_</span>.phi();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里将 <code>phase1_</code> 直接与 <code>phase1_.U()</code>（或者 <code>phase1_.phi()</code>）相乘，怎么理解？从原理上讲，应该是 <code>phase1_</code> 的体积分率与其速度的乘积。<br>仔细看一下 phaseModel 类的构造函数，<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Foam::phaseModel::phaseModel</span><br><span class="line">(</span><br><span class="line">    const twoPhaseSystem&amp; fluid,</span><br><span class="line">    const dictionary&amp; phaseProperties,</span><br><span class="line">    const word&amp; phaseName</span><br><span class="line">)</span><br><span class="line">:</span><br><span class="line">    volScalarField</span><br><span class="line">    (</span><br><span class="line">        IOobject</span><br><span class="line">        (</span><br><span class="line">            IOobject::<span class="function"><span class="title">groupName</span><span class="params">(<span class="string">"alpha"</span>, phaseName)</span></span>, <span class="comment">// "alpha.particle" </span></span><br><span class="line">            fluid.<span class="function"><span class="title">mesh</span><span class="params">()</span></span>.<span class="function"><span class="title">time</span><span class="params">()</span></span>.<span class="function"><span class="title">timeName</span><span class="params">()</span></span>,</span><br><span class="line">            fluid.<span class="function"><span class="title">mesh</span><span class="params">()</span></span>,</span><br><span class="line">            IOobject::READ_IF_PRESENT,</span><br><span class="line">            IOobject::AUTO_WRITE</span><br><span class="line">        ),</span><br><span class="line">        fluid.<span class="function"><span class="title">mesh</span><span class="params">()</span></span>,</span><br><span class="line">        <span class="function"><span class="title">dimensionedScalar</span><span class="params">(<span class="string">"alpha"</span>, dimless, <span class="number">0</span>)</span></span></span><br><span class="line">    ),</span><br><span class="line">    ......</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure></p>
<p>原来是这样，读取 “alpha.phaseName” 数据文件构建了一个 IOobject 对象，并用该对象对一个临时的 volScalarField 对象进行了初始化，然后用成员初始化列表，将该临时 volScalarField 对象对基类 volScalarField 进行初始化。</p>
<p>这样一来，对于上面的情形， <code>phase1_ * phase1_.U()</code> ，实际上是进行了一个隐式转换，先将 <code>phase1_</code> 转换成基类 volScalarField 类型，由于上述 phaseModel 类的初始化设定，转换以后，<code>phase1_</code> 其实就相当于用 alpha 初始化过的那个 volScalarField 类的对象了。所以， <code>phase1_ * phase1_.U()</code> 其实相当于  <code>alpha.phaseName * phase1_.U()</code> ，是两个 volScalarField 类对象之间的乘法运算。 </p>
<p>在 <code>twoPhaseEulerFoam</code>的代码里，类似的用法还有很多，这里不能一一举例，当看到某处费解的时候，不妨想想是否是上面提到的情形。</p>
<p>为了便于理解这个原理，我这里写了一个简单的 c++ 测试小程序<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        A(<span class="keyword">int</span> a);</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">A::A(<span class="keyword">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> A::print()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"base class:"</span>&lt;&lt;<span class="string">"a="</span>&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> B : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> b;</span><br><span class="line">        B(<span class="keyword">int</span> a, <span class="keyword">int</span> b);</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">B::B(<span class="keyword">int</span> a, <span class="keyword">int</span> b):A(a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> B::print()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Derived class:"</span>&lt;&lt;<span class="string">"a="</span>&lt;&lt;a&lt;&lt;<span class="string">",b="</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_test</span><span class="params">( A&amp; obja)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    obja.print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">operator</span>*(A&amp; a, A&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a.a * b.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">2</span>,b=<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">A <span class="title">obj1</span><span class="params">(a)</span></span>;</span><br><span class="line">    obj1.print();</span><br><span class="line"></span><br><span class="line">    <span class="function">B <span class="title">obj2</span><span class="params">(a+b,b)</span></span>;</span><br><span class="line">    obj2.print();</span><br><span class="line"></span><br><span class="line">    A&amp; obj3 = obj2;</span><br><span class="line">    obj3.print();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"obj3.a="</span>&lt;&lt;obj3.a&lt;&lt;endl;</span><br><span class="line">   <span class="comment">// cout&lt;&lt;"obj3.b="&lt;&lt;obj3.b&lt;&lt;endl; Error! class A has no member named 'b'.</span></span><br><span class="line"></span><br><span class="line">    print_test(obj1);</span><br><span class="line">    print_test(obj2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"obj1 * obj2 :"</span>&lt;&lt; obj1 * obj2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出如下：</p>
<pre><code>base <span class="class"><span class="keyword">class</span>:<span class="typename">a=2</span></span>
Derived <span class="class"><span class="keyword">class</span>:<span class="typename">a=6</span>,<span class="typename">b=4</span></span>
base <span class="class"><span class="keyword">class</span>:<span class="typename">a=6</span></span>
obj3.a=<span class="number">6</span>
base <span class="class"><span class="keyword">class</span>:<span class="typename">a=2</span></span>
base <span class="class"><span class="keyword">class</span>:<span class="typename">a=6</span></span>
obj1 * obj2 :<span class="number">12</span>
</code></pre><p>可以将上述程序中派生类对象赋值给基类的规律简单小结如下：</p>
<ul>
<li>当将基类的引用指向派生类的对象时，用该引用只能调用派生类从基类继承而来的成员。像上面程序中，obj3.a 输出的是 对象 obj2 的成员 a，但是 obj3 无法调用成员b。</li>
<li>当一个函数需要的参数是基类的引用时，可以直接将派生类的对象传递给该函数，像上面的 <code>print_test</code> 函数和重载的 <code>*</code> 运算符那样。此事相当于作了一个隐式的将派生类对象赋值给基类引用。  </li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>在读 OpenFOAM 代码过程中，有一类应用初看之下觉得很费解，比如 OpenFOAM-2.3.x 的 <code>twoPhaseEulerFoam</code>，createFields.H 有这么一段：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">phaseModel&amp; <span class="variable">phase1 =</span> fluid.phase1();</span><br><span class="line">phaseModel&amp; <span class="variable">phase2 =</span> fluid.phase2();</span><br><span class="line"></span><br><span class="line">volScalarField&amp; <span class="variable">alpha1 =</span> phase1;</span><br><span class="line">volScalarField&amp; <span class="variable">alpha2 =</span> phase2;</span><br></pre></td></tr></table></figure></p>
<p>乍看之下，感觉有点奇怪：怎么能将 phaseModel 类的引用直接赋值给 volScalarField 类的引用呢？后来查看了一下 phaseModel 类的定义，发现原来 phaseModel 类是 volScalarField 类的派生，由此上面代码就好理解了，无非是将派生类引用赋值给基类引用而已。</p>]]>
    
    </summary>
    
      <category term="C++" scheme="http://xiaopingqiu.github.io/tags/C/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/tags/OpenFOAM/"/>
    
      <category term="C++" scheme="http://xiaopingqiu.github.io/categories/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在 CentOS 上安装 OpenFOAM ]]></title>
    <link href="http://xiaopingqiu.github.io/2015/09/13/OpenFOAM-install-centOS/"/>
    <id>http://xiaopingqiu.github.io/2015/09/13/OpenFOAM-install-centOS/</id>
    <published>2015-09-13T05:23:06.000Z</published>
    <updated>2015-09-13T07:57:31.626Z</updated>
    <content type="html"><![CDATA[<p>本篇记录我在 CentOS 上编译安装 OpenFOAM 的过程。我需要在不能联网且没有 root 权限的集群上使用OpenFOAM ，最早的时候，我使用的是 <a href="http://sourceforge.net/projects/centfoam/" target="_blank" rel="external">centFOAM project</a> 提供的 64bit CentOS 安装包，这个很方便，把压缩包下载，解压，然后配置一下环境变量就可以了。但是后来 centFOAM 好像不再更新了，所以我只好尝试着自己编译。</p>
<p>由于集群上缺少一些 OpenFOAM 依赖的包，要是一个一个去下载源码编译以补齐那些依赖的包，实在很费劲，所以我采取了另一种尝试：在虚拟机里安装跟集群上一样的系统，然后在虚拟机里编译好 OpenFOAM ，再拷贝到集群上去用（据信 cenoFOAM project 提供的安装包也是在虚拟机编译好的，而且在 cfd-online 论坛上也见有人推荐这么做）。我尝试过在 CentOS 5.4 ，CentOS 6.3 以及 Scientific Linux 6.5 上安装过 OpenFOAM-2.3.x，都成功了，过程大同小异。下面是我的安装过程的一个简要记录。</p>
<a id="more"></a>
<h3 id="1_CentOS_6-3">1 CentOS 6.3</h3><p>首先，你需要一个虚拟机软件，我使用的是 VirtualBox，然后在虚拟机里安装一个64 bit 的CentOS 6.3（镜像可以去<a href="http://vault.centos.org/" target="_blank" rel="external">官网</a>下载）。注意，要想在 VirtualBox安装 64 bit的虚拟机，你的主系统也必须是 64 bit，而且，还要求你的 CPU 支持并开启了虚拟化技术，见<a href="http://rickie622.blog.163.com/blog/static/2123881120113473224536/" target="_blank" rel="external">这个链接</a>。然后，安装虚拟机的过程中，CentOS 6.3 会让你选择以哪种方式安装系统，我选择的是 “Software Development Workstation”，因为这种方式安装的包最全。以下是我在虚拟机里编译安装 OpenFOAM-2.3.x 的过程。</p>
<h4 id="1-0_补充一些依赖包">1.0 补充一些依赖包</h4><p>确保你的虚拟机可以联网，然后运行以下命令补充一些包：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yum groupinstall 'Development Tools</span><br><span class="line"></span><br><span class="line">yum <span class="keyword">install</span> glibc-devel.i686</span><br><span class="line"></span><br><span class="line">yum <span class="keyword">install</span> zlib.x86_64</span><br><span class="line">yum <span class="keyword">install</span> zlib-devel.x86_64</span><br></pre></td></tr></table></figure></p>
<h4 id="1-1_下载需要的源码包。">1.1 下载需要的源码包。</h4><p>需要的源码包包括：OpenFOAM-2.3.x ，ThirdParty-2.3.x，这两个可以在OpenFOAM的官网找到，其中 OpenFOAM-2.3.x 可以用 git 从<a href="https://github.com/OpenFOAM/OpenFOAM-2.3.x" target="_blank" rel="external">这里</a>克隆一份；gcc-4.8.2, mpfr-3.1.2, gmp-5.1.2, mpc-1.0.1, boost-1.55.0, 这些可以OpenFOAM的 github 仓库里<a href="https://github.com/OpenFOAM/ThirdParty-2.3.x" target="_blank" rel="external">找到链接</a>。因为有移植到集群上的需要，所以我这里需要自己编译gcc 和openmpi，这样，就不需要依赖集群系统上的 gcc 和 openmpi 了。</p>
<h4 id="1-2_将源码包解压到合适的位置">1.2 将源码包解压到合适的位置</h4><p>建议在虚拟里，创建一个普通用户（假设为 user），不要用root用户来编译，以下操作都假定是以user用户的身份在进行。在 $HOME 下创建一个目录 OpenFOAM，然后将OpenFOAM-2.3.x 以及 ThirdParty-2.3.x 拷贝到该目录下（如果需要的话，先解压）。然后，解压 gcc-4.8.2，mpfr-3.1.2, gmp-5.1.2, mpc-1.0.1, boost-1.55.0, 并拷贝到 <code>$HOME/ThirdParty-2.3.x</code> 下，并将 boost-1.55.0 重命名为 boost-system。</p>
<h4 id="1-3_编译前的配置和检查">1.3 编译前的配置和检查</h4><p>打开<code>$HOME/OpenFOAM/OpenFOAM-2.3.x/etc/config/settings.sh</code> 文件，跳到<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">case <span class="string">"<span class="subst">$&#123;foamCompiler&#125;</span>"</span> <span class="keyword">in</span></span><br><span class="line">OpenFOAM | ThirdParty)</span><br><span class="line">    case <span class="string">"$WM_COMPILER"</span> <span class="keyword">in</span></span><br><span class="line">    Gcc | Gcc++<span class="number">0</span>x | Gcc48 | Gcc48++<span class="number">0</span>x)</span><br><span class="line">        <span class="variable">gcc_version=</span>gcc-<span class="number">4.8</span>.<span class="number">2</span></span><br><span class="line">        <span class="variable">gmp_version=</span>gmp-<span class="number">5.1</span>.<span class="number">2</span></span><br><span class="line">        <span class="variable">mpfr_version=</span>mpfr-<span class="number">3.1</span>.<span class="number">2</span></span><br><span class="line">        <span class="variable">mpc_version=</span>mpc-<span class="number">1.0</span>.<span class="number">1</span></span><br><span class="line">        ;;</span><br></pre></td></tr></table></figure></p>
<p>检查一下你下载的软件包版本跟这里的设置是否一样，如果不一致，可以直接修改这个文件以使这里的设置和你下载的版本一致。<br>此外，还需要跳到<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">OPENMPI)</span><br><span class="line">    <span class="built_in">export</span> FOAM_MPI=openmpi-<span class="number">1.6</span>.<span class="number">5</span></span><br><span class="line">    <span class="comment"># optional configuration tweaks:</span></span><br><span class="line">    _foamSource `<span class="variable">$WM_PROJECT_DIR</span>/bin/foamEtcFile config/openmpi.sh`</span><br><span class="line"></span><br><span class="line">    <span class="built_in">export</span> MPI_ARCH_PATH=<span class="variable">$WM_THIRD_PARTY_DIR</span>/platforms/<span class="variable">$WM_ARCH</span><span class="variable">$WM_COMPILER</span>/<span class="variable">$FOAM_MPI</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Tell OpenMPI where to find its install directory</span></span><br><span class="line">    <span class="built_in">export</span> OPAL_PREFIX=<span class="variable">$MPI_ARCH_PATH</span></span><br><span class="line"></span><br><span class="line">    _foamAddPath    <span class="variable">$MPI_ARCH_PATH</span>/bin</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 64-bit on OpenSuSE 12.1 uses lib64 others use lib</span></span><br><span class="line">    _foamAddLib     <span class="variable">$MPI_ARCH_PATH</span>/lib<span class="variable">$WM_COMPILER_LIB_ARCH</span></span><br><span class="line">    _foamAddLib     <span class="variable">$MPI_ARCH_PATH</span>/lib</span><br><span class="line"></span><br><span class="line">    _foamAddMan     <span class="variable">$MPI_ARCH_PATH</span>/share/man</span><br><span class="line">    ;;</span><br></pre></td></tr></table></figure></p>
<p>看看你的 ThirdParty-2.3.x 下的 openmpi 的版本是否跟这里的一样（上面的设置是 openmpi-1.6.5），如果不一样，也需要修改这个文件。</p>
<p>然后，打开<code>$HOME/OpenFOAM/OpenFOAM-2.3.x/etc/bashrc</code> 文件，设置<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foamCompiler=ThirdParty</span><br><span class="line"><span class="keyword">export</span> WM_<span class="built_in">MPLIB</span>=OPEN<span class="built_in">MPI</span></span><br></pre></td></tr></table></figure></p>
<p>接着，打开<code>~/.bashrc</code> 文件，在最后一行输入”source $HOME/OpenFOAM/OpenFOAM-2.3.x/etc/bashrc”，保存后，在终端里运行一下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure></p>
<p>来加载跟OpenFOAM相关的环境变量。</p>
<p>最后，还需要检查一下 ThirdParty-2.3.x 目录下的那些编译辅助脚本，看看设置是否正确。需要检查的脚本有 <code>makeGcc</code>， <code>makeCGAL</code>， <code>makeCmake</code>，主要的检查项目仍然是看脚本里设置的软件包版本和实际下载的是否一致。比如，打开脚本 <code>makeGcc</code> ，有这么一段配置<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="setting">gmpPACKAGE=<span class="value">gmp-<span class="number">5.1</span>.<span class="number">2</span></span></span></span><br><span class="line"><span class="setting">mpfrPACKAGE=<span class="value">mpfr-<span class="number">3.1</span>.<span class="number">2</span></span></span></span><br><span class="line"><span class="setting">mpcPACKAGE=<span class="value">mpc-<span class="number">1.0</span>.<span class="number">1</span></span></span></span><br><span class="line"><span class="setting">gccPACKAGE=<span class="value">gcc-<span class="number">4.8</span>.<span class="number">2</span></span></span></span><br></pre></td></tr></table></figure></p>
<p>需要保证这里的设置与 ThirdParty-2.3.x 目录下实际的源码包的版本一致。</p>
<h4 id="1-4_编译过程">1.4 编译过程</h4><p>上面的配置完成以后，就可以开始编译了。按如下顺序进行编译：</p>
<ul>
<li>gcc<br>运行 ThirdParty-2.3.x 下的脚本 <code>makeGcc</code> 即可。<br>这一步完成以后，在终端里输入 <code>gcc -v</code> ，看看返回的版本是否是下载的那个版本。如若不然，重新运行一下 <code>source ~/.bashrc</code> ，再看看 gcc 的版本是否正常。要是不对的话，那就得检查一下 gcc 的编译过程是否出错了。gcc 的编译成功是前提，要是这一步没有成功，下面的也就无法进行了。 </li>
<li>CGAL<br>运行 <code>makeCGAL</code> 即可，boost 和 CGAL 的编译包括在这一步。<br>完成以后，也同样需要检查一下是否编译成功。检查的办法是，看看 <code>ThirdParty-2.3.x/platforms/linux64Gcc</code> 下是否有 <code>CGAL-4.3</code> 和 <code>boost-system</code>，然后看看这两个目录下是否都有 <code>lib</code> 和 <code>bin</code> 目录。如果没有，那就是编译出问题了，需要检查一下。 </li>
<li>Cmake<br>运行 makeCmake<br>同样的，编译完以后需要检查是否成功。</li>
<li>ThirdParty的其他包<br>运行 ThirdParty-2.3.x 下面的 <code>Allwmake</code> ，这一步包括了openmpi 以及 Scotch 的编译。<br>正常的话，这一步编译完以后，应该就可以有 <code>mpirun</code> 以及  <code>mpicc</code> 等命令了。请运行 <code>which mpirun</code> 来检查编译是否成功。  </li>
<li>编译OpenFOAM-2.3.x<br>到 <code>$HOME/OpenFOAM/OpenFOAM-2.3.x</code> 下去运行 <code>Allwmake</code>，进行 OpenFOAM 的编译。  </li>
</ul>
<p>建议将编译过程的输出保留下来，万一编译失败，可以根据编译过程的报错来找原因。比如，上面说的 “运行 makeGcc” ，在终端里可以这样操作<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./makeGcc &gt; <span class="built_in">log</span>_gcc <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp;</span><br></pre></td></tr></table></figure></p>
<p>这样，便会将编译 gcc 过程中的正常输出信息和报错信息都输出到文件 “log_gcc” 里面。此外，后来我发现，其实运行 ThirdParty-2.3.x 下面的 <code>Allwmake</code> 时，其实也包括了”CGAL”的编译，所以其实 <code>makeCGAL</code> 不需要单独拿出来作为一步。</p>
<h4 id="1-5_测试">1.5 测试</h4><p>编译结束以后，需要测试一下编译是否成功。建议至少运行一个串行算例，一个并行算例来检验 OpenFOAM 编译是否成功。最简单的是将 interFoam 求解器的 dambreak 算例串行运行一次，并行运行一次。</p>
<h4 id="1-6_移植到集群">1.6 移植到集群</h4><p>如果上述编译一切正常，那就可以考虑将编译好的OpenFOAM移植到集群了。移植之前，为了减少需要拷贝的文件的数量，可以将一些不需要的源码和编译过程产生的中间文件删除。比如，ThirdParty-2.3.x 目录下的 gcc， mpfr，gmp，mpc以及 boost 的源码包都删除（openmpi-1.6.5 的源码建议保留），因为有用的是文件其实都在 platforms 目录下，只要保证这个目录完好就可以了。然后，建议将 <code>$HOME/OpenFOAM</code> 整个目录打包，再拷贝到集群上去。打包的目的有两个，一是减小文件的空间占用，另外一个更重要的原因是，OpenFOAM 的编译过程中会产生很多重要的软链接，如果不打包，这些软链接容易在拷贝的过程中损坏（比如，假如你用U盘拷贝 OpenFOAM 这个目录，那软链接几乎肯定会损坏）。 </p>
<p>将压缩包拷贝到集群，在你的 $HOME 下解压。建议你在集群上也创建跟在虚拟上一样的目录结构，即在<code>$HOME</code>下创建目录 <code>OpenFOAM</code>，然后将 OpenFOAM-2.3.x 和 ThirdParty-2.3.x 拷贝到<code>OpenFOAM</code>目录下，这样，就不再需要去修改OpenFOAM的安装路径这个环境变量了。万一你没法做到这一点，那么，你需要修改 <code>OpenFOAM-2.3.x/etc/bashrc</code> 文件，将 <code>foamInstall=$HOME/$WM_PROJECT</code> 修改成你的实际路径（这里 <code>$HOME/$WM_PROJECT=$HOME/OpenFOAM</code>）。</p>
<p>然后，类似的，打开<code>~/.bashrc</code> 文件，在最后一行输入”source $HOME/OpenFOAM/OpenFOAM-2.3.x/etc/bashrc”，保存后，在终端里运行一下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure></p>
<p>一切正常的话，移植工作就完成了。</p>
<p>当然，也需要测试一下移植是否成功，同样可以通过运行 dambreak算例来测试。我曾经遇到的问题是，串行可以运行，但是并行出问题了。对于这种情况，解决办法是，到 <code>OpenFOAM/OpenFOAM-2.3.x/src/Pstream</code> 目录下， <code>dummy</code> 和 <code>mpi</code> 下运行  <code>wclean</code>，然后，运行 <code>Pstream</code> 下面的  <code>Allwmake</code> ，重新编译 <code>dummy</code> 和 <code>mpi</code> 。如果这样编译了仍然不能并行，那么还可以再试试重新编译openmpi，具体做法是，删除 <code>ThirdParty-2.3.x/platforms/linux64GccDPOpt/lib/openmpi-1.6.5</code> 以及 <code>ThirdParty-2.3.x/platforms/linux64Gcc/openmpi-1.6.5</code>，然后重新运行ThirdParty-2.3.x 下的  <code>Allwmake</code>，编译完以后在重新编译一下 <code>dummy</code> 和 <code>mpi</code>。一般情况下，可以编译成功，因为编译需要的东西其实都在 ThirdParty-2.3.x 下面包含了，不需要依赖系统的什么包，这也是自己上面自己手动编译 gcc 等这些包带来的好处。这样处理以后，就可以正常并行运行了。</p>
<h3 id="2-_CentOS_5-4">2. CentOS 5.4</h3><p>CentOS 5.4 上的编译和移植过程几乎和上面是一样的，只有几个细节不同，比如，安装依赖包的时候，<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="keyword">install</span> glibc-devel.i686</span><br></pre></td></tr></table></figure></p>
<p>应该是<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="keyword">install</span> glibc-devel.i386</span><br></pre></td></tr></table></figure></p>
<p>其他的差别，在我印象中是没有了。</p>
<p>最后，有必要提一下一个诡异的失败经历，这个问题我至今也不知道是什么原因导致的。<br>有一次在移植到集群的时候，重新编以 openmpi 的过程中遇到如下报错：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CDPATH=<span class="string">"$&#123;ZSH_VERSION+.&#125;:"</span> &amp;&amp; cd . &amp;&amp; <span class="regexp">/bin/</span>sh <span class="regexp">/storage02.mnt/</span>home<span class="regexp">/lmu/</span>OpenFOAM<span class="regexp">/ThirdParty-2.3.x/</span>openmpi-<span class="number">1.6</span>.<span class="number">5</span><span class="regexp">/config/mi</span>ssing --run aclocal-<span class="number">1.11</span> -I config</span><br></pre></td></tr></table></figure></p>
<p>导致 openmpi 无法编译。<br>但是，将OpenFOAM拷贝到另一个目录（不再是 <code>$HOME/OpenFOAM</code> ），再重新尝试，却成功了。</p>
<p>另一次，是在 Scientific Linux 上，也是重新编译 openmpi 的时候遇到了一样的报错，后来解决的办法是，弃用ThirdParty下的 openmpi，改启用系统的openmpi（虽然版本老一点），具体设置是将” export WM_MPLIB=OPENMPI” 改为 “ export WM_MPLIB=SYSTEMOPENMPI”，改完以后也能成功并行运行。</p>
<p>本篇博文，由于是写在我编译 OpenFOAM 好几个月之后，当时也没有详细记录编译过程，所以肯定有细节遗漏或者错误的地方。而且，在不同的系统上，也可能遇到我这里没有提到的问题，本篇博文仅仅是给有需要的人做一个参考。要是你编译过程中遇到某个问题在看了本文后得到了解决，那我的目的就达到了。有问题 ，欢迎来OpenFOAM开源计算千人群讨论交流。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本篇记录我在 CentOS 上编译安装 OpenFOAM 的过程。我需要在不能联网且没有 root 权限的集群上使用OpenFOAM ，最早的时候，我使用的是 <a href="http://sourceforge.net/projects/centfoam/">centFOAM project</a> 提供的 64bit CentOS 安装包，这个很方便，把压缩包下载，解压，然后配置一下环境变量就可以了。但是后来 centFOAM 好像不再更新了，所以我只好尝试着自己编译。</p>
<p>由于集群上缺少一些 OpenFOAM 依赖的包，要是一个一个去下载源码编译以补齐那些依赖的包，实在很费劲，所以我采取了另一种尝试：在虚拟机里安装跟集群上一样的系统，然后在虚拟机里编译好 OpenFOAM ，再拷贝到集群上去用（据信 cenoFOAM project 提供的安装包也是在虚拟机编译好的，而且在 cfd-online 论坛上也见有人推荐这么做）。我尝试过在 CentOS 5.4 ，CentOS 6.3 以及 Scientific Linux 6.5 上安装过 OpenFOAM-2.3.x，都成功了，过程大同小异。下面是我的安装过程的一个简要记录。</p>]]>
    
    </summary>
    
      <category term="CentOS" scheme="http://xiaopingqiu.github.io/tags/CentOS/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/tags/OpenFOAM/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenFOAM-2.3.x 中的 twoPhaseEulerFoam 解析之曳力模型的调用过程]]></title>
    <link href="http://xiaopingqiu.github.io/2015/09/07/twoPhaseEulerFoam23x-twoPhaseSystem/"/>
    <id>http://xiaopingqiu.github.io/2015/09/07/twoPhaseEulerFoam23x-twoPhaseSystem/</id>
    <published>2015-09-07T14:27:47.000Z</published>
    <updated>2015-09-25T09:06:26.746Z</updated>
    <content type="html"><![CDATA[<p>前面有三篇博文对 OpenFOAM-2.1.x 中的 <code>twoPhaseEulerFoam</code> 求解器进行了解读，然而 OpenFOAM-2.3.x 中，这个求解器的代码有了很大的变化。本文将以一个曳力模型的调用过程为例，介绍 OpenFOAM-2.3.x 中 <code>twoPhaseEulerFoam</code> 是如何调用相间作用力模型的。后续还将对 OpenFOAM-2.3.x 中的 <code>twoPhaseEulerFoam</code> 的其他方面进行解读。</p>
<a id="more"></a>
<p>主程序中(“ UEqn.H “)，dragCoeff 定义为：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volScalarField dragCoeff<span class="list">(<span class="keyword">fluid</span>.dragCoeff<span class="list">()</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>其中，<code>fluid</code> 为 <code>twoPhaseSystem</code> 类的对象，所以，要去找  <code>twoPhaseSystem</code> 类的成员函数 <code>dragCoeff()</code>。<br>在源文件 <code>twoPhaseSystem.C</code> 中找到如下定义：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="constant">Foam:</span><span class="symbol">:tmp&lt;Foam</span><span class="symbol">:</span><span class="symbol">:volScalarField&gt;</span> <span class="constant">Foam:</span><span class="symbol">:twoPhaseSystem</span><span class="symbol">:</span><span class="symbol">:dragCoeff</span>() const</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> drag<span class="constant">_</span>-&gt;<span class="constant">K(</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而  <code>drag_</code> 的定义为<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">autoPtr<span class="tag">&lt;<span class="title">BlendedInterfacialModel</span>&lt;<span class="attribute">dragModel</span>&gt;</span> &gt; drag_;</span></span><br></pre></td></tr></table></figure></p>
<p>所以，需要找到类 <code>BlendedInterfacialModel&lt;dragModel&gt;</code> 的成员函数 <code>K()</code>的定义。<br>在源文件 <code>BlendedInterfacialModel.C</code> 中，找到如下定义：<br><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">template&lt;<span class="keyword">class</span> modelType&gt;</span><br><span class="line"><span class="type">Foam</span>::tmp&lt;<span class="type">Foam</span>::volScalarField&gt;</span><br><span class="line"><span class="type">Foam</span>::<span class="type">BlendedInterfacialModel</span>&lt;modelType&gt;::<span class="type">K</span><span class="literal">()</span> const</span><br><span class="line">&#123;</span><br><span class="line">    tmp&lt;volScalarField&gt; f1, f2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (model_.valid<span class="literal">()</span> || model1In2_.valid<span class="literal">()</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        f1 = blending_.f1(pair1In2_.dispersed<span class="literal">()</span>, pair2In1_.dispersed<span class="literal">()</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (model_.valid<span class="literal">()</span> || model2In1_.valid<span class="literal">()</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        f2 = blending_.f2(pair1In2_.dispersed<span class="literal">()</span>, pair2In1_.dispersed<span class="literal">()</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tmp&lt;volScalarField&gt; x</span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">new</span> volScalarField</span><br><span class="line">        (</span><br><span class="line">            <span class="type">IOobject</span></span><br><span class="line">            (</span><br><span class="line">                modelType::typeName + <span class="string">"Coeff"</span>,</span><br><span class="line">                pair_.phase1<span class="literal">()</span>.mesh<span class="literal">()</span>.time<span class="literal">()</span>.timeName<span class="literal">()</span>,</span><br><span class="line">                pair_.phase1<span class="literal">()</span>.mesh<span class="literal">()</span></span><br><span class="line">            ),</span><br><span class="line">            pair_.phase1<span class="literal">()</span>.mesh<span class="literal">()</span>,</span><br><span class="line">            dimensionedScalar(<span class="string">"zero"</span>, modelType::dimK, <span class="number">0</span>)</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (model_.valid<span class="literal">()</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x<span class="literal">()</span> += model_-&gt;<span class="type">K</span><span class="literal">()</span>*(f1<span class="literal">()</span> - f2<span class="literal">()</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (model1In2_.valid<span class="literal">()</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x<span class="literal">()</span> += model1In2_-&gt;<span class="type">K</span><span class="literal">()</span>*(<span class="number">1</span> - f1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (model2In1_.valid<span class="literal">()</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x<span class="literal">()</span> += model2In1_-&gt;<span class="type">K</span><span class="literal">()</span>*f2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (model_.valid<span class="literal">()</span> || model1In2_.valid<span class="literal">()</span> || model2In1_.valid<span class="literal">()</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        correctFixedFluxBCs(x<span class="literal">()</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于曳力模型，上述成员函数的  <code>modelType</code> 可以实例化为 <code>dragModel</code>，要理解该函数的行为，有三点需要清楚： <code>pair_</code>，  <code>pair1In2_</code>， <code>pair2In1_</code> 的定义； <code>model_</code>， <code>model1In2_</code>，  <code>model2In1_</code> 的定义； <code>blendingMethod</code> 类的成员函数  <code>f1</code> 与 <code>f2</code> 的定义。下面一一解释：</p>
<h4 id="1-_pair_，_pair1In2_，_pair2In1__的定义">1.  <code>pair_</code>，  <code>pair1In2_</code>， <code>pair2In1_</code> 的定义</h4><p>这三个是 <code>BlendedInterfacialModel</code> 类的数据成员，回到 <code>twoPhaseSystem</code> 类中去看 <code>drag_</code> 的初始化，<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">drag_.<span class="keyword">set</span></span><br><span class="line">   (</span><br><span class="line">       <span class="keyword">new</span> BlendedInterfacialModel&lt;dragModel&gt;</span><br><span class="line">       (</span><br><span class="line">           lookup(<span class="string">"drag"</span>),</span><br><span class="line">           (</span><br><span class="line">               blendingMethods_.found(<span class="string">"drag"</span>)</span><br><span class="line">             ? blendingMethods_[<span class="string">"drag"</span>]</span><br><span class="line">             : blendingMethods_[<span class="string">"default"</span>]</span><br><span class="line">           ),</span><br><span class="line">           pair_,</span><br><span class="line">           pair1In2_,</span><br><span class="line">           pair2In1_</span><br><span class="line">       )</span><br><span class="line">   );</span><br></pre></td></tr></table></figure></p>
<p>可知，<code>BlendedInterfacialModel</code> 类中的 <code>pair_</code>，  <code>pair1In2_</code>， <code>pair2In1_</code> 是将 <code>twoPhaseSystem</code> 类的数据成员传递过去来实现初始化的，所以，真正要看懂的是<code>twoPhaseSystem</code>类中数据成员<code>pair_</code>，  <code>pair1In2_</code>， <code>pair2In1_</code> 的初始化，见如下代码：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">pair_.<span class="keyword">set</span></span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">new</span> phasePair</span><br><span class="line">        (</span><br><span class="line">            phase1_,</span><br><span class="line">            phase2_,</span><br><span class="line">            g,</span><br><span class="line">            sigmaTable</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">    pair1In2_.<span class="keyword">set</span></span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">new</span> orderedPhasePair</span><br><span class="line">        (</span><br><span class="line">            phase1_,</span><br><span class="line">            phase2_,</span><br><span class="line">            g,</span><br><span class="line">            sigmaTable,</span><br><span class="line">            aspectRatioTable</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">    pair2In1_.<span class="keyword">set</span></span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">new</span> orderedPhasePair</span><br><span class="line">        (</span><br><span class="line">            phase2_,</span><br><span class="line">            phase1_,</span><br><span class="line">            g,</span><br><span class="line">            sigmaTable,</span><br><span class="line">            aspectRatioTable</span><br><span class="line">        )</span><br><span class="line">    );</span><br></pre></td></tr></table></figure></p>
<p>可见，<code>pair_</code> 是  <code>phasePair</code> 类的指针，  <code>pair1In2_</code> 与 <code>pair2In1_</code> 是  <code>orderedPhasePair</code> 类的指针。<br>其中<code>phase1_</code> 和  <code>phase2_</code> 是通过从文件”phaseProperties”里读取内容来初始化的：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">phase1_</span><br><span class="line">    (</span><br><span class="line"><span class="comment">        *this, </span></span><br><span class="line"><span class="comment">        *this,</span></span><br><span class="line">        wordList(<span class="keyword">lookup</span>(<span class="string">"phases"</span>))[0]</span><br><span class="line">    ),</span><br><span class="line">    phase2_</span><br><span class="line">    (</span><br><span class="line"><span class="comment">        *this,</span></span><br><span class="line"><span class="comment">        *this,</span></span><br><span class="line">        wordList(<span class="keyword">lookup</span>(<span class="string">"phases"</span>))[1]</span><br><span class="line">    ),</span><br></pre></td></tr></table></figure></p>
<p>举例说，假设”phaseProperties” 文件里有以下内容：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">phases <span class="list">(<span class="keyword">particles</span> air)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>则， <code>phase1_</code> = “particles”， <code>phase2_</code> = “air” 。</p>
<p>根据 <code>phasePair</code> 类中的定义，成员函数 <code>dispersed()</code> 总是返回对象的<code>phase1</code>（也就是 <code>phasePair</code> 或者  <code>orderedPhasePair</code> 类的构造函数的第一个参数），所以，对于 “particles air” 体系，<code>pair1In2_.dispersed() = phase1_.name() = &quot;particles&quot;</code>， 而 <code>pair2In1_.dispersed() = phase2_.name() = &quot;air&quot;</code>。</p>
<h4 id="2-_model_，_model1In2_，_model2In1__的定义">2. <code>model_</code>， <code>model1In2_</code>，  <code>model2In1_</code> 的定义</h4><p>这三个是 <code>BlendedInterfacialModel</code> 类的数据成员，定义和初始化如下：<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">autoPtr&lt;modelType&gt; model_;</span><br><span class="line">autoPtr&lt;modelType&gt; model<span class="number">1</span>I<span class="label">n2</span>_;</span><br><span class="line">autoPtr&lt;modelType&gt; model<span class="number">2</span>I<span class="label">n1</span>_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="comment">(modelTable.found(pair_)</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        model_.set</span><br><span class="line">        <span class="comment">(</span><br><span class="line">            modelType::New</span><br><span class="line">            (</span><br><span class="line">                modelTable[pair_],</span><br><span class="line">                pair_</span><br><span class="line">            )</span>.ptr<span class="comment">()</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="comment">(modelTable.found(pair1In2_)</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        model<span class="number">1</span>I<span class="label">n2</span>_.set</span><br><span class="line">        <span class="comment">(</span><br><span class="line">            modelType::New</span><br><span class="line">            (</span><br><span class="line">                modelTable[pair1In2_],</span><br><span class="line">                pair1In2_</span><br><span class="line">            )</span>.ptr<span class="comment">()</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="comment">(modelTable.found(pair2In1_)</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        model<span class="number">2</span>I<span class="label">n1</span>_.set</span><br><span class="line">        <span class="comment">(</span><br><span class="line">            modelType::New</span><br><span class="line">            (</span><br><span class="line">                modelTable[pair2In1_],</span><br><span class="line">                pair2In1_</span><br><span class="line">            )</span>.ptr<span class="comment">()</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，这里讨论的是曳力模型的调用，所以，如前所述，<code>modelType</code> 可以实例化为 <code>dragModel</code>。<br><code>modelTable</code> 是 <code>phasePair::dictTable</code> 类型的引用，本质上是一个 HashTable（ <code>HashTable&lt;dictionary, phasePairKey, phasePairKey::hash&gt;</code> ），其 key 是 <code>phasePairKey</code> 类型的对象，value 是 <code>dictionary</code> 类的对象。 <code>found</code> 函数通过查找 <code>modelTable</code> 对象中是否存在某个 key 来决定返回值是 true 还是 false。</p>
<p>这里要分头说，一边是 <code>modelTable</code> 的初始化，另一边是 <code>pair_</code>， <code>pair2In1_</code>， <code>pair2In1_</code>  如何与 <code>phasePairKey</code> 类进行对比。</p>
<p>从 <code>twoPhaseSystem</code> 类中对 <code>drag_</code> 的初始化可知， <code>modelTable</code> 的初始化是由 <code>lookup(&quot;drag&quot;)</code> 来完成的。<code>lookup</code> 函数的作用是读取”phaseProperties” 文件的内容来实现对一个 HashTable 的初始化（具体过程将会在后续解读中涉及）。举例说，以下 “phaseProperties” 的内容<br><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">drag</span><br><span class="line">(</span><br><span class="line">    (particles <span class="keyword">in</span> air)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">type</span>            <span class="title">GidaspowErgunWenYu</span>;</span></span><br><span class="line">        residualAlpha   <span class="number">1e-6</span>;</span><br><span class="line">        residualRe      <span class="number">1e-3</span>;</span><br><span class="line">        swarmCorrection</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="class"><span class="keyword">type</span>        <span class="title">none</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>将利用 <code>(particles in air)</code> 来初始化一个 <code>phasePairKey</code> 对象（利用 <code>phasePairKey</code>类中的空白构造函数和重载的 <code>&gt;&gt;</code> 符号）。成员<code>ordeded_</code> 的值取决于 “in” 或 “and” ，若形如 “particles in air “，<code>ordeded_ = true</code>，若形如 “particles and air “， 则 <code>ordeded_ = false</code>。 则剩余内容将用于初始化一个 <code>dictionary</code> 对象。</p>
<p>而另一方面，<code>phasePair</code> 是 <code>phasePairKey</code>的派生类， <code>orderedPhasePair</code> 则是<code>phasePair</code> 的派生类，所以，将 <code>pair_</code> ，<code>pair1In2_</code> 以及 <code>pair2In1_</code> 作为 <code>found</code> 函数的参数，隐含了将派生类的引用转换成基类引用。 <code>phasePair</code>类默认 <code>ordered_ = false</code>， 而 <code>orderedPhasePair</code> 类则默认<code>ordered_ = true</code>。<code>pair_</code> ，<code>pair1In2_</code> 以及 <code>pair2In1_</code> 与 <code>modelTable_</code> 的 key 进行比较，比较的是对应的 <code>phase1</code>，<code>phase2</code> 和 <code>ordered_</code> 三个成员的值是否相等，只有三者都一样时， <code>found</code> 函数才返回 <code>true</code> 。   所以，对于上面提到的设置，即<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">phases <span class="list">(<span class="keyword">particles</span> air)</span><span class="comment">;</span></span><br><span class="line">drag</span><br><span class="line"><span class="list">(</span><br><span class="line">    <span class="list">(<span class="keyword">particles</span> in air)</span></span><br><span class="line">    .......</span><br><span class="line">)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>只有<code>modelTable.found(pair1In2_)</code>的值为<code>true</code>。同样，也就只有 <code>model1In2_.valid()</code> 为 <code>true</code> （即 <code>model1In2_</code> 指针不为空。）  </p>
<h4 id="3-_blendingMethod_类的成员函数_f1_与_f2">3. <code>blendingMethod</code> 类的成员函数  <code>f1</code> 与 <code>f2</code></h4><p>这两个函数的实现在不同的 <code>blendingMethods</code>中不一样，以最简单的 <code>noBlending</code> 类型为例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">Foam::tmp&lt;Foam::volScalarField&gt; Foam::blendingMethods::noBlending::f1</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> phaseModel&amp; phase1,</span><br><span class="line">    <span class="keyword">const</span> phaseModel&amp; phase2</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> fvMesh&amp; mesh(phase1.mesh());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        tmp&lt;volScalarField&gt;</span><br><span class="line">        (</span><br><span class="line">            <span class="keyword">new</span> volScalarField</span><br><span class="line">            (</span><br><span class="line">                IOobject</span><br><span class="line">                (</span><br><span class="line">                    <span class="string">"f"</span>,</span><br><span class="line">                    mesh.time().timeName(),</span><br><span class="line">                    mesh</span><br><span class="line">                ),</span><br><span class="line">                mesh,</span><br><span class="line">                dimensionedScalar</span><br><span class="line">                (</span><br><span class="line">                    <span class="string">"f"</span>,</span><br><span class="line">                    dimless,</span><br><span class="line">                    phase2.name() != continuousPhase_</span><br><span class="line">                ) <span class="comment">// 如果 phase2 就是 continuousPhase，那么 f1 = 0；否则 f1 = 1</span></span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foam::tmp&lt;Foam::volScalarField&gt; Foam::blendingMethods::noBlending::f2</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> phaseModel&amp; phase1,</span><br><span class="line">    <span class="keyword">const</span> phaseModel&amp; phase2</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> fvMesh&amp; mesh(phase1.mesh());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        tmp&lt;volScalarField&gt;</span><br><span class="line">        (</span><br><span class="line">            <span class="keyword">new</span> volScalarField</span><br><span class="line">            (</span><br><span class="line">                IOobject</span><br><span class="line">                (</span><br><span class="line">                    <span class="string">"f"</span>,</span><br><span class="line">                    mesh.time().timeName(),</span><br><span class="line">                    mesh</span><br><span class="line">                ),</span><br><span class="line">                mesh,</span><br><span class="line">                dimensionedScalar</span><br><span class="line">                (</span><br><span class="line">                    <span class="string">"f"</span>,</span><br><span class="line">                    dimless,</span><br><span class="line">                    phase1.name() == continuousPhase_</span><br><span class="line">                ) <span class="comment">// 如果 phase1 是 continuousPhase，那么 f2 = 1，否则 f2 = 0。</span></span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再回头看 <code>BlendedInterfacialModel</code> 类的成员函数 <code>K()</code>，<br><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (model_.valid<span class="literal">()</span> || model1In2_.valid<span class="literal">()</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       f1 = blending_.f1(pair1In2_.dispersed<span class="literal">()</span>, pair2In1_.dispersed<span class="literal">()</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (model_.valid<span class="literal">()</span> || model2In1_.valid<span class="literal">()</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       f2 = blending_.f2(pair1In2_.dispersed<span class="literal">()</span>, pair2In1_.dispersed<span class="literal">()</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>根据上面的 “phaseProperties” 的设置，可知 <code>pair1In2_.dispersed() = &quot;particles&quot;</code>，  <code>pair2In1_.dispersed() = &quot;air&quot;</code>，而  <code>continuousPhase_</code> 是从 “phaseProperties” 的 “blending” 子字典里读取的，这里<code>continuousPhase_ = &quot;air&quot;</code>，于是，可以得到 <code>f1 = 0</code>， <code>f2 = 1</code>。再看 <code>K()</code> 的返回值，可知，最终有效的返回值是<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="comment">(model1In2_.valid()</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       x<span class="comment">()</span> += model<span class="number">1</span>I<span class="label">n2</span>_-&gt;K<span class="comment">()</span>*<span class="comment">(1 - f1)</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>即，最终 <code>K()</code> 函数的返回值是 <code>model1In2_-&gt;K()</code> 。而<code>model1In2_-&gt;K()</code>的值就取决于具体调用的曳力模型了，举例说，假如调用的是 Ergun 曳力模型，则 <code>K()</code> 最终返回的值，也就是 “UEqn.H” 中的 <code>dragCoeff</code> 的值是<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="rule"><span class="attribute">Foam</span>:<span class="value">:tmp&lt;Foam::volScalarField&gt; Foam::dragModel::<span class="function">K</span>() const</span><br><span class="line">&#123;</span><br><span class="line">    return</span><br><span class="line">        <span class="number">0.75</span></span><br><span class="line">       *<span class="function">CdRe</span>()</span><br><span class="line">       *<span class="function">max</span>(pair_.<span class="function">dispersed</span>(), residualAlpha_)</span><br><span class="line">       *swarmCorrection_-&gt;<span class="function">Cs</span>()</span><br><span class="line">       *pair_.<span class="function">continuous</span>().<span class="function">rho</span>()</span><br><span class="line">       *pair_.<span class="function">continuous</span>().<span class="function">nu</span>()</span><br><span class="line">       /<span class="function">sqr</span>(pair_.<span class="function">dispersed</span>().<span class="function">d</span>())</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中 <code>CdRe()</code> 的定义为<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="rule"><span class="attribute">Foam</span>:<span class="value">:tmp&lt;Foam::volScalarField&gt; Foam::dragModels::Ergun::<span class="function">CdRe</span>() const</span><br><span class="line">&#123;</span><br><span class="line">    return</span><br><span class="line">        (<span class="number">4</span>/<span class="number">3</span>)</span><br><span class="line">       *(</span><br><span class="line">            <span class="number">150</span></span><br><span class="line">           *<span class="function">max</span>(<span class="function">scalar</span>(<span class="number">1</span>) - pair_.<span class="function">continuous</span>(), residualAlpha_)</span><br><span class="line">           /<span class="function">max</span>(pair_.<span class="function">continuous</span>(), residualAlpha_)</span><br><span class="line">          + <span class="number">1.75</span></span><br><span class="line">           *pair_.<span class="function">Re</span>()</span><br><span class="line">        )</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意所有曳力模型的 <code>K()</code>函数形式是一样的，不同曳力模型的区别在于 <code>CdRe()</code> 的实现不一样。<br>此外，virtualMass，  heatTransfer，lift，wallLubrication，turbulentDispersion 这些子模型的调用也都是经过类似的过程进行的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前面有三篇博文对 OpenFOAM-2.1.x 中的 <code>twoPhaseEulerFoam</code> 求解器进行了解读，然而 OpenFOAM-2.3.x 中，这个求解器的代码有了很大的变化。本文将以一个曳力模型的调用过程为例，介绍 OpenFOAM-2.3.x 中 <code>twoPhaseEulerFoam</code> 是如何调用相间作用力模型的。后续还将对 OpenFOAM-2.3.x 中的 <code>twoPhaseEulerFoam</code> 的其他方面进行解读。</p>]]>
    
    </summary>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/tags/OpenFOAM/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[vim Extension for OpenFOAM]]></title>
    <link href="http://xiaopingqiu.github.io/2015/08/16/vimExtensionOpenFOAM/"/>
    <id>http://xiaopingqiu.github.io/2015/08/16/vimExtensionOpenFOAM/</id>
    <published>2015-08-16T06:59:23.000Z</published>
    <updated>2015-08-16T08:50:58.124Z</updated>
    <content type="html"><![CDATA[<p>本篇介绍一个<a href="https://bitbucket.org/shor-ty/vimextensionopenfoam" target="_blank" rel="external">vim 插件</a>，该插件会自动检测某个文件是否是 OpenFOAM 的设置文件，然后根据预设的颜色显示方案来对大部分的 OpenFOAM 关键字进行高亮显示。单凭这一个特性，还不至让我专门写一篇博文来介绍它，真正让我觉得实用的是另外一个附带的特性：关键字补全。安装此插件以后，可以在用 vim 编辑 OpenFOAM 设置文件的时候对 OpenFOAM 的很多关键字，包括边界条件，湍流模型，离散格式等等进行自动补全，下面对这个插件和基本功能进行一个简单介绍。</p>
<a id="more"></a>
<h4 id="1-_安装">1. 安装</h4><p>安装很简单，首先去 <a href="https://bitbucket.org/shor-ty/vimextensionopenfoam" target="_blank" rel="external">https://bitbucket.org/shor-ty/vimextensionopenfoam</a> 下载，建议使用 git clone 来讲插件的代码下载到本地。然后，运行代码根目录下的安装脚本 <code>install</code>，就完成了安装。更详细的步骤以及颜色配置的选项，在插件项目的主页上也有介绍，这里不再赘述。</p>
<h4 id="2-_基本特性">2. 基本特性</h4><p>该插件的基本特性就是对 OpenFOAM 关键字进行高亮显示，见下图：</p>
<ul>
<li><p>图1：使用插件之前<br><img src="/image/vimext/without_plugin.png" alt=""></p>
</li>
<li><p>图2：使用插件之后<br><img src="/image/vimext/with_plugin.png" alt=""></p>
</li>
</ul>
<p>有了这个高亮显示后，就可以根据颜色看出设置文件里的关键词是否有错了。</p>
<h4 id="3-_关键字补全">3. 关键字补全</h4><p>关键字补全在实际使用中还是很有作用的，一来可以减少手动输入，二来可以很有效地减少键入错误。注意，按照插件作者的介绍，这个插件的主要功能是高亮显示 OpenFOAM 关键词，补全功能，则算是一个副产物。下面通过几个动画来显示补全功能：</p>
<ul>
<li><p>边界条件补全<br><img src="/image/vimext/k.gif" alt=""><br><img src="/image/vimext/k1.gif" alt=""></p>
</li>
<li><p>RAS 湍流模型<br><img src="/image/vimext/RAS.gif" alt=""></p>
</li>
<li><p>fvSchemes<br><img src="/image/vimext/fvSchemes.gif" alt=""> </p>
</li>
<li>fvSolutions<br><img src="/image/vimext/fvSolutions.gif" alt=""> </li>
</ul>
<p>需要注意的是，这里我只使用了 vim 自带的最简单的补全方法：Ctrl n 和 Ctrl p。以上动画中，输入关键字的头几个字母，只需要按 ctrl n 或 ctrl p 就会显示出所有候选补全选项。</p>
<p>但是，这个插件没有包括所有的 OpenFOAM 关键字，比如标准求解器以及 LES 湍流模型就没有包括。可以通过编辑 <code>~/.vim/syntax/foam256</code>目录下的相应设置文件进行修改来对其进行扩展。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本篇介绍一个<a href="https://bitbucket.org/shor-ty/vimextensionopenfoam">vim 插件</a>，该插件会自动检测某个文件是否是 OpenFOAM 的设置文件，然后根据预设的颜色显示方案来对大部分的 OpenFOAM 关键字进行高亮显示。单凭这一个特性，还不至让我专门写一篇博文来介绍它，真正让我觉得实用的是另外一个附带的特性：关键字补全。安装此插件以后，可以在用 vim 编辑 OpenFOAM 设置文件的时候对 OpenFOAM 的很多关键字，包括边界条件，湍流模型，离散格式等等进行自动补全，下面对这个插件和基本功能进行一个简单介绍。</p>]]>
    
    </summary>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/tags/OpenFOAM/"/>
    
      <category term="vim" scheme="http://xiaopingqiu.github.io/tags/vim/"/>
    
      <category term="vim" scheme="http://xiaopingqiu.github.io/categories/vim/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[twoPhaseEulerFoam 全解读之三]]></title>
    <link href="http://xiaopingqiu.github.io/2015/06/27/twoPhaseEulerFoam3/"/>
    <id>http://xiaopingqiu.github.io/2015/06/27/twoPhaseEulerFoam3/</id>
    <published>2015-06-27T12:39:01.000Z</published>
    <updated>2015-11-03T14:29:33.575Z</updated>
    <content type="html"><![CDATA[<p>本系列将对OpenFOAM-2.1.1 中的 <code>twoPhaseEulerFoam</code> 求解器进行完全解读，共分三部分：方程推导，代码解读，补充说明。本篇对 <code>twoPhaseEulerFoam</code> 中的 <code>alphaEqn.H</code> 进行详细地的解读，并作一些补充说明。</p>
<a id="more"></a>
<h3 id="2-3-_alphaEqn">2.3. alphaEqn</h3><p>前文提到，经过求解 <code>pEqn</code>，并修正速度<code>Ua</code>和<code>Ub</code>以后，总体的连续性便得到了保证。为了得到分散相的体积分率<code>alpha</code>，还需要利用得到的速度场来求解分散相的连续性方程，即<code>alphaEqn</code>。分散相连续性方程可以表达如下：<br>$$<br>\frac{\partial \alpha_a}{\partial t}+\nabla \cdot (\alpha_a U_a)=0<br>$$</p>
<p>为了让每一项都写成守恒形式，并且保证$\alpha_a$的有界性，Weller 将分散相连续性方程写成如下形式<br>$$<br>\frac{\partial \alpha_a}{\partial t}+\nabla \cdot (\alpha_a U)+\nabla \cdot(U_r\alpha_a(1-\alpha_a))=0<br>$$<br>其中<br>$$<br>U=\alpha_a U_a + \alpha_b U_b \\<br>U_r=U_a-U_b<br>$$<br>OpenFOAM-2.1.1 的<code>alphaEqn</code>求解的正是 Weller 提出的形式。主要的代码如下：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fvScalarMatrix alphaEqn</span><br><span class="line">       <span class="list">(</span><br><span class="line">            <span class="keyword">fvm</span>:<span class="keyword">:ddt</span><span class="list">(<span class="keyword">alpha</span>)</span></span><br><span class="line">          + fvm:<span class="keyword">:div</span><span class="list">(<span class="keyword">phic</span>, alpha, scheme)</span></span><br><span class="line">          + fvm:<span class="keyword">:div</span><span class="list">(<span class="keyword">-fvc</span>:<span class="keyword">:flux</span><span class="list">(<span class="keyword">-phir</span>, beta, schemer)</span>, alpha, schemer)</span></span><br><span class="line">       )</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>其中<code>phic</code>与<code>phir</code>的定义如下：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">surfaceScalarField <span class="title">phic</span><span class="params">(<span class="string">"phic"</span>, phi)</span></span>;</span><br><span class="line"><span class="function">surfaceScalarField <span class="title">phir</span><span class="params">(<span class="string">"phir"</span>, phia - phib)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>得到分散相体积分率后，连续相体积分率$\alpha_b$则为$1-\alpha_a$，如下<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beta = <span class="literal">scalar</span>(1) - <span class="keyword">alpha</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-_补充说明">3. 补充说明</h2><p>想必读者肯定发现了，我前面的代码解读相比于<code>twoPhaseEulerFoam</code>的源码其实省略了很多，总体上来讲，省略了三大块，一是跟<code>kineticTheory</code>相关的，二是跟<code>g0</code>相关的，三是<code>packingLimiter</code>，下面对这三部分进行一些补充说明。</p>
<h3 id="3-1_kineticTheory">3.1 kineticTheory</h3><p><code>kineticTheory</code>是 KTGF(Kinetic Theory of Granular Flow) 方法在OpenFOAM-2.1.1里的实现。KTGF 的主要作用是计算固相压力和固相粘度，以封闭前述的分散相动量方程，所以<code>kineticTheory</code>只有在模拟气固（液固）两相流时才需要开启。 <code>kineticTheory</code> 是否开启以及 KTGF 模型的参数需要在算例的<code>constant/kineticTheoryProperties</code>文件里进行设置。如果开启了<code>kineticTheory</code>，主要的影响如下：</p>
<ul>
<li><p>UEqn.H</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (kineticTheory.on<span class="literal">()</span>)</span><br><span class="line">&#123;</span><br><span class="line">    kineticTheory.solve(gradUaT);</span><br><span class="line">    nuEffa = kineticTheory.mua<span class="literal">()</span>/rhoa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果开启<code>kineticTheory</code>，则固相粘度<code>nuEffa</code>是由 KTGF 来计算得到，否则<code>nuEffa</code>是用一个简单的关联式来计算</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    nuEffa = <span class="keyword">s</span><span class="string">qr(Ct)</span>*nutb + nua;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外，<code>Rca</code>项也要加上额外的项</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (kineticTheory.<span class="keyword">on</span>())</span><br><span class="line"><span class="comment">&#123;</span><br><span class="line">    Rca -= ((kineticTheory.lambda()/rhoa)*tr(gradUaT))*tensor(I);</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>pEqn.H<br>如果<code>kineticTheory</code>开启了，则要在压力修正方程中加上额外的固相压力项。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (kineticTheory.on())</span><br><span class="line">&#123;</span><br><span class="line">    phiDraga -= rUaAf*fvc::snGrad(kineticTheory.pa()/rhoa)*mesh.magSf();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>有关 OpenFOAM 中使用的 KTGF 模型的理论可以参考<a href="http://repository.tudelft.nl/view/ir/uuid%3A919e2efa-5db2-40e6-9082-83b1416709a6/" target="_blank" rel="external">Derivation, Implementation, and Validation of Computer Simulation Models for Gas-Solid Fluidized Beds</a>，以及B.G.M. van Wachem 的其他相关论文。</p>
<h3 id="3-2_g0">3.2 g0</h3><p>跟 <code>kineticTheory</code>一样，<code>g0</code> 也是只有在模拟气固（液固）两相流时才需要开启，相关的设置在<code>constant/ppProperties</code>里，当<code>g0</code>的值设置为大于零时，则跟<code>g0</code>相关的项会其作用，主要的影响如下：</p>
<ul>
<li><p>pEqn</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (g0.<span class="keyword">value</span><span class="literal">()</span> &gt; <span class="number">0.0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    phiDraga -= ppMagf*fvc::snGrad(alpha)*mesh.magSf<span class="literal">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>ppMagf</code>的定义如下：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ppMagf = rUaAf<span class="keyword">*</span>fvc::interpolate</span><br><span class="line">(</span><br><span class="line"> (1.0/(rhoa<span class="keyword">*</span>(alpha + scalar(0.0001))))</span><br><span class="line"> <span class="keyword">*</span>g0<span class="keyword">*</span>min(exp(preAlphaExp<span class="keyword">*</span>(alpha - alphaMax)), expMax)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>这一段的效果，相当于在<a href="http://xiaopingqiu.github.io/2015/05/17/twoPhaseEulerFoam1/" target="_blank" rel="external">本系列第一篇</a>最后的分散相动量方程的等式右边额外增加一项：<br>$$<br>-g0*min(e^{preAlphaExp*(\alpha_a - \alpha_{Max})},expMax)\nabla \alpha_a / (\alpha_a \rho_a)<br>$$<br>可见，这一项的作用是给固相额外施加了一个力，可以认为是固相压力，这个力与$\alpha_a$的梯度有关，且与梯度的方向相反。<br>注意这一项的特点：<code>g0</code>, <code>preAlphaExp</code>, <code>alphaMax</code>, <code>expMax</code> 都是需要用户指定的参数，一般将<code>g0</code>, <code>preAlphaExp</code>和<code>expMax</code>设置为一个比较大的正整数（$10^3$的量级），当<code>alpha - alphaMax &lt; 0</code>时，$e^{\,preAlphaExp*(\alpha_a - \alpha_{Max})}$ 将是一个很小的数，此时整个增加的一项也将是一个较小的数，所以，<code>alpha - alphaMax &lt; 0</code>时额外增加的那一项对动量方程的贡献很小。但是，当<code>alpha - alphaMax &gt; 0</code>时，随着 <code>alpha</code> 偏离 <code>alphaMax</code> 越来越远，<code>exp(preAlphaExp*(alpha - alphaMax)</code>将迅速增大，<code>min(exp(preAlphaExp*(alpha - alphaMax)), expMax)</code>的值也将迅速增大，直到设定值<code>expMax</code>。可见，<code>g0</code>项的作用可以理解为为了防止固相过度堆积。气固系统中，固相的体积分率是有上限的，可以将<code>alphaMax</code>设置为这个上限值，当某个网格里的<code>alpha</code>超过设定的<code>alphaMax</code>时，就让固相迅速弹开，以防止固相体积分率过大。</p>
</li>
<li><p>alphaEqn.H<br>alphaEqn.H 里有两处跟 <code>g0</code> 有关的，<br>一处是对 <code>phic</code> 和 <code>phir</code> 进行修正：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (g0.value() &gt; <span class="number">0.0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    surfaceScalarField alphaf(fvc::interpolate(alpha));</span><br><span class="line">    surfaceScalarField phipp(ppMagf*fvc::snGrad(alpha)*mesh.magSf());</span><br><span class="line">    phir += phipp;</span><br><span class="line">    phic += fvc::interpolate(alpha)*phipp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>另一处是对 <code>alphaEqn</code> 进行修正：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (g0.value() &gt; <span class="number">0.0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ppMagf = rUaAf*fvc::interpolate</span><br><span class="line">    (</span><br><span class="line">     (1.0/(rhoa*(alpha + scalar(0.0001))))</span><br><span class="line">     *g0*min(exp(preAlphaExp*(alpha - alphaMax)), expMax)</span><br><span class="line">     );</span><br><span class="line">    </span><br><span class="line">    alphaEqn -= fvm::laplacian</span><br><span class="line">    (</span><br><span class="line">     (fvc::interpolate(alpha) + scalar(0.0001))*ppMagf,</span><br><span class="line">     alpha,</span><br><span class="line">     <span class="string">"laplacian(alphaPpMag,alpha)"</span></span><br><span class="line">     );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为什么当 <code>g0 &gt; 0</code> 时，需要在 <code>alphaEqn</code> 中额外减去一个 <code>laplacian</code> 项呢？这里要结合上面提到的两段代码来进行分析。<br>在对 <code>phic</code> 和 <code>phir</code> 进行修正这一段， <code>phic</code> 和 <code>phir</code> 分别加上了一项。将修正过的 <code>phic</code> 和 <code>phir</code> 代入到 <code>alphaEqn</code> 中，会导致 <code>alphaEqn</code> 与上文的分散相连续性方程<br>$$<br>\frac{\partial \alpha_a}{\partial t}+\nabla \cdot (\alpha_a U)+\nabla \cdot(U_r\alpha_a(1-\alpha_a))=0<br>$$<br>不一致，其中 <code>alphaEqn</code> 多出了几项：<br>其中<br><code>fvm::div(phic, alpha, scheme)</code> 比 $ \nabla \cdot (\alpha_a U) $ 多了 <code>fvm::div(alphaf*phipp, alpha, scheme)</code> 一项，写成公式，就是 $ \nabla \cdot [\alpha (\alpha *\mathrm{ppMagf}) \nabla \alpha] $ 。</p>
<p>而 <code>fvm::div(-fvc::flux(-phir, beta, schemer), alpha, schemer)</code> 则比 $ \nabla \cdot (\alpha_a U)+\nabla \cdot(U_r\alpha_a(1-\alpha_a) $ 多出了 <code>fvm::div(-fvc::flux(-phipp, beta, schemer), alpha, schemer)</code> 一项，写成公式就是 $ \nabla \cdot [\alpha (\beta *\mathrm{ppMagf}) \nabla \alpha] $ 。<br>多出的这两项加起来，为<br>$$<br>\nabla \cdot [\alpha  *\mathrm{ppMagf} \  \nabla \alpha]<br>$$</p>
<p>对比上面的 <code>alphaEqn</code> 减去的 <code>laplacian</code> 项，会发现这一项跟那个 <code>laplacian</code> 是一样的。</p>
<p>所以，<code>g0 &gt; 0</code> 时，先将固相压力带来的通量代入到 <code>alphaEqn</code> 的构建中，然后再减去对应的 <code>laplacian</code> 项，这么做的目的，应该是为了计算稳定性以及保证 <code>alpha</code> 的有界性（保证0&lt;<code>alpha</code>&lt;<code>alphaMax</code>）。但是这背后的数值原理，我也没有完全理解。</p>
<p>最后，有必要说明一下，<code>g0</code>相关的项其实就是在动量方程中增加了一项颗粒压力，想要达到的效果是防止固相过度堆积。<code>kineticTheory</code>开启后将计算颗粒相的应力，其中包括了颗粒相压力。所以 <code>g0</code>可以当作 KTGF 的某种简单的替代。从原理上讲，<code>kineticTheory</code>和<code>g0</code>不应该同时开启。</p>
<h3 id="3-3_packingLimiter">3.3 packingLimiter</h3><p>packingLimiter 的作用，从名字可以看出，也是用来处理过度堆积问题的。packingLimiter 缺乏理论基础，仅仅是一种不甚高明的数值技巧，其主要的处理是定义了一个<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volScalarField alphaEx<span class="list">(<span class="keyword">max</span><span class="list">(<span class="keyword">alpha</span> - alphaMax, scalar<span class="list">(<span class="number">0</span>)</span>)</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>当<code>alpha - alphaMax &gt; 0</code>时，<code>alphaEx = alpha - alphaMax &gt; 0</code>，否则<code>alphaEx = 0</code>。<br>packingLimiter 本质操作是，当某个网格的固相体积分率超过设定的最大值时，就让该网格的固相往它的邻居网格匀一匀，就是这么简(ren)单(xing)。所以，一般情况下，不建议开启packingLimiter。</p>
<p>至此，OpenFOAM-2.1.1 版本的<code>twoPhaseEulerFoam</code>便解读完了。最近的 OpenFOAM-2.3 系列中的<code>twoPhaseEulerFoam</code> 变化很大，求解的是全守恒形式的动量方程了（而不是 phase-intensive形式的），耦合了传热模型，考虑了可压缩效应，而且alphaEqn的求解不再是利用隐式迭代的方式，而是改成了用 MULES 方法来求解。这些有待于下一步进行解读。</p>
<h2 id="参考资料">参考资料</h2><ol>
<li>Henrik Rusche， PHD Thesis， Computational Fluid Dynamics of Dispersed Two-Phase Flows at High Phase Fractions， Imperial College of Science, Technology &amp; Medicine, Department of Mechanical Engineering, 2002</li>
<li><a href="https://openfoamwiki.net/index.php/BubbleFoam" target="_blank" rel="external">https://openfoamwiki.net/index.php/BubbleFoam</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>本系列将对OpenFOAM-2.1.1 中的 <code>twoPhaseEulerFoam</code> 求解器进行完全解读，共分三部分：方程推导，代码解读，补充说明。本篇对 <code>twoPhaseEulerFoam</code> 中的 <code>alphaEqn.H</code> 进行详细地的解读，并作一些补充说明。</p>]]>
    
    </summary>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/tags/OpenFOAM/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在 Windows 7 下配置 OpenFOAM 运行环境]]></title>
    <link href="http://xiaopingqiu.github.io/2015/06/14/OpenFOAM-on-win/"/>
    <id>http://xiaopingqiu.github.io/2015/06/14/OpenFOAM-on-win/</id>
    <published>2015-06-14T13:06:32.000Z</published>
    <updated>2015-06-17T06:25:43.426Z</updated>
    <content type="html"><![CDATA[<p>本篇介绍如何在 Windows 7 64 bit 下配置 OpenFOAM 的编译及运行环境。我并不打算在 windows 下进行 OpenFOAM 的开发，这里的折腾仅仅是作为一种测试，想看看目前的 OpenFOAM for windows 安装能做到什么程度。我使用的是<a href="http://www.c-fields.com/" target="_blank" rel="external">Creative Fields</a>提供的安装包，编译环境是基于 Mingw-64 来搭建的，linux模拟环境采用的是 MSYS，终端使用的是 <a href="https://code.google.com/p/mintty/" target="_blank" rel="external">mintty</a>。经过一番折腾，我成功在 Windows 下安装了OpenFOAM-2.3.0，程序可以串行或并行运行，也可以用 wmake 编译新的代码。本篇博文不会一步一步详细介绍我的搭建过程，仅介绍一些基本的原则以及我遇到的坑。尤其注意的是，以下很多步骤其实对于安装 OpenFOAM for Windows 不是必需的，仅仅是因为我的特殊要求而徒增折腾而已。</p>
<a id="more"></a>
<h2 id="1-_安装">1. 安装</h2><p>安装步骤其实很简单，从<a href="http://www.c-fields.com/technical-area/downloads" target="_blank" rel="external">Creative Fields</a>下载 OpenFOAM for Windows，然后运行安装程序，选择需要的安装的 OpenFOAM 版本（OpenFOAM-2.3.0 或者 FOAM-extend-3.1，这里我安装的是前者），此外 Mingw compiler 也需要选上，不然无法编译新的 OpenFOAM 代码。选好以后，就开始安装过程，安装过程其实是将预编译好的 OpenFOAM 解压到你指定的目录。安装结束以后，从<code>install_dir/OpenFOAM\OpenFOAM-2.3.0</code>运行<code>of23.bat</code>,便会开启一个 Windows 的 cmd 窗口，从这个窗口里便可以运行 OpenFOAM 了。经测试，串行运行 <code>cavity</code> 和并行运行 <code>dambreak</code> 算例都能成功。如果仅仅满足于能在 Windows 下运行 OpenFOAM，那到这里就可以了，下面的不需要再看了。</p>
<p>但是，默认的 OpenFOAM 运行环境有很多不如意的地方，一是终端太简陋，没有颜色；二是 <code>vim</code> 使用的体验非常差；三是无法正常编译新的 OpenFOAM 代码。为了获得更好的使用体验以及更完整的功能，我进行了以下折腾。</p>
<h2 id="2-_运行环境的配置">2. 运行环境的配置</h2><p>先简单描述一下我电脑的配置环境：我已安装过 32位版的 mingw，并配置好了 msys+mintty 环境，使用体验很不错。但是，从<a href="http://www.c-fields.com/technical-area/downloads" target="_blank" rel="external">Creative Fields</a> 提供的 OpenFOAM for Windows 默认使用的是它自带的 MSYS，经测试有问题，最不能忍的一个是，这个版本的 MSYS 配合 mintty 终端使用的时候，无法使用<code>ctrl + z</code>将程序放到后台，按<code>ctrl + z</code>会导致终端崩溃。此外，这个版本的 OpenFOAM 是在64 环境编译好的，经测验无法在 32位mingw 环境下编译新的代码，因为库的版本不一致。我不想破坏原来的配置，希望实现两个不同的终端入口，其中一个进入后会自动载入OpenFOAM的运行环境，包括 OpenFOAM 相关的环境变量， Mingw-64 编译环境，以及我配置好的 msys+mintty 运行环境。另一个入口，进入后则会自动载入先前配置的 msys + mingw-32 运行环境。下面开始配置：</p>
<h4 id="2-1-_修改of23-bat">2.1. 修改<code>of23.bat</code></h4><p>默认的内容如下：<br><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@echo OFF</span><br><span class="line">if NOT exist D:<span class="command">\OpenFOAM</span><span class="command">\MSYS</span><span class="command">\home</span><span class="command">\%</span>USERNAME<span class="comment">%\.profile call D:\OpenFOAM\MSYS\initProfile.bat</span></span><br><span class="line">SET FOAM=of23</span><br><span class="line">D:<span class="command">\OpenFOAM</span><span class="command">\MSYS</span><span class="command">\bin</span><span class="command">\sh</span>.exe --login -i</span><br></pre></td></tr></table></figure></p>
<p>我想载入我的 msys 环境，则需要对这个批处理脚本进行修改。最省事的方法是将原来安装 msys 时的脚本<code>msys.bat</code>的内容拷过来，然后加上一些 OpemFOAM 相关的变量，经测试，只需要改三处：</p>
<ul>
<li>加上这一句<code>if NOT exist D:\OpenFOAM\MSYS\home\%USERNAME%\.profile call D:\OpenFOAM\MSYS\initProfile.bat</code>，这个跟加载 OpenFOAM 环境变量有关。</li>
<li>加一个环境变量 <code>set FOAM=of23</code>，注意如果安装的是<code>FOAM-extend-3.1</code>这一条可能会不一样。</li>
<li><p>指定 msys 的路径，一共有两处需要修改。<br><code>if NOT EXIST %WD%msys-1.0.dll set WD=.\bin\</code> 改成<br><code>if NOT EXIST %WD%msys-1.0.dll set WD=C:\MinGw\msys\1.0\bin\</code><br>以及<br><code>if NOT EXIST %WD%msys-1.0.dll set WD=%~dp0\bin\</code> 改成<br><code>if NOT EXIST %WD%msys-1.0.dll set WD=C:\MinGw\msys\1.0\bin\</code><br>注意<code>C:\MinGw\msys\1.0\bin\</code>是我的 msys 的路径。</p>
<p>完成这个以后，建立一个<code>of23.bat</code>的快捷方式，并将快捷方式的属性里目标设为:<code>D:\OpenFOAM\OpenFOAM\OpenFOAM-2.3.0\of23.bat -mintty</code>。设置好以后，运行这个快捷方式，便会自动载入 msys+mintty 运行环境了，并且自动配置好了OpenFOAM运行相关的环境。</p>
</li>
</ul>
<h4 id="2-2-_解决32位和64位_Mingw_的冲突问题">2.2. 解决32位和64位 Mingw 的冲突问题</h4><p>以上运行环境里默认加载的是32位 Mingw 编译环境，无法编译新的 OpenFOAM 代码，为了解决这个问题，需要实现在需要运行 OpenFOAM 时，自动载入64位的 Mingw，这需要通过修改<code>$HOME/.profile</code> 文件来实现。摸索过程不细说了，这里贴上我的最终配置：<br><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">if <span class="special">[</span> -n "<span class="formula">$<span class="special">&#123;</span>FOAM+1<span class="special">&#125;</span>" <span class="special">]</span>; then  </span><br><span class="line">if <span class="special">[</span> $</span>FOAM == "of23" <span class="special">]</span>; then  </span><br><span class="line">echo Setting up OpenFoam 2.3 shell  </span><br><span class="line">source /D/OpenFOAM/OpenFOAM/OpenFOAM-2.3.0/etc/bashrc  </span><br><span class="line">export PATH=/D/OpenFOAM/MinGW/bin:<span class="formula">$PATH</span><br><span class="line">export CPLUS_INCLUDE_PATH='D:<span class="command">\OpenFOAM</span><span class="command">\MinGw</span><span class="command">\include</span>;D:<span class="command">\OpenFOAM</span><span class="command">\MinGW</span><span class="command">\lib</span><span class="command">\gcc</span><span class="command">\x</span>86_64-w64-mingw32\4.9.2<span class="command">\include</span>'</span><br><span class="line">export C_INCLUDE_PATH='D:<span class="command">\OpenFOAM</span><span class="command">\MinGw</span><span class="command">\include</span>;D:<span class="command">\OpenFOAM</span><span class="command">\MinGW</span><span class="command">\lib</span><span class="command">\gcc</span><span class="command">\x</span>86_64-w64-mingw32\4.9.2<span class="command">\include</span>'</span><br><span class="line">export LIBRARY_PATH='D:<span class="command">\OpenFOAM</span><span class="command">\MinGW</span><span class="command">\lib</span>;D:<span class="command">\OpenFOAM</span><span class="command">\MinGW</span><span class="command">\lib</span><span class="command">\gcc</span><span class="command">\x</span>86_64-w64-mingw32\4.9.2'</span><br><span class="line">elif <span class="special">[</span> $</span>FOAM == "f3" <span class="special">]</span>; then </span><br><span class="line">echo Setting up foam-extend-3.1 shell  </span><br><span class="line">source /D/OpenFOAM/OpenFOAM/foam-extend-3.1/etc/bashrc  </span><br><span class="line">export PATH=/D/OpenFOAM/MinGW/bin:<span class="formula">$PATH</span><br><span class="line">export CPLUS_INCLUDE_PATH='D:<span class="command">\OpenFOAM</span><span class="command">\MinGw</span><span class="command">\include</span>;D:<span class="command">\OpenFOAM</span><span class="command">\MinGW</span><span class="command">\lib</span><span class="command">\gcc</span><span class="command">\x</span>86_64-w64-mingw32\4.9.2<span class="command">\include</span>'</span><br><span class="line">export C_INCLUDE_PATH='D:<span class="command">\OpenFOAM</span><span class="command">\MinGw</span><span class="command">\include</span>;D:<span class="command">\OpenFOAM</span><span class="command">\MinGW</span><span class="command">\lib</span><span class="command">\gcc</span><span class="command">\x</span>86_64-w64-mingw32\4.9.2<span class="command">\include</span>'</span><br><span class="line">export LIBRARY_PATH='D:<span class="command">\OpenFOAM</span><span class="command">\MinGW</span><span class="command">\lib</span>;D:<span class="command">\OpenFOAM</span><span class="command">\MinGW</span><span class="command">\lib</span><span class="command">\gcc</span><span class="command">\x</span>86_64-w64-mingw32\4.9.2'</span><br><span class="line">else  </span><br><span class="line">echo No foam preset in MSYS  </span><br><span class="line">fi  </span><br><span class="line">fi  </span><br><span class="line"><span class="special">#</span>echo Setting up ParaView </span><br><span class="line">export PATH=$</span>PATH:/d/Program<span class="command">\ </span>Files<span class="command">\ </span><span class="command">\(</span>x86<span class="command">\)</span>//ParaView<span class="command">\ </span>4.1.0/bin/</span><br><span class="line"><span class="special">#</span> echo Setting up PATH </span><br><span class="line">export PATH=<span class="formula">$LD_LIBRARY_PATH:$</span>PATH </span><br><span class="line"><span class="special">#</span> echo Done</span><br></pre></td></tr></table></figure></p>
<p>以上配置好以后，便可以用<code>wmake</code>来编译新的 OpenFOAM 代码了。</p>
<h4 id="2-3-_一些坑">2.3. 一些坑</h4><p>如果以上配置好以后，仍然无法编译你的 OpenFOAM 代码，那可能是以下原因造成的：</p>
<ul>
<li>Creative Fields 这个版本的 OpenFOAM，将所有的属于 OpenFOAM 的源码文件名都在之前加了一个<code>OF_</code>的前缀。我估计这是为了防止文件名冲突，因为windows下，文件名不区分大小写，如此一来，OpenFOAM的源码文件<code>Vector.H</code>便与标准C++的头文件<code>vector.h</code>无法区分了。所以，从Linux下拷贝过来的OpenFOAM源码无法直接在这个环境下编译，需要修改一下<code>#include</code>的源文件名再尝试。</li>
<li>wmake编译的时候，默认会去<code>src</code>目录下编译生成的<code>lnInclude</code>目录下寻找头文件，但是，估计是由于 msys 环境下不支持符号链接，这个版本的OpenFOAM的 <code>src</code>目录下不自带<code>lnInclude</code>目录，所以，编译会遇到找不到头文件的错误，解决办法是重新运行一次<code>src</code>目录的<code>Allwmake</code>，编译不会成功，不过无所谓，只要生成了那些<code>lnInclude</code>目录就行了。</li>
<li>mpicc，mpic++，mpicxx这几个程序在默认情况下不能正常运行，原因是，在<code>D:\OpenFOAM\OpenFOAM\ThirdParty-2.3.0\platforms\mingw64Gcc\openmpi-1.6.5\share\openmpi</code>下定义的<code>*-wrapper-data.txt</code>文件中，指定的默认编译器是<code>cl.exe</code>，这是<code>visual studio</code>带的命令行编译器。将之改成<code>gcc.exe</code>( mpic++ 和 mpicxx 的改成<code>g++.exe</code>)，便可以正常运行了。</li>
</ul>
<p>最后，所有配置都弄好以后，便可以以比较好的体验在Windows下编译和运行OpenFOAM了，但是，msys+mintty 这套环境仍有一个遗憾，那就是并行不能正常。如果在 mintty 终端里直接运行<code>mpirun -np 4 interFoam.exe -parallel</code>，会报错：<code>..\..\..\SOURCES\openmpi-1.6.5\opal\event\event.c: ompi_evesel-&gt;dispatch() failed.</code>。但是如果用 <code>nohup</code> 命令，<code>nohup mpirun -np 4 interFoam.exe -parallel &amp;</code>则可以并行运行。只是仍有一个bug，那就是程序运行结束以后，进程<code>interFoam.exe</code>不会自动关闭，需要手动从任务管理器里去结束。但在默认的<code>of23.bat</code>环境里，并行是正常的，所以妥协的办法是当需要并行运行的时候，就转移到默认环境里去运行。</p>
<p>以上仅供读者参考，不推荐新手去折腾，因为不太值得，安装一个 Ubuntu 虚拟机，然后在里面安装配置 OpenFOAM 简单多了，而且使用体验也更好。即便要折腾，也不太推荐Creative Fields 的这个安装包，因为它在所有的OpenFOAM源文件名前加了<code>OF_</code>前缀,这对编译从linux环境下拷贝过来的 OpenFOAM 代码造成了不小的麻烦。不知道其他的OpenFOAM for windows 安装包采用的是什么方法来规避上面提到的文件名可能冲突这个问题的。</p>
<p>顺带提一句，Creative Fields 除了提供OpenFOAM for Windows，还有一个画网格工具套装叫<code>cfMesh</code>，经简单试用，其特点是自动化程度很高，网格生成速度特别快。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本篇介绍如何在 Windows 7 64 bit 下配置 OpenFOAM 的编译及运行环境。我并不打算在 windows 下进行 OpenFOAM 的开发，这里的折腾仅仅是作为一种测试，想看看目前的 OpenFOAM for windows 安装能做到什么程度。我使用的是<a href="http://www.c-fields.com/">Creative Fields</a>提供的安装包，编译环境是基于 Mingw-64 来搭建的，linux模拟环境采用的是 MSYS，终端使用的是 <a href="https://code.google.com/p/mintty/">mintty</a>。经过一番折腾，我成功在 Windows 下安装了OpenFOAM-2.3.0，程序可以串行或并行运行，也可以用 wmake 编译新的代码。本篇博文不会一步一步详细介绍我的搭建过程，仅介绍一些基本的原则以及我遇到的坑。尤其注意的是，以下很多步骤其实对于安装 OpenFOAM for Windows 不是必需的，仅仅是因为我的特殊要求而徒增折腾而已。</p>]]>
    
    </summary>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/tags/OpenFOAM/"/>
    
      <category term="Windows" scheme="http://xiaopingqiu.github.io/tags/Windows/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[foamTimeAverage]]></title>
    <link href="http://xiaopingqiu.github.io/2015/05/31/foamTimeAverage/"/>
    <id>http://xiaopingqiu.github.io/2015/05/31/foamTimeAverage/</id>
    <published>2015-05-31T09:11:00.000Z</published>
    <updated>2015-06-04T01:27:01.949Z</updated>
    <content type="html"><![CDATA[<p> 在<a href="http://xiaopingqiu.github.io/2015/04/12/fieldAverage/" target="_blank" rel="external">前面的一篇博文</a>中，我介绍了<code>fieldAverage</code>这个<code>functionObject</code>的用法，其中提到， 可以用<code>window</code>这个参数来控制所计算的时均值的时间范围。如果 <code>base = time</code>且<code>window = 10</code>，那从第10s以后，每个时刻 t 输出的时均值其实相当于从 t-10 到 t 这个时间段内的时均值。但是，根据分析可以发现，这个时均值并不严格等价于从 t-10 时刻到 t 时刻某个场的时均值。有时候，需要从某个时刻才开始计算时均值，而<code>fieldAverage</code>没有参数可以控制从某个时刻才开始计算时间平均。于是我参照<code>OpenFOAM</code>的<code>patchAverage.C</code>的代码写了一个后处理程序，用来计算指定时间段内的某个场的时均值。</p>
 <a id="more"></a>
<h3 id="foamTimeAverage_简介">foamTimeAverage 简介</h3><p> <code>foamTimeAverage</code> 是一段简单的后处理程序，其功能是在算例运行结束以后，根据指定的时间段，从数据文件夹里循环读入指定时间段内指定场的数据，并计算该段时间的该指定场的时均值，结果将会输出到该时间段最后一个时刻的数据文件夹内。举例说：<br> <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foamTimeAverage <span class="tag">p</span> -<span class="tag">time</span> <span class="number">0.4</span>:<span class="number">0.5</span></span><br></pre></td></tr></table></figure></p>
<p> 将会计算<code>0.4 s-0.5 s</code>时间段内<code>p</code>的时均值，结果将输出到<code>0.5</code>内，时均值文件名为<code>p_mean</code>。这个程序只支持计算<code>volField</code>的时均值，不支持<code>surfaceField</code>。目前，这个程序只在<code>OpenFOAM-2.1.1</code>和<code>OpenFOAM-2.3.1</code>下通过可编译测试，运行的结果目前只在<code>OpenFOAM-2.1.1</code>下对<code>volScalarField</code>和<code>volVectorField</code>进行了测试。理论上讲，应该在其他版本的<code>OpenFOAM</code>下也可以正常编译和运行。</p>
<p> 以下是<code>foamTimeAverage</code>的代码：<br> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*---------------------------------------------------------------------------*\</span><br><span class="line"> *=========                 |</span><br><span class="line"> *\\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox</span><br><span class="line"> *\\     /   O peration     |</span><br><span class="line"> *\\    /    A nd           | Copyright (C) 1991-2009 OpenCFD Ltd.</span><br><span class="line"> *\\   /     M anipulation  |</span><br><span class="line"> * -------------------------------------------------------------------------------</span><br><span class="line"> license</span><br><span class="line"> This file is part of OpenFOAM.</span><br><span class="line"></span><br><span class="line"> OpenFOAM is free software; you can redistribute it and/or modify it</span><br><span class="line"> under the terms of the GNU General Public License as published by the</span><br><span class="line"> Free Software Foundation; either version 2 of the License, or (at your</span><br><span class="line"> option) any later version.</span><br><span class="line"></span><br><span class="line"> OpenFOAM is distributed in the hope that it will be useful, but WITHOUT</span><br><span class="line"> ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span><br><span class="line"> FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License</span><br><span class="line"> for more details.</span><br><span class="line"></span><br><span class="line"> You should have received a copy of the GNU General Public License</span><br><span class="line"> along with OpenFOAM; if not, write to the Free Software Foundation,</span><br><span class="line"> Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA</span><br><span class="line"></span><br><span class="line">Application</span><br><span class="line">   foamTimeAverage</span><br><span class="line"></span><br><span class="line">Author</span><br><span class="line">  Xiaoping Qiu </span><br><span class="line">  q.giskard@gmail.com</span><br><span class="line"></span><br><span class="line">Description</span><br><span class="line">Calculates the time average  of the specified volField over the specified time range.</span><br><span class="line"></span><br><span class="line">\*---------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "fvCFD.H"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> FieldType&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calcTimeAverage</span></span><br><span class="line"><span class="params">(</span><br><span class="line">    fvMesh&amp; mesh,</span><br><span class="line">    <span class="keyword">const</span> IOobject&amp; fieldHeader,</span><br><span class="line">    <span class="keyword">const</span> word&amp; fieldName,</span><br><span class="line">    Time&amp; runTime,</span><br><span class="line">    instantList&amp; timeDirs,</span><br><span class="line">    <span class="keyword">bool</span>&amp; done</span><br><span class="line">)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    label nfield = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> word meanFieldName = fieldName + <span class="string">"_mean"</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//Info &lt;&lt; "class name = " &lt;&lt; fieldHeader.headerClassName() &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//Info &lt;&lt; "typeName = " &lt;&lt; FieldType::typeName &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">if</span>(!done &amp;&amp; fieldHeader.headerClassName() == FieldType::typeName)</span><br><span class="line">    &#123;</span><br><span class="line">	<span class="function">FieldType <span class="title">dummy</span></span><br><span class="line">	    <span class="params">(</span><br><span class="line">		IOobject</span><br><span class="line">		(</span><br><span class="line">		    fieldName,</span><br><span class="line">		    runTime.timeName()</span>,</span><br><span class="line">		    mesh,</span><br><span class="line">		    IOobject::MUST_READ</span><br><span class="line">		),</span><br><span class="line">		mesh</span><br><span class="line">	    )</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">FieldType <span class="title">meanField</span></span><br><span class="line">	    <span class="params">(</span><br><span class="line">		IOobject</span><br><span class="line">		(</span><br><span class="line">		    meanFieldName,</span><br><span class="line">		    runTime.timeName()</span>,</span><br><span class="line">		    mesh,</span><br><span class="line">		    IOobject::NO_READ</span><br><span class="line">		),</span><br><span class="line">		dummy</span><br><span class="line">	    )</span>;</span><br><span class="line"></span><br><span class="line">	meanField *= scalar(<span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">	forAll(timeDirs, timeI)</span><br><span class="line">	&#123;</span><br><span class="line">	    runTime.setTime(timeDirs[timeI], timeI);</span><br><span class="line">	    Info &lt;&lt; <span class="string">"Time = "</span> &lt;&lt; runTime.timeName() &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	    <span class="function">IOobject <span class="title">io</span></span><br><span class="line">		<span class="params">(</span><br><span class="line">		    fieldName,</span><br><span class="line">		    runTime.timeName()</span>,</span><br><span class="line">		    mesh,</span><br><span class="line">		    IOobject::MUST_READ</span><br><span class="line">		)</span>;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span> (io.headerOk())</span><br><span class="line">	    &#123;</span><br><span class="line">		mesh.readUpdate();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(!done &amp;&amp; io.headerClassName() == FieldType::typeName)</span><br><span class="line">		&#123;</span><br><span class="line">		    Info &lt;&lt; <span class="string">"   Reading "</span> &lt;&lt; io.headerClassName() &lt;&lt; <span class="string">" "</span> &lt;&lt;io.name() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		    <span class="function">FieldType <span class="title">field</span><span class="params">(io, mesh)</span></span>;</span><br><span class="line"></span><br><span class="line">		    meanField += field;</span><br><span class="line">		    nfield++;</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">else</span></span><br><span class="line">	    &#123;</span><br><span class="line">		Info &lt;&lt; <span class="string">"   No Field "</span> &lt;&lt; fieldName &lt;&lt; endl; </span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(nfield &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	    Info &lt;&lt; <span class="string">"number of field = "</span> &lt;&lt; nfield &lt;&lt; endl;</span><br><span class="line">	    meanField /= nfield;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Info&lt;&lt; <span class="string">"writing to timeDir "</span> &lt;&lt; runTime.timeName()  &lt;&lt; endl;</span><br><span class="line">	meanField.write();</span><br><span class="line">	done = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Main program:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line"></span><br><span class="line">    Foam::timeSelector::addOptions();</span><br><span class="line">    <span class="preprocessor">#<span class="keyword">include</span> "addRegionOption.H"</span></span><br><span class="line">    Foam::argList::validArgs.append(<span class="string">"fieldName"</span>);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#   <span class="keyword">include</span> "setRootCase.H"</span></span><br><span class="line"><span class="preprocessor">#   <span class="keyword">include</span> "createTime.H"</span></span><br><span class="line">    instantList timeDirs = timeSelector::select0(runTime, args);</span><br><span class="line">    runTime.setTime(timeDirs[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line"><span class="preprocessor">#   <span class="keyword">include</span> "createNamedMesh.H"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// get filename from command line</span></span><br><span class="line">    <span class="keyword">const</span> word fieldName = args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">bool</span> done = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">IOobject <span class="title">fieldHeader</span></span><br><span class="line">	<span class="params">(</span><br><span class="line">	    fieldName,</span><br><span class="line">	    runTime.timeName()</span>,</span><br><span class="line">	    mesh,</span><br><span class="line">	    IOobject::MUST_READ</span><br><span class="line">	)</span>;</span><br><span class="line">    <span class="keyword">if</span>(fieldHeader.headerOk())<span class="comment">//very important!</span></span><br><span class="line">    &#123;</span><br><span class="line">	calcTimeAverage&lt;volScalarField&gt;(mesh, fieldHeader, fieldName, runTime, timeDirs, done);</span><br><span class="line">	calcTimeAverage&lt;volVectorField&gt;(mesh, fieldHeader, fieldName, runTime, timeDirs, done);</span><br><span class="line">	calcTimeAverage&lt;volTensorField&gt;(mesh, fieldHeader, fieldName, runTime, timeDirs, done);</span><br><span class="line">	calcTimeAverage&lt;volSymmTensorField&gt;(mesh, fieldHeader, fieldName, runTime, timeDirs, done);</span><br><span class="line">	calcTimeAverage&lt;volSphericalTensorField&gt;(mesh, fieldHeader, fieldName, runTime, timeDirs, done);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">	Info&lt;&lt; <span class="string">" Error! No field "</span> &lt;&lt; fieldName &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Info&lt;&lt; <span class="string">"End\n"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ************************************************************************* //</span></span><br></pre></td></tr></table></figure></p>
<p> 更详细的参考，包括编译和使用方法，见<a href="https://github.com/xiaopingqiu/foamTimeAverage" target="_blank" rel="external">代码的github页面</a>。</p>
<h3 id="一点说明">一点说明</h3><p> <code>foamTimeAverage</code> 这个程序有一个缺点，那就是只能根据输出的文件来计算时均值。举例说，假如算例的时间步长取<code>0.0001 s</code>，每<code>0.01 s</code> 输出一次，那<code>0.4 s-0.5 s</code>这个时间段的时均值就只涉及到<code>0.40s, 0.41s, 0.42s, ... 0.50s</code>这些时刻的值。有时候，如果想计算的是更精确的时均值，即<code>0.4000s, 0.4001s, 0.4002s ... 0.5000s</code>这些时刻的时均值，该怎么办呢？我没有实际测试过，但有一种方法我觉得可行，需要结合<code>fieldAverage</code>和<code>foamTimeAverage</code>来实现，具体操作如下：</p>
<ol>
<li><p>设置<code>fieldAverage</code>，注意将<code>resetOnOutput</code>设置为<code>true</code>，<code>outputControl</code>设置为<code>outputTime</code>，<code>base</code>设为<code>time</code>，<code>window</code>不需要设置，这样，应该就会在每一个输出的时间文件夹里输出一个时均值，这个时均值计算的上一次输出到下一次输出之间的时间段内的时均值，用上面的例子来说，即<code>0.5</code>文件夹内输出的<code>p</code>的时均值<code>pMean</code>是<code>0.4001s, 0.4002s, ... 0.5000s</code>这些时刻的<code>p</code>的时均值。</p>
</li>
<li><p>用<code>foamTimeAverage</code>计算指定时间段内<code>pMean</code>的时均值。举例说，<br><code>foamTimeAverage pMean -time 0.04:0.05</code> 计算的将是 <code>0.3001s, 0.3002s, ... 0.5000s</code>这些时刻的时均值，这是因为，0.04 文件夹内的<code>pMean</code>是 <code>0.3001s, 0.3002s, ... 0.4000s</code>的时均值，0.05 文件夹内的<code>pMean</code>是<code>0.4001s, 0.4002s, ... 0.5000s</code>时刻内的时均值。</p>
<p>用以上方法就可以实现计算指定时间段内同时精度更高的时均值了。<strong>再次申明一下，上述方法仅仅是我根据原理进行的推演，没有经过检验</strong>。</p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p> 在<a href="http://xiaopingqiu.github.io/2015/04/12/fieldAverage/">前面的一篇博文</a>中，我介绍了<code>fieldAverage</code>这个<code>functionObject</code>的用法，其中提到， 可以用<code>window</code>这个参数来控制所计算的时均值的时间范围。如果 <code>base = time</code>且<code>window = 10</code>，那从第10s以后，每个时刻 t 输出的时均值其实相当于从 t-10 到 t 这个时间段内的时均值。但是，根据分析可以发现，这个时均值并不严格等价于从 t-10 时刻到 t 时刻某个场的时均值。有时候，需要从某个时刻才开始计算时均值，而<code>fieldAverage</code>没有参数可以控制从某个时刻才开始计算时间平均。于是我参照<code>OpenFOAM</code>的<code>patchAverage.C</code>的代码写了一个后处理程序，用来计算指定时间段内的某个场的时均值。</p>]]>
    
    </summary>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/tags/OpenFOAM/"/>
    
      <category term="Postprocessing" scheme="http://xiaopingqiu.github.io/tags/Postprocessing/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[twoPhaseEulerFoam 全解读之二]]></title>
    <link href="http://xiaopingqiu.github.io/2015/05/17/twoPhaseEulerFoam2/"/>
    <id>http://xiaopingqiu.github.io/2015/05/17/twoPhaseEulerFoam2/</id>
    <published>2015-05-17T07:23:04.000Z</published>
    <updated>2015-06-27T12:42:13.207Z</updated>
    <content type="html"><![CDATA[<p>本系列将对OpenFOAM-2.1.1 中的 <code>twoPhaseEulerFoam</code> 求解器进行完全解读，共分三部分：方程推导，代码解读，补充说明。本篇对 <code>twoPhaseEulerFoam</code> 中的 <code>UEqn.H</code> 和 <code>pEqn.H</code> 中的代码进行详细地的解读。</p>
<a id="more"></a>
<h2 id="2-_代码解读">2. 代码解读</h2><h3 id="2-1-_UEqn">2.1. UEqn</h3><p>前一篇导出了分散相的动量守恒方程<br>$$<br>\begin{aligned}<br>&amp;(1+\frac{\alpha_b \rho_b}{\rho_a} C_{vm})(\frac{\partial U_a}{\partial t} + U_a\cdot \nabla U_a ) -\nabla \cdot \left[ \nu_{eff} \nabla U_a \right ] + \nabla \cdot \left[ R_{c,a}\right] + \frac{\nabla(\alpha_a)}{\alpha_a} \cdot \left[ -\nu_{eff}\nabla U_a + R_{c,a}\right] \\<br>= &amp; -\frac{\alpha_b}{\rho_a} K U_a - \frac{\alpha_b}{\rho_a} \left\{ {C_l (\alpha_b \rho_b + \alpha_a \rho_a) U_r \times (\nabla \times U) -  C_{vm}\rho_b\left[ {\frac{\partial U_b}{\partial t} + U_b \cdot \nabla U_b }\right] } \right\} -\frac{\nabla p}{\rho_a} + g + \frac{\alpha_b}{\rho_a} K U_b<br> \end{aligned}<br>$$<br>这一篇分析<code>twoPhaseEulerFoam</code>求解器是怎么来对动量方程进行离散的，以及，如果通过构建压力方程来对速度进行修正以保证两相的连续性。</p>
<p>注意上述动量方程中，有两项还需要处理一下：<br>$$U_a \cdot \nabla U_a=\nabla\cdot(U_aU_a)-U_a(\nabla\cdot U_a)$$</p>
<p>$$\frac{\nabla(\alpha_a)}{\alpha_a}\cdot\left[-\nu_{eff} \nabla U_a\right] = \nabla \cdot\left[ -\nu_{eff}\frac{(\nabla \alpha_a)}{\alpha_a}(\nabla U_a)\right]-U_a\left(\nabla\cdot(-\nu_{eff}\frac{\nabla \alpha_a}{\alpha_a}) \right)$$<br>转化前后的形式从数学上来等价的，但是在有限体积离散过程中，转化前的 $U_a \cdot \nabla U_a$  和 $\frac{\nabla(\alpha_a)}{\alpha_a}\cdot\left[-\nu_{eff} \nabla U_a\right]$ 对于$U_a$来说是非守恒的，转化后的形式是守恒的(参考<a href="http://www.sciencedirect.com/science/article/pii/S0029549309003021" target="_blank" rel="external">这篇文献</a>，注意这样转化后，动量方程空间上是守恒的，但时间上仍是不守恒的，<a href="http://www.cfd-online.com/Forums/openfoam-solving/71141-rewriting-twophaseeulerfoam-conservative-form.html" target="_blank" rel="external">这个帖子</a>也有一些有价值的信息)。</p>
<p>这样转化以后，得到的动量方程就跟<code>twoPhaseEulerFoam</code>里的定义是一模一样了:<br>$$<br>\begin{aligned}<br>&amp;(1+\frac{\alpha_b \rho_b}{\rho_a} C_{vm})\left(\frac{\partial U_a}{\partial t} + \nabla\cdot(U_aU_a)-U_a(\nabla\cdot U_a) \right)\\<br>-&amp;\nabla \cdot \left[ \nu_{eff} \nabla U_a \right ] + \nabla \cdot \left[ R_{c,a}\right] +\nabla \cdot\left[ -\nu_{eff}\frac{(\nabla \alpha_a)}{\alpha_a}(\nabla U_a)\right]-U_a\left(\nabla\cdot(-\nu_{eff}\frac{\nabla \alpha_a}{\alpha_a}) \right) \\<br>+ &amp; \frac{\nabla(\alpha_a)}{\alpha_a} \cdot \left[ R_{c,a}\right] \\<br>= &amp; -\frac{\alpha_b}{\rho_a} K U_a - \frac{\alpha_b}{\rho_a} \left\{ {C_l (\alpha_b \rho_b + \alpha_a \rho_a) U_r \times (\nabla \times U) -  C_{vm}\rho_b\left[ {\frac{\partial U_b}{\partial t} + U_b \cdot \nabla U_b }\right] } \right\} \\<br>-&amp;\frac{\nabla p}{\rho_a} + g + \frac{\alpha_b}{\rho_a} K U_b<br> \end{aligned}<br>$$</p>
<p>下面将动量方程的每一项与<code>twoPhaseEulerFoam</code>的<code>UEqn.H</code>的代码一一对应。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">scalar</span><span class="list">(<span class="number">1</span>)</span> + Cvm*rhob*beta/rhoa)</span>*</span><br><span class="line">            <span class="list">(</span><br><span class="line">                <span class="keyword">fvm</span>:<span class="keyword">:ddt</span><span class="list">(<span class="keyword">Ua</span>)</span></span><br><span class="line">              + fvm:<span class="keyword">:div</span><span class="list">(<span class="keyword">phia</span>, Ua, <span class="string">"div(phia,Ua)"</span>)</span></span><br><span class="line">              - fvm:<span class="keyword">:Sp</span><span class="list">(<span class="keyword">fvc</span>:<span class="keyword">:div</span><span class="list">(<span class="keyword">phia</span>)</span>, Ua)</span></span><br><span class="line">            )</span></span><br></pre></td></tr></table></figure></p>
<p><code>fvm::ddt(Ua)</code>对应$\frac{\partial U_a}{\partial t}$，<code>phia</code>定义为<code>fvc::interpolate(Ua) &amp; mesh.Sf()</code>，于是<code>fvm::div(phia, Ua, &quot;div(phia,Ua)&quot;)</code> 和 <code>fvm::Sp(fvc::div(phia), Ua)</code> 便分别对应 $\nabla\cdot(U_aU_a)$ 和 $U_a(\nabla\cdot U_a)$了 <strong>[ <em>注一</em> ]</strong>。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- fvm::<span class="function"><span class="title">laplacian</span><span class="params">(nuEffa, Ua)</span></span></span><br><span class="line">+ fvc::<span class="function"><span class="title">div</span><span class="params">(Rca)</span></span></span><br><span class="line">+ fvm::<span class="function"><span class="title">div</span><span class="params">(phiRa, Ua, <span class="string">"div(phia,Ua)"</span>)</span></span></span><br><span class="line">- fvm::<span class="function"><span class="title">Sp</span><span class="params">(fvc::div(phiRa)</span></span>, Ua)</span><br></pre></td></tr></table></figure>
<p><code>fvm::laplacian(nuEffa, Ua)</code>对应$\nabla \cdot \left[ \nu_{eff} \nabla U_a \right ]$，<code>fvc::div(Rca)</code>对应$\nabla \cdot \left[ R_{c,a}\right]$。<br><code>phiRa</code>的定义是<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-fvc::<span class="function"><span class="title">interpolate</span><span class="params">(nuEffa)</span></span>*mesh.<span class="function"><span class="title">magSf</span><span class="params">()</span></span>*fvc::<span class="function"><span class="title">snGrad</span><span class="params">(alpha)</span></span></span><br><span class="line">            /fvc::<span class="function"><span class="title">interpolate</span><span class="params">(alpha + scalar(<span class="number">0.001</span>)</span></span>)</span><br></pre></td></tr></table></figure></p>
<p>相当于$-\nu_{eff}\frac{\nabla \alpha_a}{\alpha_a}$ <strong>[ <em>注二</em> ]</strong>。<br>于是 <code>fvm::div(phiRa, Ua, &quot;div(phia,Ua)&quot;)</code> 和 <code>fvm::Sp(fvc::div(phiRa), Ua)</code> 便分别对应 $\nabla \cdot\left[ -\nu_{eff} \frac{(\nabla \alpha_a)}{\alpha_a}(\nabla U_a)\right] $ 和 $U_a\left(\nabla\cdot(-\nu_{eff}\frac{\nabla \alpha_a}{\alpha_a}) \right)$。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">fvc</span>:<span class="keyword">:grad</span><span class="list">(<span class="keyword">alpha</span>)</span>/<span class="list">(<span class="keyword">fvc</span>:<span class="keyword">:average</span><span class="list">(<span class="keyword">alpha</span>)</span> + scalar<span class="list">(<span class="number">0.001</span>)</span>)</span> &amp; Rca)</span></span><br></pre></td></tr></table></figure>
<p>对应$\frac{\nabla(\alpha_a)}{\alpha_a} \cdot \left[ R_{c,a}\right]$，其中<code>&amp;</code>运算符已重载为计算矢量与张量的点乘积 <strong>[ <em>注三</em> ]</strong>。</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> =<span class="ruby">=</span><br><span class="line"></span><span class="comment">//  g                          // Buoyancy term transfered to p-equation</span></span><br><span class="line">-<span class="ruby"> <span class="symbol">fvm:</span><span class="symbol">:Sp</span>(beta/rhoa*<span class="constant">K</span>, <span class="constant">Ua</span>)</span><br><span class="line"></span><span class="comment">//+ beta/rhoa*K*Ub             // Explicit drag transfered to p-equation</span></span><br><span class="line">-<span class="ruby"> beta/rhoa*(liftCoeff - <span class="constant">Cvm</span>*rhob*<span class="constant">DDtUb</span>)</span><br><span class="line"></span>        );</span><br></pre></td></tr></table></figure>
<p><code>fvm::Sp(beta/rhoa*K, Ua)</code>对应 $\frac{\alpha_b}{\rho_a} K U_a$，<code>beta/rhoa*(liftCoeff - Cvm*rhob*DDtUb)</code> 对应<br>$$<br>\frac{\alpha_b}{\rho_a} \left\{ {C_l (\alpha_b \rho_b + \alpha_a \rho_a) U_r \times (\nabla \times U) -  C_{vm}\rho_b\left[ {\frac{\partial U_b}{\partial t} + U_b \cdot \nabla U_b }\right] } \right\}<br>$$<br>其中变量<code>liftCoeff</code>定义为<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">volVectorField</span> <span class="tag">liftCoeff</span>(<span class="tag">Cl</span>*(<span class="tag">beta</span>*<span class="tag">rhob</span> + <span class="tag">alpha</span>*<span class="tag">rhoa</span>)*(<span class="tag">Ur</span> ^ <span class="rule"><span class="attribute">fvc</span>:<span class="value">:<span class="function">curl</span>(U)))</span></span>;</span><br></pre></td></tr></table></figure></p>
<p><code>DDtUb</code>定义为<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DDtUb =</span><br><span class="line">        fvc::ddt(Ub)</span><br><span class="line">      + fvc::div(phib, Ub)</span><br><span class="line">      - fvc::div(phib)*Ub;</span><br></pre></td></tr></table></figure></p>
<p>重力 $g$ 以及曳力的显式项 $\frac{\alpha_b}{\rho_a} K U_b $ 如注释所述，将会在 <code>pEqn</code> 中考虑，压力梯度项 $\frac{\nabla p}{\rho_a}$ 则将在 <code>pEqn</code> 中用来约束两相的连续性。<br>至此动量方程的每一项都与<code>UEqn.H</code>的代码对应起来了。</p>
<h3 id="2-2-_pEqn">2.2. pEqn</h3><p>压力方程的作用是修正两相速度$U_a$ 和 $U_b$以使速度满足连续性方程。将两相的连续性方程加起来，得到总体的连续性方程如下 <strong>[ <em>注四</em> ]</strong>：<br>$$\begin{aligned}<br>&amp; \frac{\partial \alpha_a}{\partial t} + \nabla \cdot (\alpha_a U_a) + \frac{\partial \alpha_b}{\partial t} + \nabla \cdot (\alpha_b U_b) \\<br>= &amp; \frac{\partial (\alpha_a+\alpha_b)}{\partial t} + \nabla \cdot (\alpha_a U_a+\alpha_b U_b) = 0<br>\end{aligned}$$<br>由于$\alpha_a+\alpha_b=1$，于是两相连续性方程等价于<br>$$<br>\nabla \cdot (\alpha_a U_a+\alpha_b U_b) = 0<br>$$</p>
<p>再来看压力方程是如何构建起来的。<br>完整的动量方程离散后，可以写作如下的统一形式：<br>$$<br>a_{p,a}U_{p,a}=H(U_a)-\frac{\nabla p}{\rho_a}+\frac{\alpha_b}{\rho_a} K U_b +g<br>$$</p>
<p>$$<br>a_{p,b}U_{p,b}=H(U_b)-\frac{\nabla p}{\rho_b}+\frac{\alpha_a}{\rho_b} K U_a +g<br>$$<br>其中$H(U_a)$ 和 $H(U_b)$ 包含了动量方程中除 压力梯度项，显式曳力项以及重力项以后所有项的贡献。<br>由此离散方程可以得到 $U_a$ 和 $U_b$ 的表达式如下：<br>$$<br>U_{a}=\frac{1}{a_{p,a}}H(U_a)-\frac{\nabla p}{a_{p,a}\rho_a}+\frac{\alpha_b}{ a_{p,a} \rho_a} K U_b +\frac{1}{a_{p,a}} g<br>$$</p>
<p>$$<br>U_{b}=\frac{1}{a_{p,b}}H(U_b)-\frac{\nabla p}{a_{p,b}\rho_b}+\frac{\alpha_a}{ a_{p,b} \rho_b} K U_a +\frac{1}{a_{p,b}} g<br>$$</p>
<p>如果此 $U_a$ 和 $U_b$ 是方程组的解，那么它们必须满足整体的连续性方程，即<br>$$\begin{aligned}<br>&amp; \nabla \cdot \left[ \alpha_a (\frac{1}{a_{p,a}}H(U_a)-\frac{\nabla p}{a_{p,a}\rho_a}+\frac{\alpha_b}{ a_{p,a} \rho_a} K U_b +\frac{1}{a_{p,a}} g)\right] \\<br>+ &amp; \nabla \cdot \left[ \alpha_b (\frac{1}{a_{p,b}}H(U_b)-\frac{\nabla p}{a_{p,b}\rho_b}+\frac{\alpha_a}{ a_{p,b} \rho_b} K U_a +\frac{1}{a_{p,b}} g ) \right] = 0<br>\end{aligned}$$<br>将压力梯度项移到方程的一边，得到<br>$$\begin{aligned}<br>&amp; \nabla \cdot \left[ \alpha_a (\frac{1}{a_{p,a}}H(U_a)+\frac{\alpha_b}{ a_{p,a} \rho_a} K U_b +\frac{1}{a_{p,a}} g)\right] + \nabla \cdot \left[ \alpha_b (\frac{1}{a_{p,b}}H(U_b)+\frac{\alpha_a}{ a_{p,b} \rho_b} K U_a +\frac{1}{a_{p,b}} g ) \right] \\<br>= &amp;\nabla \cdot \left[ (\frac{\alpha_a }{a_{p,a}\rho_a} + \frac{\alpha_b }{a_{p,b}\rho_b})  \nabla p \right ]<br>\end{aligned}$$<br><strong>这便是压力修正方程的原型</strong>。<br>在<code>pEqn.H</code>中，压力方程其实修正的是界面通量，压力方程迭代收敛以后能保证界面通量的连续性。所以，散度表达式需要根据高斯定理写成界面通量之和的形式：<br>$$\begin{aligned}<br>&amp; \nabla \cdot \left[ \alpha_a (\frac{1}{a_{p,a}}H(U_a)+\frac{\alpha_b}{ a_{p,a} \rho_a} K U_b +\frac{1}{a_{p,a}} g)\right] \\<br>= &amp; (\alpha_a)_f \left[\sum_f(\frac{1}{a_{p,a}})_f H(U_a)\cdot S_f + \sum_f(\frac{\alpha_b K}{ a_{p,a} \rho_a})_f U_b \cdot S_f +\sum_f(\frac{1}{a_{p,a}})_f g \cdot S_f \right ]<br>\end{aligned}$$<br>下标 $_f$ 表示该项将要在代码中用界面上的变量来表示，在OpenFOAM中，即<code>surfaceScalarField</code>，$S_f$ 表示界面的面积矢量，下面的公式里也是一样。<br>$$\begin{aligned}<br>&amp; \nabla \cdot \left[ \alpha_b (\frac{1}{a_{p,b}}H(U_b)+\frac{\alpha_a}{ a_{p,b} \rho_b} K U_a +\frac{1}{a_{p,b}} g)\right] \\<br>= &amp; (\alpha_b)_f \left[\sum_f(\frac{1}{a_{p,b}})_f H(U_b)\cdot S_f + \sum_f(\frac{\alpha_a K}{ a_{p,b} \rho_b})_f U_a \cdot S_f +\sum_f(\frac{1}{a_{p,b}})_f g \cdot S_f \right]<br>\end{aligned}$$</p>
<p>以及<br>$$<br> \nabla \cdot \left[ (\frac{\alpha_a }{a_{p,a}\rho_a} + \frac{\alpha_b }{a_{p,b}\rho_b})  \nabla p \right ] = \sum_f (\frac{\alpha_a }{a_{p,a}\rho_a} + \frac{\alpha_b }{a_{p,b}\rho_b})_f (\nabla p) \cdot S_f<br>$$<br>下面是<code>pEqn</code>定义了几个跟界面通量有关的变量：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">surfaceScalarField alphaf(fvc::interpolate(alpha));</span><br><span class="line">surfaceScalarField betaf(scalar(<span class="number">1</span>) - alphaf);</span><br><span class="line"></span><br><span class="line">volScalarField rUaA(<span class="number">1.0</span>/UaEqn.A());</span><br><span class="line">volScalarField rUbA(<span class="number">1.0</span>/UbEqn.A());</span><br><span class="line"></span><br><span class="line">phia == (fvc::interpolate(Ua) &amp; mesh.Sf());</span><br><span class="line">phib == (fvc::interpolate(Ub) &amp; mesh.Sf());</span><br><span class="line"></span><br><span class="line">rUaAf = fvc::interpolate(rUaA);</span><br><span class="line">surfaceScalarField rUbAf(fvc::interpolate(rUbA));</span><br><span class="line"></span><br><span class="line">Ua = rUaA*UaEqn.H();</span><br><span class="line">Ub = rUbA*UbEqn.H();</span><br><span class="line"></span><br><span class="line">surfaceScalarField phiDraga</span><br><span class="line">(</span><br><span class="line">    fvc::interpolate(beta/rhoa*K*rUaA)*phib + rUaAf*(g &amp; mesh.Sf())</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">surfaceScalarField phiDragb</span><br><span class="line">(</span><br><span class="line">    fvc::interpolate(alpha/rhob*K*rUbA)*phia + rUbAf*(g &amp; mesh.Sf())</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">phia = (fvc::interpolate(Ua) &amp; mesh.Sf()) + fvc::ddtPhiCorr(rUaA, Ua, phia) + phiDraga;</span><br><span class="line">phib = (fvc::interpolate(Ub) &amp; mesh.Sf()) + fvc::ddtPhiCorr(rUbA, Ub, phib) + phiDragb;</span><br><span class="line"></span><br><span class="line">phi = alphaf*phia + betaf*phib;</span><br><span class="line"></span><br><span class="line">surfaceScalarField Dp</span><br><span class="line">(</span><br><span class="line">    <span class="string">"(rho*(1|A(U)))"</span>,</span><br><span class="line">    alphaf*rUaAf/rhoa + betaf*rUbAf/rhob</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p><code>phiDraga</code> 和 <code>phiDragb</code> 分别对应 $(\frac{\alpha_b K}{ a_{p,a} \rho_a})_f U_b \cdot S_f +(\frac{1}{a_{p,a}})_f g \cdot S_f$ 和 $(\frac{\alpha_a K}{ a_{p,b} \rho_b})_f U_a \cdot S_f +(\frac{1}{a_{p,b}})_f g \cdot S_f$</p>
<p>由于13-14行的定义，28-29行中的 <code>(fvc::interpolate(Ua) &amp; mesh.Sf())</code> 和 <code>(fvc::interpolate(Ub) &amp; mesh.Sf())</code> 便分别对应的是 $(\frac{1}{a_{p,a}})_f H(U_a)\cdot S_f$ 和 $(\frac{1}{a_{p,b}})_f H(U_b)\cdot S_f$ 。</p>
<p>有了上面的定义，可以看出31行定义的<code>phi=alphaf*phia + betaf*phib</code>便表示了压力方程的左边。</p>
<p>再看33-36行定义的<code>Dp</code>，很显然，表示的是压力方程右边的$(\frac{\alpha_a }{a_{p,a}\rho_a} + \frac{\alpha_b }{a_{p,b}\rho_b})_f$。</p>
<p>有了以上的定义，便可以构建用于修正界面通量的压力方程了：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fvScalarMatrix pEqn</span><br><span class="line">  <span class="list">(</span><br><span class="line">     <span class="keyword">fvm</span>:<span class="keyword">:laplacian</span><span class="list">(<span class="keyword">Dp</span>, p)</span> == fvc:<span class="keyword">:div</span><span class="list">(<span class="keyword">phi</span>)</span></span><br><span class="line">  )</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>如上所述，<code>pEqn</code>收敛以后，得到的就是满足连续性的界面通量了，然后再利用求得的界面通量来修正两相的速度，便得到了满足两相连续性的速度：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Ua += fvc::reconstruct(phiDraga - rUaAf<span class="keyword">*</span>SfGradp/rhoa);</span><br><span class="line">Ua.correctBoundaryConditions();</span><br><span class="line"></span><br><span class="line">Ub += fvc::reconstruct(phiDragb - rUbAf<span class="keyword">*</span>SfGradp/rhob);</span><br><span class="line">Ub.correctBoundaryConditions();</span><br><span class="line"></span><br><span class="line">U = alpha<span class="keyword">*</span>Ua + beta<span class="keyword">*</span>Ub;</span><br></pre></td></tr></table></figure></p>
<p>注意，<code>Ua</code>和<code>Ub</code>为什么是这样来修正呢？回想上面变量定义那个代码段的13-14行，这两行将<code>Ua</code>和<code>Ub</code>分别定义成了$\frac{1}{a_{p,a}} H(U_a)$ 和 $\frac{1}{a_{p,b}} H(U_b)$。<br>回想<code>Ua</code>和<code>Ub</code>的离散方程的统一形式<br>$$<br>U_{a}=\frac{1}{a_{p,a}}H(U_a)-\frac{\nabla p}{a_{p,a}\rho_a}+\frac{\alpha_b}{ a_{p,a} \rho_a} K U_b +\frac{1}{a_{p,a}} g<br>$$</p>
<p>$$<br>U_{b}=\frac{1}{a_{p,b}}H(U_b)-\frac{\nabla p}{a_{p,b}\rho_b}+\frac{\alpha_a}{ a_{p,b} \rho_b} K U_a +\frac{1}{a_{p,b}} g<br>$$</p>
<p>会发现13-14行定义的<code>Ua</code>和<code>Ub</code>都少了几项，所以缺了的这几项的贡献需要在速度修正步骤加回来，而<code>Ua+=</code>后面的<code>fvc::reconstruct(phiDraga - rUaAf*SfGradp/rhoa)</code>刚好就对应着<code>Ua</code>缺少的那几项。因为经过压力方程修正以后，界面通量是连续的，所以，将缺失的几项对应的界面通量通过<code>reconstruct</code>函数从界面通量重构从对体中心的速度的贡献，便得到了满足连续性的体中心速度了。对<code>Ub</code>也是同样的。</p>
<p>经过以上步骤，便能得到满足整体连续性的两相速度<code>Ua</code> 和 <code>Ub</code>了。</p>
<h2 id="注释">注释</h2><p><strong>注一</strong>：OpenFOAM 里的<code>div</code>函数，字面意义上看起来好像是散度的意思，实际上，<code>div</code>函数执行的是<strong>加和</strong>运算。举例说，对于<code>fvc::div(phia)</code>，<code>phia</code>是<code>surfaceScalarField</code>，其值为<code>(fvc::interpolate(Ua) &amp; mesh.Sf())</code>，即将存储在体中心的<code>Ua</code>插值到每个网格对应的面的面心，然后用面心的速度与该面的面积矢量点乘。从代码中看，<code>fvc::div(phia)</code>对应的是 $\nabla \cdot U_a$，根据高斯定理，也就是 $\sum_f (U_a)_f \cdot S_f$，而<code>phia</code>对应着 $(U_a)_f \cdot S_f$，所以，<code>fvc::div(phia)</code>实际进行的运算是将包围每个网格的面上的通量加起来。更详细的说明见我的<a href="http://xiaopingqiu.github.io/2015/05/17/OpenFOAMcode1/" target="_blank" rel="external">另一篇博文</a>。<br><strong>注二</strong>：注意这里的$\frac{\nabla \alpha_a}{\alpha_a}$ 在代码中的表示方法，详细说明见我的<a href="http://xiaopingqiu.github.io/2015/05/17/OpenFOAMcode1/" target="_blank" rel="external">另一篇博文</a>。<br><strong>注三</strong>：注意这里的$\frac{\nabla \alpha_a}{\alpha_a}$ 在代码中的表示方法，以及与上一个$\frac{\nabla \alpha_a}{\alpha_a}$ 的区别，详细说明见我的<a href="http://xiaopingqiu.github.io/2015/05/17/OpenFOAMcode1/" target="_blank" rel="external">另一篇博文</a>。<br><strong>注四</strong>：这里说的总体的连续性方程指的是<strong>总体体积的守恒</strong>，而不是总体质量的守恒，这二者的差异见Henrik Rusche 的 PHD 论文 P112 的说明。</p>
<h2 id="参考资料">参考资料</h2><ol>
<li>Henrik Rusche， PHD Thesis， Computational Fluid Dynamics of Dispersed Two-Phase Flows at High Phase Fractions， Imperial College of Science, Technology &amp; Medicine, Department of Mechanical Engineering, 2002</li>
<li><a href="https://openfoamwiki.net/index.php/BubbleFoam" target="_blank" rel="external">https://openfoamwiki.net/index.php/BubbleFoam</a></li>
<li><a href="http://www.cfd-online.com/Forums/openfoam-solving/71141-rewriting-twophaseeulerfoam-conservative-form.html" target="_blank" rel="external">http://www.cfd-online.com/Forums/openfoam-solving/71141-rewriting-twophaseeulerfoam-conservative-form.html</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>本系列将对OpenFOAM-2.1.1 中的 <code>twoPhaseEulerFoam</code> 求解器进行完全解读，共分三部分：方程推导，代码解读，补充说明。本篇对 <code>twoPhaseEulerFoam</code> 中的 <code>UEqn.H</code> 和 <code>pEqn.H</code> 中的代码进行详细地的解读。</p>]]>
    
    </summary>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/tags/OpenFOAM/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[twoPhaseEulerFoam 全解读之一]]></title>
    <link href="http://xiaopingqiu.github.io/2015/05/17/twoPhaseEulerFoam1/"/>
    <id>http://xiaopingqiu.github.io/2015/05/17/twoPhaseEulerFoam1/</id>
    <published>2015-05-17T06:46:07.000Z</published>
    <updated>2015-05-17T07:16:05.037Z</updated>
    <content type="html"><![CDATA[<p>本系列将对OpenFOAM-2.1.1 中的 <code>twoPhaseEulerFoam</code> 求解器进行完全解读，共分三部分：方程推导，代码解读，补充说明。本篇进行方程推导，详细介绍如果从双流体模型出发得到 <code>twoPhaseEulerFoam</code> 中的 <code>UEqn.H</code> 对应的模型方程形式。</p>
<a id="more"></a>
<h2 id="1-_方程推导">1. 方程推导</h2><p>双流体模型方程可以表达成如下形式：</p>
<p><strong>连续性方程</strong>：<br>$$\frac{\partial(\alpha_\phi\rho_\phi)}{\partial t}+\nabla\cdot(\alpha_\phi\rho_\phi U_\phi)=0$$<br><strong>动量守恒方程</strong>:<br>$$\frac{\partial(\alpha_\phi\rho_\phi U_\phi)}{\partial t}+\nabla\cdot(\alpha_\phi\rho_\phi U_\phi U_\phi)+\nabla\cdot(\alpha_\phi\tau_\phi)+\nabla\cdot(\alpha_\phi\rho_\phi R_\phi )=-\alpha_\phi\nabla p+\alpha_\phi\rho_\phi g+M_\phi$$<br>式中，下标$\phi=a,b$分别代表分散相和连续相，$\tau_\phi$表示粘性应力项，$R_\phi$表示雷诺应力项，$M_\phi$表示相间作用项。<br>上述方程是完全守恒形式的，但是注意到上述动量方程的瞬变项是$\frac{\partial(\alpha_\phi\rho_\phi U_\phi)}{\partial t}$，等于说解这个方程能得到的是每个时间步的动量，若要转化成速度，则需要用动量除以密度与体积分率的乘积，即$\frac{(\alpha_\phi\rho_\phi U_\phi)}{\alpha_\phi\rho_\phi}$。那么当离散相a的体积分率$\alpha_a\to0$时，这个除法就要出问题了。于是，Weller [1] 提出通过构造一种”phase-intensive”形式的动量方程来避开这个问题，见下面的详细推导。<br>Weller提出的方法的核心是将$\alpha_\phi\rho_\phi$从动量方程的瞬变项中剥离出来，以使动量方程直接对速度进行演化，而不是动量。<br>首先对动量方程的瞬变项和对流项进行如下转化：<br>$$\frac{\partial(\alpha_\phi\rho_\phi U_\phi)}{\partial t}=\alpha_\phi\rho_\phi\frac{\partial( U_\phi)}{\partial t}+U_\phi\frac{\partial(\alpha_\phi\rho_\phi )}{\partial t}$$</p>
<p>$$\nabla\cdot(\alpha_\phi\rho_\phi U_\phi U_\phi)= \alpha_\phi\rho_\phi U_\phi\cdot \nabla( U_\phi) + U_\phi\nabla\cdot(\alpha_\phi\rho_\phi  U_\phi)$$<br>注：这里到了张量运算公式$[\nabla\cdot \mathbf{vw}]=[\mathbf{v}\cdot\nabla\mathbf{w}]+\mathbf{w}(\nabla\cdot\mathbf{v})$，具体可参考 Bird 的 Transport Phenomenon 的 Appendix A。</p>
<p>于是，瞬变项和对流项的加和可以写成如下形式：<br>$$\frac{\partial(\alpha_\phi\rho_\phi U_\phi)}{\partial t}+\nabla\cdot(\alpha_\phi\rho_\phi U_\phi U_\phi)=\alpha_\phi\rho_\phi\left[\frac{\partial( U_\phi)}{\partial t}+U_\phi \cdot \nabla( U_\phi)\right]+U_\phi \left[ \frac{\partial(\alpha_\phi\rho_\phi )}{\partial t}+\nabla\cdot(\alpha_\phi\rho_\phi  U_\phi)\right]$$<br>注意右边第二项的括号里其实就是连续性方程的左边，其值为0，因此得到：<br>$$\frac{\partial(\alpha_\phi\rho_\phi U_\phi)}{\partial t}+\nabla\cdot(\alpha_\phi\rho_\phi U_\phi U_\phi) = \alpha_\phi\rho_\phi\left[\frac{\partial( U_\phi)}{\partial t}+U_\phi \cdot \nabla( U_\phi)\right]$$</p>
<p>于是得到第一步转化之后的动量方程：<br>$$\alpha_\phi\rho_\phi\left[\frac{\partial( U_\phi)}{\partial t}+U_\phi\cdot\nabla( U_\phi)\right] + \nabla\cdot(\alpha_\phi\tau_\phi) + \nabla\cdot(\alpha_\phi\rho_\phi R_\phi ) = -\alpha_\phi\nabla p + \alpha_\phi\rho_\phi g + M_\phi$$</p>
<p>下面处理粘性应力项和雷诺应力项。</p>
<p>$$\nabla\cdot(\alpha_\phi\tau_\phi) + \nabla\cdot(\alpha_\phi\rho_\phi R_\phi )=\nabla\cdot\left[\alpha_\phi\rho_\phi(\frac{\tau_\phi}{\rho_\phi}+R_\phi)\right] = \nabla\cdot\left[\alpha_\phi\rho_\phi R_{eff,\phi}\right ]$$</p>
<p>其中 $R_{eff,\phi}=\frac{\tau_\phi}{\rho_\phi}+R_\phi$。</p>
<p>根据定义(此处参考<a href="https://openfoamwiki.net/index.php/BubbleFoam" target="_blank" rel="external">BubbleFoam的Wiki页面</a>)：<br>$$<br>\boldsymbol{\tau}_{\phi} = - \rho_{\phi} \nu_{\phi} \left[\nabla \mathbf{U}_{\phi} + \nabla^{\textrm{T}} \mathbf{U}_{\phi} \right] + \frac{2}{3}\rho_{\phi}\nu_{\phi} \left( \nabla \cdot \mathbf{U}_{\phi} \right) \mathbf{I}<br>$$<br>以及<br>$$<br>\mathbf{R}_{\phi} = -  \nu_{\phi,\textrm{t}} \left[ \nabla \mathbf{U}_{\phi} +\nabla^{\textrm{T}} \mathbf{U}_{\phi} \right] + \frac{2}{3}  \nu_{\phi,\textrm{t}} \left( \nabla \cdot \mathbf{U}_{\phi} \right) \mathbf{I} + \frac{2}{3} k_{\phi} \mathbf{I}<br>$$<br>代入到 $R_{eff,\phi}$中，得：<br>$$R_{eff,\phi}=-(\nu_\phi+\nu_{\phi , t})\left[ \nabla \mathbf{U}_{\phi} +\nabla^{\textrm{T}} \mathbf{U}_{\phi} \right]+\frac{2}{3}(\nu_\phi+\nu_{\phi , t}) \left (\nabla \cdot \mathbf{U}_{\phi}\right )  \mathbf{I} + \frac{2}{3} k_{\phi} \mathbf{I}$$<br>令 $\nu_{eff}=\nu_\phi+\nu_{\phi , t}$ ，则：<br>$$<br>R_{eff,\phi}=-\nu_{eff}\left[ \nabla \mathbf{U}_{\phi} +\nabla^{\textrm{T}} \mathbf{U}_{\phi} \right]+\frac{2}{3}\nu_{eff}<br>\left (\nabla \cdot \mathbf{U}_{\phi}\right )  \mathbf{I} + \frac{2}{3} k_{\phi} \mathbf{I} = -\nu_{eff}\nabla U_\phi + R_{c,\phi}<br>$$<br>其中$$R_{c,\phi}=-\nu_{eff} \nabla \mathbf{U}^\textrm{T}_{\phi}+\frac{2}{3}\nu_{eff}<br>\left (\nabla \cdot \mathbf{U}_{\phi}\right )  \mathbf{I} + \frac{2}{3} k_{\phi} \mathbf{I}$$</p>
<p>于是得到：<br> $$\begin{aligned}<br>\nabla\cdot\left[\alpha_\phi\rho_\phi R_{eff,\phi}\right ] = &amp; \nabla(\alpha_\phi\rho_\phi)\cdot\left[ R_{eff,\phi}\right] + \alpha_\phi\rho_\phi\nabla\cdot \left [ R_{eff,\phi}\right ]\\<br>=&amp; \alpha_\phi\rho_\phi\nabla\cdot\left[ -\nu_{eff}\nabla U_\phi\right] + \alpha_\phi\rho_\phi\nabla\cdot\left[ R_{c,\phi}\right] + \nabla(\alpha_\phi\rho_\phi)\left[ -\nu_{eff}\nabla U_\phi + R_{c,\phi}\right]<br>\end{aligned}<br> $$</p>
<p>代入到动量方程中，并且方程两边同时除以$\alpha_\phi\rho_\phi$，得到：<br> $$<br> \frac{\partial U_\phi}{\partial t} + U_\phi\cdot\nabla U_\phi -\nabla \cdot \left[ \nu_{eff} \nabla U_\phi \right ] + \nabla \cdot \left[ R_{c,\phi}\right] + \frac{\nabla(\alpha_\phi\rho_\phi)}{\alpha_\phi\rho_\phi}\cdot \left[ -\nu_{eff}\nabla U_\phi + R_{c,\phi}\right] = -\frac{\nabla p}{\rho_\phi} + g + \frac{M_\phi}{\alpha_\phi\rho_\phi}<br> $$</p>
<p>如果假定两相流体均为不可压缩，密度恒为常数，于是可以得到不可压缩的双流体模型的方程组：</p>
<p><strong>连续性方程</strong><br>$$\frac{\partial(\alpha_\phi)}{\partial t}+\nabla\cdot(\alpha_\phi U_\phi)=0$$</p>
<p><strong>动量方程</strong><br> $$<br> \frac{\partial U_\phi}{\partial t} + U_\phi\cdot\nabla U_\phi -\nabla \cdot \left[ \nu_{eff} \nabla U_\phi \right ] + \nabla \cdot \left[ R_{c,\phi}\right] + \frac{\nabla(\alpha_\phi)}{\alpha_\phi} \cdot \left[ -\nu_{eff}\nabla U_\phi + R_{c,\phi}\right] = -\frac{\nabla p}{\rho_\phi} + g + \frac{M_\phi}{\alpha_\phi\rho_\phi}<br> $$</p>
<p>方程中还剩下相间作用项没有处理，对于分散相和连续项形式，相间作用力是大小相等符号想反，这里只考虑分散相的形式，令$\phi=a$，则得到分散相的动量方程：<br>$$<br> \frac{\partial U_a}{\partial t} + U_a\cdot\nabla U_a -\nabla \cdot \left[ \nu_{eff} \nabla U_a \right ] + \nabla \cdot \left[ R_{c,a}\right] + \frac{\nabla(\alpha_a)}{\alpha_a} \cdot \left[ -\nu_{eff}\nabla U_a + R_{c,a}\right] = -\frac{\nabla p}{\rho_a} + g + \frac{M_a}{\alpha_a\rho_a}<br> $$</p>
<p> 相间作用只考虑曳力，升力以及虚拟质量力，即$M,a=M_{drag}+M_{lift}+M_{vm}$，下面分别考虑每一种相间作用力。</p>
<ul>
<li>曳力<br>$M_{drag}=-\beta(U_a-U_b)$，其中$\beta$为曳力系数。</li>
<li>升力<br>$M_{lift}=-\alpha_a\alpha_b C_l (\alpha_b \rho_b + \alpha_a \rho_a)U_r \times (\nabla \times U)$ ，其中 $U_r=U_a-U_b$，$U=\alpha_a U_a + \alpha_b U_b$</li>
<li>虚拟质量力<br>$M_{vm}=\alpha_a\alpha_b C_{vm}\rho_b\left[ \frac{DU_b}{Dt}-\frac{DU_a}{Dt}\right]$，其中$\frac{D}{Dt}$表示物质导数，$\frac{DU_b}{Dt}=\frac{\partial U_b}{\partial t} + U_b \cdot \nabla U_b$，$\frac{DU_a}{Dt}=\frac{\partial U_a}{\partial t}+U_a \cdot \nabla U_a$</li>
</ul>
<p>考虑到形式的统一，令$K=\frac{\beta}{\alpha_a\alpha_b}$，则曳力可表示为$M_{drag}=-\alpha_a\alpha_b K(U_a-U_b)$</p>
<p>代入到分散相a的动量方程中，得到：<br>$$\begin{aligned}<br>&amp;\frac{\partial U_a}{\partial t} + U_a\cdot \nabla U_a -\nabla \cdot \left[ \nu_{eff} \nabla U_a \right ] + \nabla \cdot \left[ R_{c,a}\right] + \frac{\nabla(\alpha_a)}{\alpha_a} \cdot \left[ -\nu_{eff}\nabla U_a + R_{c,a}\right] \\<br>= &amp; -\frac{\nabla p}{\rho_a} + g - \frac{\alpha_b}{\rho_a} K (U_a-U_b) - \frac{\alpha_b}{\rho_a}<br> C_l (\alpha_b \rho_b + \alpha_a \rho_a) U_r \times (\nabla \times U) \\<br> +&amp;  \frac{\alpha_b}{\rho_a} C_{vm}\rho_b\left[ \frac{\partial U_b}{\partial t} + U_b \cdot \nabla U_b - (\frac{\partial U_a}{\partial t}+U_a \cdot \nabla U_a)\right]<br> \end{aligned}$$</p>
<p>将相关的项合并，并调整顺序，便得到与<code>twoPhaseEulerFoam</code>求解器的<code>UEqn.H</code>文件中相同形式的分散相动量方程：<br>$$<br>\begin{aligned}<br>&amp;(1+\frac{\alpha_b \rho_b}{\rho_a} C_{vm})(\frac{\partial U_a}{\partial t} + U_a\cdot \nabla U_a ) -\nabla \cdot \left[ \nu_{eff} \nabla U_a \right ] + \nabla \cdot \left[ R_{c,a}\right] + \frac{\nabla(\alpha_a)}{\alpha_a} \cdot \left[ -\nu_{eff}\nabla U_a + R_{c,a}\right] \\<br>= &amp; -\frac{\alpha_b}{\rho_a} K U_a - \frac{\alpha_b}{\rho_a} \left\{ {C_l (\alpha_b \rho_b + \alpha_a \rho_a) U_r \times (\nabla \times U) -  C_{vm}\rho_b\left[ {\frac{\partial U_b}{\partial t} + U_b \cdot \nabla U_b }\right] } \right\} \\<br>- &amp; \frac{\nabla p}{\rho_a} + g + \frac{\alpha_b}{\rho_a} K U_b<br>\end{aligned}<br>$$</p>
<p>连续相b的动量方程形式相仿，这里就不再重复了。这里有几点<strong>注意事项</strong>：</p>
<ol>
<li>此处的双流体模型在推导的过程中，是把a当作分散相，b当作连续相的。分散相的体积分率$\alpha_a$可以等于0，但是连续项体积分率$\alpha_b$不能等于0 ，否则会出问题。</li>
<li>曳力系数 $\beta$ 的形式就是文献中常见的形式，比如，WenYu 曳力系数 $\beta=\frac{3}{4}\frac{(1-\alpha_b)\alpha_b}{d_{p,a}}|U_b-U_a|C_{D0}\alpha_b^{-2.7}$，Ergun 曳力系数 $\beta=150\frac{(1-\alpha_b)^2\mu_b}{\alpha_b d_a^2}+1.75\frac{(1-\alpha_b)\rho_b{U_b-U_a}}{d_a}$。而程序中定义的$K=\frac{\beta}{\alpha_a\alpha_b}$，所以，当$\alpha_b\to 0$时，如果用WenYu曳力那还不会出错，因为曳力系数中的分子里同时含有$\alpha_a\alpha_b$，运算$K=\frac{\beta}{\alpha_a\alpha_b}$不会出现除以0的问题；但如果用Ergun曳力，那就要出问题了，因为Ergun曳力系数中两项的分子都没有$\alpha_b$，所以运算$K=\frac{\beta}{\alpha_a\alpha_b}$就要出问题了。</li>
</ol>
<h2 id="参考资料">参考资料</h2><ol>
<li>Henrik Rusche， PHD Thesis， Computational Fluid Dynamics of Dispersed Two-Phase Flows at High Phase Fractions， Imperial College of Science, Technology &amp; Medicine, Department of Mechanical Engineering, 2002</li>
<li><a href="https://openfoamwiki.net/index.php/BubbleFoam" target="_blank" rel="external">https://openfoamwiki.net/index.php/BubbleFoam</a></li>
<li><a href="http://dyfluid.com/pdf/%E5%8F%8C%E6%B5%81%E4%BD%93%E6%A8%A1%E5%9E%8B%E5%9C%A8OpenFOAM%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90.pdf" target="_blank" rel="external">http://dyfluid.com/pdf/%E5%8F%8C%E6%B5%81%E4%BD%93%E6%A8%A1%E5%9E%8B%E5%9C%A8OpenFOAM%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90.pdf</a></li>
<li><a href="http://www.cfd-online.com/Forums/openfoam-solving/71141-rewriting-twophaseeulerfoam-conservative-form.html" target="_blank" rel="external">http://www.cfd-online.com/Forums/openfoam-solving/71141-rewriting-twophaseeulerfoam-conservative-form.html</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>本系列将对OpenFOAM-2.1.1 中的 <code>twoPhaseEulerFoam</code> 求解器进行完全解读，共分三部分：方程推导，代码解读，补充说明。本篇进行方程推导，详细介绍如果从双流体模型出发得到 <code>twoPhaseEulerFoam</code> 中的 <code>UEqn.H</code> 对应的模型方程形式。</p>]]>
    
    </summary>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/tags/OpenFOAM/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenFOAM 中的 div 与 snGrad 操作符]]></title>
    <link href="http://xiaopingqiu.github.io/2015/05/17/OpenFOAMcode1/"/>
    <id>http://xiaopingqiu.github.io/2015/05/17/OpenFOAMcode1/</id>
    <published>2015-05-17T06:02:37.000Z</published>
    <updated>2015-06-03T02:54:38.137Z</updated>
    <content type="html"><![CDATA[<p>OpenFOAM 的方便之处之一是利用<code>C++</code>的类模板和函数重载等技术定义了很多各种离散操作符，如<code>div</code>,<code>laplacian</code>,<code>grad</code> 等等。利用这些操作符，很容易就能对偏微分方程进行离散，并构建起线性方程组。但是，这些操作符真正执行的运算，却需要结合有限体积方法的本质来理解一番才能真正掌握。下面尝试着对 OpenFOAM 中的 <code>div</code> 和 <code>snGrad</code> 操作符进行一点解读。</p>
<a id="more"></a>
<h3 id="1-_div_操作符的本质">1. div 操作符的本质</h3><p> <code>div</code>操作符表面看，是计算散度的，实际上，在OpenFAOM中，div 操作符的作用是<strong>加和</strong>，比如说 $ \nabla \cdot (UU)$，在OpenFOAM中表示为<code>fvm::div(phi,U)</code>，这段代码真正执行的是$\sum_f U_f \phi_f$运算，即将每个网格包含的面上的流率与速度乘积，然后再加起来。再比如，<code>twoPhaseEulerFoam</code>的<code>UaEqn</code>方程有一项是<code>fvm::sp(fvc::div(phia),Ua)</code>，其对应的公式是 $U_a(\nabla \cdot U_a)$。为什么是这样呢？以下试图对背后的原理做一点解释：<br>单相流的动量守恒方程的微分形式如下：<br>$$\frac{\partial U}{\partial t}+\nabla\cdot (UU)+\nabla \cdot dev(-\nu_{eff} (\nabla U+(\nabla U)^T))=-\nabla p +Q$$<br>为了使用有限体积方法，需要将动量方程写成积分形式，即<br>$$\int_V\left [\frac{\partial U}{\partial t}+\nabla\cdot (UU)+\nabla \cdot dev(-\nu_{eff} (\nabla U+(\nabla U)^T))\right ]dV=\int_V\left [ -\nabla p +Q \right ]dV$$<br>这里只分析$\int_V \nabla\cdot (UU) dV$这一项，利用高斯定理，可以将这一个体积分，转化成对包围该体积微元的表面的面积分:$\oint_{\partial V} (UU)\cdot dS$，其中 $dS$ 是面积微元矢量。又因为实际操作中，一个体积微元总是由有限的几个面组成的，所以$$\oint_{\partial V} (UU)\cdot dS=\sum_f\int_{S_f}(UU)\cdot dS_f=\sum_f(UU)_f\cdot S_f$$，其中$$(UU)_f=\frac{1}{mag(S_f)}\int_{S_f}(UU)\cdot dS_f$$。<br>这里做一个近似：$$(UU)_f\approx(U_fU_f)$$<br>于是得到$$\sum_f(UU)_f\cdot S_f\approx \sum_f(U_fU_f)\cdot S_f$$<br>运用张量计算规则$[\mathbf{uv}\cdot\mathbf{w}]=\mathbf{u}(\mathbf{v} \cdot \mathbf{w})$，得到<br>$$\sum_f(U_fU_f)\cdot S_f=\sum_fU_f(U_f\cdot S_f)=\sum_fU_f\phi_f$$<br>综上，OpenFOAM中的代码<code>fvm::div(UU)</code>对应的公式其实是$\int_V \nabla\cdot (UU) dV$，而根据推导，在有限体积方法中 $\int_V \nabla\cdot (UU) dV=\sum_f(U_f\phi_f)$，所以，<code>fvm::div(UU)</code>实质上<strong>进行的运算是，把网格当作体积微元，将网格中心的速度 $U$ 插值到包围该网格的所有面上的面心上得到 $U_f$，并计算每个面上的速度通量 $\phi_f$，然后返回每一个面上的速度与通量乘积的加和</strong>。$U_f$的计算需要用到本网格与邻近网格的速度值，离散格式的作用就体现在如果利用本网格与邻近网格的速度得到面上的速度。</p>
<p> 再来看上面提到的另一项$U_a(\nabla \cdot U_a)$，根据上面类似的推导<br>$$\int_V\left [ U_a(\nabla \cdot U_a)\right ]dV=U_a\int_V(\nabla \cdot U_a)dV$$<br>注意，这里之所以能这样变换，是因为在一个体积微元dV内，Ua是常数。根据高斯定理<br>$$\int_V(\nabla \cdot U_a)dV=\oint_{\partial V}U_a\cdot dS=\sum_f(U_a)_f\cdot S_f=\sum_f(\phi_a)_f$$<br>于是得到<br>$$\int_V\left [ U_a(\nabla \cdot U_a)\right ]dV=U_a\sum_f(\phi_a)_f$$<br>这一项在OpenFOAM中的表达是<code>fvm::sp(fvc::div(phia),Ua)</code>，含义就很明显了,这一项相当于是一个系数与需要求解的量$U_a$的乘积，所以被当作隐式的源项来处里。注意我先前以为把$(\nabla \cdot U_a)$当作显式处理是人为简化的结果，其实不然，这是自然而然的结果。而在这里也可以看出，$\sum_f(\phi_a)_f$对应的代码是<code>fvc::div(phia)</code>，也印证了上面的观点，即<code>div</code>操作符<strong>本质上是在作加和运算</strong>。</p>
<h3 id="2-_grad_与_snGrad">2. grad 与 snGrad</h3><p>在<code>twoPhaseEulerFoam</code>中，$\frac{\nabla \alpha}{\alpha}$在两个不同的地方用了两种不同的表示。<br>$$<br>\nabla \cdot \left \{ [\nu_{eff,a} \frac{\nabla \alpha}{\alpha}][U_a] \right \}<br>$$<br>对应的代码是：<code>fvm::div(phiRa,Ua)</code>，其中<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">phiRa=-fvc::interpolate(nuEffa)*mesh.magSf()*fvc::snGrad(alpha)</span><br><span class="line">     /fvc::interpolate(alpha + scalar(0.001));</span><br></pre></td></tr></table></figure></p>
<p>而另一项<br>$$[\frac{\nabla \alpha }{\alpha}]\cdot{Rca}$$<br>对应的代码是<code>fvc::grad(alpha)/fvc::average(alpha + scalar(0.001)) &amp; Rca</code></p>
<p> <strong>下面是我对这个的理解</strong>：<br>对于<br>$$<br>\nabla \cdot \left \{ [\nu_{eff,a} \frac{\nabla \alpha}{\alpha}][U_a] \right \}<br>$$</p>
<p>其处理方法跟$\nabla \cdot(U_aU_a)$是一样的，因为$ \frac{\nabla \alpha}{\alpha}$也是一个矢量。<code>phiRa</code>相当于是 $\left [\nu_{eff,a} \frac{\nabla \alpha}{\alpha} \right ]$这个矢量的界面通量，类比于<code>phia</code>。<code>phia</code>的定义是<code>linearInterpolate(Ua) &amp; mesh.Sf()</code>，而<code>phiRa</code>理论上应该也可以定义成类似于<code>linearInterpolate(gradalpha) &amp; mesh.Sf()</code>，前提是要先定义一个 <code>volVectorField gradalpha=-nuEffa*fvc::grad(alpha)/alpha</code>。但是考虑到界面通量本质上是先将一个<code>volVectorField</code>插值到面上，并乘以面积矢量，对于 $\frac{\nabla \alpha}{\alpha}$，完全可以直接求出每个面上的$\frac{\nabla \alpha}{\alpha}$，然后乘以面积矢量，而不需要先建立体中心的$\frac{\nabla \alpha}{\alpha}$再插值到面上。<code>snGrad</code>就是这样一个用来求面上的梯度量的函数，它求解面上的梯度时，采用如下公式：<br>$$(\nabla \phi)_f=\frac{\phi_N-\phi_P}{|\mathbf{d}|}$$<br>即用相邻网格的值减去面所属网格的值，再除以两个网格中心矢量的模。注意这个处理对于正交网格是精确的，对于非正交网格，只是一个近似处理。而且要注意，这样求得的面上的梯度值已经是一个标量了。再回到<code>phiRa</code>的定义，既然<code>fvc::snGrad(alpha)</code>已经是标量了，那只要再乘以面积矢量的模<code>mesh.magSf()</code>，便是界面上的通量了。<code>fvc::interpolate(nuEffa)</code>和<code>fvc::interpolate(alpha + scalar(0.001))</code>则分别是将volField插值到面。</p>
<p> 再来看$$[\frac{\nabla \alpha }{\alpha}]\cdot{Rca}$$<br> 这一项是被当作显式的源项来处理，所以，我们需要得到的是一个volVcetorField。所以这里将$\nabla \alpha$处理成 volVectorField，再与作为 volTensorField 的 <code>Rca</code> 进行点乘，得到的就是 volVcetorField。因此，这里的$\frac{\nabla \alpha }{\alpha}$对应的代码是 <code>fvc::grad(alpha)/fvc::average(alpha + scalar(0.001))</code>。注意这里的 <code>fvc::average()</code> 函数的定义<a href="http://foam.sourceforge.net/docs/cpp/a05323_source.html#l00046" target="_blank" rel="external">如下</a>：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">43</span> <span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line"> <span class="number">44</span> tmp&lt;<span class="type">GeometricField</span>&lt;<span class="type">Type</span>, fvPatchField, volMesh&gt; &gt;</span><br><span class="line"> <span class="number">45</span> average</span><br><span class="line"> <span class="number">46</span> (</span><br><span class="line"> <span class="number">47</span>     <span class="keyword">const</span> <span class="type">GeometricField</span>&lt;<span class="type">Type</span>, fvsPatchField, surfaceMesh&gt;&amp; ssf</span><br><span class="line"> <span class="number">48</span> )</span><br><span class="line"> <span class="number">49</span> &#123;</span><br><span class="line"> <span class="number">50</span>     <span class="keyword">const</span> fvMesh&amp; mesh = ssf.mesh();</span><br><span class="line"> <span class="number">51</span> </span><br><span class="line"> <span class="number">52</span>     tmp&lt;<span class="type">GeometricField</span>&lt;<span class="type">Type</span>, fvPatchField, volMesh&gt; &gt; taverage</span><br><span class="line"> <span class="number">53</span>     (</span><br><span class="line"> <span class="number">54</span>         new <span class="type">GeometricField</span>&lt;<span class="type">Type</span>, fvPatchField, volMesh&gt;</span><br><span class="line"> <span class="number">55</span>         (</span><br><span class="line"> <span class="number">56</span>             <span class="type">IOobject</span></span><br><span class="line"> <span class="number">57</span>             (</span><br><span class="line"> <span class="number">58</span>                 <span class="string">"average("</span>+ssf.name()+')',</span><br><span class="line"> <span class="number">59</span>                 ssf.instance(),</span><br><span class="line"> <span class="number">60</span>                 mesh,</span><br><span class="line"> <span class="number">61</span>                 <span class="type">IOobject</span>::<span class="type">NO</span>\_READ,</span><br><span class="line"> <span class="number">62</span>                 <span class="type">IOobject</span>::<span class="type">NO</span>\_WRITE</span><br><span class="line"> <span class="number">63</span>             ),</span><br><span class="line"> <span class="number">64</span>             mesh,</span><br><span class="line"> <span class="number">65</span>             ssf.dimensions()</span><br><span class="line"> <span class="number">66</span>         )</span><br><span class="line"> <span class="number">67</span>     );</span><br><span class="line"> <span class="number">68</span> </span><br><span class="line"> <span class="number">69</span>     <span class="type">GeometricField</span>&lt;<span class="type">Type</span>, fvPatchField, volMesh&gt;&amp; av = taverage();</span><br><span class="line"> <span class="number">70</span> </span><br><span class="line"> <span class="number">71</span>     av.internalField() =</span><br><span class="line"> <span class="number">72</span>     (</span><br><span class="line"> <span class="number">73</span>         surfaceSum(mesh.magSf()*ssf)/surfaceSum(mesh.magSf())</span><br><span class="line"> <span class="number">74</span>     )().internalField();</span><br><span class="line"> <span class="number">75</span> </span><br><span class="line"> <span class="number">76</span>     typename <span class="type">GeometricField</span>&lt;<span class="type">Type</span>, fvPatchField, volMesh&gt;::</span><br><span class="line"> <span class="number">77</span>     <span class="type">GeometricBoundaryField</span>&amp; bav = av.boundaryField();</span><br><span class="line"> <span class="number">78</span> </span><br><span class="line"> <span class="number">79</span>     forAll(bav, patchi)</span><br><span class="line"> <span class="number">80</span>     &#123;</span><br><span class="line"> <span class="number">81</span>         bav[patchi] = ssf.boundaryField()[patchi];</span><br><span class="line"> <span class="number">82</span>     &#125;</span><br><span class="line"> <span class="number">83</span> </span><br><span class="line"> <span class="number">84</span>     av.correctBoundaryConditions();</span><br><span class="line"> <span class="number">85</span> </span><br><span class="line"> <span class="number">86</span>     <span class="keyword">return</span> taverage;</span><br><span class="line"> <span class="number">87</span> &#125;</span><br><span class="line"> <span class="number">88</span> </span><br><span class="line"> <span class="number">89</span> </span><br><span class="line"> <span class="number">90</span> <span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line"> <span class="number">91</span> tmp&lt;<span class="type">GeometricField</span>&lt;<span class="type">Type</span>, fvPatchField, volMesh&gt; &gt;</span><br><span class="line"> <span class="number">92</span> average</span><br><span class="line"> <span class="number">93</span> (</span><br><span class="line"> <span class="number">94</span>     <span class="keyword">const</span> tmp&lt;<span class="type">GeometricField</span>&lt;<span class="type">Type</span>, fvsPatchField, surfaceMesh&gt; &gt;&amp; tssf</span><br><span class="line"> <span class="number">95</span> )</span><br><span class="line"> <span class="number">96</span> &#123;</span><br><span class="line"> <span class="number">97</span>     tmp&lt;<span class="type">GeometricField</span>&lt;<span class="type">Type</span>, fvPatchField, volMesh&gt; &gt; taverage</span><br><span class="line"> <span class="number">98</span>     (</span><br><span class="line"> <span class="number">99</span>         fvc::average(tssf())</span><br><span class="line"><span class="number">100</span>     );</span><br><span class="line"><span class="number">101</span>     tssf.clear();</span><br><span class="line"><span class="number">102</span>     <span class="keyword">return</span> taverage;</span><br><span class="line"><span class="number">103</span> &#125;</span><br><span class="line"><span class="number">104</span> </span><br><span class="line"><span class="number">105</span> </span><br><span class="line"><span class="number">106</span> <span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line"><span class="number">107</span> tmp&lt;<span class="type">GeometricField</span>&lt;<span class="type">Type</span>, fvPatchField, volMesh&gt; &gt;</span><br><span class="line"><span class="number">108</span> average</span><br><span class="line"><span class="number">109</span> (</span><br><span class="line"><span class="number">110</span>     <span class="keyword">const</span> <span class="type">GeometricField</span>&lt;<span class="type">Type</span>, fvPatchField, volMesh&gt;&amp; vtf</span><br><span class="line"><span class="number">111</span> )</span><br><span class="line"><span class="number">112</span> &#123;</span><br><span class="line"><span class="number">113</span>     <span class="keyword">return</span> fvc::average(linearInterpolate(vtf));</span><br><span class="line"><span class="number">114</span> &#125;</span><br><span class="line"><span class="number">115</span> </span><br><span class="line"><span class="number">116</span> </span><br><span class="line"><span class="number">117</span> <span class="keyword">template</span>&lt;class <span class="type">Type</span>&gt;</span><br><span class="line"><span class="number">118</span> tmp&lt;<span class="type">GeometricField</span>&lt;<span class="type">Type</span>, fvPatchField, volMesh&gt; &gt;</span><br><span class="line"><span class="number">119</span> average</span><br><span class="line"><span class="number">120</span> (</span><br><span class="line"><span class="number">121</span>     <span class="keyword">const</span> tmp&lt;<span class="type">GeometricField</span>&lt;<span class="type">Type</span>, fvPatchField, volMesh&gt; &gt;&amp; tvtf</span><br><span class="line"><span class="number">122</span> )</span><br><span class="line"><span class="number">123</span> &#123;</span><br><span class="line"><span class="number">124</span>     tmp&lt;<span class="type">GeometricField</span>&lt;<span class="type">Type</span>, fvPatchField, volMesh&gt; &gt; taverage</span><br><span class="line"><span class="number">125</span>     (</span><br><span class="line"><span class="number">126</span>         fvc::average(tvtf())</span><br><span class="line"><span class="number">127</span>     );</span><br><span class="line"><span class="number">128</span>     tvtf.clear();</span><br><span class="line"><span class="number">129</span>     <span class="keyword">return</span> taverage;</span><br><span class="line"><span class="number">130</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出，<code>fvc::average()</code>函数的返回类型是<code>tmp&lt;GeometricField&lt;Type, fvPatchField, volMesh&gt; &gt;</code>，对应<code>alpha</code>，返回类型就是<code>tmp&lt;GeometricField&lt;scalar, fvPatchField, volMesh&gt; &gt;</code>，即<code>tmp&lt;volScalarField&gt;</code>。<code>average</code>函数的核心定义见代码71-74行，可见<code>average</code>采用的是面积加权平均，即$$\overline{\phi}=\frac{\sum_f\phi_f*|S_f|}{\sum_f |S_f|}$$。如果给<code>average</code>的参数类型是surfaceFiled，那么直接计算平均值后返回volField，如果给的参数的volField，那就先将volField插值到面，计算平均值后再返回volField，见代码106-114行。</p>
<h3 id="参考资料">参考资料</h3><ol>
<li><a href="http://www.openfoam.org/docs/cpp/" target="_blank" rel="external">http://www.openfoam.org/docs/cpp/</a></li>
<li>OpenFOAM: A little User-Manual, Gerhard Holzinger, <a href="https://github.com/ParticulateFlow/OSCCAR-doc" target="_blank" rel="external">https://github.com/ParticulateFlow/OSCCAR-doc</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>OpenFOAM 的方便之处之一是利用<code>C++</code>的类模板和函数重载等技术定义了很多各种离散操作符，如<code>div</code>,<code>laplacian</code>,<code>grad</code> 等等。利用这些操作符，很容易就能对偏微分方程进行离散，并构建起线性方程组。但是，这些操作符真正执行的运算，却需要结合有限体积方法的本质来理解一番才能真正掌握。下面尝试着对 OpenFOAM 中的 <code>div</code> 和 <code>snGrad</code> 操作符进行一点解读。</p>]]>
    
    </summary>
    
      <category term="Code Explained" scheme="http://xiaopingqiu.github.io/tags/Code-Explained/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/tags/OpenFOAM/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[利用functionObjects对指定区域内进行后处理]]></title>
    <link href="http://xiaopingqiu.github.io/2015/05/09/functionObjects/"/>
    <id>http://xiaopingqiu.github.io/2015/05/09/functionObjects/</id>
    <published>2015-05-09T07:24:56.000Z</published>
    <updated>2015-05-09T07:42:05.792Z</updated>
    <content type="html"><![CDATA[<p>CFD中很重要的一个环节是模拟结果的后处理。而后处理过程中，常常涉及到对某个指定区域的某个物理量进行操作，比如，求指定截面上的流率，或者求某个区域内的平均空隙率，等等。这里介绍一种利用 OpenFOAM 中的 <code>functionObjects</code> 来对指定区域进行后处理的方法。本方法一共分三步：1). 将指定区域内的网格(或者面)提取到 cellZone（或faceZone）; 2). 在 controlDict 里写后处理 functions；3). 运行后处理。<br><a id="more"></a></p>
<h3 id="1-_将指定区域的网格(或面)提取到_cellZone_(或faceZone)">1. 将指定区域的网格(或面)提取到 cellZone (或faceZone)</h3><p>这一步有很多方法可以实现，这里介绍用<code>setSet</code>结合<code>setsToZones</code>的方法。</p>
<h4 id="1-1_setSet的基本用法">1.1 <code>setSet</code>的基本用法</h4><p><code>setSet</code>是 OpenFOAM 提供的一个用于生成网格集合(cellSet)、面集合（faceSet）以及点集合（pointSet）的交互式工具，终端里运行<code>setSet</code>，便进入交互模式：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">$ setSet</span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------------------------------------------------------------------------*\</span><br><span class="line">| =========                 |                                                 |</span><br><span class="line">| \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |</span><br><span class="line">|  \\    /   O peration     | Version:  2.3.1                                 |</span><br><span class="line">|   \\  /    A nd           | Web:      www.OpenFOAM.org                      |</span><br><span class="line">|    \\/     M anipulation  |                                                 |</span><br><span class="line">\*---------------------------------------------------------------------------*/</span></span><br><span class="line"><span class="string">Build  :</span> <span class="number">2.3</span>.1-bcfaaa7b8660</span><br><span class="line"><span class="string">Exec   :</span> setSet</span><br><span class="line"><span class="string">Date   :</span> May <span class="number">09</span> <span class="number">2015</span></span><br><span class="line"><span class="string">Time   :</span> <span class="number">13</span>:<span class="number">50</span>:<span class="number">44</span></span><br><span class="line"><span class="string">Host   :</span> <span class="string">"xxxxx"</span></span><br><span class="line"><span class="string">PID    :</span> <span class="number">11255</span></span><br><span class="line"><span class="string">Case   :</span> <span class="regexp">/home/</span>xxxxx<span class="regexp">/OpenFOAM/</span>xxxx-<span class="number">2.3</span>.1<span class="regexp">/run/</span>volField/cavity</span><br><span class="line"><span class="string">nProcs :</span> <span class="number">1</span></span><br><span class="line"><span class="string">sigFpe :</span> Enabling floating point exception trapping (FOAM_SIGFPE).</span><br><span class="line"><span class="string">fileModificationChecking :</span> Monitoring run-time modified files using timeStampMaster</span><br><span class="line"><span class="string">allowSystemOperations :</span> Allowing user-supplied system call operations</span><br><span class="line"></span><br><span class="line"><span class="comment">// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //</span></span><br><span class="line">Create time</span><br><span class="line"></span><br><span class="line">Create polyMesh <span class="keyword">for</span> time = <span class="number">0</span></span><br><span class="line"><span class="label"></span><br><span class="line">Time:</span><span class="number">0</span>  <span class="string">cells:</span><span class="number">9</span>  <span class="string">faces:</span><span class="number">42</span>  <span class="string">points:</span><span class="number">32</span>  <span class="string">patches:</span><span class="number">3</span>  <span class="string">bb:</span>(<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>) (<span class="number">0.1</span> <span class="number">0.1</span> <span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line">Successfully read history from .setSet</span><br><span class="line">Time = <span class="number">0</span></span><br><span class="line">    mesh not changed.</span><br><span class="line">Please type <span class="string">'help'</span>, <span class="string">'quit'</span> or a set command after prompt.</span><br><span class="line">readline&gt;</span><br></pre></td></tr></table></figure></p>
<p><code>setSet</code>的基本语法是：<code>cellSet|faceSet|pointSet &lt;setName&gt; &lt;action&gt; &lt;source&gt;</code>。第一个字段，是选择需要建立的是哪一类集合(cellSet|faceSet|pointSet)，第二个字段是<code>setName</code>，顾名思义，给集合取个名字，第三个字段是<code>action</code>，即具体的操作，比如<code>new</code>(新建)，<code>add</code>(增加）等，最后一个字段是<code>source</code>，即指定cell(face,point)的来源，比如有一种是<code>boxToCell</code>，这种来源要求定义一个box，并将中心在这个box里的网格当作操作的对象。下面举几个例子：</p>
<ul>
<li><code>faceSet f0 new boxToFace (0 0 0) (1 1 1)</code>: 建立一个新的面集f0，并将面心落在对角线顶点分别为(0 0 0)和(1 1 1)的立方体中的面提取出来放到该集合中;</li>
<li><code>cellSet f0 new boxToCell (0 0 0) (1 1 1)</code>:建立一个新的网格集f0，并将面心落在对角线顶点分别为(0 0 0)和(1 1 1)的立方体中的网格提取出来放到该集合中;</li>
<li><code>faceSet f0 new patchToFace movingWall</code>:新建一个面集f0，并将边界<code>movingWall</code>的所有面放到该集合中；</li>
<li><code>cellSet c0 new faceToCell f0 any</code>: 新建一个网格集合c0，并将面集f0中所有的面对应的网格放到网格集合c0中；</li>
<li><code>cellSet c0 add pointToCell p0 any</code>，将点集p0中所有的点对应的网格添加到<strong>已经存在</strong>的网格集c0中。</li>
</ul>
<p>如果要一次建立很多个集合，那么可以将建立规则写在一个文本文件里，每个规则一行，写好后的文件大致是这样<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">faceSet f0 <span class="keyword">new</span> boxToFace (<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>) (<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>)</span><br><span class="line">faceSet f1 <span class="keyword">new</span> boxToFace (<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>) (<span class="number">2</span> <span class="number">2</span> <span class="number">2</span>)</span><br><span class="line">cellSet c0 <span class="keyword">new</span> faceToCell f0 <span class="keyword">any</span></span><br><span class="line">cellSet c1 <span class="keyword">new</span> faceToCell f1 <span class="keyword">any</span></span><br></pre></td></tr></table></figure></p>
<p>然后运行命令<br><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>Set -batch <span class="variable">&lt;filename&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>进行批处理。但是这样会针对每一个时间步都运行一次，如果只想运行一次，可以指定时间<br><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>Set -batch <span class="variable">&lt;filename&gt;</span> -time <span class="number">0</span></span><br><span class="line">或者</span><br><span class="line"><span class="built_in">set</span>Set -batch <span class="variable">&lt;filename&gt;</span> -latestTime</span><br></pre></td></tr></table></figure></p>
<p>运行结束以后，程序会将sets信息放在<code>polyMesh/sets</code>目录下，同时生成相应的vtk文件在算例根目录下的VTK目录里，方便在paraview中查看。<br>关于<code>setSet</code>更详细的信息可以参考<code>setSet</code>提供的 help（终端里运行<code>setSet</code>进入交互模式以后输入<code>help</code>）。</p>
<h4 id="1-2_setsToZones">1.2 setsToZones</h4><p>这一步非常简单，只需要在终端里运行<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setsToZones</span><br></pre></td></tr></table></figure></p>
<p>就可以将前面建立好的 cellSet(faceSet,pointSet)转换成 cellZone(faceZone,pointZone)。</p>
<p>其实除了<code>setSet</code>和<code>setsToZones</code>结合的方法，还可以用<code>topoSet</code>来生成cellZone，本篇不详述了，可以参考 <a href="https://openfoamwiki.net/index.php/TopoSet" target="_blank" rel="external">OpenFOAMWiki</a>。</p>
<h3 id="2-_在_controlDict_里写_functions">2. 在 controlDict 里写 functions</h3><p>有了前面建立好的cellZone (faceZone,pointZone) 以后，就可以在 controlDict 写 functions 来对指定的区域进行后处理了。funtions 的基本写法是在 controlDict 文件的最后，添加类似如下的信息：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">functions</span><br><span class="line">(</span><br><span class="line">   cell0</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">type</span> cellSource; <span class="comment">// 指定操作区域的类型，cellsource 表示是操作区域是一个基于网格(cell)的，比如cellZone。</span></span><br><span class="line">     functionObjectLibs <span class="comment">// 指定需要加载的动态库</span></span><br><span class="line">     (</span><br><span class="line">         <span class="comment">//"libsimpleFunctionObjects.so" // swak4Foam 提供的一个函数库</span></span><br><span class="line">         <span class="string">"libfieldFunctionObjects.so"</span>  <span class="comment">// OpenFOAM自带的一个函数库</span></span><br><span class="line">     );</span><br><span class="line">     verbose <span class="literal">true</span>; <span class="comment">//是否要在终端里输出程序运行过程</span></span><br><span class="line">     <span class="comment">//outputControl timeStep; // 每一个时间步都运行</span></span><br><span class="line">     outputControl outputTime; <span class="comment">// 只在需要输出的时间步才运行，参考controlDict的 writeControl和writeInterval</span></span><br><span class="line">     <span class="keyword">log</span>           <span class="literal">true</span>; <span class="comment">// 是否生成 log</span></span><br><span class="line">     valueOutput   <span class="literal">true</span>; <span class="comment">// 是否需要在每一个时间步对应的数据文件夹里(0.1 0.2 之类的) 将指定 source 的值输出来。</span></span><br><span class="line">     source        cellZone; <span class="comment">//指定操作区域的具体的组成，这里cellZone表示操作区域是由一个cellZone组成的。</span></span><br><span class="line">     sourceName    f0; <span class="comment">// cellZone 的名字</span></span><br><span class="line">     operation     volAverage; <span class="comment">//操作方法，这里是体积平均</span></span><br><span class="line">     fields <span class="comment">// 需要进行操作的物理量</span></span><br><span class="line">     (</span><br><span class="line">         T</span><br><span class="line">     );</span><br><span class="line">   &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>注意这里的结构，<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">functions</span></span><br><span class="line">(</span><br><span class="line">  ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>是最外一层，包括在其中的就是各种功能的 <code>functionObjects</code>了。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">cell0</span></span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代表的是一个<code>functionObject</code>，其中<code>cell0</code>是该<code>functionObject</code>的名字。里面内容的含义参照上面示例中的注释。如果需要写多个<code>functionObjects</code>，那只需要依次都写下来就好了，注意<code>functionObjects</code>的名字不能重复，结构如下<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">functions</span></span><br><span class="line">(</span><br><span class="line">   cell0</span><br><span class="line">   &#123;</span><br><span class="line">   ...</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   cell1</span><br><span class="line">   &#123;</span><br><span class="line">    ...</span><br><span class="line">   &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h3 id="3-_运行后处理">3. 运行后处理</h3><p>写好<code>functions</code>以后，就可以运行后处理了。在终端里运行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span>FlowFunctionObjects</span><br></pre></td></tr></table></figure></p>
<p>就能执行定义在controlDict里的后处理函数了。<br>有时候，可能会报错，说找不到<code>phi</code>，那这时可以加上<code>-noFlow</code>选项<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">execFlowFunctionObjects</span>  -<span class="built_in">no</span>Flow</span><br></pre></td></tr></table></figure></p>
<p>当然，时间相关的选项也是可以用的<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">execFlowFunctionObjects</span>  -<span class="built_in">no</span>Flow -time <span class="number">3</span></span><br><span class="line">execFlowFunctionObjects  -<span class="built_in">no</span>Flow -latestTime</span><br></pre></td></tr></table></figure></p>
<p>注意，本篇强调的是后处理，即算例运行完以后对数据进行的处理。实际上，熟悉OpenFOAM都知道，写在 controlDict 的functions是会随着算例的运行而同时运行的，所以，如果是运行一个新算例，那么你也完全可以事先规划好后处理相关的操作，然后在controlDict写好functions，这样等算例运行结束，所需要的后处理结果也同时生成了。</p>
<p>有人会问，我怎么知道那些 type，source，operation 等有哪些选项可用呢？这里介绍一种的方法，即所谓的<a href="https://openfoamwiki.net/index.php/OpenFOAM_guide/Use_bananas" target="_blank" rel="external">香蕉大法</a>。比如对于 type，你不知道有哪些可用，那么将type设置为 banana  (将上面第2节示例的中 <code>type cellSource</code>改成<code>type banana</code>)，然后运行<code>execFlowFunctionObjects</code>，这时，会得到如下信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">--&gt; FOAM FATAL ERROR: </span><br><span class="line">Unknown <span class="keyword">function</span> <span class="built_in">type</span> banana</span><br><span class="line">Valid <span class="built_in">functions</span> are : </span><br><span class="line"><span class="number">14</span></span><br><span class="line">(</span><br><span class="line">cellSource</span><br><span class="line">faceSource</span><br><span class="line">fieldAverage</span><br><span class="line">fieldCoordinateSystemTransform</span><br><span class="line">fieldM<span class="keyword">in</span>Max</span><br><span class="line">initSwakFunctionObject</span><br><span class="line">nearWallFields</span><br><span class="line">patchProbes</span><br><span class="line">probes</span><br><span class="line"><span class="built_in">read</span>Fields</span><br><span class="line">sets</span><br><span class="line">streamLine</span><br><span class="line">surfaceInterpolateFields</span><br><span class="line">surfaces</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>这回就知道了所有可用选项了吧。对于 source 和 operation 也可以同样的方法得到所有可用的选项。注意，source和operation的可用选项，是随着type的不同而不同的，这里就不详述了。<br>P.S：banana不是OpenFOAM定义的特殊字符串，改成任意非有效的字符串，效果都一样。</p>
<p>最后，上面只是介绍了一些一般性的原则，如果读者想参考一些实际的例子，可以去 OpenFOAM 的 tutorials 里挖掘，这里给一个找出 OpenFOAM 中有哪些算例运用了 functions 的方法，供大家参考。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find</span> $WM_PROJECT_DIR -name controlDict | xargs <span class="keyword">grep</span> <span class="string">"functions"</span></span><br></pre></td></tr></table></figure>
<p>在我的电脑上，运行结果如下：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/src/</span>postProcessing<span class="regexp">/functionObjects/</span>systemCall/<span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/src/</span>postProcessing<span class="regexp">/functionObjects/</span>utilities<span class="regexp">/timeActivatedFileUpdate/</span><span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/src/</span>postProcessing<span class="regexp">/functionObjects/</span>field<span class="regexp">/fieldAverage/</span><span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/src/</span>postProcessing<span class="regexp">/functionObjects/</span>field<span class="regexp">/nearWallFields/</span><span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/src/</span>postProcessing<span class="regexp">/functionObjects/</span>field<span class="regexp">/fieldValues/</span><span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/src/</span>postProcessing<span class="regexp">/functionObjects/</span>field<span class="regexp">/streamLine/</span><span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/src/</span>postProcessing<span class="regexp">/functionObjects/</span>field<span class="regexp">/fieldMinMax/</span><span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/src/</span>postProcessing<span class="regexp">/functionObjects/</span>field<span class="regexp">/wallBoundedStreamLine/</span><span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/src/</span>postProcessing<span class="regexp">/functionObjects/</span>IO/<span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>incompressible<span class="regexp">/pimpleFoam/</span>TJunctionFan<span class="regexp">/system/</span><span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>incompressible<span class="regexp">/pimpleFoam/</span>channel395<span class="regexp">/system/</span><span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>incompressible<span class="regexp">/pimpleFoam/</span>TJunction<span class="regexp">/system/</span><span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>incompressible<span class="regexp">/pisoFoam/</span>les<span class="regexp">/pitzDailyMapped/</span>system/<span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>incompressible<span class="regexp">/pisoFoam/</span>les<span class="regexp">/pitzDaily/</span>system/<span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>incompressible<span class="regexp">/pisoFoam/</span>les<span class="regexp">/motorBike/</span>lesFiles/<span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>incompressible<span class="regexp">/pisoFoam/</span>les<span class="regexp">/motorBike/</span>motorBike<span class="regexp">/system/</span><span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>incompressible<span class="regexp">/pimpleDyMFoam/</span>wingMotion<span class="regexp">/wingMotion2D_simpleFoam/</span>system/<span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>incompressible<span class="regexp">/pimpleDyMFoam/</span>propeller<span class="regexp">/system/</span><span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>incompressible<span class="regexp">/pimpleDyMFoam/</span>movingCone<span class="regexp">/system/</span><span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>incompressible<span class="regexp">/simpleFoam/</span>pitzDaily<span class="regexp">/system/</span><span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>incompressible<span class="regexp">/simpleFoam/</span>pitzDailyExptInlet<span class="regexp">/system/</span><span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>incompressible<span class="regexp">/simpleFoam/</span>motorBike<span class="regexp">/system/</span><span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>lagrangian<span class="regexp">/reactingParcelFoam/</span>verticalChannel<span class="regexp">/system/</span><span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>lagrangian<span class="regexp">/LTSReactingParcelFoam/</span>verticalChannel<span class="regexp">/system/</span><span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>lagrangian<span class="regexp">/simpleReactingParcelFoam/</span>verticalChannel<span class="regexp">/system/</span><span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>multiphase<span class="regexp">/interFoam/</span>ras<span class="regexp">/waterChannel/</span>LTSInterFoam<span class="regexp">/system/</span><span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>multiphase<span class="regexp">/interFoam/</span>ras<span class="regexp">/waterChannel/</span>system/<span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>multiphase<span class="regexp">/interDyMFoam/</span>ras<span class="regexp">/sloshingTank3D3DoF/</span>system/<span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>multiphase<span class="regexp">/interDyMFoam/</span>ras<span class="regexp">/sloshingTank3D6DoF/</span>system/<span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>multiphase<span class="regexp">/interDyMFoam/</span>ras<span class="regexp">/sloshingTank2D3DoF/</span>system/<span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>multiphase<span class="regexp">/interDyMFoam/</span>ras<span class="regexp">/DTCHull/</span>system/<span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>multiphase<span class="regexp">/interDyMFoam/</span>ras<span class="regexp">/sloshingTank3D/</span>system/<span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>multiphase<span class="regexp">/interDyMFoam/</span>ras<span class="regexp">/sloshingTank2D/</span>system/<span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>multiphase<span class="regexp">/twoPhaseEulerFoam/</span>laminar<span class="regexp">/bubbleColumn/</span>system/<span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>multiphase<span class="regexp">/twoPhaseEulerFoam/</span>laminar<span class="regexp">/bubbleColumnIATE/</span>system/<span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>multiphase<span class="regexp">/twoPhaseEulerFoam/</span>laminar<span class="regexp">/fluidisedBed/</span>system/<span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>multiphase<span class="regexp">/twoPhaseEulerFoam/</span>LES<span class="regexp">/bubbleColumn/</span>system/<span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>multiphase<span class="regexp">/twoPhaseEulerFoam/</span>RAS<span class="regexp">/bubbleColumn/</span>system/<span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>multiphase<span class="regexp">/twoPhaseEulerFoam/</span>RAS<span class="regexp">/fluidisedBed/</span>system/<span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>multiphase<span class="regexp">/potentialFreeSurfaceDyMFoam/</span>oscillatingBox<span class="regexp">/system/</span><span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>multiphase<span class="regexp">/LTSInterFoam/</span>DTCHull<span class="regexp">/system/</span><span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>multiphase<span class="regexp">/cavitatingFoam/</span>les<span class="regexp">/throttle3D/</span>system/<span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>multiphase<span class="regexp">/cavitatingFoam/</span>les<span class="regexp">/throttle/</span>system/<span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>multiphase<span class="regexp">/compressibleInterDyMFoam/</span>ras<span class="regexp">/sloshingTank2D/</span>system/<span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>multiphase<span class="regexp">/potentialFreeSurfaceFoam/</span>oscillatingBox<span class="regexp">/system/</span><span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>multiphase<span class="regexp">/multiphaseEulerFoam/</span>bubbleColumn<span class="regexp">/system/</span><span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>discreteMethods<span class="regexp">/dsmcFoam/</span>freeSpaceStream<span class="regexp">/system/</span><span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>discreteMethods<span class="regexp">/dsmcFoam/</span>wedge15Ma5<span class="regexp">/system/</span><span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>discreteMethods<span class="regexp">/dsmcFoam/</span>supersonicCorner<span class="regexp">/system/</span><span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>discreteMethods<span class="regexp">/dsmcFoam/</span>freeSpacePeriodic<span class="regexp">/system/</span><span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>basic<span class="regexp">/potentialFoam/</span>cylinder<span class="regexp">/system/</span><span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>compressible<span class="regexp">/rhoPimpleFoam/</span>les<span class="regexp">/pitzDaily/</span>system/<span class="string">controlDict:</span>functions</span><br><span class="line"><span class="regexp">/opt/</span>openfoam231<span class="regexp">/tutorials/</span>compressible<span class="regexp">/sonicFoam/</span>ras<span class="regexp">/nacaAirfoil/</span>system/<span class="string">controlDict:</span>functions</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>CFD中很重要的一个环节是模拟结果的后处理。而后处理过程中，常常涉及到对某个指定区域的某个物理量进行操作，比如，求指定截面上的流率，或者求某个区域内的平均空隙率，等等。这里介绍一种利用 OpenFOAM 中的 <code>functionObjects</code> 来对指定区域进行后处理的方法。本方法一共分三步：1). 将指定区域内的网格(或者面)提取到 cellZone（或faceZone）; 2). 在 controlDict 里写后处理 functions；3). 运行后处理。<br>]]>
    
    </summary>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/tags/OpenFOAM/"/>
    
      <category term="Postprocessing" scheme="http://xiaopingqiu.github.io/tags/Postprocessing/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ParaView 的远程模式]]></title>
    <link href="http://xiaopingqiu.github.io/2015/05/03/paraview-remote/"/>
    <id>http://xiaopingqiu.github.io/2015/05/03/paraview-remote/</id>
    <published>2015-05-03T12:49:02.000Z</published>
    <updated>2015-05-03T14:58:20.758Z</updated>
    <content type="html"><![CDATA[<p>OpenFOAM 用户肯定都用过<a href="http://www.paraview.org/" target="_blank" rel="external">ParaView</a>可视化软件，这款软件可以方便地读取 OpenFOAM 的数据进行种类丰富的可视化操作。用 ParaView 可视化 OpenFOAM数据很简单，只需要在算例目录下运行<code>paraFoam</code>即可(注一)。但是，如果你不是在本地机器上运行 OpenFOAM，而是在远程机器上运行，这时候想在本地直接用 ParaView 来可视化远程机器上的数据，该怎么办呢？这个问题要分情况讨论：</p>
<ol>
<li>远程机器没有禁止远程开启GUI<ul>
<li>本地机器安装的是Linux系统，那么可以这样做：<code>ssh -X your_remote_machine</code> 登录到远程机器，注意这里加了<code>-X</code>选项，正常的话，应该直接在终端里运行<code>paraFoam</code>就可以远程启动 ParaView。</li>
<li>本地机器安装的是 Windows，这种情况下可以通过安装一个 Xserver，比如<a href="http://sourceforge.net/projects/xming/" target="_blank" rel="external">Xming</a>，然后用一个支持 X11 Forwarding 的 SSH 客户端（比如 putty）用<code>ssh -X</code>登录到远程机器，正常的话，直接运行<code>paraFoam</code>可以远程启动 ParaView。但根据我的使用经验，这种方法稳定性很差，容易崩溃。</li>
</ul>
</li>
<li>远程机器设置了禁止远程开启GUI程序<br>这种情况下上面提到的两种方法就都不奏效了。这时，下面要介绍的 ParaView 远程模式就能派上用场了。</li>
</ol>
<p>ParaView 远程模式基本的使用方法是，在远程机器上启动一个<code>pvserver</code>，然后用本地机器安装的 ParaView 连接到这个 server上(Client/Server 模式)，或者反过来，本地机器开启一个 server，然后让远程机器连接到本地的 server(Client/Server(reverse connection) 模式),以下将一一介绍。</p>
<a id="more"></a>
<h4 id="Client/Server_模式">Client/Server 模式</h4><p>建立方法如下：</p>
<ol>
<li>在远程机器上运行pvserver；</li>
<li>运行本地机器上的 ParaView，点击菜单栏左上角的“Connect”，出来如下界面：<br><img src="/image/paraview_remote/cs1.png" alt=""></li>
<li>选择 “Add server”，然后在如下界面中设置 server：<br><img src="/image/paraview_remote/cs2.png" alt=""><br>“Server Type”选择”Client/Server”，”Host”填写远程的机器的 IP，”Port”默认即可。点”configure”，便添加了一个 server，这个设置会自动保存下来，下次再打开 “Connect”时，默认就会看到保存的 server 列表。<br><img src="/image/paraview_remote/cs3.png" alt=""></li>
<li>双击列表中需要连接的 server，正常地话便连接到远程机器了，这时候点打开文件，看到的便是远程机器上的文件了！</li>
</ol>
<p><strong>注意事项</strong>：本地机器和远程机器的必须安装同一个版本的ParaView，否则会报错。此外，这种连接方式不能使用”PointSprite_Plugin”插件来显示颗粒。</p>
<h4 id="Client/Server(reverse_connection)_模式">Client/Server(reverse connection) 模式</h4><p>有时候，远程机器上无法正常运行<code>pvserver</code>, 比如报如下错误：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Waiting <span class="keyword">for</span> client… </span><br><span class="line">Connection <span class="string">URL:</span> <span class="string">cs:</span><span class="comment">//A402:11111 </span></span><br><span class="line"><span class="string">ERROR:</span> In <span class="regexp">/home/</span>utkarsh<span class="regexp">/Dashboards/</span>MyTests<span class="regexp">/NightlyMaster/</span>ParaViewSuperbuild-Release<span class="regexp">/paraview/</span>src<span class="regexp">/paraview/</span>VTK<span class="regexp">/Common/</span>System/vtkSocket.cxx, line <span class="number">206</span> </span><br><span class="line">vtkServerSocket (<span class="number">0x1a1206e0</span>): Socket error <span class="keyword">in</span> call to bind. Address already <span class="keyword">in</span> use.</span><br><span class="line"><span class="string">ERROR:</span> In <span class="regexp">/home/</span>utkarsh<span class="regexp">/Dashboards/</span>MyTests<span class="regexp">/NightlyMaster/</span>ParaViewSuperbuild-Release<span class="regexp">/paraview/</span>src<span class="regexp">/paraview/</span>ParaViewCore<span class="regexp">/ClientServerCore/</span>Core/vtkTCPNetworkAccessManager.cxx, line <span class="number">355</span> </span><br><span class="line">vtkTCPNetworkAccessManager (<span class="number">0x1983fa00</span>): Failed to set up server socket.</span><br><span class="line"> Exiting…</span><br></pre></td></tr></table></figure></p>
<p>这时，可以采用Client/Server(reverse connection) 模式，这种模式是在本地机器上开启一个 server，然后让远程机器连上它，具体做法如下：</p>
<ol>
<li>先在本地机器上启动 ParaView，并按照上面所述的方法建立一个server，注意这里”Server Type” 要选择 “Client/Server(reverse connection)”，如下图：<br><img src="/image/paraview_remote/rc1.png" alt=""></li>
<li>连接上这个新建的 server：<br><img src="/image/paraview_remote/rc2.png" alt=""><br>连上以后，显示”waiting for server to connect”，如下<br><img src="/image/paraview_remote/rc3.png" alt=""></li>
<li><p>在远程机器上运行 </p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">pvserver</span> -rc -ch=<span class="number">192.168.1.34</span></span><br></pre></td></tr></table></figure>
<p>注意这里用选项-rc开启reverse connection 模式，-ch选项指定本地机器的 IP。这样就建立了从远程机器到本地机器的连接。 </p>
</li>
<li>连接建立以后，点打开文件，看到的便是远程机器上的文件了，跟 Client/Server 模式一样。</li>
</ol>
<p><strong>一个细节值得注意</strong>：当用 Client/Server 模式或Client/Server(reverse connection) 模式建立起本地机器与远程机器的连接以后，”Save Screenshot”, “Save Animation”, “Export Scene” 以及”Save state”会输出到本地机器，而”Save Data”和”Save Geometry”将仍然输出到远程机器。</p>
<p>注一：<code>paraFoam</code>的正常运行依赖于 libPV3reader.so 等几个库，有时候这几个库不能正常编译生成。ParaView 自从 4.0 版本以后，不需要使用<code>paraFoam</code>直接就能读取 OpenFOAM的数据，用户只需要在算例下新建一个<code>.foam</code>结尾的空文件，然后用 ParaView打开这个空文件即可。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>OpenFOAM 用户肯定都用过<a href="http://www.paraview.org/">ParaView</a>可视化软件，这款软件可以方便地读取 OpenFOAM 的数据进行种类丰富的可视化操作。用 ParaView 可视化 OpenFOAM数据很简单，只需要在算例目录下运行<code>paraFoam</code>即可(注一)。但是，如果你不是在本地机器上运行 OpenFOAM，而是在远程机器上运行，这时候想在本地直接用 ParaView 来可视化远程机器上的数据，该怎么办呢？这个问题要分情况讨论：</p>
<ol>
<li>远程机器没有禁止远程开启GUI<ul>
<li>本地机器安装的是Linux系统，那么可以这样做：<code>ssh -X your_remote_machine</code> 登录到远程机器，注意这里加了<code>-X</code>选项，正常的话，应该直接在终端里运行<code>paraFoam</code>就可以远程启动 ParaView。</li>
<li>本地机器安装的是 Windows，这种情况下可以通过安装一个 Xserver，比如<a href="http://sourceforge.net/projects/xming/">Xming</a>，然后用一个支持 X11 Forwarding 的 SSH 客户端（比如 putty）用<code>ssh -X</code>登录到远程机器，正常的话，直接运行<code>paraFoam</code>可以远程启动 ParaView。但根据我的使用经验，这种方法稳定性很差，容易崩溃。</li>
</ul>
</li>
<li>远程机器设置了禁止远程开启GUI程序<br>这种情况下上面提到的两种方法就都不奏效了。这时，下面要介绍的 ParaView 远程模式就能派上用场了。</li>
</ol>
<p>ParaView 远程模式基本的使用方法是，在远程机器上启动一个<code>pvserver</code>，然后用本地机器安装的 ParaView 连接到这个 server上(Client/Server 模式)，或者反过来，本地机器开启一个 server，然后让远程机器连接到本地的 server(Client/Server(reverse connection) 模式),以下将一一介绍。</p>]]>
    
    </summary>
    
      <category term="Postprocessing" scheme="http://xiaopingqiu.github.io/tags/Postprocessing/"/>
    
      <category term="paraview" scheme="http://xiaopingqiu.github.io/tags/paraview/"/>
    
      <category term="Paraview" scheme="http://xiaopingqiu.github.io/categories/Paraview/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[fieldAverage 使用说明]]></title>
    <link href="http://xiaopingqiu.github.io/2015/04/12/fieldAverage/"/>
    <id>http://xiaopingqiu.github.io/2015/04/12/fieldAverage/</id>
    <published>2015-04-12T09:00:54.000Z</published>
    <updated>2015-11-26T16:13:27.295Z</updated>
    <content type="html"><![CDATA[<p><code>fieldAverage</code>是 OpenFOAM 中的一种 functionObject，用来计算时均值。其基本用法是作为一个 function object 放在 controlDict 文件中，运行 solver 的同时计算指定场的时均值，以下是一个示例：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">functions</span><br><span class="line">&#123;</span><br><span class="line">    fieldAverage1</span><br><span class="line">    &#123;</span><br><span class="line">        type            fieldAverage;</span><br><span class="line">        functionObjectLibs ( <span class="string">"libfieldFunctionObjects.so"</span> );</span><br><span class="line">        outputControl   outputTime;</span><br><span class="line">        fields</span><br><span class="line">        (</span><br><span class="line">            Ua</span><br><span class="line">            &#123;</span><br><span class="line">                 mean        <span class="function_start"><span class="keyword">on</span></span>;</span><br><span class="line">                 prime2Mean  off;</span><br><span class="line">                 base        <span class="property">time</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Ub</span><br><span class="line">            &#123;</span><br><span class="line">                 mean        <span class="function_start"><span class="keyword">on</span></span>;</span><br><span class="line">                 prime2Mean  off;</span><br><span class="line">                 base        <span class="property">time</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>但是，在有效地使用<code>fieldAverage</code>之前，有一些问题需要澄清，其中最重要的一个是：<strong><code>fieldAverage</code>到底在对哪个时间段求的时间平均</strong>？本文通过对<code>fieldAverage</code>的源码进行分析，试图厘清这些细节，并给出一个可靠的<code>fieldAverage</code>使用说明。涉及到的源文件包括：<code>fieldAverage.H</code>, <code>fieldAverage.C</code>, <code>fieldAverageTemplates.C</code>, <code>fieldAverageItem.C</code>，位于目录<code>$WM_PROJECT_DIR/src/postProcessing/functionObjects/field/fieldAverage</code>下。</p>
<h5 id="首要问题：fieldAverage对哪个时间区间进行时均计算？">首要问题：<strong><code>fieldAverage</code>对哪个时间区间进行时均计算</strong>？</h5><p>上面这段代码是从我运行的一个算例的 controlDict 中摘出来的。算例运行过程中发现，每一个时间步都要调用计算时均值相关的代码，并屏幕上的输出也会打印出<code>Calculating averages</code>，而每一个输出数据文件里，都有<code>*Mean</code>数据，其中<code>*</code>表示在<code>controlDict</code>中定义了需要求解时均值的某个场。<br>经过摸索发现，跟时均值求解密切相关的一段代码位于<a href="http://foam.sourceforge.net/docs/cpp/a08780_source.html" target="_blank" rel="external"><code>fieldAverageTemplates.C</code></a>，下面是从中摘出来的一段核心代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">182</span> <span class="keyword">template</span>&lt;<span class="keyword">class</span> Type&gt;</span><br><span class="line"><span class="number">183</span> <span class="keyword">void</span> Foam::fieldAverage::calculateMeanFieldType(<span class="keyword">const</span> label fieldI) <span class="keyword">const</span></span><br><span class="line"><span class="number">184</span> &#123;</span><br><span class="line"><span class="number">185</span>  <span class="keyword">const</span> word&amp; fieldName = faItems_[fieldI].fieldName();</span><br><span class="line"><span class="number">187</span>  <span class="keyword">if</span> (obr_.foundObject&lt;Type&gt;(fieldName))</span><br><span class="line"><span class="number">188</span>  &#123;</span><br><span class="line"><span class="number">189</span>    <span class="keyword">const</span> Type&amp; baseField = obr_.lookupObject&lt;Type&gt;(fieldName);</span><br><span class="line"><span class="number">190</span> </span><br><span class="line"><span class="number">191</span>    Type&amp; meanField = <span class="keyword">const_cast</span>&lt;Type&amp;&gt;</span><br><span class="line"><span class="number">192</span>    (</span><br><span class="line"><span class="number">193</span>    obr_.lookupObject&lt;Type&gt;(faItems_[fieldI].meanFieldName())</span><br><span class="line"><span class="number">194</span>    );</span><br><span class="line"><span class="number">195</span> </span><br><span class="line"><span class="number">196</span>    scalar dt = obr_.time().deltaTValue();</span><br><span class="line"><span class="number">197</span>    scalar Dt = totalTime_[fieldI];</span><br><span class="line"><span class="number">198</span> </span><br><span class="line"><span class="number">199</span>    <span class="keyword">if</span> (faItems_[fieldI].iterBase())</span><br><span class="line"><span class="number">200</span>    &#123;</span><br><span class="line"><span class="number">201</span>      dt = <span class="number">1.0</span>;</span><br><span class="line"><span class="number">202</span>      Dt = scalar(totalIter_[fieldI]);</span><br><span class="line"><span class="number">203</span>    &#125;</span><br><span class="line"><span class="number">204</span> </span><br><span class="line"><span class="number">205</span>    scalar alpha = (Dt - dt)/Dt;</span><br><span class="line"><span class="number">206</span>    scalar beta = dt/Dt;</span><br><span class="line"><span class="number">207</span> </span><br><span class="line"><span class="number">208</span>    <span class="keyword">if</span> (faItems_[fieldI].window() &gt; <span class="number">0</span>)</span><br><span class="line"><span class="number">209</span>    &#123;</span><br><span class="line"><span class="number">210</span>      <span class="keyword">const</span> scalar w = faItems_[fieldI].window();</span><br><span class="line"><span class="number">211</span> </span><br><span class="line"><span class="number">212</span>      <span class="keyword">if</span> (Dt - dt &gt;= w)</span><br><span class="line"><span class="number">213</span>      &#123;</span><br><span class="line"><span class="number">214</span>        alpha = (w - dt)/w;</span><br><span class="line"><span class="number">215</span>        beta = dt/w;</span><br><span class="line"><span class="number">216</span>      &#125;</span><br><span class="line"><span class="number">217</span>    &#125;</span><br><span class="line"><span class="number">219</span>    meanField = alpha*meanField + beta*baseField;</span><br><span class="line"><span class="number">220</span>  &#125;</span><br><span class="line"><span class="number">221</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p>以下是我根据理解整理的代码解析：</p>
<ol>
<li>变量<code>baseField</code>定义为当前时间步计算得到的场的值(Ua)，<code>meanField</code>定义为上一个时间步对应的场的时均值(UaMean)。</li>
<li><code>dt</code>定义为时间步长，<code>Dt</code>定义为当前所在的时间。注意199行，<code>iterBase()</code>这个函数定义为当<code>base</code> (见controlDict) 为<code>ITER</code>时，返回<code>true</code>。此时，<code>dt</code>定义为1，意义很显然，当以时间步数为基准的时候，下一步和上一步当然是只相差1个时间步；<code>Dt</code>则被定义为当前所在的时间步(第xx步)。所以，<code>Dt</code>和<code>dt</code>的真实含义取决于<code>base</code>。<strong><code>fieldAverageItem.C</code>中给<code>base</code>赋了默认值为<code>ITER</code></strong>。<code>base</code>可以指定为<code>time</code>，具体见下文。</li>
<li><p>alpha 定义为(Dt-dt)/Dt, beta 定义为 dt/Dt。然后当前时间步的<code>meanField</code>定义为<code>alpha*meanField + beta*baseField</code>。举例说明，假设dt = 1, Dt = 20, 假设上一时间步的时均值为<code>meanField_pre</code>，则新时刻时均值为</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">19/20<span class="keyword">*</span>meanField_pre + 1/20<span class="keyword">*</span>baseField) = (19<span class="keyword">*</span>meanField_pre + baseField)/20</span><br></pre></td></tr></table></figure>
<p><code>19*meanField_pre</code>的含义很明显，前19步的时均值乘以总时间步数，也就是前 19 步 Field 值的加和，再加上当前时间步的值<code>baseField</code>，就是前 20 步的 Field 值的和。用这个值除以20，得到新时刻的时均值<code>meanField</code>。由此可见，在这种情况下，<strong>每个时间步输出的时均值是从开始时刻到当前时间步的Field值对总时间的平均</strong>。</p>
</li>
<li><p>很多时候，我们并不想得到从开始到结束整个模拟时段内的平均值，而希望得到指定时段内的平均值，这时，可以通过指定<code>window</code>变量的值来达到目的。代码208行，注意到这里出现了一个新函数<code>window</code>。可以查到<code>window</code>函数返回值默认是<code>-1</code>。但可以在controlDict中<code>base</code>下面定义变量<code>windows</code>的值，当<code>window</code>函数返回值大于0时，208-217将被执行。接着上一点的假设，dt = 1, 定义并初始化为<code>window</code>函数的返回值，假设为20。则： </p>
<ul>
<li>当 <code>Dt</code> 小于或等于20时，不满足<code>Dt - dt &gt;= w</code>，此时时均值将按照上一点叙述的进行计算。</li>
<li>当 <code>Dt</code>大于20以后，假设<code>Dt = 21</code>，此时 <code>alpha = (w-dt)/w = (20-1)/20</code>，<code>bata = dt/w = 1/19</code>。令<code>meanField_pre</code>为<code>Dt = 20</code> 时的时均值，则<code>Dt = 21</code>时的时均值<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">meanField = 19/20 <span class="keyword">*</span> meanField_pre + 1/20 <span class="keyword">*</span> baseField = (19 <span class="keyword">*</span> meanField_pre + baseField)/20</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>对比发现，如果<code>window = -1</code>(默认值)，则<code>Dt = 21</code>的时均值应该是<code>20/21 * meanField_pre + 1/21 * baseField</code>。而定义了<code>windows = 20</code>以后，此处的<code>19 * meanField_pre</code> 可以理解为<code>Dt = 21</code>这一步之前的19步的Field值的和，加上<code>baseField</code>，则为<code>Dt = 21</code> 以及其之前19步，共20步的Field值的和。再除以20，则为 <code>Dt = 21</code>以及其之前19步这20步的时均值。<strong>所以，当设定<code>window</code>为一正整数<code>w</code>时，输出的时均值是当前时间步以及其之前<code>w-1</code>步，这<code>w</code>步内Field的时均值</strong>。</p>
</li>
</ol>
<p>附上一个更一般化的示例：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">fieldAverage1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">type</span> fieldAverage;</span><br><span class="line">    functionObjectLibs (<span class="string">"libfieldFunctionObjects.so"</span>);</span><br><span class="line">    resetOnRestart true;</span><br><span class="line">    resetOnOutput false;</span><br><span class="line">    outputControl   outputTime;</span><br><span class="line">    fields</span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">U</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">mean</span>            <span class="keyword">on</span>;</span><br><span class="line">            prime2Mean      <span class="keyword">on</span>;</span><br><span class="line">            base            time; <span class="comment">//以物理时间为基础来计算平均，而不是时间步数。</span></span><br><span class="line">            <span class="keyword">window</span>          10.0;</span><br><span class="line">            windowName      w1; <span class="comment">//optional</span></span><br><span class="line">        &#125;</span><br><span class="line">        p</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">mean</span>            <span class="keyword">on</span>;</span><br><span class="line">            prime2Mean      <span class="keyword">on</span>;</span><br><span class="line">            base            time;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>resetOnRestart</code>的值决定当solver继续运行时，是否要读取最近一个时间步的<code>meanField</code>的值来计算接下来时刻的时均值；<code>resetOnOutput</code>，顾名思义，是否要在每一次输出到文件以后重置<code>meanField</code>的值。这两个开关的默认值都是<code>false</code>。<br><code>mean</code>这个开关的含义无需多言，计算公式如下：<br>$$ \overline {x} = \frac{1}{N} \sum \limits _{i=0}^{N} x_i $$<br><code>prime2Mean</code>的计算公式如下：<br>$$ \overline{x’}^{\, 2} = \frac{1}{N}\displaystyle\sum\limits_{i=0}^N (x_i - \overline{x})^2 $$<br>所以，如果<code>prime2Mean</code>为<code>on</code>，<code>mean</code>必须为<code>on</code>。</p>
<p>此外，如果计算已经结束，controlDict 中定义的 function 仍可以用<code>execFlowFunctionObjects</code>来执行。只是，这样的运行只能利用输出到文件的数据来进行计算了。举例说，假如时间步长是 0.001s， 每 0.1s 输出一次，那么同样是1-2s的时均值，solver运行过程中求解的公式是:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( field.<span class="function"><span class="title">at</span><span class="params">(<span class="number">1.001</span>)</span></span> +field.<span class="function"><span class="title">at</span><span class="params">(<span class="number">1.002</span>)</span></span> + ... + field.<span class="function"><span class="title">at</span><span class="params">(<span class="number">2.0</span>)</span></span> )/<span class="number">1000</span></span><br></pre></td></tr></table></figure></p>
<p>而solver运行完以后利用<code>execFlowFunctionObjects</code>计算的时均值应该是：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( field.<span class="function"><span class="title">at</span><span class="params">(<span class="number">1.1</span>)</span></span> + field.<span class="function"><span class="title">at</span><span class="params">(<span class="number">1.2</span>)</span></span> + ... + field.<span class="function"><span class="title">at</span><span class="params">(<span class="number">2</span>)</span></span> )/<span class="number">10</span></span><br></pre></td></tr></table></figure></p>
<p>注意，这个结果没有经过直接的验证，是我根据原理推演的结果。<br>有时候，运行<code>execFlowFunctionObjects</code>会报错说找不到<code>phi</code>，这时加上<code>-noFlow</code>选项，就不会报错了。</p>
<h5 id="小结">小结</h5><ol>
<li><code>base</code>用来指定作时间平均的基础，是基于时间步数(ITER)还是物理时间(time);</li>
<li><code>window</code>用来作平均的时间段的长度，如果不设定，则求的是从开始到当前时间这个时间段的平均值。<code>window</code>的数值的实际含义依<code>base</code>而定，如果<code>base</code>是<code>ITER</code>，则<code>window=20</code>表示当前步及其前 19 个时间步从 20 个时间步内的平均，而如果<code>base</code>是<code>time</code>,则表示的是 20s 内的平均。</li>
</ol>
<p><strong>错误更正</strong>：<br>2015.09.05: 在 controlDict 里， <code>base</code> 只能是  <code>time</code> 或 <code>iteration</code>，而不能是上文中说的 <code>ITER</code>， <code>ITER</code> 只是代码中使用的一个代称 。感谢“启之” 指出！  </p>
<p><strong>补充</strong>:<br>2015.11.26：上文没有提 <code>prime2Mean</code> 的计算方法，今天仔细看了一下，记录如下。<br> <code>prime2Mean</code> 的公式上面提到了，计算代码需要结合三个个函数来看，分别是 fieldAverage.C 文件里的 <code>calcAverages</code> 函数（事实上，上文提到的计算时均值的函数 <code>calculateMeanFieldType</code> 也是在这个函数中调用的）以及 fieldAverageTemplates.C 中定义的 <code>calculatePrime2MeanFields</code> 和 <code>addMeanSqrToPrime2Mean</code> 两个函数。我们看 <code>calcAverages</code> 看起</p>
<figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void <span class="type">Foam</span>::fieldAverage::calcAverages<span class="literal">()</span></span><br><span class="line">&#123;</span><br><span class="line">   ......</span><br><span class="line">   ......</span><br><span class="line">    <span class="type">Info</span>&lt;&lt; <span class="string">"    Calculating averages"</span> &lt;&lt; nl;</span><br><span class="line"></span><br><span class="line">    addMeanSqrToPrime2Mean&lt;scalar, scalar&gt;<span class="literal">()</span>;</span><br><span class="line">    addMeanSqrToPrime2Mean&lt;<span class="built_in">vector</span>, symmTensor&gt;<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">    calculateMeanFields&lt;scalar&gt;<span class="literal">()</span>;</span><br><span class="line">    calculateMeanFields&lt;<span class="built_in">vector</span>&gt;<span class="literal">()</span>;</span><br><span class="line">    calculateMeanFields&lt;sphericalTensor&gt;<span class="literal">()</span>;</span><br><span class="line">    calculateMeanFields&lt;symmTensor&gt;<span class="literal">()</span>;</span><br><span class="line">    calculateMeanFields&lt;tensor&gt;<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">    calculatePrime2MeanFields&lt;scalar, scalar&gt;<span class="literal">()</span>;</span><br><span class="line">    calculatePrime2MeanFields&lt;<span class="built_in">vector</span>, symmTensor&gt;<span class="literal">()</span>;</span><br><span class="line">  ......</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，计算时均值 <code>mean</code> ，其实只要调用 <code>calculateMeanFields</code> 函数就可以了，但是计算 <code>prime2Mean</code> 则分成两部分：分别是在计算 <code>mean</code> 之前调用 <code>addMeanSqrToPrime2Mean</code> ，以及在计算 <code>mean</code> 之后调用 <code>calculatePrime2MeanFields</code>。下面一一来看这两个函数，注意到 <code>addMeanSqrToPrime2Mean</code> 和 <code>calculatePrime2MeanFields</code> 两个函数其实分别是通过调用 <code>addMeanSqrToPrime2MeanType</code> 和 <code>calculatePrime2MeanFieldType</code> 来其作用的，所以这里只看真正执行计算任务的<code>addMeanSqrToPrime2MeanType</code> 和 <code>calculatePrime2MeanFieldType</code> 函数。</p>
<ul>
<li>addMeanSqrToPrime2MeanType<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Type1, <span class="keyword">class</span> Type2&gt;</span><br><span class="line"><span class="keyword">void</span> Foam::fieldAverage::addMeanSqrToPrime2MeanType(<span class="keyword">const</span> label fieldI) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> word&amp; fieldName = faItems_[fieldI].fieldName();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obr_.foundObject&lt;Type1&gt;(fieldName))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> Type1&amp; meanField =</span><br><span class="line">            obr_.lookupObject&lt;Type1&gt;(faItems_[fieldI].meanFieldName());</span><br><span class="line"></span><br><span class="line">        Type2&amp; prime2MeanField = <span class="keyword">const_cast</span>&lt;Type2&amp;&gt;</span><br><span class="line">        (</span><br><span class="line">            obr_.lookupObject&lt;Type2&gt;(faItems_[fieldI].prime2MeanFieldName())</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        prime2MeanField += sqr(meanField);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这个函数很简单，就是直接往上一步的 <code>prime2MeanField</code> 加上上一步的 <code>meanField</code> 。</p>
<ul>
<li>calculatePrime2MeanFieldType<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Type1, <span class="keyword">class</span> Type2&gt;</span><br><span class="line"><span class="keyword">void</span> Foam::fieldAverage::calculatePrime2MeanFieldType(<span class="keyword">const</span> label fieldI) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> word&amp; fieldName = faItems_[fieldI].fieldName();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obr_.foundObject&lt;Type1&gt;(fieldName))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> Type1&amp; baseField = obr_.lookupObject&lt;Type1&gt;(fieldName);</span><br><span class="line">        <span class="keyword">const</span> Type1&amp; meanField =</span><br><span class="line">            obr_.lookupObject&lt;Type1&gt;(faItems_[fieldI].meanFieldName());</span><br><span class="line"></span><br><span class="line">        Type2&amp; prime2MeanField = <span class="keyword">const_cast</span>&lt;Type2&amp;&gt;</span><br><span class="line">        (</span><br><span class="line">            obr_.lookupObject&lt;Type2&gt;(faItems_[fieldI].prime2MeanFieldName())</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        scalar dt = obr_.time().deltaTValue();</span><br><span class="line">        scalar Dt = totalTime_[fieldI];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (faItems_[fieldI].iterBase())</span><br><span class="line">        &#123;</span><br><span class="line">            dt = <span class="number">1.0</span>;</span><br><span class="line">            Dt = scalar(totalIter_[fieldI]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        scalar alpha = (Dt - dt)/Dt;</span><br><span class="line">        scalar beta = dt/Dt;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (faItems_[fieldI].window() &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">const</span> scalar w = faItems_[fieldI].window();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (Dt - dt &gt;= w)</span><br><span class="line">            &#123;</span><br><span class="line">                alpha = (w - dt)/w;</span><br><span class="line">                beta = dt/w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        prime2MeanField =</span><br><span class="line">            alpha*prime2MeanField</span><br><span class="line">          + beta*sqr(baseField)</span><br><span class="line">          - sqr(meanField);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这个函数里， <code>alpha</code> 与 <code>beta</code> 的定义跟上文计算时均值的函数 <code>calculateMeanFieldType</code> 是一样的，关键在于最后的那一句。<br>那么，这两个函数结合起来，如果就等价于上文给出的 <code>prime2MeanField</code> 的计算公式了呢？下面做一个简单的分析：<br>t = 1 时，某个场 <code>x</code> 记为 <code>x1</code> ， <code>meanField</code> 记为 <code>m1</code>，等于 <code>x1</code> ， <code>prime2MeanField</code> 记为 <code>pM1</code>，等于 0；</p>
<p>t = 2 时，此刻的 <code>x</code> 记为 <code>x2</code> ， <code>meanField</code> 记为 <code>m2</code>，等于 <code>(x1+x2)/2</code>， <code>prime2MeanField</code> 的理论值等于 $\frac{1}{2} [(x_1-m_2)^2+(x_2-m_2)^2]$，而按照代码，此刻的 <code>prime2MeanField</code> （记为pM2）的计算分两步， 先是计算当前步的 <code>meanField</code> 之前，执行 <code>prime2MeanField = pM1 + m1</code> ，然后是在计算当前步的 <code>meanField</code> 之后，执行 <code>prime2MeanField = 1/2*(prime2MeanField) + 1/2*x2 - m2*m2</code>，结合起来，得到 <code>pM2 = 1/2*(pM1+m1*m1) + 1/2*x2*x2 - m2*m2 = 1/2*m1*m1 + 1/2*x2*x2 - m2*m2 =  1/2*x1*x1 + 1/2*x2*x2 - m2*m2</code> ， 由于 <code>2*m2 = x1 + x2</code> ，于是，上式可以进一步化简， <code>pM2 = 1/2*x1*x1 + 1/2*x2*x2 - 2*m2*m2 + m2*m2 = 1/2*x1*x1 + 1/2*x2*x2 -(x1+x2)*m2 + m2*m2 = 1/2*(x1*x1 -2*x1*m2 + m2*m2) + 1/2*(x2*x2 -2*x2*m2 + m2*m2) = 1/2*(x1-m2)^2 + 1/2*(x2-m2)^2</code> ，这就与理论值刚好对上了；</p>
<p>t = 3时，也可以类推下去，这里简略写一下：<code>pM3 = 2/3*(pM2 + m2*m2) + 1/3*x3*x3 - m3*m3 = 1/3*(x1*x1 + x2*x2 + x3*x3) - m3*m3 = 1/3*(x1*x1 + x2*x2 + x3*x3) - 2/3*(x1+x2+x3)*m3 + m3*m3 = 1/3*[(x1-m3)^2 + (x2-m3)^2 + (x3-m3)^2]</code>，同样是跟理论值是一样的。 </p>
]]></content>
    <summary type="html">
    <![CDATA[<p><code>fieldAverage</code>是 OpenFOAM 中的一种 functionObject，用来计算时均值。其基本用法是作为一个 function object 放在 controlDict 文件中，运行 solver 的同时计算指定场的时均值，以下是一个示例：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">functions</span><br><span class="line">&#123;</span><br><span class="line">    fieldAverage1</span><br><span class="line">    &#123;</span><br><span class="line">        type            fieldAverage;</span><br><span class="line">        functionObjectLibs ( <span class="string">"libfieldFunctionObjects.so"</span> );</span><br><span class="line">        outputControl   outputTime;</span><br><span class="line">        fields</span><br><span class="line">        (</span><br><span class="line">            Ua</span><br><span class="line">            &#123;</span><br><span class="line">                 mean        <span class="function_start"><span class="keyword">on</span></span>;</span><br><span class="line">                 prime2Mean  off;</span><br><span class="line">                 base        <span class="property">time</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Ub</span><br><span class="line">            &#123;</span><br><span class="line">                 mean        <span class="function_start"><span class="keyword">on</span></span>;</span><br><span class="line">                 prime2Mean  off;</span><br><span class="line">                 base        <span class="property">time</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/tags/OpenFOAM/"/>
    
      <category term="Postprocessing" scheme="http://xiaopingqiu.github.io/tags/Postprocessing/"/>
    
      <category term="OpenFOAM" scheme="http://xiaopingqiu.github.io/categories/OpenFOAM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello World]]></title>
    <link href="http://xiaopingqiu.github.io/2015/04/04/hello-world/"/>
    <id>http://xiaopingqiu.github.io/2015/04/04/hello-world/</id>
    <published>2015-04-04T02:00:00.000Z</published>
    <updated>2015-04-10T14:57:00.000Z</updated>
    <content type="html"><![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start">Quick Start</h2><h3 id="Create_a_new_post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
<h4 id="Test_code">Test code</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"hello world!"</span> &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="中文支持测试">中文支持测试</h4><p>看看是否支持中文。</p>
<h4 id="数学公式">数学公式</h4><p>$$ x=\frac{-b\pm \sqrt{b^2-4ac}}{2a} $$</p>
<h4 id="本地图片测试">本地图片测试</h4><p><img src="/image/juperter_impact.jpg" alt="Jupiter"></p>
<h4 id="gif图片测试">gif图片测试</h4><p><img src="/image/cfb.gif" alt="cfb"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io]]>
    </summary>
    
      <category term="test" scheme="http://xiaopingqiu.github.io/tags/test/"/>
    
      <category term="test" scheme="http://xiaopingqiu.github.io/categories/test/"/>
    
  </entry>
  
</feed>